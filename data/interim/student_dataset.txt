@Override public int calcWidthInPixels(@NotNull Inlay inlay) { return calcWidthInPixels(inlay.getEditor()); }
public int calcWidthInPixels(@NotNull Editor editor) { var editorContext = FontInfo.getFontRenderContext(editor.getComponent()); var context = new FontRenderContext( editorContext.getTransform(), AntialiasingType.getKeyForCurrentScope(false), UISettings.getEditorFractionalMetricsHint()); var fontMetrics = FontInfo.getFontMetrics(FontUtil.getActiveFont(editor), context); return fontMetrics.stringWidth(text) + WIDTH_OFFSET; }
@Override public @Nullable GutterIconRenderer calcGutterIconRenderer(@NotNull Inlay inlay) { return EditorCustomElementRenderer.super.calcGutterIconRenderer(inlay); }
public void resetAndRescan() { problemManager.reset(); documentMarkupModelScanner.scanForProblemsManually(); }
public void resetMarkupModelProblemListeners() { MarkupModelProblemListener.disposeAll(); installMarkupModelListenerOnAllProjects(); }
@Override public boolean equals(Object obj) { if (obj instanceof GutterRenderer) { GutterRenderer other = (GutterRenderer) obj; return Objects.equals(getIcon(), other.getIcon()) && Objects.equals(getTooltipText(), other.getTooltipText()); } return false; }
@Override public int hashCode() { return Objects.hash(getIcon(), getTooltipText()); }
public static void notify(String content, NotificationType type, Project project) { NotificationGroupManager.getInstance() .getNotificationGroup("InlineProblems") .createNotification("InlineProblems", content, type) .notify(project); }
public void projectOpened(InlineProblemProject project) { boolean isUnityProjectOpenedBefore = isAUnityProjectOpened(); projects.add(project); if (!isUnityProjectOpenedBefore && isAUnityProjectOpened()) { handleUnityProjectOpened(project.getProject()); } }
public void projectClosed(Project project) { boolean isUnityProjectOpenedBefore = isAUnityProjectOpened(); List<InlineProblemProject> projectsToRemove = projects.stream().filter(p -> p.getProject().equals(project)).collect(Collectors.toList()); if (projectsToRemove.size() != 1) logger.warn("ProjectManager projects to remove size: " + projectsToRemove.size()); projectsToRemove.forEach(projects::remove); if (isUnityProjectOpenedBefore && !isAUnityProjectOpened()) { handleNoMoreUnityProjectsOpened(project); } }
private boolean isAUnityProjectOpened() { return projects.stream().anyMatch(p -> p.getType().equals(ProjectType.UNITY_GAME_ENGINE)); }
private void handleUnityProjectOpened(Project project) { enabledListenerBefore = settings.getEnabledListener(); if (enabledListenerBefore == Listener.MANUAL_SCANNING) return; settings.setEnabledListener(Listener.MANUAL_SCANNING); ListenerManager listenerManager = ListenerManager.getInstance(); listenerManager.resetAndRescan(); listenerManager.changeListener(); Notifier.notify( "Unity project opened. Listener changed to Manual Scanning.", NotificationType.INFORMATION, project); }
public void undrawErrorLineHighlight( InlineProblem problem, @Nullable List<InlineProblem> problemsInLine) { MarkupModel markupModel = problem.getTextEditor().getEditor().getMarkupModel(); Arrays.stream(markupModel.getAllHighlighters()) .filter(h -> h.isValid() && h.hashCode() == problem.getProblemLineHighlighterHashCode()) .forEach(markupModel::removeHighlighter); if (problemsInLine != null && problemsInLine.size() > 1) { problemsInLine.remove(problem); drawLineHighlighterAndGutterIcon(problemsInLine); } }
public void undrawInlineProblemLabel(InlineProblem problem) { Editor editor = problem.getTextEditor().getEditor(); Document document = editor.getDocument(); int documentLineStartOffset = document.getLineStartOffset(0); int endLine = document.getLineCount() - 1; if (endLine < 0) endLine = 0; int documentLineEndOffset = document.getLineEndOffset(endLine); if (problem.isBlockElement()) { editor .getInlayModel() .getBlockElementsInRange(documentLineStartOffset, documentLineEndOffset) .stream() .filter(e -> problem.getInlineProblemLabelHashCode() == e.getRenderer().hashCode()) .filter(e -> e.getRenderer() instanceof InlineProblemLabel) .forEach(Disposable::dispose); } else { editor .getInlayModel() .getAfterLineEndElementsInRange(documentLineStartOffset, documentLineEndOffset) .stream() .filter(e -> problem.getInlineProblemLabelHashCode() == e.getRenderer().hashCode()) .filter(e -> e.getRenderer() instanceof InlineProblemLabel) .forEach(Disposable::dispose); } }
public void removeProblem(InlineProblem problem) { List<InlineProblem> problemsInLine = null; if (settingsState.isShowAnyGutterIcons()) { problemsInLine = getProblemsInLineForProblemSorted(problem); } inlineDrawer.undrawErrorLineHighlight(problem, problemsInLine); inlineDrawer.undrawInlineProblemLabel(problem); if (!Collections.synchronizedList(activeProblems).remove(problem)) { logger.warn("Removal of problem failed, resetting"); resetForEditor(problem.getTextEditor().getEditor()); return; } }
public void addProblem(InlineProblem problem) { problem.setDrawDetails(new DrawDetails(problem, problem.getTextEditor().getEditor())); List<InlineProblem> problemsInLine = getProblemsInLineForProblem(problem); problemsInLine.add(problem); problemsInLine = problemsInLine.stream() .sorted((p1, p2) -> Integer.compare(p2.getSeverity(), p1.getSeverity())) .collect(Collectors.toList()); problemsInLine.forEach( p -> { if (p != problem) removeProblem(p); }); problemsInLine.forEach(this::addProblemPrivate); inlineDrawer.drawLineHighlighterAndGutterIcon(problemsInLine); }
public boolean shouldProblemBeIgnored(int severity) { if (severity >= HighlightSeverity.ERROR.myVal) { return !settingsState.isHighlightErrors() && !settingsState.isShowErrors(); } else if (severity >= HighlightSeverity.WARNING.myVal) { return !settingsState.isHighlightWarnings() && !settingsState.isShowWarnings(); } else if (severity >= HighlightSeverity.WEAK_WARNING.myVal) { return !settingsState.isHighlightWeakWarnings() && !settingsState.isShowWeakWarnings(); } else if (severity >= HighlightSeverity.INFORMATION.myVal) { return !settingsState.isHighlightInfos() && !settingsState.isShowInfos(); } return true; }
public void reset() { final List<InlineProblem> activeProblemSnapShot = List.copyOf(activeProblems); activeProblemSnapShot.forEach(this::removeProblem); }
public void resetForEditor(Editor editor) { final List<InlineProblem> activeProblemsSnapShot = List.copyOf(activeProblems); activeProblemsSnapShot.stream() .filter(aP -> aP.getTextEditor().getEditor().equals(editor)) .forEach(this::removeProblem); }
public void updateFromNewActiveProblems(List<InlineProblem> problems) { updateFromNewActiveProblems(problems, List.copyOf(activeProblems)); }
public void updateFromNewActiveProblemsForProjectAndFile( List<InlineProblem> problems, Project project, String filePath) { final List<InlineProblem> activeProblemsSnapShot = activeProblems.stream() .filter(p -> p.getProject().equals(project) && p.getFile().equals(filePath)) .collect(Collectors.toList()); updateFromNewActiveProblems(problems, activeProblemsSnapShot); }
@Override public void dispose() { mergingUpdateQueue.cancelAllUpdates(); }
@Override public void run() { List<InlineProblem> problems = getProblemsInEditor(textEditor); problemManager.updateFromNewActiveProblemsForProjectAndFile( problems, textEditor.getEditor().getProject(), textEditor.getFile().getPath()); }
public void restartManualScan() { cancelScheduledFuture(); createAndStartScheduledFuture(); }
private void cancelScheduledFuture() { if (!scheduledFuture.cancel(false)) { if (!scheduledFuture.cancel(true)) { logger.warn("Unable to cancel scheduledFuture"); } } }
private void createAndStartScheduledFuture() { scheduledFuture = AppExecutorUtil.getAppScheduledExecutorService() .scheduleWithFixedDelay( () -> ApplicationManager.getApplication() .invokeAndWait(this::scanForProblemsManually), 2000, delayMilliseconds, TimeUnit.MILLISECONDS); }
@Override public void loadState(@NotNull SettingsState state) { XmlSerializerUtil.copyBean(state, this); migrateState(); }
@Override public void noStateLoaded() { migrateState(); }
private void migrateState() { if (!filterListMigrationDone01) { List<String> newFilterListEntries = List.of("Consider unknown contexts non-blocking"); for (String entry : newFilterListEntries) { if (!problemFilterList.contains(entry)) { problemFilterList += ";" + entry; } } filterListMigrationDone01 = true; } if (!highlightProblemListenerDeprecateMigrationDone) { if (enabledListener == Listener.HIGHLIGHT_PROBLEMS_LISTENER) { enabledListener = Listener.MARKUP_MODEL_LISTENER; } highlightProblemListenerDeprecateMigrationDone = true; } }
@Transient public boolean isShowAnyGutterIcons() { return showErrorsInGutter || showWarningsInGutter || showWeakWarningsInGutter || showInfosInGutter; }
@Override @Nullable public JComponent createComponent() { settingsComponent = new SettingsComponent(); return settingsComponent.getSettingsPanel(); }
@Override public void disposeUIResources() { settingsComponent = null; }
@Override public void afterAdded(@NotNull RangeHighlighterEx highlighter) { ApplicationManager.getApplication().invokeLater(() -> handleEvent(EventType.ADD, highlighter)); }
@Override public void beforeRemoved(@NotNull RangeHighlighterEx highlighter) { ApplicationManager.getApplication() .invokeLater(() -> handleEvent(EventType.REMOVE, highlighter)); }
@Override public void attributesChanged( @NotNull RangeHighlighterEx highlighter, boolean renderersChanged, boolean fontStyleOrColorChanged) { ApplicationManager.getApplication() .invokeLater(() -> handleEvent(EventType.CHANGE, highlighter)); }
public static void disposeAll() { List.copyOf(disposables) .forEach( d -> { Disposer.dispose(d); disposables.remove(d); }); }
private InlineProblem findActiveProblemByRangeHighlighterHashCode(int hashCode) { return problemManager.getActiveProblems().stream() .filter(p -> p.getRangeHighlighterHashCode() == hashCode) .findFirst() .orElse(null); }
public void handleAccept(PsiFile file) { if (settingsState.getEnabledListener() != Listener.HIGHLIGHT_PROBLEMS_LISTENER) return; if (file.getProject().isDisposed() || file.getVirtualFile() == null) return; FileEditor editor = FileEditorManager.getInstance(file.getProject()).getSelectedEditor(file.getVirtualFile()); if (editor == null) { return; } TextEditor textEditor = (TextEditor) editor; markupModelScanner.scanForProblemsManuallyInTextEditor(textEditor); }
@Nullable @Override public Color fromString(@NotNull String value) { if (value.isEmpty() || value.isBlank()) { return null; } try { return Color.decode(value); } catch (NumberFormatException e) { return null; } }
@Override public @Nullable String toString(@NotNull Color value) { return "#" + Integer.toHexString(value.getRGB()).substring(2); }
@NotNull public static @Nls String message( @NotNull @PropertyKey(resourceBundle = BUNDLE) String key, Object @NotNull ... params) { return INSTANCE.messageOrDefault(key, DEFAULT_BUNDLE.getString(key), params); }
@NotNull public static Supplier<@Nls String> messagePointer( @NotNull @PropertyKey(resourceBundle = BUNDLE) String key, Object @NotNull ... params) { var result = INSTANCE.messageOrNull(key, params); if (result == null) { return () -> DEFAULT_BUNDLE.getString(key); } return () -> result; }
@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_camera); mSectionsPagerAdapter = new SectionsPagerAdapter(getSupportFragmentManager()); mViewPager = (ViewPager) findViewById(R.id.pager); mViewPager.setAdapter(mSectionsPagerAdapter); getWindow() .setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE); }
@Override protected void onPause() { super.onPause(); timeout(); }
private boolean isAppOnForeground(Context context) { ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List<ActivityManager.RunningAppProcessInfo> appProcesses = activityManager.getRunningAppProcesses(); if (appProcesses == null) { return false; } final String packageName = context.getPackageName(); for (ActivityManager.RunningAppProcessInfo appProcess : appProcesses) { if (appProcess.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND && appProcess.processName.equals(packageName)) { return true; } } return false; }
@Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.menu_camera, menu); return true; }
@Override public Response serve( String uri, Method method, Map<String, String> header, Map<String, String> parameters, Map<String, String> files) { Log.d("Streaming", "Server should be up now"); Response res = new NanoHTTPD.Response(Response.Status.OK, "video/quicktime", fis); res.addHeader("Content-Disposition: attachment; filename=", fileName); return res; }
public void generateKey(char[] passphraseOrPin, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException { final int iterations = 5000; final int outputKeyLength = 256; SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1"); KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength); this.key = secretKeyFactory.generateSecret(keySpec); }
private static byte[] generateSalt() { final int saltLength = 32; SecureRandom sr = new SecureRandom(); byte[] salt = new byte[saltLength]; sr.nextBytes(salt); return salt; }
public static void storeSalt(Context ctx) { FileOutputStream outputStream; final String filename = "salt.cfg"; byte[] salt = generateSalt(); try { outputStream = ctx.openFileOutput(filename, Context.MODE_PRIVATE); outputStream.write(salt); outputStream.close(); } catch (Exception e) { e.printStackTrace(); } }
public void surfaceCreated(SurfaceHolder holder) { if (mCamera == null) { return; } try { mCamera.setPreviewDisplay(holder); mCamera.startPreview(); } catch (IOException e) { e.printStackTrace(); } }
public void surfaceDestroyed(SurfaceHolder holder) { mCamera = null; }
public static void storeVideo(Globals appState, SQLiteDatabase database, Video video) { ContentValues values = new ContentValues(); values.put(appState.getCOLUMN_NAME_TITLE(), video.getTitle()); values.put(appState.getCOLUMN_NAME_LENGTH(), video.getLength()); values.put(appState.getCOLUMN_NAME_TIME(), video.getDate()); database.insert(appState.getTableName(), null, values); }
public static void deleteVideo(Globals appState, SQLiteDatabase database, String title) { String[] magic = {title}; database.delete(appState.getTableName(), "title = ?", magic); }
public static CameraFragment newInstance(int sectionNumber) { CameraFragment fragment = new CameraFragment(); Bundle args = new Bundle(); args.putInt(ARG_SECTION_NUMBER, sectionNumber); fragment.setArguments(args); return fragment; }
@Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fragment_camera, container, false); setUpVideoButton(rootView); setUpGalleryButton(rootView); return rootView; }
@Override public void onResume() { super.onResume(); safeCameraOpenInView(getView()); Globals appState = (Globals) getActivity().getApplicationContext(); Security securestore = appState.getSecurestore(); VirtualFileSystem vfs = appState.getVFS(); if (!vfs.isMounted()) vfs.mount(appState.getDbFile(), securestore.getKey().getEncoded()); int currentOrientation = getResources().getConfiguration().orientation; portrait = (currentOrientation == Configuration.ORIENTATION_PORTRAIT); prepareForVideoRecording(); new Thread(new benchmark()).start(); }
@Override public void onPause() { releaseCameraAndPreview(); super.onPause(); }
@Override public void onDestroy() { if (cursor != null && cursor.moveToFirst()) { cursor.close(); } Globals appState = (Globals) getActivity().getApplicationContext(); VirtualFileSystem vfs = appState.getVFS(); if (vfs.isMounted()) vfs.unmount(); super.onDestroy(); }
private boolean safeCameraOpenInView(View view) { boolean qOpened = false; releaseCameraAndPreview(); mCamera = getCameraInstance(); qOpened = (mCamera != null); mPreview = new CameraPreview(getActivity().getBaseContext(), mCamera); FrameLayout preview = (FrameLayout) view.findViewById(R.id.camera_preview); preview.addView(mPreview); setCameraDisplayOrientation(this.getActivity(), 0, mCamera); return qOpened; }
public static void setCameraDisplayOrientation( Activity activity, int cameraId, android.hardware.Camera camera) { android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo(); android.hardware.Camera.getCameraInfo(cameraId, info); int rotation = activity.getWindowManager().getDefaultDisplay().getRotation(); int degrees = 0; switch (rotation) { case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; } int result; if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) { result = (info.orientation + degrees) % 360; result = (360 - result) % 360; } else { result = (info.orientation - degrees + 360) % 360; } camera.setDisplayOrientation(result); }
private byte[] rotateYUV420Degree90(byte[] data, int imageWidth, int imageHeight) { byte[] yuv = new byte[imageWidth * imageHeight * 3 / 2]; int i = 0; for (int x = 0; x < imageWidth; x++) { for (int y = imageHeight - 1; y >= 0; y--) { yuv[i] = data[y * imageWidth + x]; i++; } } i = imageWidth * imageHeight * 3 / 2 - 1; for (int x = imageWidth - 1; x > 0; x = x - 2) { for (int y = 0; y < imageHeight / 2; y++) { yuv[i] = data[(imageWidth * imageHeight) + (y * imageWidth) + x]; i--; yuv[i] = data[(imageWidth * imageHeight) + (y * imageWidth) + (x - 1)]; i--; } } return yuv; }
public static byte[] halveYUV420(byte[] data, int imageWidth, int imageHeight) { byte[] yuv = new byte[imageWidth / 2 * imageHeight / 2 * 3 / 2]; int i = 0; for (int y = 0; y < imageHeight; y += 2) { for (int x = 0; x < imageWidth; x += 2) { yuv[i] = data[y * imageWidth + x]; i++; } } for (int y = 0; y < imageHeight / 2; y += 2) { for (int x = 0; x < imageWidth; x += 4) { yuv[i] = data[(imageWidth * imageHeight) + (y * imageWidth) + x]; i++; yuv[i] = data[(imageWidth * imageHeight) + (y * imageWidth) + (x + 1)]; i++; } } return yuv; }
public Boolean hookCallback() { try { mCamera.setPreviewCallback(callback); Log.d("Strongbox", "Camera callback hooked"); return true; } catch (Exception e) { Log.d("Strongbox", "Hooking camera callback failed"); return false; } }
private void startRecording() { mFrameQ = new ArrayDeque<VideoFrame>(); mFramesTotal = 0; frameCounter = 0; startTime = new java.util.Date().getTime(); lastTime = startTime; String fileName = "Video_" + startTime + ".mov"; info.guardianproject.iocipher.File fileOut = new info.guardianproject.iocipher.File(mFileBasePath, fileName); try { mIsRecording = true; if (useAAC) initAudio(fileOut.getAbsolutePath() + ".aac"); else initAudio(fileOut.getAbsolutePath() + ".pcm"); boolean withEmbeddedAudio = false; Encoder encoder = new Encoder(fileOut, benchmarkFPS, withEmbeddedAudio); encoder.start(); startAudioRecording(); Log.d("Strongbox", "Started Recording"); } catch (Exception e) { Log.d("Video", "error starting video", e); } }
public void run() { try { while (mIsRecording || (!mFrameQ.isEmpty())) { if (mFrameQ.peek() != null) { VideoFrame vf = mFrameQ.pop(); muxer.addFrame( mLastWidth / 2, mLastHeight / 2, ByteBuffer.wrap(vf.image), benchmarkFPS, vf.duration); } } muxer.finish(); fos.close(); } catch (Exception e) { Log.e(TAG, "IO", e); } }
@Override public void handleMessage(Message msg) { super.handleMessage(msg); if (msg.what == 0) { int frames = msg.getData().getInt("frames"); } else if (msg.what == 1) { mIsRecording = false; if (aac != null) aac.stopRecording(); } }
public void onClick(View v) { if (isRecording) { recordVideoButton.setBackgroundResource(R.drawable.ic_video_call); getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED); stopRecording(); isRecording = false; } else { recordVideoButton.setBackgroundResource(R.drawable.ic_stop); int currentOrientation = getResources().getConfiguration().orientation; if (currentOrientation == Configuration.ORIENTATION_LANDSCAPE) { getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE); portrait = false; } else { getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT); portrait = true; } hookCallback(); startRecording(); isRecording = true; } }
@Override public void run() { if (benchmarkFPS == -1) { benchmarking = true; try { Thread.sleep(1000); } catch (Exception e) { Log.d("Benchmark", "Trouble sleeping. Try Ativan?"); } hookCallback(); try { Thread.sleep(2500); } catch (Exception e) { Log.d("Benchmark", "Trouble sleeping. Try Ativan?"); } if (mCamera != null) mCamera.setPreviewCallback(null); benchmarking = false; } }
@Override public void onClick(View v) { ViewPager viewPager = (ViewPager) getActivity().findViewById(R.id.pager); viewPager.setCurrentItem(1); }
private void releaseCameraAndPreview() { if (mCamera != null) { mCamera.setPreviewCallback(null); mCamera.stopPreview(); mCamera.release(); mCamera = null; } }
private static final void safeClose(Closeable closeable) { if (closeable != null) { try { closeable.close(); } catch (IOException e) { } } }
private static final void safeClose(Socket closeable) { if (closeable != null) { try { closeable.close(); } catch (IOException e) { } } }
private static final void safeClose(ServerSocket closeable) { if (closeable != null) { try { closeable.close(); } catch (IOException e) { } } }
public void stop() { try { safeClose(myServerSocket); closeAllConnections(); if (myThread != null) { myThread.join(); } } catch (Exception e) { e.printStackTrace(); } }
public synchronized void registerConnection(Socket socket) { openConnections.add(socket); }
public synchronized void unRegisterConnection(Socket socket) { openConnections.remove(socket); }
public synchronized void closeAllConnections() { for (Socket socket : openConnections) { safeClose(socket); } }
public final boolean wasStarted() { return myServerSocket != null && myThread != null; }
public final boolean isAlive() { return wasStarted() && !myServerSocket.isClosed() && myThread.isAlive(); }
@Deprecated public Response serve( String uri, Method method, Map<String, String> headers, Map<String, String> parms, Map<String, String> files) { return new Response(Response.Status.NOT_FOUND, MIME_PLAINTEXT, "Not Found"); }
public Response serve(IHTTPSession session) { Map<String, String> files = new HashMap<String, String>(); Method method = session.getMethod(); if (Method.PUT.equals(method) || Method.POST.equals(method)) { try { session.parseBody(files); } catch (IOException ioe) { return new Response( Response.Status.INTERNAL_ERROR, MIME_PLAINTEXT, "SERVER INTERNAL ERROR: IOException: " + ioe.getMessage()); } catch (ResponseException re) { return new Response(re.getStatus(), MIME_PLAINTEXT, re.getMessage()); } } Map<String, String> parms = session.getParms(); parms.put(QUERY_STRING_PARAMETER, session.getQueryParameterString()); return serve(session.getUri(), method, session.getHeaders(), parms, files); }
protected String decodePercent(String str) { String decoded = null; try { decoded = URLDecoder.decode(str, "UTF8"); } catch (UnsupportedEncodingException ignored) { } return decoded; }
protected Map<String, List<String>> decodeParameters(Map<String, String> parms) { return this.decodeParameters(parms.get(QUERY_STRING_PARAMETER)); }
protected Map<String, List<String>> decodeParameters(String queryString) { Map<String, List<String>> parms = new HashMap<String, List<String>>(); if (queryString != null) { StringTokenizer st = new StringTokenizer(queryString, "&"); while (st.hasMoreTokens()) { String e = st.nextToken(); int sep = e.indexOf('='); String propertyName = (sep >= 0) ? decodePercent(e.substring(0, sep)).trim() : decodePercent(e).trim(); if (!parms.containsKey(propertyName)) { parms.put(propertyName, new ArrayList<String>()); } String propertyValue = (sep >= 0) ? decodePercent(e.substring(sep + 1)) : null; if (propertyValue != null) { parms.get(propertyName).add(propertyValue); } } } return parms; }
static Method lookup(String method) { for (Method m : Method.values()) { if (m.toString().equalsIgnoreCase(method)) { return m; } } return null; }
@Override public void exec(Runnable code) { ++requestCount; Thread t = new Thread(code); t.setDaemon(true); t.setName("NanoHttpd Request Processor (#" + requestCount + ")"); t.start(); }
@Override public TempFile createTempFile() throws Exception { DefaultTempFile tempFile = new DefaultTempFile(tmpdir); tempFiles.add(tempFile); return tempFile; }
@Override public void clear() { for (TempFile file : tempFiles) { try { file.delete(); } catch (Exception ignored) { } } tempFiles.clear(); }
@Override public OutputStream open() throws Exception { return fstream; }
@Override public void delete() throws Exception { safeClose(fstream); file.delete(); }
public void addHeader(String name, String value) { header.put(name, value); }
protected void send(OutputStream outputStream) { String mime = mimeType; SimpleDateFormat gmtFrmt = new SimpleDateFormat("E, d MMM yyyy HH:mm:ss 'GMT'", Locale.US); gmtFrmt.setTimeZone(TimeZone.getTimeZone("GMT")); try { if (status == null) { throw new Error("sendResponse(): Status can't be null."); } PrintWriter pw = new PrintWriter(outputStream); pw.print("HTTP/1.1 " + status.getDescription() + " \r\n"); if (mime != null) { pw.print("Content-Type: " + mime + "\r\n"); } if (header == null || header.get("Date") == null) { pw.print("Date: " + gmtFrmt.format(new Date()) + "\r\n"); } if (header != null) { for (String key : header.keySet()) { String value = header.get(key); pw.print(key + ": " + value + "\r\n"); } } sendConnectionHeaderIfNotAlreadyPresent(pw, header); if (requestMethod != Method.HEAD && chunkedTransfer) { sendAsChunked(outputStream, pw); } else { int pending = data != null ? data.available() : 0; sendContentLengthHeaderIfNotAlreadyPresent(pw, header, pending); pw.print("\r\n"); pw.flush(); sendAsFixedLength(outputStream, pending); } outputStream.flush(); safeClose(data); } catch (IOException ioe) { } }
protected void sendContentLengthHeaderIfNotAlreadyPresent( PrintWriter pw, Map<String, String> header, int size) { if (!headerAlreadySent(header, "content-length")) { pw.print("Content-Length: " + size + "\r\n"); } }
protected void sendConnectionHeaderIfNotAlreadyPresent( PrintWriter pw, Map<String, String> header) { if (!headerAlreadySent(header, "connection")) { pw.print("Connection: keep-alive\r\n"); } }
private boolean headerAlreadySent(Map<String, String> header, String name) { boolean alreadySent = false; for (String headerName : header.keySet()) { alreadySent |= headerName.equalsIgnoreCase(name); } return alreadySent; }
private void sendAsChunked(OutputStream outputStream, PrintWriter pw) throws IOException { pw.print("Transfer-Encoding: chunked\r\n"); pw.print("\r\n"); pw.flush(); int BUFFER_SIZE = 16 * 1024; byte[] CRLF = "\r\n".getBytes(); byte[] buff = new byte[BUFFER_SIZE]; int read; while ((read = data.read(buff)) > 0) { outputStream.write(String.format("%x\r\n", read).getBytes()); outputStream.write(buff, 0, read); outputStream.write(CRLF); } outputStream.write(String.format("0\r\n\r\n").getBytes()); }
private void sendAsFixedLength(OutputStream outputStream, int pending) throws IOException { if (requestMethod != Method.HEAD && data != null) { int BUFFER_SIZE = 16 * 1024; byte[] buff = new byte[BUFFER_SIZE]; while (pending > 0) { int read = data.read(buff, 0, ((pending > BUFFER_SIZE) ? BUFFER_SIZE : pending)); if (read <= 0) { break; } outputStream.write(buff, 0, read); pending -= read; } } }
@Override public TempFileManager create() { return new DefaultTempFileManager(); }
private int findHeaderEnd(final byte[] buf, int rlen) { int splitbyte = 0; while (splitbyte + 3 < rlen) { if (buf[splitbyte] == '\r' && buf[splitbyte + 1] == '\n' && buf[splitbyte + 2] == '\r' && buf[splitbyte + 3] == '\n') { return splitbyte + 4; } splitbyte++; } return 0; }
private String saveTmpFile(ByteBuffer b, int offset, int len) { String path = ""; if (len > 0) { FileOutputStream fileOutputStream = null; try { TempFile tempFile = tempFileManager.createTempFile(); ByteBuffer src = b.duplicate(); fileOutputStream = new FileOutputStream(tempFile.getName()); FileChannel dest = fileOutputStream.getChannel(); src.position(offset).limit(offset + len); dest.write(src.slice()); path = tempFile.getName(); } catch (Exception e) { throw new Error(e); } finally { safeClose(fileOutputStream); } } return path; }
private int stripMultipartHeaders(ByteBuffer b, int offset) { int i; for (i = offset; i < b.limit(); i++) { if (b.get(i) == '\r' && b.get(++i) == '\n' && b.get(++i) == '\r' && b.get(++i) == '\n') { break; } } return i + 1; }
private void decodeParms(String parms, Map<String, String> p) { if (parms == null) { queryParameterString = ""; return; } queryParameterString = parms; StringTokenizer st = new StringTokenizer(parms, "&"); while (st.hasMoreTokens()) { String e = st.nextToken(); int sep = e.indexOf('='); if (sep >= 0) { p.put(decodePercent(e.substring(0, sep)).trim(), decodePercent(e.substring(sep + 1))); } else { p.put(decodePercent(e).trim(), ""); } } }
@Override public Iterator<String> iterator() { return cookies.keySet().iterator(); }
public String read(String name) { return cookies.get(name); }
public void set(String name, String value, int expires) { queue.add(new Cookie(name, value, Cookie.getHTTPTime(expires))); }
public void set(Cookie cookie) { queue.add(cookie); }
public void delete(String name) { set(name, "-delete-", -30); }
public void unloadQueue(Response response) { for (Cookie cookie : queue) { response.addHeader("Set-Cookie", cookie.getHTTPHeader()); } }
public static GalleryFragment newInstance(int sectionNumber) { GalleryFragment fragment = new GalleryFragment(); Bundle args = new Bundle(); args.putInt(ARG_SECTION_NUMBER, sectionNumber); fragment.setArguments(args); return fragment; }
@Override public void onItemClick(AdapterView<?> parent, View view, int position, long id) { TextView tvBody = (TextView) view.findViewById(R.id.tvBody); String filename = tvBody.getText().toString() + ".mov"; info.guardianproject.iocipher.File file = new info.guardianproject.iocipher.File(filename); Log.d("GalleryFragment", "Attempting to play " + file.getAbsolutePath()); String fileExtension = MimeTypeMap.getFileExtensionFromUrl(file.getAbsolutePath()); String mimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(fileExtension); if (fileExtension.equals("mp4") || mimeType.startsWith("video")) { Intent intent = new Intent(getActivity(), MjpegViewerActivity.class); intent.setType(mimeType); intent.putExtra("video", file.getAbsolutePath()); startActivity(intent); } }
@Override public void onDestroy() { super.onDestroy(); cursor.close(); }
@Override public void bindView(View view, Context context, android.database.Cursor cursor) { bindView(view, context, (Cursor) cursor); }
public View newView(Context context, android.database.Cursor cursor, ViewGroup parent) { return LayoutInflater.from(context).inflate(R.layout.list_item, parent, false); }
public View newView(Context context, Cursor cursor, ViewGroup parent) { return LayoutInflater.from(context).inflate(R.layout.list_item, parent, false); }
public void onClick(DialogInterface dialog, int id) { videoserver.stop(); videoserver = null; }
public static WebOptimizedMP4Muxer withOldHeader( SeekableByteChannel output, Brand brand, MovieBox oldHeader) throws IOException { int size = (int) oldHeader.getHeader().getSize(); TrakBox vt = oldHeader.getVideoTrack(); SampleToChunkBox stsc = Box.findFirst(vt, SampleToChunkBox.class, "mdia", "minf", "stbl", "stsc"); size -= stsc.getSampleToChunk().length * 12; size += 12; ChunkOffsetsBox stco = Box.findFirst(vt, ChunkOffsetsBox.class, "mdia", "minf", "stbl", "stco"); if (stco != null) { size -= stco.getChunkOffsets().length << 2; size += vt.getFrameCount() << 3; } else { ChunkOffsets64Box co64 = Box.findFirst(vt, ChunkOffsets64Box.class, "mdia", "minf", "stbl", "co64"); size -= co64.getChunkOffsets().length << 3; size += vt.getFrameCount() << 3; } return new WebOptimizedMP4Muxer(output, brand, size + (size >> 1)); }
@Override public void storeHeader(MovieBox movie) throws IOException { long mdatEnd = out.position(); long mdatSize = mdatEnd - mdatOffset + 8; out.position(mdatOffset); NIOUtils.writeLong(out, mdatSize); out.position(headerPos); try { movie.write(header); header.flip(); int rem = header.capacity() - header.limit(); if (rem < 8) { header.duplicate().putInt(header.capacity()); } out.write(header); if (rem >= 8) new Header("free", rem).write(out); } catch (ArrayIndexOutOfBoundsException e) { Logger.warn("Could not web-optimize, header is bigger then allocated space."); new Header("free", header.remaining()).write(out); out.position(mdatEnd); MP4Util.writeMovie(out, movie); } }
public void stopRecording() { isRecording = false; }
protected void onDestroy() { recorder.release(); player.release(); encoder.release(); decoder.release(); }
public boolean setEncoder(int sampleRate, int channels, int bitRate) throws Exception { encoder = MediaCodec.createEncoderByType("audio/mp4a-latm"); MediaFormat format = new MediaFormat(); format.setString(MediaFormat.KEY_MIME, "audio/mp4a-latm"); format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, channels); format.setInteger(MediaFormat.KEY_SAMPLE_RATE, sampleRate); format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate * 1024); format.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectHE); encoder.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); initAudioRecord(sampleRate); return true; }
public boolean setDecoder(int sampleRate, int channels, int bitRate) throws Exception { decoder = MediaCodec.createDecoderByType("audio/mp4a-latm"); MediaFormat format = new MediaFormat(); format.setString(MediaFormat.KEY_MIME, "audio/mp4a-latm"); format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, channels); format.setInteger(MediaFormat.KEY_SAMPLE_RATE, sampleRate); format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate * 1024); format.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectHE); decoder.configure(format, null, null, 0); setPlayer(sampleRate); return true; }
public void addFrame(int width, int height, ByteBuffer buff, long timeScaleFPS, long duration) throws IOException { if (size == null) { size = new Size(width, height); videoTrack.addSampleEntry(MP4Muxer.videoSampleEntry(imageType, size, ENCODER_NAME)); if (af != null) audioTrack.addSampleEntry(MP4Muxer.audioSampleEntry(af)); } videoTrack.addFrame( new MP4Packet(buff, frameNo, timeScaleFPS, 1, frameNo, true, null, frameNo, 0)); frameNo++; }
public void addAudio(ByteBuffer buffer) throws IOException { audioTrack.addSamples(buffer); }
public void finish() throws IOException { videoTrack.addSampleEntry(MP4Muxer.videoSampleEntry(imageType, size, "JCodec")); if (af != null) audioTrack.addSampleEntry(MP4Muxer.audioSampleEntry(af)); muxer.writeHeader(); NIOUtils.closeQuietly(ch); }
@Override public int read(ByteBuffer arg0) throws IOException { return ch.read(arg0); }
@Override public void close() throws IOException { ch.close(); }
@Override public boolean isOpen() { return ch.isOpen(); }
@Override public int write(ByteBuffer arg0) throws IOException { int size = arg0.remaining(); long newPos = position() + size; int result = ch.write(arg0, position()); position(newPos); return result; }
@Override public long position() throws IOException { return ch.position(); }
@Override public SeekableByteChannel position(long newPosition) throws IOException { ch.position(newPosition); return this; }
@Override public long size() throws IOException { return ch.size(); }
@Override public SeekableByteChannel truncate(long size) throws IOException { ch.truncate(size); return this; }
private Rect destRect(int bmw, int bmh) { int tempx; int tempy; if (displayMode == MjpegView.SIZE_STANDARD) { tempx = (dispWidth / 2) - (bmw / 2); tempy = (dispHeight / 2) - (bmh / 2); return new Rect(tempx, tempy, bmw + tempx, bmh + tempy); } if (displayMode == MjpegView.SIZE_BEST_FIT) { float bmasp = (float) bmw / (float) bmh; bmw = dispWidth; bmh = (int) (dispWidth / bmasp); if (bmh > dispHeight) { bmh = dispHeight; bmw = (int) (dispHeight * bmasp); } tempx = (dispWidth / 2) - (bmw / 2); tempy = (dispHeight / 2) - (bmh / 2); return new Rect(tempx, tempy, bmw + tempx, bmh + tempy); } if (displayMode == MjpegView.SIZE_FULLSCREEN) { return new Rect(0, 0, dispWidth, dispHeight); } return null; }
private Bitmap makeFpsOverlay(Paint p, String text) { Rect b = new Rect(); p.getTextBounds(text, 0, text.length(), b); int bwidth = b.width() + 2; int bheight = b.height() + 2; Bitmap bm = Bitmap.createBitmap(bwidth, bheight, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); p.setColor(overlayBackgroundColor); c.drawRect(0, 0, bwidth, bheight, p); p.setColor(overlayTextColor); c.drawText(text, -b.left + 1, (bheight / 2) - ((p.ascent() + p.descent()) / 2) + 1, p); return bm; }
private void init(Context context) { SurfaceHolder holder = getHolder(); holder.addCallback(this); thread = new MjpegViewThread(holder, context); setFocusable(true); overlayPaint = new Paint(); overlayPaint.setTextAlign(Paint.Align.LEFT); overlayPaint.setTextSize(12); overlayPaint.setTypeface(Typeface.DEFAULT); overlayTextColor = Color.WHITE; overlayBackgroundColor = Color.BLACK; ovlPos = MjpegView.POSITION_LOWER_RIGHT; displayMode = MjpegView.SIZE_STANDARD; dispWidth = getWidth(); dispHeight = getHeight(); }
public void startPlayback() { if (mIn != null) { mRun = true; thread.start(); } }
public void stopPlayback() { mRun = false; boolean retry = true; while (retry) { try { thread.join(); retry = false; } catch (InterruptedException e) { e.getStackTrace(); Log.d(TAG, "catch IOException hit in stopPlayback", e); } } }
public void surfaceChanged(SurfaceHolder holder, int f, int w, int h) { thread.setSurfaceSize(w, h); }
public void surfaceDestroyed(SurfaceHolder holder) { surfaceDone = false; stopPlayback(); }
public void surfaceCreated(SurfaceHolder holder) { surfaceDone = true; }
private int getEndOfSeqeunce(DataInputStream in, byte[] sequence) throws IOException { int seqIndex = 0; byte c; int i = 0; while (true) { try { c = (byte) in.readUnsignedByte(); if (c == sequence[seqIndex]) { seqIndex++; if (seqIndex == sequence.length) { return i + 1; } } else { seqIndex = 0; } i++; } catch (EOFException ef) { break; } } return -1; }
private int getStartOfSequence(DataInputStream in, byte[] sequence) throws IOException { int end = getEndOfSeqeunce(in, sequence); return (end < 0) ? (-1) : (end - sequence.length); }
private int parseContentLength(byte[] headerBytes) throws IOException, NumberFormatException { ByteArrayInputStream headerIn = new ByteArrayInputStream(headerBytes); Properties props = new Properties(); props.load(headerIn); return Integer.parseInt(props.getProperty(CONTENT_LENGTH)); }
public Bitmap readMjpegFrame() throws IOException { mark(FRAME_MAX_LENGTH); int headerLen = getStartOfSequence(this, SOI_MARKER); if (headerLen < 0) return null; reset(); byte[] header = new byte[headerLen]; readFully(header); mContentLength = getEndOfSeqeunce(this, EOF_MARKER); if (mContentLength < 0) return null; reset(); byte[] frameData = new byte[mContentLength]; skipBytes(headerLen); readFully(frameData); return BitmapFactory.decodeStream(new ByteArrayInputStream(frameData)); }
public void run() { try { playAudio(); } catch (Exception e) { e.printStackTrace(); } }
public void initAudio(String vfsPath) throws Exception { isAudio = new BufferedInputStream(new FileInputStream(vfsPath)); if (useAAC) { aac = new AACHelper(); aac.setDecoder( MediaConstants.sAudioSampleRate, MediaConstants.sAudioChannels, MediaConstants.sAudioBitRate); } else { int minBufferSize = AudioTrack.getMinBufferSize( MediaConstants.sAudioSampleRate, MediaConstants.sChannelConfigOut, AudioFormat.ENCODING_PCM_16BIT) * 8; at = new AudioTrack( AudioManager.STREAM_MUSIC, MediaConstants.sAudioSampleRate, MediaConstants.sChannelConfigOut, AudioFormat.ENCODING_PCM_16BIT, minBufferSize, AudioTrack.MODE_STREAM); } }
public void playAudio() throws IOException { if (useAAC) aac.startPlaying(isAudio); else { try { byte[] music = null; music = new byte[512]; at.play(); int i = 0; while ((i = isAudio.read(music)) != -1) at.write(music, 0, i); } catch (IOException e) { e.printStackTrace(); } at.stop(); at.release(); isAudio.close(); at = null; } }
public void onPause() { super.onPause(); mv.stopPlayback(); if (at != null) at.stop(); timeout(); }
@Override public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
@Override public void onTextChanged(CharSequence s, int start, int before, int count) { TextView warning = (TextView) findViewById(R.id.match_warn); warning.setText(""); Button createButton = (Button) findViewById(R.id.create_button); createButton.setEnabled(true); }
@Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.menu_main, menu); return true; }
public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.unlock); watch(); }
@Override public void onTextChanged(CharSequence s, int start, int before, int count) { TextView warning = (TextView) findViewById(R.id.pass_warn); warning.setText(""); Button createButton = (Button) findViewById(R.id.unlock_button); createButton.setEnabled(true); }
private double convert(double min) { double current = min; double max = 1; while (current < 1) { current = current * 10; max = max * 10; } return max; }
@Test public void test_delay2() { rabbitTemplate.convertAndSend( "delay_exchange", "delay_key", "123123", message -> { message.getMessageProperties().setHeader("x-delay", 15000); return message; }); }
@Test public void test_create_rebate_order() { BehaviorEntity behaviorEntity = new BehaviorEntity(); behaviorEntity.setUserId("ogdb46DaYxN6nliqjeveqnZMfqmI"); behaviorEntity.setOutBusinessNo("20250511"); behaviorEntity.setBehaviorTypeVO(BehaviorTypeVO.SIGN); rebateService.createOrder(behaviorEntity); }
@Test public void test_cacheStrategyAwardCount() { String cacheKey = Constants.RedisKey.STRATEGY_AWARD_COUNT_KEY + "300001" + Constants.UNDERLINE + "102"; strategyRepository.cacheStrategyAwardCount(cacheKey, 10); }
@Test public void test_subtractionAwardStock() { String cacheKey = Constants.RedisKey.STRATEGY_AWARD_COUNT_KEY + "300001" + Constants.UNDERLINE + "102"; strategyRepository.subtractionAwardStock(cacheKey); }
@Test public void test_queue() throws InterruptedException { String cacheKey = Constants.RedisKey.STRATEGY_AWARD_COUNT_QUERY_KEY; RBlockingQueue<StrategyAwardStockKeyVO> blockingQueue = redisService.getBlockingQueue(cacheKey); RDelayedQueue<StrategyAwardStockKeyVO> delayedQueue = redisService.getDelayedQueue(blockingQueue); delayedQueue.offer( StrategyAwardStockKeyVO.builder().strategyId(100001L).awardId(102).build(), 3, TimeUnit.SECONDS); new CountDownLatch(1).await(); }
@Test public void testQuery() throws IOException { List<UserAwardRecordDoc> last20UserAwardRecordsByActivityId = userAwardRecordIndex.queryLastestDocByActivityId(100302L, 20); System.out.println(last20UserAwardRecordsByActivityId); }
public static void main(String[] args) { SpringApplication.run(Application.class); }
@Bean public SnowflakeGenerator snowflakeGenerator() { return new SnowflakeGenerator(1, 0); }
@Bean(name = "cache") public Cache<String, String> cache() { return CacheBuilder.newBuilder().expireAfterWrite(3, TimeUnit.SECONDS).build(); }
@Bean public XxlJobSpringExecutor xxlJobExecutor() { XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setAddress(address); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; }
private Method getMethod(JoinPoint jp) throws NoSuchMethodException { Signature sig = jp.getSignature(); MethodSignature methodSignature = (MethodSignature) sig; return jp.getTarget() .getClass() .getMethod(methodSignature.getName(), methodSignature.getParameterTypes()); }
@Override public EventMessage<SendAwardMessage> buildEventMessage(SendAwardMessage data) { return EventMessage.<SendAwardMessage>builder() .id(RandomStringUtils.randomNumeric(11)) .timestamp(new Date()) .data(data) .build(); }
@Override public BaseEvent.EventMessage<SyncAwardRecordEvent.SyncRecordMessage> buildEventMessage( SyncAwardRecordEvent.SyncRecordMessage data) { return BaseEvent.EventMessage.<SyncAwardRecordEvent.SyncRecordMessage>builder() .id(RandomStringUtils.randomNumeric(11)) .timestamp(new Date()) .data(data) .build(); }
public static UserAwardRecordEntity buildDistributeUserAwardRecordEntity( String userId, String orderId, Integer awardId, AwardStateVO awardState) { UserAwardRecordEntity userAwardRecord = new UserAwardRecordEntity(); userAwardRecord.setUserId(userId); userAwardRecord.setOrderId(orderId); userAwardRecord.setAwardId(awardId); userAwardRecord.setAwardState(awardState); return userAwardRecord; }
public static UserCreditAwardEntity buildUserCreditAwardEntity( String userId, BigDecimal creditAmount) { return UserCreditAwardEntity.builder().userId(userId).creditAmount(creditAmount).build(); }
@Override public List<UserAwardRecordEntity> queryLastestAwardingRecord(Long activityId, int count) throws IOException { return awardRepository.queryLastestAwardingRecord(activityId, count); }
@Override public PageData<UserAwardRecordEntity> queryUserAwardingRecord( int page, int pageSize, String userId) { return awardRepository.queryUserAwardingRecord(page, pageSize, userId); }
@Override public void saveUserAwardRecordDoc(UserAwardRecordDocEntity userAwardRecordDoc) throws IOException { awardRepository.saveUserAwardRecordDoc(userAwardRecordDoc); }
private BigDecimal generateRandom(BigDecimal min, BigDecimal max) { if (min.equals(max)) return min; BigDecimal randomBigDecimal = min.add(BigDecimal.valueOf(Math.random()).multiply(max.subtract(min))); return randomBigDecimal.round(new MathContext(3)); }
public static CreditAccountEntity createCreditAccountEntity( String userId, BigDecimal adjustAmount) { return CreditAccountEntity.builder().userId(userId).adjustAmount(adjustAmount).build(); }
public static CreditOrderEntity createCreditOrderEntity( String userId, TradeNameVO tradeName, TradeTypeVO tradeType, BigDecimal tradeAmount, String outBusinessNo) { return CreditOrderEntity.builder() .userId(userId) .orderId(RandomStringUtils.randomNumeric(12)) .tradeName(tradeName) .tradeType(tradeType) .tradeAmount(tradeAmount) .outBusinessNo(outBusinessNo) .build(); }
@Override public EventMessage<Long> buildEventMessage(Long sku) { return EventMessage.<Long>builder() .id(RandomStringUtils.randomNumeric(11)) .timestamp(new Date()) .data(sku) .build(); }
@Override public boolean subtractionActivitySkuStock(Long sku, Date endDateTime) { String cacheKey = Constants.RedisKey.ACTIVITY_SKU_STOCK_COUNT_KEY + sku; return activityRepository.subtractionActivitySkuStock(sku, cacheKey, endDateTime); }
@Override public Boolean skuStockAssembleCheck(Long sku) { String cacheKey = Constants.RedisKey.ACTIVITY_SKU_STOCK_COUNT_KEY + sku; return activityRepository.skuStockAssembleCheck(cacheKey); }
@Override protected void doCreateOrder(CreateQuotaOrderAggregate createOrderAggregate) { activityRepository.saveOrder(createOrderAggregate); }
@Override protected void activityCheckChain( ActivitySkuEntity activitySkuEntity, ActivityEntity activityEntity, ActivityCountEntity activityCountEntity) { IActionChain iActionChain = activityChainFactory.openActionChain(); iActionChain.action(activitySkuEntity, activityEntity, activityCountEntity); }
@Override public ActivitySkuStockKeyVO takeQueueValue() throws InterruptedException { return activityRepository.takeQueueValue(); }
@Override public void clearQueue() { activityRepository.clearQueueValue(); }
@Override public void updateActivitySkuStock(Long sku) { activityRepository.updateActivitySkuStock(sku); }
@Override public void clearActivitySkuStock(Long sku) { activityRepository.clearActivitySkuStock(sku); }
@Override public Integer queryRaffleActivityAccountDayPartakeCount(Long activityId, String userId) { return activityRepository.queryRaffleActivityAccountDayPartakeCount(activityId, userId); }
@Override public Integer queryRaffleActivityAccountTotalPartakeCount(Long activityId, String userId) { return activityRepository.queryRaffleActivityAccountTotalPartakeCount(activityId, userId); }
@Override public ActivityAccountEntity queryActivityAccountEntity(Long activityId, String userId) { return activityRepository.queryActivityAccountEntity(activityId, userId); }
public ActivitySkuEntity queryActivitySku(Long sku) { return activityRepository.queryActivitySku(sku); }
public ActivityEntity queryActivity(Long activityId) { return activityRepository.queryRaffleActivityByActivityId(activityId); }
public ActivityCountEntity queryActivityCount(Long activityCountId) { return activityRepository.queryRaffleActivityCountByActivityCountId(activityCountId); }
@Override public IActionChain next() { return next; }
@Override public IActionChain appendNext(IActionChain next) { this.next = next; return next; }
public IActionChain openActionChain() { return this.actionChain; }
@Override public UserRaffleOrderEntity createOrder(String userid, Long activityId) { PartakeRaffleActivityEntity partakeRaffleActivityEntity = new PartakeRaffleActivityEntity(); partakeRaffleActivityEntity.setUserId(userid); partakeRaffleActivityEntity.setActivityId(activityId); return createOrder(partakeRaffleActivityEntity); }
@Override public ActivityEntity queryActivityById(Long activityId) { return repository.queryRaffleActivityByActivityId(activityId); }
@Override public EventMessage<RebateMessage> buildEventMessage(RebateMessage data) { return EventMessage.<RebateMessage>builder() .id(RandomStringUtils.randomNumeric(11)) .timestamp(new Date()) .data(data) .build(); }
@Override public List<BehaviorRebateOrderEntity> queryOrderByOutBusinessNo( String userId, String outBusinessNo) { return repository.queryOrderByOutBusinessNo(userId, outBusinessNo); }
@Override public List<TaskEntity> queryNoSendMessageTaskList() { return taskRepository.queryNoSendMessageTaskList(); }
@Override public void sendMessage(TaskEntity taskEntity) {}
@Override public void updateTaskSendMessageCompleted(String userId, String messageId) {}
@Override public void updateTaskSendMessageFail(String userId, String messageId) {}
public String[] ruleModels() { if (StringUtils.isBlank(ruleModels)) return null; return ruleModels.split(Constants.SPLIT); }
private RaffleAwardEntity buildRaffleAwardEntity( Long strategyId, Integer awardId, String awardConfig) { StrategyAwardEntity strategyAward = repository.queryStrategyAwardEntity(strategyId, awardId); return RaffleAwardEntity.builder() .awardId(awardId) .awardTitle(strategyAward.getAwardTitle()) .awardImage(strategyAward.getAwardImage()) .awardConfig(awardConfig) .sort(strategyAward.getSort()) .build(); }
@Override public DefaultChainFactory.StrategyAwardVO raffleLogicChain(String userId, Long strategyId) { ILogicChain logicChain = defaultChainFactory.openLogicChain(strategyId); return logicChain.logic(userId, strategyId); }
@Override public StrategyAwardStockKeyVO takeQueueValue() throws InterruptedException { return repository.takeQueueValue(); }
@Override public void updateStrategyAwardStock(Long strategyId, Integer awardId) { repository.updateStrategyAwardStock(strategyId, awardId); }
@Override public List<StrategyAwardEntity> queryRaffleStrategyAwardList(Long strategyId) { return repository.queryStrategyAwardList(strategyId); }
@Override public Map<String, Integer> queryAwardRuleLockCountByRuleIds(String[] treeIds) { return repository.queryAwardRuleLockCountByRuleIds(treeIds); }
@Override public List<RuleWeightVO> queryAwardRuleWeight(Long strategyId, String userId) { return repository.queryAwardRuleWeight(strategyId, userId); }
@Override public ILogicChain next() { return next; }
@Override public ILogicChain appendNext(ILogicChain next) { this.next = next; return next; }
@Override protected String ruleModel() { return DefaultChainFactory.LogicModel.RULE_DEFAULT.getCode(); }
@Override protected String ruleModel() { return DefaultChainFactory.LogicModel.RULE_BLACKLIST.getCode(); }
@Override protected String ruleModel() { return DefaultChainFactory.LogicModel.RULE_WEIGHT.getCode(); }
public IDecisionTreeEngine openLogicTree(RuleTreeVO ruleTreeVO) { return new DecisionTreeEngine(logicTreeNodeGroup, ruleTreeVO); }
private void cacheStrategyAwardCount(Long strategyId, Integer awardId, Integer awardCount) { String cacheKey = Constants.RedisKey.STRATEGY_AWARD_COUNT_KEY + strategyId + Constants.UNDERLINE + awardId; repository.cacheStrategyAwardCount(cacheKey, awardCount); }
@Override public Boolean subtractionAwardStock(Long strategyId, Integer awardId) { String cacheKey = Constants.RedisKey.STRATEGY_AWARD_COUNT_KEY + strategyId + Constants.UNDERLINE + awardId; return repository.subtractionAwardStock(cacheKey); }
public Response<String> limitError(String code, HttpServletRequest request) { return Response.<String>builder() .code(ResponseCode.VIEW_LIMIT.getCode()) .info(ResponseCode.VIEW_LIMIT.getInfo()) .build(); }
public String currentDay() { return dateFormatDay.format(new Date()); }
public String currentMonth() { return dateFormatDay.format(new Date()); }
@Override public void removeCodeByOpenId(String code, String openId) { redisService.remove(Key + code); redisService.remove(Key + openId); }
@Override public ActivitySkuEntity queryActivitySku(Long sku) { RaffleActivitySku raffleActivitySku = raffleActivitySkuDao.queryActivitySku(sku); if (raffleActivitySku == null) return null; return ActivitySkuEntity.builder() .sku(raffleActivitySku.getSku()) .activityId(raffleActivitySku.getActivityId()) .activityCountId(raffleActivitySku.getActivityCountId()) .stockCount(raffleActivitySku.getStockCount()) .stockCountSurplus(raffleActivitySku.getStockCountSurplus()) .build(); }
@Override public void cacheActivityStock(String cacheKey, Integer stockCount) { if (redisService.isExists(cacheKey)) return; redisService.setAtomicLong(cacheKey, stockCount); }
@Override public void skuCountStockConsumeSendQueue(ActivitySkuStockKeyVO activitySkuStockKeyVO) { String cacheKey = Constants.RedisKey.ACTIVITY_SKU_COUNT_QUERY_KEY; RBlockingQueue<ActivitySkuStockKeyVO> blockingQueue = redisService.getBlockingQueue(cacheKey); RDelayedQueue<ActivitySkuStockKeyVO> delayedQueue = redisService.getDelayedQueue(blockingQueue); delayedQueue.offer(activitySkuStockKeyVO, 3, TimeUnit.SECONDS); }
@Override public ActivitySkuStockKeyVO takeQueueValue() throws InterruptedException { String cacheKey = Constants.RedisKey.ACTIVITY_SKU_COUNT_QUERY_KEY; RBlockingQueue<ActivitySkuStockKeyVO> blockingQueue = redisService.getBlockingQueue(cacheKey); return blockingQueue.poll(); }
@Override public void clearQueueValue() { String cacheKey = Constants.RedisKey.ACTIVITY_SKU_COUNT_QUERY_KEY; redisService.getBlockingQueue(cacheKey).clear(); }
@Override public void updateActivitySkuStock(Long sku) { raffleActivitySkuDao.updateActivitySkuStock(sku); }
@Override public void clearActivitySkuStock(Long sku) { raffleActivitySkuDao.clearActivitySkuStock(sku); }
@Override public Boolean skuStockAssembleCheck(String cacheKey) { return redisService.isExists(cacheKey); }
@Override public Integer queryRaffleActivityAccountDayPartakeCount(Long activityId, String userId) { RaffleActivityAccountDay raffleActivityAccountDay = new RaffleActivityAccountDay(); raffleActivityAccountDay.setActivityId(activityId); raffleActivityAccountDay.setUserId(userId); raffleActivityAccountDay.setDay(raffleActivityAccountDay.currentDay()); Integer count = raffleActivityAccountDayDao.queryRaffleActivityAccountDayPartakeCount( raffleActivityAccountDay); return null == count ? 0 : count; }
@Override public Integer queryRaffleActivityAccountTotalPartakeCount(Long activityId, String userId) { RaffleActivityAccount raffleActivityAccountDay = new RaffleActivityAccount(); raffleActivityAccountDay.setActivityId(activityId); raffleActivityAccountDay.setUserId(userId); Integer count = raffleActivityAccountDao.queryRaffleActivityAccountTotalPartakeCount( raffleActivityAccountDay); return null == count ? 0 : count; }
@Override public StrategyRuleEntity queryStrategyRule(Long strategyId, String ruleModel) { StrategyRule strategyRuleReq = new StrategyRule(); strategyRuleReq.setStrategyId(strategyId); strategyRuleReq.setRuleModel(ruleModel); StrategyRule strategyRuleRes = strategyRuleDao.queryStrategyRule(strategyRuleReq); if (null == strategyRuleRes) return null; return StrategyRuleEntity.builder() .strategyId(strategyRuleRes.getStrategyId()) .awardId(strategyRuleRes.getAwardId()) .ruleType(strategyRuleRes.getRuleType()) .ruleModel(strategyRuleRes.getRuleModel()) .ruleValue(strategyRuleRes.getRuleValue()) .ruleDesc(strategyRuleRes.getRuleDesc()) .build(); }
@Override public String queryStrategyRuleValue(Long strategyId, String ruleModel) { return queryStrategyRuleValue(strategyId, null, ruleModel); }
@Override public String queryStrategyRuleValue(Long strategyId, Integer awardId, String ruleModel) { StrategyRule strategyRule = new StrategyRule(); strategyRule.setStrategyId(strategyId); strategyRule.setAwardId(awardId); strategyRule.setRuleModel(ruleModel); return strategyRuleDao.queryStrategyRuleValue(strategyRule); }
@Override public StrategyAwardRuleModelVO queryStrategyAwardRuleModelVO(Long strategyId, Integer awardId) { StrategyAward strategyAward = new StrategyAward(); strategyAward.setStrategyId(strategyId); strategyAward.setAwardId(awardId); String ruleModels = strategyAwardDao.queryStrategyAwardRuleModels(strategyAward); if (null == ruleModels) return null; return StrategyAwardRuleModelVO.builder().ruleModels(ruleModels).build(); }
@Override public void cacheStrategyAwardCount(String cacheKey, Integer awardCount) { if (redisService.isExists(cacheKey)) return; redisService.setAtomicLong(cacheKey, awardCount); }
@Override public StrategyAwardStockKeyVO takeQueueValue() throws InterruptedException { String cacheKey = Constants.RedisKey.STRATEGY_AWARD_COUNT_QUERY_KEY; RBlockingQueue<StrategyAwardStockKeyVO> destinationQueue = redisService.getBlockingQueue(cacheKey); return destinationQueue.poll(); }
@Override public void updateStrategyAwardStock(Long strategyId, Integer awardId) { StrategyAward strategyAward = new StrategyAward(); strategyAward.setStrategyId(strategyId); strategyAward.setAwardId(awardId); strategyAwardDao.updateStrategyAwardStock(strategyAward); }
@Override public Long queryStrategyIdByActivityId(Long activityId) { return raffleActivityDao.queryStrategyIdByActivityId(activityId); }
@Override public String queryAwardConfig(Integer awardId) { return awardDao.queryAwardConfigById(awardId); }
@Override public String queryAwardKey(Integer awardId) { return awardDao.queryAwardKeyById(awardId); }
@Override public long incr(String key) { return redissonClient.getAtomicLong(key).incrementAndGet(); }
@Override public long incrBy(String key, long delta) { return redissonClient.getAtomicLong(key).addAndGet(delta); }
@Override public long decr(String key) { return redissonClient.getAtomicLong(key).decrementAndGet(); }
@Override public long decrBy(String key, long delta) { return redissonClient.getAtomicLong(key).addAndGet(-delta); }
@Override public void remove(String key) { redissonClient.getBucket(key).delete(); }
@Override public boolean isExists(String key) { return redissonClient.getBucket(key).isExists(); }
public void addToSet(String key, String value) { RSet<String> set = redissonClient.getSet(key); set.add(value); }
public boolean isSetMember(String key, String value) { RSet<String> set = redissonClient.getSet(key); return set.contains(value); }
public void addToList(String key, String value) { RList<String> list = redissonClient.getList(key); list.add(value); }
public void addToMap(String key, String field, String value) { RMap<String, String> map = redissonClient.getMap(key); map.put(field, value); }
public void addToSortedSet(String key, String value) { RSortedSet<String> sortedSet = redissonClient.getSortedSet(key); sortedSet.add(value); }
@Override public String toString() { return "cn.bugstack.types.exception.AppException{" + "code='" + code + '\'' + ", info='" + info + '\'' + '}'; }
public static void customResolveLazyCrossReferences(LazyLinkingResource resource) throws InterruptedException { EcoreUtil2.resolveLazyCrossReferences(resource, null); Collection<BslResolveCrossReferencesJob> jobs = BslResolveCrossReferencesJob.findJobsByResource(resource); for (BslResolveCrossReferencesJob job : jobs) { job.join(); } }
@Override public XtextResource exec(XtextResource state) throws Exception { return state; }
protected DerivedStateAwareResource getResourceFromProject(String projectName, String fileName) throws Exception { IProject project = testingWorkspace.setUpProject(projectName, getClass()); testingWorkspace.waitForBuildCompletion(); BslPackage.eINSTANCE.eClass(); IV8File file = V8ModelManager.INSTANCE.getV8Model().getV8Project(projectName).getV8File(fileName); assertTrue(file instanceof V8XtextFile); V8XtextFile xtextFile = (V8XtextFile) file; return getResourceFromFile(xtextFile); }
protected void initProject(String projectName) throws Exception, CoreException, IOException, InterruptedException { testingWorkspace.cleanUpWorkspace(); IProject project = testingWorkspace.setUpProject(projectName, getClass()); ServiceAccess.get(IBmModelManager.class).waitModelSynchronization(project); BslPackage.eINSTANCE.eClass(); testingWorkspace.waitForBuildCompletion(); }
protected Module init(String projectName, String fileName) throws Exception { res = getResourceFromProject(projectName, fileName); assertTrue(res instanceof BslResource); ((BslResource) res).setDeepAnalysis(true); IResourceServiceProvider provider = res.getResourceServiceProvider(); initilizeSpecialServicesByRSP(provider); EObject eObject = res.getContents().get(0); assertTrue(eObject instanceof Module); customResolveLazyCrossReferences(res); return (Module) eObject; }
protected Module init(String projectName) throws Exception { return init(projectName, "/src/CommonModules/CommonModule/Module.bsl"); }
protected Module getBslModule(String projectName, String fileName) throws Exception { IV8File file = V8ModelManager.INSTANCE.getV8Model().getV8Project(projectName).getV8File(fileName); assertTrue(file instanceof V8XtextFile); V8XtextFile xtextFile = (V8XtextFile) file; DerivedStateAwareResource resource = getResourceFromFile(xtextFile); assertTrue(resource instanceof BslResource); ((BslResource) resource).setDeepAnalysis(true); IResourceServiceProvider provider = resource.getResourceServiceProvider(); initilizeSpecialServicesByRSP(provider); EObject eObject = resource.getContents().get(0); assertTrue(eObject instanceof Module); customResolveLazyCrossReferences(resource); return (Module) eObject; }
@Before public void initTestProjects() throws Exception { project = testingWorkspace.getWorkspaceRoot().getProject(PROJECT_NAME); if (!project.isAccessible()) { initProject(PROJECT_NAME); } }
@After public void afterTest() throws Exception { restoreState(oldFileContent, oldFile); }
@Override protected void initilizeSpecialServicesByRSP(IResourceServiceProvider rsp) { typesComputer = rsp.get(TypesComputer.class); assertNotNull(typesComputer); }
@Test public void testFunctionCopyRecursiveReturnFixArray() throws Exception { readOldContents(); File newFile = new File(FOLDER_NAME + "common-functions/copy-recursive.bsl"); replaceFileContent(oldFile, newFile); Module module = getBslModule(PROJECT_NAME, PATH_COMMON_MODULE_TEST); Method method = module.allMethods().get(4); Expression array = getRightExpr(method.getStatements().get(1)); checkExpr(array, Lists.newArrayList(IEObjectTypeNames.FIXED_ARRAY)); Environmental envs = EcoreUtil2.getContainerOfType(array, Environmental.class); List<TypeItem> types = typesComputer.computeTypes(array, envs.environments()); assertEquals(2, types.size()); assertTrue(types.get(0) instanceof Type); Type type = (Type) types.get(0); Type collectionType = (Type) type.getCollectionElementTypes().allTypes().get(0); assertEquals(IEObjectTypeNames.STRUCTURE, McoreUtil.getTypeName(collectionType)); }
@Test public void testFunctionCopyRecursiveReturnValueList() throws Exception { readOldContents(); File newFile = new File(FOLDER_NAME + "common-functions/copy-recursive.bsl"); replaceFileContent(oldFile, newFile); Module module = getBslModule(PROJECT_NAME, PATH_COMMON_MODULE_TEST); Method method = module.allMethods().get(5); Expression structure = getRightExpr(method.getStatements().get(2)); checkExpr(structure, Lists.newArrayList(IEObjectTypeNames.VALUE_LIST)); Environmental envs = EcoreUtil2.getContainerOfType(structure, Environmental.class); List<TypeItem> types = typesComputer.computeTypes(structure, envs.environments()); assertEquals(1, types.size()); assertTrue(types.get(0) instanceof Type); Type type = (Type) types.get(0); assertEquals(IEObjectTypeNames.VALUE_LIST, McoreUtil.getTypeName(type)); }
private void checkExpr(EObject expr, List<String> expectedType) { Environmental envs = EcoreUtil2.getContainerOfType(expr, Environmental.class); List<TypeItem> types = typesComputer.computeTypes(expr, envs.environments()); Set<String> setTypes = new HashSet<>(); for (TypeItem type : types) { setTypes.add(McoreUtil.getTypeName(type)); } assertEquals(Sets.newHashSet(expectedType), setTypes); }
private void checkProperties( List<Property> properties, Map<String, Collection<String>> expected, boolean isPropertyRu, boolean allowOtherProp) { assertNotNull(properties); assertEquals(expected.isEmpty(), properties.isEmpty()); Map<String, Collection<String>> toCheck = Maps.newHashMap(expected); for (Property property : properties) { String keyName = isPropertyRu ? property.getNameRu() : property.getName(); assertNotNull(keyName); Collection<String> types = toCheck.remove(keyName); assertTrue( MessageFormat.format("Found not expected property {0}", keyName), types != null || allowOtherProp); if (types == null) continue; Set<String> actualTypes = Sets.newHashSet( property.getTypes().stream() .map(McoreUtil::getTypeName) .collect(Collectors.toList())); assertEquals(Sets.newHashSet(types), actualTypes); } assertEquals("Not all checking properties found", Maps.newHashMap(), toCheck); }
private void replaceFileContent(IFile oldFile, File newFile) throws Exception { InputStream stream = new FileInputStream(newFile); updateFileContent(oldFile, stream); }
private void restoreState(String oldFileContent, IFile oldFile) throws Exception { InputStream stream = new StringInputStream(oldFileContent); updateFileContent(oldFile, stream); }
private void updateFileContent(IFile file, InputStream stream) throws Exception { file.setContents(stream, true, false, null); testingWorkspace.buildWorkspace(); project.refreshLocal(IResource.DEPTH_INFINITE, new NullProgressMonitor()); try { Job.getJobManager().join(ResourcesPlugin.FAMILY_AUTO_BUILD, null); Job.getJobManager().join(ResourcesPlugin.FAMILY_MANUAL_BUILD, null); } catch (OperationCanceledException | InterruptedException e) { throw new IllegalStateException("Cannot update file:" + file.toString(), e); } }
private void replaceFileContent(IFile oldFile, File newFile) throws Exception { try (InputStream stream = new FileInputStream(newFile)) { updateFileContent(oldFile, stream); } }
private void restoreState(String oldFileContent, IFile oldFile) throws Exception { try (InputStream stream = new StringInputStream(oldFileContent, StandardCharsets.UTF_8.name())) { updateFileContent(oldFile, stream); } }
private void updateFileContent(IFile file, InputStream stream) throws Exception { file.setContents(stream, true, false, null); project.refreshLocal(IResource.DEPTH_INFINITE, new NullProgressMonitor()); try { Job.getJobManager().join(ResourcesPlugin.FAMILY_AUTO_BUILD, null); Job.getJobManager().join(ResourcesPlugin.FAMILY_MANUAL_BUILD, null); } catch (OperationCanceledException | InterruptedException e) { throw new IllegalStateException("Cannot update file:" + file.toString(), e); } }
protected List<TypeItem> computeTypes(Invocation inv, String paramContent) { List<TypeItem> refTypes = getReturnRefTypes(inv.getParams().get(0)); if (refTypes.isEmpty()) return Collections.emptyList(); String content = paramContent.trim().replace(System.lineSeparator(), ""); if (content.isEmpty()) return Collections.emptyList(); String[] properties = content.split("\\.", -1); return getTypeByPropertyName(refTypes, properties, inv); }
protected List<TypeItem> computeTypes(Invocation inv, String paramContent) { String content = paramContent.trim(); String[] parts = content.split("\\."); if (parts.length == 2 && paramContent.split(System.lineSeparator()).length == 1) { String key = parts[0].toLowerCase(); if (NON_REF_MANAGER_MODULE_BASE.containsKey(key)) { QualifiedName fqn = NON_REF_MANAGER_MODULE_BASE.get(key).append(parts[1]); TypeItem type = getTypesByFqn(fqn, inv); return type == null ? Collections.emptyList() : Lists.newArrayList(type); } else if (REF_MANAGER_MODULE_BASE.containsKey(key)) { QualifiedName fqn = REF_MANAGER_MODULE_BASE.get(key).append(parts[1]); TypeItem type = getTypesByFqn(fqn, inv); return type == null ? Collections.emptyList() : Lists.newArrayList(type); } } return Collections.emptyList(); }
private TypeItem computeType(TypeItem sourceType, TypeItem item, EObject context) { Type type = EcoreUtil2.cloneWithProxies((Type) EcoreUtil.resolve(item, context)); TypeItem resolveSourceType = (TypeItem) EcoreUtil.resolve(sourceType, context); if (resolveSourceType instanceof Type && !resolveSourceType.eIsProxy()) { TypeContainerRef containerRef = McoreFactory.eINSTANCE.createTypeContainerRef(); containerRef .getTypes() .addAll(((Type) resolveSourceType).getCollectionElementTypes().allTypes()); type.setCollectionElementTypes(containerRef); type.setIterable(type.isIterable()); } return type; }
private List<TypeItem> transformTypes( Expression expr, Invocation context, boolean isResultFixData) { Environmental envs = EcoreUtil2.getContainerOfType(expr, Environmental.class); List<TypeItem> types = typesComputer.computeTypes(expr, envs.environments()); if (types.isEmpty()) { return Collections.emptyList(); } return types.stream() .map(it -> transformType(it, envs, context, isResultFixData)) .collect(Collectors.toList()); }
private Optional<Boolean> needTransformCollectionType(EList<Expression> params) { if (params.size() != 2) return Optional.empty(); Expression expression = params.get(1); if (!(expression instanceof BooleanLiteral)) return Optional.empty(); BooleanLiteral returnFixDataParam = (BooleanLiteral) expression; return Optional.of(returnFixDataParam.isIsTrue()); }
public Map<String, Triple<StringLiteral, String, StringLiteral>> getStructureExpressionContent( EObject expression) { if (expression instanceof OperatorStyleCreator) { return getStructureExpressionContent((OperatorStyleCreator) expression); } else if (expression instanceof StaticFeatureAccess) { return getStructureExpressionContent((StaticFeatureAccess) expression); } return new HashMap<>(); }
private List<TypeItem> computeTypes(Invocation inv, Collection<Property> properties) { IEObjectProvider provider = IEObjectProvider.Registry.INSTANCE.get( McorePackage.Literals.TYPE_ITEM, versionSupport.getRuntimeVersionOrDefault(inv, Version.LATEST)); TypeItem structure = provider.getProxy(IEObjectTypeNames.STRUCTURE); Type structureType = EcoreUtil2.cloneWithProxies((Type) EcoreUtil.resolve(structure, inv)); for (Property prop : properties) { if (prop instanceof DerivedProperty) { DerivedProperty property = McoreFactory.eINSTANCE.createDerivedProperty(); property.setName(prop.getName()); property.setNameRu(prop.getNameRu()); property.setReadable(true); property.setWritable(true); property.setTypeContainer(McoreFactory.eINSTANCE.createTypeContainerRef()); ((TypeContainerRef) property.getTypeContainer()).getTypes().addAll(prop.getTypes()); property.setSource(((DerivedProperty) prop).getSource()); structureType.getContextDef().getProperties().add(property); } } List<TypeItem> collectionTypes = Lists.newArrayList(); collectionTypes.add(structureType); return collectionTypes; }
private TypeItem computeTypes(Invocation inv, TypeItem type) { String name = McoreUtil.getTypeName(type); String[] parts = name.split("\\."); if (parts.length != 2) return null; String key = parts[0].toLowerCase(); if (key.endsWith(REF)) key = key.substring(0, key.length() - REF.length()); if (REF_MANAGER_MODULE_BASE.containsKey(key)) { QualifiedName fqn = REF_MANAGER_MODULE_BASE.get(key).append(parts[1]); return getTypesByFqn(fqn, inv); } return null; }
private List<TypeItem> computeTypesByString(Invocation inv, List<TypeItem> refTypes) { Pair<String, Collection<StringLiteral>> paramContent = expressionValueComputer.getExpressionContent(inv.getParams().get(1)); if (paramContent == null) return Collections.emptyList(); return computeTypes(inv, refTypes, paramContent.getFirst()); }
private BslDerivedPropertySource createLiteralSource( StringLiteral literal, String literalText, int literalStatiPosition) { BslDerivedPropertySource bslSource = BslFactory.eINSTANCE.createBslDerivedPropertySource(); Module module = EcoreUtil2.getContainerOfType(literal, Module.class); bslSource.setModuleUri(EcoreUtil.getURI(module).toString()); ICompositeNode node = NodeModelUtils.getNode(literal); int localOffset = node.getOffset() + node.getText().indexOf(literalText, literalStatiPosition); String methodName = ""; Method method = EcoreUtil2.getContainerOfType(literal, Method.class); if (method != null) { methodName = method.getName(); ICompositeNode methodNode = NodeModelUtils.findActualNodeFor(method); localOffset = localOffset - methodNode.getTotalOffset(); } bslSource.setLocalOffset(localOffset); bslSource.setMethodName(methodName); return bslSource; }
protected List<TypeItem> computeTypes( Invocation inv, List<TypeItem> refTypes, String paramContent) { String content = paramContent.trim().replace(System.lineSeparator(), ""); String[] attributes = content .replace(" ", "") .toLowerCase() .split("\\,"); if (attributes.length == 0) return Collections.emptyList(); Map<String, Pair<String, EObject>> names = new HashMap<>(); for (int i = 0; i < attributes.length; i++) { String attribute = attributes[i]; names.put(attribute, Tuples.create(attribute, null)); } return createCustomTypeByPropertyNames(refTypes, names, inv); }
protected List<TypeItem> computeTypes( Invocation inv, List<TypeItem> refTypes, Map<String, Pair<String, EObject>> paramContent) { return createCustomTypeByPropertyNames(refTypes, paramContent, inv); }
@Override protected List<TypeItem> computeTypes( Invocation inv, List<TypeItem> refTypes, String paramContent) { List<TypeItem> types = super.computeTypes(inv, refTypes, paramContent); if (!types.isEmpty()) { return typesComputerHelper.createCustomMapType(refTypes, types, inv); } return Collections.emptyList(); }
public List<TypeItem> createCustomMapType( List<TypeItem> keyTypes, List<TypeItem> valueTypes, EObject context) { IEObjectProvider provider = IEObjectProvider.Registry.INSTANCE.get( McorePackage.Literals.TYPE_ITEM, this.versionSupport.getRuntimeVersionOrDefault(context, Version.LATEST)); Type type = (Type) provider.getProxy(IEObjectTypeNames.MAP); Type mapType = createCustomMapWithType(type, keyTypes, valueTypes, context, provider); return Collections.singletonList(mapType); }
private DerivedProperty cloneProperty(DerivedProperty prop) { DerivedProperty property = McoreFactory.eINSTANCE.createDerivedProperty(); property.setName(prop.getName()); property.setNameRu(prop.getNameRu()); property.setReadable(prop.isReadable()); property.setWritable(prop.isWritable()); property.setTypeContainer(McoreFactory.eINSTANCE.createTypeContainerRef()); TypeContainer typeContainer = property.getTypeContainer(); if (typeContainer instanceof TypeContainerRef) ((TypeContainerRef) typeContainer).getTypes().addAll(prop.getTypes()); property.setSource(prop.getSource()); return property; }
protected boolean isValidModuleNameInvocation(Invocation inv) { return isValidModuleNameInvocation(inv, COMMON_MODULE_NAME, COMMON_MODULE_NAME_RU); }
protected boolean isValidClientModuleNameInvocation(Invocation inv) { return isValidModuleNameInvocation( inv, COMMON_CLIENT_MODULE_NAME, COMMON_CLIENT_MODULE_NAME_RU); }
protected boolean isValidClientServerModuleNameInvocation(Invocation inv) { return isValidModuleNameInvocation( inv, COMMON_CLIENT_SERVER_MODULE_NAME, COMMON_CLIENT_SERVER_MODULE_NAME_RU); }
protected boolean isRefType(TypeItem item) { String category = McoreUtil.getTypeCategory(item); return !Strings.isNullOrEmpty(category) && MdTypeUtil.getRefTypeNames().contains(category) && !category.equals("AnyRef"); }
@Override protected List<TypeItem> computeTypes(Invocation inv, String paramContent) { List<TypeItem> refTypes = getReturnArrayRefTypes(inv.getParams().get(0)); if (refTypes.isEmpty()) return Collections.emptyList(); String content = paramContent.trim().replace(System.lineSeparator(), ""); if (content.isEmpty()) return Collections.emptyList(); String[] properties = content.split("\\.", -1); List<TypeItem> types = getTypeByPropertyName(refTypes, properties, inv); if (!types.isEmpty()) { return typesComputerHelper.createCustomMapType(refTypes, types, inv); } return Collections.emptyList(); }
private List<TypeItem> computeTypes(Invocation inv, Collection<Property> properties) { IEObjectProvider provider = IEObjectProvider.Registry.INSTANCE.get( McorePackage.Literals.TYPE_ITEM, versionSupport.getRuntimeVersionOrDefault(inv, Version.LATEST)); TypeItem structure = provider.getProxy(IEObjectTypeNames.STRUCTURE); Type structureType = EcoreUtil2.cloneWithProxies((Type) EcoreUtil.resolve(structure, inv)); for (Property prop : properties) { if (prop instanceof DerivedProperty) { DerivedProperty property = McoreFactory.eINSTANCE.createDerivedProperty(); property.setName(prop.getName()); property.setNameRu(prop.getNameRu()); property.setReadable(true); property.setWritable(true); property.setTypeContainer(McoreFactory.eINSTANCE.createTypeContainerRef()); ((TypeContainerRef) property.getTypeContainer()).getTypes().addAll(prop.getTypes()); property.setSource(((DerivedProperty) prop).getSource()); structureType.getContextDef().getProperties().add(property); } } List<TypeItem> collectionTypes = Lists.newArrayList(); collectionTypes.add(structureType); ExtendedCollectionType extendedType = TypeSystemUtil.createExtendedArrayType(collectionTypes, provider, inv); return Lists.newArrayList(extendedType); }
@Override protected void doConfigure() { bind(IResourceLookup.class).toService(); bind(IRuntimeVersionSupport.class).toService(); bind(IBmModelManager.class).toService(); URI uri = URI.createURI("*.bsl"); final IResourceServiceProvider rsp = IResourceServiceProvider.Registry.INSTANCE.getResourceServiceProvider(uri); bind(TypesComputer.class).toProvider(() -> rsp.get(TypesComputer.class)); bind(DynamicFeatureAccessComputer.class) .toProvider(() -> rsp.get(DynamicFeatureAccessComputer.class)); bind(IScopeProvider.class).toProvider(() -> rsp.get(IScopeProvider.class)); bind(ValueTableDynamicContextDefProvider.class) .toProvider(() -> rsp.get(ValueTableDynamicContextDefProvider.class)); }
public static void log(IStatus status) { plugin.getLog().log(status); }
public static void logError(Throwable throwable) { log(createErrorStatus(throwable.getMessage(), throwable)); }
public static IStatus createErrorStatus(String message, Throwable throwable) { return new Status(IStatus.ERROR, PLUGIN_ID, 0, message, throwable); }
public static IStatus createWarningStatus(String message) { return new Status(IStatus.WARNING, PLUGIN_ID, 0, message, null); }
public static IStatus createWarningStatus(final String message, Exception throwable) { return new Status(IStatus.WARNING, PLUGIN_ID, 0, message, throwable); }
@Override public void start(BundleContext bundleContext) throws Exception { super.start(bundleContext); BslPlugin.context = bundleContext; plugin = this; BslPackage.eINSTANCE.eClass(); }
@Override public void stop(BundleContext bundleContext) throws Exception { injector = null; plugin = null; super.stop(bundleContext); BslPlugin.context = null; }
private Injector createInjector() { try { return Guice.createInjector(new ExternalDependenciesModule(this)); } catch (Exception e) { log( createErrorStatus( "Failed to create injector for " + getBundle().getSymbolicName(), e)); throw new RuntimeException( "Failed to create injector for " + getBundle().getSymbolicName(), e); } }
@Override public void start(BundleContext context) throws Exception { super.start(context); plugin = this; }
@Override public void stop(BundleContext context) throws Exception { plugin = null; super.stop(context); }
@Override public void start(BundleContext bundleContext) throws Exception { super.start(bundleContext); this.bundleContext = bundleContext; plugin = this; }
@Override public void stop(BundleContext bundleContext) throws Exception { injector = null; plugin = null; super.stop(bundleContext); }
@Override protected void doConfigure() { bind(IQualifiedNameProvider.class).toService(); }
protected boolean isDerivedProperty(Property property) { return property instanceof DerivedProperty && property.eGet(DERIVED_PROPERTY__SOURCE, false) != null; }
@Override public Collection<QualifiedName> getExportedName( Triple<EObject, List<Expression>, Integer> context, IScopeProvider scopeProvider) { return Collections.emptyList(); }
@Test void test_describe() { var context = SensorContextTester.create(BASE_DIR); var diagnosticsLoaderSensor = new LanguageServerDiagnosticsLoaderSensor(context); var sensorDescriptor = new DefaultSensorDescriptor(); diagnosticsLoaderSensor.describe(sensorDescriptor); assertThat(sensorDescriptor.name()) .containsIgnoringCase("BSL Language Server diagnostics loader"); }
@Test void test_execute() { var fileName = "src/test.bsl"; var inputFile = Tools.inputFileBSL(fileName, BASE_DIR); var sonarRuntime = SonarRuntimeImpl.forSonarLint(Version.create(7, 9)); var context = SensorContextTester.create(BASE_DIR); context.setRuntime(sonarRuntime); context .settings() .setProperty( "sonar.bsl.languageserver.reportPaths", "bsl-json.json, bsl-json2.json, empty.json, empty2.json"); context.fileSystem().add(inputFile); var activeRules = new ActiveRulesBuilder() .addRule( new NewActiveRule.Builder() .setRuleKey( RuleKey.of( BSLLanguageServerRuleDefinition.REPOSITORY_KEY, "OneStatementPerLine")) .setName("OneStatementPerLine") .build()) .build(); context.setActiveRules(activeRules); var diagnosticsLoaderSensor = new LanguageServerDiagnosticsLoaderSensor(context); diagnosticsLoaderSensor.execute(context); assertThat(context.isCancelled()).isFalse(); }
@Test void test_createExtIssue() { var issueCode = "Test"; var issueSeverity = DiagnosticSeverity.Information; var context = SensorContextTester.create(BASE_DIR); var inputFile = Tools.inputFileBSL(FILE_NAME, BASE_DIR); var issuesLoader = new IssuesLoader(context); var diagnostic = new Diagnostic(); diagnostic.setCode(issueCode); diagnostic.setSeverity(issueSeverity); diagnostic.setMessage("Check message"); diagnostic.setRange(new Range(new Position(0, 0), new Position(0, 1))); diagnostic.setRelatedInformation(null); issuesLoader.createIssue(inputFile, diagnostic); assertThat(context.allExternalIssues()).hasSize(1); var issue = (DefaultExternalIssue) context.allExternalIssues().toArray()[0]; assertThat(issue.ruleId()).isEqualTo(issueCode); }
@Test void test_createIssueOnProject() { var issueSeverity = DiagnosticSeverity.Information; var diagnosticName = "OneStatementPerLine"; var ruleKey = RuleKey.of(BSLLanguageServerRuleDefinition.REPOSITORY_KEY, diagnosticName); var context = SensorContextTester.create(BASE_DIR); var activeRules = new ActiveRulesBuilder() .addRule( new NewActiveRule.Builder().setRuleKey(ruleKey).setName(diagnosticName).build()) .build(); context.setActiveRules(activeRules); var inputFile = Tools.inputFileBSL(FILE_NAME, BASE_DIR); context.fileSystem().add(inputFile); var issuesLoader = new IssuesLoader(context); var diagnostic = new Diagnostic(); diagnostic.setCode(diagnosticName); diagnostic.setSeverity(issueSeverity); diagnostic.setMessage("Check message OneStatementPerLine"); diagnostic.setRange(new Range(new Position(0, 0), new Position(0, 1))); issuesLoader.createIssue(context.project(), diagnostic); assertThat(context.allIssues()).hasSize(1); var issue = (DefaultIssue) context.allIssues().toArray()[0]; assertThat(issue.ruleKey()).isEqualTo(ruleKey); assertThat(issue.primaryLocation().inputComponent()).isEqualTo(context.project()); }
@Test void issueWithIncorrectRange() { var issueSeverity = DiagnosticSeverity.Information; var diagnosticName = "OneStatementPerLine"; var ruleKey = RuleKey.of(BSLLanguageServerRuleDefinition.REPOSITORY_KEY, diagnosticName); var context = SensorContextTester.create(BASE_DIR); var activeRules = new ActiveRulesBuilder() .addRule( new NewActiveRule.Builder().setRuleKey(ruleKey).setName(diagnosticName).build()) .build(); context.setActiveRules(activeRules); var inputFile = Tools.inputFileBSL(FILE_NAME, BASE_DIR); context.fileSystem().add(inputFile); var issuesLoader = new IssuesLoader(context); var diagnostic = new Diagnostic(); diagnostic.setCode(diagnosticName); diagnostic.setSeverity(issueSeverity); diagnostic.setMessage("Check message OneStatementPerLine"); diagnostic.setRange(new Range(new Position(3, 0), new Position(3, 25))); issuesLoader.createIssue(inputFile, diagnostic); assertThat(context.allIssues()) .hasSize(1) .element(0) .extracting(Issue::primaryLocation) .extracting(IssueLocation::textRange) .isEqualTo( new DefaultTextRange(new DefaultTextPointer(4, 0), new DefaultTextPointer(4, 0))); }
@Test void testHighlightingBSL() { var vocabulary = BSLLexer.VOCABULARY; var highlightingMap = getHighlightingMapBSL(vocabulary); testHighlighting(vocabulary, highlightingMap); }
@Test void testHighlightingSDBL() { var vocabulary = SDBLLexer.VOCABULARY; var highlightingMap = getHighlightingMapSDBL(vocabulary); testHighlighting(vocabulary, highlightingMap); }
private void testHighlighting(Vocabulary vocabulary, Map<String, TypeOfText> highlightingMap) { initContext(vocabulary); highlighter.saveHighlighting(inputFile, documentContext); checkHighlighting(vocabulary, context, highlightingMap); }
private void checkTokenTypeAtPosition( String componentKey, int line, int character, TypeOfText typeOfText) { var typeOfTexts = context.highlightingTypeAt(componentKey, line, character); assertThat(typeOfTexts) .as("Position %d:%d should have typeOfText %s", line, character, typeOfText) .contains(typeOfText); }
private void initContext(Vocabulary vocabulary) { context = SensorContextTester.create(Path.of(".")); highlighter = new BSLHighlighter(context); documentContext = mock(DocumentContext.class); List<Token> tokens = new ArrayList<>(); var maxTokenType = vocabulary.getMaxTokenType(); for (var tokenType = 1; tokenType <= maxTokenType; tokenType++) { var token = new CommonToken(tokenType, "a"); token.setLine(1); token.setCharPositionInLine(tokenType - 1); tokens.add(token); } var content = tokens.stream().map(Token::getText).collect(Collectors.joining()); if (vocabulary.equals(SDBLLexer.VOCABULARY)) { var sdblTokenizer = mock(SDBLTokenizer.class); when(sdblTokenizer.getTokens()).thenReturn(tokens); when(documentContext.getQueries()).thenReturn(List.of(sdblTokenizer)); } else { when(documentContext.getTokens()).thenReturn(tokens); } inputFile = Tools.inputFileBSL(FILE_NAME, BASE_DIR, content); }
private void checkHighlighting( Vocabulary vocabulary, SensorContextTester context, Map<String, TypeOfText> highlightingMap) { var maxTokenType = vocabulary.getMaxTokenType(); var componentKey = "moduleKey:" + FILE_NAME; assertThat(IntStream.range(1, maxTokenType)) .isNotEmpty() .allSatisfy( tokenType -> { String symbolicTokenName = vocabulary.getSymbolicName(tokenType); if (symbolicTokenName == null) { return; } var typeOfText = highlightingMap.get(symbolicTokenName); if (typeOfText == null) { return; } var typeOfTexts = context.highlightingTypeAt(componentKey, 1, tokenType - 1); assertThat(typeOfTexts) .as( "Symbolic token name %s should maps to typeOfText %s", symbolicTokenName, typeOfText) .contains(typeOfText); }); }
@Test void testGetExtensions() { var runtime = SonarRuntimeImpl.forSonarQube(VERSION_8_9, SonarQubeSide.SCANNER, SonarEdition.COMMUNITY); var context = new Plugin.Context(runtime); bslPlugin.define(context); assertThat((List<?>) context.getExtensions()).hasSize(25); }
@Test void testQualityProfile() { var profile = new BSLQualityProfile(); var context = new BuiltInQualityProfilesDefinition.Context(); profile.define(context); assertThat(context.profilesByLanguageAndName().get(BSLLanguage.KEY)).hasSize(1); }
@Test void testQualityProfileAll() { var runtime = SonarRuntimeImpl.forSonarQube(VERSION_8_9, SonarQubeSide.SCANNER, SonarEdition.COMMUNITY); var config = new MapSettings() .setProperty(AccReporter.create().getEnabledKey(), true) .setProperty(EdtReporter.create().getEnabledKey(), true) .asConfig(); var context = new PluginContextImpl.Builder() .setSonarRuntime(runtime) .setBootConfiguration(config) .build(); bslPlugin.define(context); var profile = new QualityProfilesContainer(config); var contextProfile = new BuiltInQualityProfilesDefinition.Context(); profile.define(contextProfile); assertThat(contextProfile.profilesByLanguageAndName().get(BSLLanguage.KEY)).hasSize(5); }
@Test void testDescriptor() { var fileLinesContextFactory = mock(FileLinesContextFactory.class); var context = createSensorContext(); var sensor = new BSLCoreSensor(context, fileLinesContextFactory); var sensorDescriptor = new DefaultSensorDescriptor(); sensor.describe(sensorDescriptor); assertThat(sensorDescriptor.name()).isEqualTo("BSL Core Sensor"); assertThat(sensorDescriptor.languages().toArray()[0]).isEqualTo(BSLLanguage.KEY); }
@Test void testExecuteCoverage() { var diagnosticName = "OneStatementPerLine"; var ruleKey = RuleKey.of(BSLLanguageServerRuleDefinition.REPOSITORY_KEY, diagnosticName); SensorContextTester context; BSLCoreSensor sensor; var fileLinesContext = mock(FileLinesContext.class); var fileLinesContextFactory = mock(FileLinesContextFactory.class); when(fileLinesContextFactory.createFor(any(InputFile.class))).thenReturn(fileLinesContext); context = createSensorContext(); context.settings().setProperty(BSLCommunityProperties.LANG_SERVER_ENABLED_KEY, false); setActiveRules(context, diagnosticName, ruleKey); sensor = new BSLCoreSensor(context, fileLinesContextFactory); sensor.execute(context); assertThat(context.isCancelled()).isFalse(); }
private NewActiveRule newActiveRule(String diagnosticName, String key, String value) { return new NewActiveRule.Builder() .setRuleKey(RuleKey.of(BSLLanguageServerRuleDefinition.REPOSITORY_KEY, diagnosticName)) .setName(diagnosticName) .setParam(key, value) .build(); }
private NewActiveRule newActiveRule(String diagnosticName) { return new NewActiveRule.Builder() .setRuleKey(RuleKey.of(BSLLanguageServerRuleDefinition.REPOSITORY_KEY, diagnosticName)) .setName(diagnosticName) .build(); }
private SensorContextTester createSensorContext() { var sonarRuntime = SonarRuntimeImpl.forSonarLint(SONAR_VERSION); var context = SensorContextTester.create(BASE_DIR); context.fileSystem().setEncoding(StandardCharsets.UTF_8); context.setRuntime(sonarRuntime); context.settings().setProperty("sonar.sources", "src"); context.settings().setProperty("sonar.tests", "test"); var inputFile = Tools.inputFileBSL(FILE_NAME, BASE_DIR); context.fileSystem().add(inputFile); return context; }
public static InputFile inputFileBSL(String name, File baseDir, String content) { return TestInputFileBuilder.create("moduleKey", name) .setModuleBaseDir(baseDir.toPath()) .setType(InputFile.Type.MAIN) .setLanguage(BSLLanguage.KEY) .setCharset(StandardCharsets.UTF_8) .setContents(content) .initMetadata(content) .build(); }
@Test void test_create() { var settings = new MapSettings(); settings.setProperty( BSLCommunityProperties.BSL_FILE_EXTENSIONS_KEY, BSLCommunityProperties.BSL_FILE_EXTENSIONS_DEFAULT_VALUE); var language = new BSLLanguage(settings.asConfig()); assertThat(language.getKey()).containsIgnoringCase("bsl"); assertThat(language.getName()).containsIgnoringCase("1C (BSL)"); assertThat(language.getFileSuffixes()).containsOnly(".bsl", ".os"); }
@Test void test_init() { var config = new MapSettings().asConfig(); var ruleDefinition = new BSLLanguageServerRuleDefinition(config); var context = new RulesDefinition.Context(); ruleDefinition.define(context); assertThat(context.repositories()).hasSize(1); assertThat(context.repository(BSLLanguageServerRuleDefinition.REPOSITORY_KEY)).isNotNull(); }
@Test void testCheckTagParameters() { var config = new MapSettings().asConfig(); var ruleDefinition = new BSLLanguageServerRuleDefinition(config); var context = new RulesDefinition.Context(); ruleDefinition.define(context); assertThat(context.repositories()).hasSize(1); assertThat( Objects.requireNonNull( context.repository(BSLLanguageServerRuleDefinition.REPOSITORY_KEY)) .rules() .stream() .filter(rule -> !rule.params().isEmpty()) .filter( rule -> !rule.tags().contains(BSLLanguageServerRuleDefinition.PARAMETERS_TAG_NAME)) .count()) .isZero(); assertThat( Objects.requireNonNull( context.repository(BSLLanguageServerRuleDefinition.REPOSITORY_KEY)) .rules() .stream() .filter(rule -> rule.params().isEmpty()) .filter( rule -> rule.tags().contains(BSLLanguageServerRuleDefinition.PARAMETERS_TAG_NAME)) .count()) .isZero(); }
@Test void testQualityProfile() { var config = new MapSettings() .setProperty( AccReporter.create().getRulesPathsKey(), ACC_TEST_RULES_FILE + "," + ACC_TEST2_RULES_FILE) .asConfig(); var profile = new QualityProfilesContainer(config); var context = new BuiltInQualityProfilesDefinition.Context(); profile.define(context); assertThat(context.profilesByLanguageAndName().get(BSLLanguage.KEY)).isNull(); }
@Test void testQualityProfileEnabled() { var properties = AccReporter.create(); var config = new MapSettings() .setProperty(properties.getEnabledKey(), true) .setProperty( properties.getRulesPathsKey(), ACC_TEST_RULES_FILE + "," + ACC_TEST2_RULES_FILE) .asConfig(); var profile = new QualityProfilesContainer(config); var context = new BuiltInQualityProfilesDefinition.Context(); profile.define(context); assertThat(context.profilesByLanguageAndName().get(BSLLanguage.KEY)).hasSize(3); }
@Test void testQualityProfileEnabledWithoutFiles() { var properties = AccReporter.create(); var config = new MapSettings().setProperty(properties.getEnabledKey(), true).asConfig(); var profile = new QualityProfilesContainer(config); var context = new BuiltInQualityProfilesDefinition.Context(); profile.define(context); assertThat(context.profilesByLanguageAndName().get(BSLLanguage.KEY)).hasSize(3); }
@Test void testDefine() { var config = new MapSettings().setProperty(reporter.getEnabledKey(), true).asConfig(); var ruleDefinition = new RuleDefinitionsContainer(config); var context = new RulesDefinition.Context(); ruleDefinition.define(context); assertThat(context.repositories()).hasSize(1); var repository = context.repository(reporter.getRepositoryKey()); assertThat(repository).isNotNull(); assertThat(repository.rules()).hasSize(179); assertThat(repository.rules()).allMatch(rule -> rule.name().length() < 200); }
@Test void testEmptyExternalFilePath() { var config = new MapSettings() .setProperty(reporter.getEnabledKey(), true) .setProperty(reporter.getRulesPathsKey(), "") .asConfig(); var ruleDefinition = new RuleDefinitionsContainer(config); var context = new RulesDefinition.Context(); ruleDefinition.define(context); assertThat(context.repositories()).hasSize(1); var repository = context.repository(reporter.getRepositoryKey()); assertThat(repository).isNotNull(); assertThat(repository.rules()).hasSize(179); assertThat(repository.rules()).allMatch(rule -> rule.name().length() < 200); }
@Test void testExternalFile() { var baseDir = new File("src/test/resources").getAbsoluteFile(); var fileRules = new File(baseDir, "examples/acc-test.json"); var fileRulesSecond = new File(baseDir, "examples/acc-test-second.json"); var fileRulesThird = new File(baseDir, "examples/edt-test.json"); var config = new MapSettings() .setProperty(reporter.getEnabledKey(), true) .setProperty( reporter.getRulesPathsKey(), fileRules.getAbsolutePath() + "," + fileRulesSecond.getAbsolutePath() + "," + fileRulesThird.getAbsolutePath()) .asConfig(); var ruleDefinition = new RuleDefinitionsContainer(config); var context = new RulesDefinition.Context(); ruleDefinition.define(context); assertThat(context.repositories()).hasSize(1); var repository = context.repository(reporter.getRepositoryKey()); assertThat(repository).isNotNull(); assertThat(repository.rules()).hasSize(183); assertThat(repository.rules()).allMatch(rule -> rule.name().length() < 200); }
public void highlightToken( Token token, Collection<HighlightingData> highlightingData, @Nullable TypeOfText typeOfText) { if (typeOfText == null) { return; } var line = token.getLine(); var charPositionInLine = token.getCharPositionInLine(); String tokenText = token.getText(); var range = Ranges.create( line, charPositionInLine, charPositionInLine + (int) tokenText.codePoints().count()); highlightingData.add(new HighlightingData(range, typeOfText)); }
private static Set<HighlightingData> newHashSet(Integer line) { return new HashSet<>(); }
private static Set<Integer> createBslAnnotations() { return Set.of( BSLLexer.AMPERSAND, BSLLexer.ANNOTATION_AFTER_SYMBOL, BSLLexer.ANNOTATION_AROUND_SYMBOL, BSLLexer.ANNOTATION_ATCLIENT_SYMBOL, BSLLexer.ANNOTATION_ATCLIENTATSERVER_SYMBOL, BSLLexer.ANNOTATION_ATCLIENTATSERVERNOCONTEXT_SYMBOL, BSLLexer.ANNOTATION_ATSERVER_SYMBOL, BSLLexer.ANNOTATION_ATSERVERNOCONTEXT_SYMBOL, BSLLexer.ANNOTATION_BEFORE_SYMBOL, BSLLexer.ANNOTATION_CHANGEANDVALIDATE_SYMBOL, BSLLexer.ANNOTATION_CUSTOM_SYMBOL, BSLLexer.ANNOTATION_UNKNOWN); }
private static Set<Integer> createBslComments() { return Set.of(BSLLexer.LINE_COMMENT); }
private static Set<Integer> createBslStrings() { return Set.of( BSLLexer.STRING, BSLLexer.STRINGSTART, BSLLexer.STRINGPART, BSLLexer.STRINGTAIL, BSLLexer.PREPROC_STRING); }
private static Set<Integer> createBslLiterals() { return Set.of( BSLLexer.TRUE, BSLLexer.FALSE, BSLLexer.UNDEFINED, BSLLexer.NULL, BSLLexer.DATETIME, BSLLexer.DECIMAL, BSLLexer.FLOAT); }
private static Set<Integer> createBslSeparators() { return Set.of( BSLLexer.SEMICOLON, BSLLexer.QUESTION, BSLLexer.PLUS, BSLLexer.MINUS, BSLLexer.MUL, BSLLexer.QUOTIENT, BSLLexer.MODULO, BSLLexer.ASSIGN, BSLLexer.LESS_OR_EQUAL, BSLLexer.LESS, BSLLexer.NOT_EQUAL, BSLLexer.GREATER_OR_EQUAL, BSLLexer.GREATER, BSLLexer.COMMA, BSLLexer.COLON, BSLLexer.TILDA); }
private static Set<Integer> createBslKeywords() { return Set.of( BSLLexer.PROCEDURE_KEYWORD, BSLLexer.FUNCTION_KEYWORD, BSLLexer.ENDPROCEDURE_KEYWORD, BSLLexer.ENDFUNCTION_KEYWORD, BSLLexer.EXPORT_KEYWORD, BSLLexer.VAL_KEYWORD, BSLLexer.ENDIF_KEYWORD, BSLLexer.ENDDO_KEYWORD, BSLLexer.IF_KEYWORD, BSLLexer.ELSIF_KEYWORD, BSLLexer.ELSE_KEYWORD, BSLLexer.THEN_KEYWORD, BSLLexer.WHILE_KEYWORD, BSLLexer.DO_KEYWORD, BSLLexer.FOR_KEYWORD, BSLLexer.TO_KEYWORD, BSLLexer.EACH_KEYWORD, BSLLexer.IN_KEYWORD, BSLLexer.TRY_KEYWORD, BSLLexer.EXCEPT_KEYWORD, BSLLexer.ENDTRY_KEYWORD, BSLLexer.RETURN_KEYWORD, BSLLexer.CONTINUE_KEYWORD, BSLLexer.RAISE_KEYWORD, BSLLexer.VAR_KEYWORD, BSLLexer.NOT_KEYWORD, BSLLexer.OR_KEYWORD, BSLLexer.AND_KEYWORD, BSLLexer.NEW_KEYWORD, BSLLexer.GOTO_KEYWORD, BSLLexer.BREAK_KEYWORD, BSLLexer.EXECUTE_KEYWORD, BSLLexer.ADDHANDLER_KEYWORD, BSLLexer.REMOVEHANDLER_KEYWORD, BSLLexer.ASYNC_KEYWORD, BSLLexer.AWAIT_KEYWORD); }
private static Set<Integer> createSdblSeparators() { return Set.of( SDBLLexer.SEMICOLON, SDBLLexer.PLUS, SDBLLexer.MINUS, SDBLLexer.MUL, SDBLLexer.QUOTIENT, SDBLLexer.ASSIGN, SDBLLexer.LESS_OR_EQUAL, SDBLLexer.LESS, SDBLLexer.NOT_EQUAL, SDBLLexer.GREATER_OR_EQUAL, SDBLLexer.GREATER, SDBLLexer.COMMA, SDBLLexer.BRACE, SDBLLexer.BRACE_START, SDBLLexer.NUMBER_SIGH); }
private static Set<Integer> createSdblLiterals() { return Set.of( SDBLLexer.TRUE, SDBLLexer.FALSE, SDBLLexer.UNDEFINED, SDBLLexer.NULL, SDBLLexer.DECIMAL, SDBLLexer.FLOAT); }
private static Set<Integer> createSdblVirtualTables() { return Set.of( SDBLLexer.ACTUAL_ACTION_PERIOD_VT, SDBLLexer.BALANCE_VT, SDBLLexer.BALANCE_AND_TURNOVERS_VT, SDBLLexer.BOUNDARIES_VT, SDBLLexer.DR_CR_TURNOVERS_VT, SDBLLexer.EXT_DIMENSIONS_VT, SDBLLexer.RECORDS_WITH_EXT_DIMENSIONS_VT, SDBLLexer.SCHEDULE_DATA_VT, SDBLLexer.SLICEFIRST_VT, SDBLLexer.SLICELAST_VT, SDBLLexer.TASK_BY_PERFORMER_VT, SDBLLexer.TURNOVERS_VT); }
private static Set<Integer> createSdblMetadataTypes() { return Set.of( SDBLLexer.ACCOUNTING_REGISTER_TYPE, SDBLLexer.ACCUMULATION_REGISTER_TYPE, SDBLLexer.BUSINESS_PROCESS_TYPE, SDBLLexer.CALCULATION_REGISTER_TYPE, SDBLLexer.CATALOG_TYPE, SDBLLexer.CHART_OF_ACCOUNTS_TYPE, SDBLLexer.CHART_OF_CALCULATION_TYPES_TYPE, SDBLLexer.CHART_OF_CHARACTERISTIC_TYPES_TYPE, SDBLLexer.CONSTANT_TYPE, SDBLLexer.DOCUMENT_TYPE, SDBLLexer.DOCUMENT_JOURNAL_TYPE, SDBLLexer.ENUM_TYPE, SDBLLexer.EXCHANGE_PLAN_TYPE, SDBLLexer.EXTERNAL_DATA_SOURCE_TYPE, SDBLLexer.FILTER_CRITERION_TYPE, SDBLLexer.INFORMATION_REGISTER_TYPE, SDBLLexer.SEQUENCE_TYPE, SDBLLexer.TASK_TYPE); }
private static Set<Integer> createSdblStrings() { return Set.of(SDBLLexer.STR); }
private static Set<Integer> createSdblComments() { return Set.of(SDBLLexer.LINE_COMMENT); }
private static Set<Integer> createSdblParameters() { return Set.of(SDBLLexer.AMPERSAND, SDBLLexer.PARAMETER_IDENTIFIER); }
private static Set<Integer> createSdblEDS() { return Set.of(SDBLLexer.EDS_CUBE, SDBLLexer.EDS_TABLE, SDBLLexer.EDS_CUBE_DIMTABLE); }
@Override public void describe(SensorDescriptor descriptor) { descriptor.name("BSL Core Sensor"); descriptor.onlyOnLanguage(BSLLanguage.KEY); }
private void processFile(InputFile inputFile, ServerContext bslServerContext) { var uri = inputFile.uri(); var documentContext = bslServerContext.addDocument(uri); bslServerContext.rebuildDocument(documentContext); if (langServerEnabled) { documentContext .getDiagnostics() .forEach( (Diagnostic diagnostic) -> { var code = DiagnosticCode.getStringValue(diagnostic.getCode()); var hasExtraMins = diagnosticsWithExtraMins.contains(code); if (diagnosticsOnProject.contains(code)) { issuesLoader.createIssue( Either.forRight(context.project()), diagnostic, hasExtraMins); } else { issuesLoader.createIssue(Either.forLeft(inputFile), diagnostic, hasExtraMins); } }); } saveCpd(inputFile, documentContext); highlighter.saveHighlighting(inputFile, documentContext); saveMeasures(inputFile, documentContext); bslServerContext.tryClearDocument(documentContext); }
private static Object castDiagnosticParameterValue(String valueToCast, Class<?> type) { Object value; if (type == Integer.class) { value = Integer.parseInt(valueToCast); } else if (type == Boolean.class) { value = Boolean.parseBoolean(valueToCast); } else if (type == Float.class) { value = Float.parseFloat(valueToCast); } else if (type == String.class) { value = valueToCast; } else { throw new IllegalArgumentException("Unsupported diagnostic parameter type " + type); } return value; }
private static boolean checkSkipCpd(Token token, boolean skipCpd) { var tokenType = token.getType(); if (tokenType == BSLLexer.ANNOTATION_CHANGEANDVALIDATE_SYMBOL || tokenType == BSLLexer.PREPROC_ENDINSERT) { skipCpd = true; } if (tokenType == BSLLexer.ENDPROCEDURE_KEYWORD || tokenType == BSLLexer.ENDFUNCTION_KEYWORD || tokenType == BSLLexer.PREPROC_INSERT) { skipCpd = false; } return skipCpd; }
@NotNull private static Map<String, Object> getDiagnosticConfiguration( DiagnosticInfo diagnosticInfo, ActiveRule activeRule) { var params = activeRule.params(); var diagnosticParameters = diagnosticInfo.getParameters(); Map<String, Object> diagnosticConfiguration = new HashMap<>(diagnosticParameters.size()); params.forEach( (String key, String value) -> diagnosticInfo .getParameter(key) .ifPresent( diagnosticParameterInfo -> diagnosticConfiguration.put( key, castDiagnosticParameterValue( value, diagnosticParameterInfo.getType())))); return diagnosticConfiguration; }
public static PropertyDefinition.Builder newPropertyBuilderBSL( int index, String key, String l10nKey, String defaultValue) { return newPropertyBuilder( index, key, l10nKey, defaultValue, BSLCommunityProperties.BSL_CATEGORY); }
public static PropertyDefinition.Builder newPropertyBuilderExternal( int index, String key, String l10nKey, String defaultValue) { return newPropertyBuilder(index, key, l10nKey, defaultValue, EXTERNAL_ANALYZERS_CATEGORY); }
public static PropertyDefinition.Builder newPropertyBuilderReport( int index, String key, String l10nKey, String addString, String subCategory) { return PropertyDefinition.builder(key) .name(getResourceString("report." + l10nKey + ".name", addString)) .description(getResourceString("report." + l10nKey + ".description", addString)) .category(BSLCommunityProperties.BSL_CATEGORY) .subCategory(subCategory) .index(index); }
private static PropertyDefinition.Builder newPropertyBuilder( int index, String key, String l10nKey, String defaultValue, String category) { return PropertyDefinition.builder(key) .name(getResourceString(l10nKey + ".name")) .description(getResourceString(l10nKey + ".description")) .defaultValue(defaultValue) .category(category) .index(index); }
private static TextRange selectThisOrPreviousLine(InputFile inputFile, int line) { var lines = inputFile.lines(); if (line == 0) { return inputFile.newRange(1, 0, lines, 0); } if (lines >= line) { try { return inputFile.selectLine(line); } catch (IllegalArgumentException e) { LOGGER.error("Can't compute TextRange for given line {}", line, e); lines = line - 1; } } return selectThisOrPreviousLine(inputFile, lines); }
private static Map<DiagnosticSeverity, Severity> createDiagnosticSeverityMap() { Map<DiagnosticSeverity, Severity> map = new EnumMap<>(DiagnosticSeverity.class); map.put(DiagnosticSeverity.Warning, Severity.MAJOR); map.put(DiagnosticSeverity.Information, Severity.MINOR); map.put(DiagnosticSeverity.Hint, Severity.INFO); map.put(DiagnosticSeverity.Error, Severity.CRITICAL); return map; }
private static Map<DiagnosticSeverity, RuleType> createRuleTypeMap() { Map<DiagnosticSeverity, RuleType> map = new EnumMap<>(DiagnosticSeverity.class); map.put(DiagnosticSeverity.Warning, RuleType.CODE_SMELL); map.put(DiagnosticSeverity.Information, RuleType.CODE_SMELL); map.put(DiagnosticSeverity.Hint, RuleType.CODE_SMELL); map.put(DiagnosticSeverity.Error, RuleType.BUG); return map; }
@NotNull private Map<String, LoaderSettings> computeLoaderSettings(SensorContext context) { var settings = ExternalReporters.REPORTERS.stream() .map(properties -> new LoaderSettings(properties, context)) .collect(Collectors.toMap(LoaderSettings::getRepositoryKey, Function.identity())); settings.put( BSLLS_ENGINE_ID, new LoaderSettings(BSLLS_ENGINE_ID, true, BSLLanguageServerRuleDefinition.REPOSITORY_KEY)); return settings; }
public void createIssue(InputFile file, Diagnostic diagnostic) { createIssue(Either.forLeft(file), diagnostic, false); }
public void createIssue(InputProject project, Diagnostic diagnostic) { createIssue(Either.forRight(project), diagnostic, false); }
private void createExternalIssue( LoaderSettings settings, Either<InputFile, InputProject> fileOrProject, Diagnostic diagnostic) { var issue = context.newExternalIssue(); issue.engineId(settings.engineId); var ruleId = DiagnosticCode.getStringValue(diagnostic.getCode()); issue.ruleId(ruleId); issue.type(ruleTypeMap.get(diagnostic.getSeverity())); issue.severity(severityMap.get(diagnostic.getSeverity())); processDiagnostic( fileOrProject, diagnostic, ruleId, issue::newLocation, issue::addLocation, issue::at); issue.save(); }
@Override public void define(Context context) { context.addExtension(BSLLanguage.class); context.addExtension(BSLQualityProfile.class); context.addExtensions(BSLCommunityProperties.getProperties()); ExternalReporters.REPORTERS.forEach(reporter -> reporter.addExtension(context)); context.addExtension(BSLLanguageServerRuleDefinition.class); context.addExtension(QualityProfilesContainer.class); context.addExtension(RuleDefinitionsContainer.class); context.addExtension(BSLCoreSensor.class); context.addExtension(LanguageServerDiagnosticsLoaderSensor.class); }
@Override public void describe(SensorDescriptor descriptor) { descriptor.onlyOnLanguage(BSLLanguage.KEY); descriptor.name("BSL Language Server diagnostics loader"); }
@Override public void execute(SensorContext context) { var reportFiles = ExternalReportProvider.getReportFiles(context, LANG_SERVER_REPORT_PATH_KEY); reportFiles.forEach(this::parseAndSaveResults); }
private void parseAndSaveResults(File analysisResultsFile) { LOGGER.info("Parsing 'BSL Language Server' analysis results:"); LOGGER.info(analysisResultsFile.getAbsolutePath()); var analysisInfo = getAnalysisInfo(analysisResultsFile); if (analysisInfo == null) { return; } var fileinfos = analysisInfo.getFileinfos(); for (var fileInfo : fileinfos) { processFileInfo(fileInfo); } }
private void processFileInfo(FileInfo fileInfo) { fileSystem = context.fileSystem(); var path = fileInfo.getPath(); predicates = fileSystem.predicates(); var inputFile = getInputFile(path); if (inputFile == null) { LOGGER.warn("Can't find inputFile for absolute path {}", path); return; } var diagnostics = fileInfo.getDiagnostics(); diagnostics.forEach((Diagnostic diagnostic) -> processDiagnostic(inputFile, diagnostic)); }
private void processDiagnostic(InputFile inputFile, Diagnostic diagnostic) { issueLoader.createIssue(inputFile, diagnostic); }
@Override public void define(Context context) { NewBuiltInQualityProfile profile = context.createBuiltInQualityProfile("BSL Language Server rules", BSLLanguage.KEY); profile.setDefault(true); List<String> ruleKeys = BSLLanguageServerRuleDefinition.getActivatedRuleKeys(); ruleKeys.forEach( ruleKey -> profile.activateRule(BSLLanguageServerRuleDefinition.REPOSITORY_KEY, ruleKey)); profile.done(); }
@Override public void define(Context context) { var repository = context.createRepository(REPOSITORY_KEY, BSLLanguage.KEY).setName(REPOSITORY_NAME); var configuration = new LanguageServerConfiguration(); configuration.setLanguage(createDiagnosticLanguage()); var diagnosticInfos = getDiagnosticInfo(configuration); diagnosticInfos.forEach( (DiagnosticInfo currentDiagnosticInfo) -> { diagnosticInfo = currentDiagnosticInfo; var newRule = repository.createRule(diagnosticInfo.getCode().getStringValue()); setUpNewRule(newRule); setUpRuleParams(newRule); }); repository.done(); }
private Language createDiagnosticLanguage() { var diagnosticLanguageCode = config .get(BSLCommunityProperties.LANG_SERVER_DIAGNOSTIC_LANGUAGE_KEY) .orElse(BSLCommunityProperties.LANG_SERVER_DIAGNOSTIC_LANGUAGE_DEFAULT_VALUE); return Language.valueOf(diagnosticLanguageCode.toUpperCase(Locale.ENGLISH)); }
private static Map<DiagnosticSeverity, String> createDiagnosticSeverityMap() { Map<DiagnosticSeverity, String> map = new EnumMap<>(DiagnosticSeverity.class); map.put(DiagnosticSeverity.INFO, org.sonar.api.rule.Severity.INFO); map.put(DiagnosticSeverity.MINOR, org.sonar.api.rule.Severity.MINOR); map.put(DiagnosticSeverity.MAJOR, org.sonar.api.rule.Severity.MAJOR); map.put(DiagnosticSeverity.CRITICAL, org.sonar.api.rule.Severity.CRITICAL); map.put(DiagnosticSeverity.BLOCKER, org.sonar.api.rule.Severity.BLOCKER); return map; }
private static Map<DiagnosticType, RuleType> createRuleTypeMap() { Map<DiagnosticType, RuleType> map = new EnumMap<>(DiagnosticType.class); map.put(DiagnosticType.CODE_SMELL, RuleType.CODE_SMELL); map.put(DiagnosticType.ERROR, RuleType.BUG); map.put(DiagnosticType.VULNERABILITY, RuleType.VULNERABILITY); map.put(DiagnosticType.SECURITY_HOTSPOT, RuleType.SECURITY_HOTSPOT); return map; }
@Override public void define(Context context) { ruleDefinitions.forEach(ruleDefinition -> ruleDefinition.define(context)); }
protected void define(Context context) { if (enabled) { repository = context.createRepository(repositoryKey, BSLLanguage.KEY).setName(repositoryName); loadRules(); repository.done(); } }
private void loadRules() { RulesFileReader.getRulesFiles(rulesDefaultPath, rulesFilePaths) .forEach(file -> file.rules().forEach(this::createRule)); }
private void createRule(RulesFile.Rule rule) { var foundRule = repository.rule(rule.code()); if (foundRule == null) { foundRule = repository.createRule(rule.code()).addTags(ruleTag); } foundRule .setName(rule.name()) .setHtmlDescription(rule.description()) .setType(RuleType.valueOf(rule.type())) .setSeverity(rule.severity()); foundRule.setDebtRemediationFunction( foundRule.debtRemediationFunctions().linear(rule.effortMinutes() + "min")); }
protected void define(Context context) { if (isEnabled) { addFullCheckProfile(context); if (reporter.isInclude1CCertifiedProfile()) { add1CCertifiedProfile(context); } } }
protected void activateDefaultRules(NewBuiltInQualityProfile profile) { activateRules(profile, RulesFile.Rule::active); }
private void addFullCheckProfile(Context context) { var profile = createQualityProfile(context, "%s - full check"); activateDefaultRules(profile); profile.done(); }
private void add1CCertifiedProfile(Context context) { var profile = createQualityProfile(context, "%s - 1C:Compatible"); activateRules(profile, RulesFile.Rule::needForCertificate); profile.done(); }
private NewBuiltInQualityProfile createQualityProfile(Context context, String nameTemplate) { return context.createBuiltInQualityProfile( String.format(nameTemplate, reporter.getSubcategory()), BSLLanguage.KEY); }
private void activateRules( NewBuiltInQualityProfile profile, Predicate<? super RulesFile.Rule> filter) { rulesFiles.stream() .map(RulesFile::rules) .flatMap(Collection::stream) .filter(filter) .map(RulesFile.Rule::code) .distinct() .forEach(key -> profile.activateRule(reporter.getRepositoryKey(), key)); }
private boolean hasMore() { return current < filePaths.length; }
default void addExtension(Plugin.Context context) { var index = getStartIndex(); Arrays.asList( PropertyDefinitionUtils.newPropertyBuilderReport( ++index, getEnabledKey(), "enabled", getName(), getSubcategory()) .defaultValue(Boolean.toString(isEnableDefaultValue())) .type(PropertyType.BOOLEAN) .onQualifiers(Qualifiers.APP) .build(), PropertyDefinitionUtils.newPropertyBuilderReport( ++index, getCreateExternalIssuesKey(), "createExternalIssues", getName(), getSubcategory()) .defaultValue(Boolean.toString(isCreateExternalIssuesDefaultValue())) .type(PropertyType.BOOLEAN) .onQualifiers(Qualifiers.APP, Qualifiers.PROJECT) .build(), PropertyDefinitionUtils.newPropertyBuilderReport( ++index, getRulesPathsKey(), "rulePath", getName(), getSubcategory()) .defaultValue("") .type(PropertyType.STRING) .onQualifiers(Qualifiers.APP) .multiValues(true) .build()) .forEach(context::addExtension); }
public record Rule( String code, String name, String description, String type, String severity, boolean active, boolean needForCertificate, int effortMinutes, String internalCode) {}
@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); if (savedInstanceState != null) { mDialogId = savedInstanceState.getInt("mDialogId"); mBackgroundColor = savedInstanceState.getInt("mBackgroundColor"); } setContentView(R.layout.main); mRootLayout = findViewById(R.id.root_layout); mRootLayout.setBackgroundColor(mBackgroundColor); mColorSetting1 = findViewById(R.id.color_setting_1); mColorSetting2 = findViewById(R.id.color_setting_2); configureSettingColors(); findViewById(R.id.pick_color).setOnClickListener(this); findViewById(R.id.open_settings).setOnClickListener(this); mColorSetting1.setOnClickListener(this); mColorSetting2.setOnClickListener(this); }
@Override protected void onSaveInstanceState(@NonNull Bundle outState) { super.onSaveInstanceState(outState); outState.putInt("mDialogId", mDialogId); outState.putInt("mBackgroundColor", mBackgroundColor); }
@SuppressWarnings("deprecation") @Override public void onClick(View v) { int id = v.getId(); if (id == R.id.pick_color) { if (mDialogId == -1) { mDialogId = new ColorPicker(this, mBackgroundColor, true, this).show(); } } else { Intent intent = new Intent(this, SettingsActivity.class); startActivityForResult(intent, 0); } }
@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode == RESULT_OK) { configureSettingColors(); } }
private void configureSettingColors() { SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this); int defColor1 = getResources().getColor(R.color.default_color_1); mColorSetting1.setBackgroundColor(prefs.getInt("color_setting_1", defColor1)); int defColor2 = getResources().getColor(R.color.default_color_2); mColorSetting2.setBackgroundColor(prefs.getInt("color_setting_2", defColor2)); }
@Override public void onColorChanged(int color) { mBackgroundColor = color; mRootLayout.setBackgroundColor(mBackgroundColor); }
@Override public void onDialogClosing() { mDialogId = -1; }
@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); getSupportFragmentManager() .beginTransaction() .replace(android.R.id.content, new SettingsFragment()) .commit(); setResult(Activity.RESULT_OK); }
@Override public void onCreatePreferences(Bundle savedInstanceState, String rootKey) { addPreferencesFromResource(R.xml.settings); }
@Override public void draw(@NonNull Canvas canvas) { if (mBitmap != null) { canvas.drawBitmap(mBitmap, null, getBounds(), mPaint); } }
@Override protected void onBoundsChange(Rect bounds) { super.onBoundsChange(bounds); int height = bounds.height(); int width = bounds.width(); numRectanglesHorizontal = (int) Math.ceil(((double) width / mRectangleSize)); numRectanglesVertical = (int) Math.ceil(height / mRectangleSize); generatePatternBitmap(); }
private void generatePatternBitmap() { if (getBounds().width() <= 0 || getBounds().height() <= 0) return; mBitmap = Util.allocateBitmap(getBounds().width(), getBounds().height()); if (mBitmap == null) return; Canvas canvas = new Canvas(mBitmap); Rect r = new Rect(); boolean verticalStartWhite = true; for (int i = 0; i <= numRectanglesVertical; i++) { boolean isWhite = verticalStartWhite; for (int j = 0; j <= numRectanglesHorizontal; j++) { r.top = i * mRectangleSize; r.left = j * mRectangleSize; r.bottom = r.top + mRectangleSize; r.right = r.left + mRectangleSize; canvas.drawRect(r, isWhite ? mPaintWhite : mPaintGray); isWhite = !isWhite; } verticalStartWhite = !verticalStartWhite; } }
public Bitmap generatePatternBitmap(int w, int h) { if (w <= 0 || h <= 0) return null; Bitmap bitmap = Util.allocateBitmap(w, h); if (bitmap == null) return null; Canvas canvas = new Canvas(bitmap); int numRectanglesHorizontal = (int) Math.ceil(((double) w / mRectangleSize)); int numRectanglesVertical = (int) Math.ceil(h / mRectangleSize); Rect r = new Rect(); boolean verticalStartWhite = true; for (int i = 0; i <= numRectanglesVertical; i++) { boolean isWhite = verticalStartWhite; for (int j = 0; j <= numRectanglesHorizontal; j++) { r.top = i * mRectangleSize; r.left = j * mRectangleSize; r.bottom = r.top + mRectangleSize; r.right = r.left + mRectangleSize; canvas.drawRect(r, isWhite ? mPaintWhite : mPaintGray); isWhite = !isWhite; } verticalStartWhite = !verticalStartWhite; } return bitmap; }
@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { final int intrinsicSize = mPreferredBarLength + (mBarPointerHaloRadius * 2); int measureSpec; if (mOrientation == ORIENTATION_HORIZONTAL) { measureSpec = widthMeasureSpec; } else { measureSpec = heightMeasureSpec; } int lengthMode = MeasureSpec.getMode(measureSpec); int lengthSize = MeasureSpec.getSize(measureSpec); int length; if (lengthMode == MeasureSpec.EXACTLY) { length = lengthSize; } else if (lengthMode == MeasureSpec.AT_MOST) { length = Math.min(intrinsicSize, lengthSize); } else { length = intrinsicSize; } int barPointerHaloRadiusx2 = mBarPointerHaloRadius * 2; mBarLength = length - barPointerHaloRadiusx2; if (mOrientation == ORIENTATION_VERTICAL) { setMeasuredDimension(barPointerHaloRadiusx2, (mBarLength + barPointerHaloRadiusx2)); } else { setMeasuredDimension((mBarLength + barPointerHaloRadiusx2), barPointerHaloRadiusx2); } }
@Override protected void onDraw(Canvas canvas) { canvas.drawRect(mBarRect, mBarPaint); int cX, cY; if (mOrientation == ORIENTATION_HORIZONTAL) { cX = mBarPointerPosition; cY = mBarPointerHaloRadius; } else { cX = mBarPointerHaloRadius; cY = mBarPointerPosition; } canvas.drawCircle(cX, cY, mBarPointerHaloRadius, mBarPointerHaloPaint); canvas.drawCircle(cX, cY, mBarPointerRadius, mBarPointerPaint); }
private void calculateColor(int coord) { coord = coord - mBarPointerHaloRadius; if (coord < 0) { coord = 0; } else if (coord > mBarLength) { coord = mBarLength; } mColor = Color.HSVToColor(Math.round(mPosToOpacFactor * coord), mHSVColor); if (Color.alpha(mColor) > 250) { mColor = Color.HSVToColor(mHSVColor); } else if (Color.alpha(mColor) < 5) { mColor = Color.TRANSPARENT; } }
@Override protected Parcelable onSaveInstanceState() { Parcelable superState = super.onSaveInstanceState(); Bundle state = new Bundle(); state.putParcelable(STATE_PARENT, superState); state.putFloatArray(STATE_COLOR, mHSVColor); state.putInt(STATE_OPACITY, getOpacity()); state.putBoolean(STATE_ORIENTATION, ORIENTATION_HORIZONTAL); return state; }
@Override protected void onRestoreInstanceState(Parcelable state) { Bundle savedState = (Bundle) state; Parcelable superState = savedState.getParcelable(STATE_PARENT); super.onRestoreInstanceState(superState); setColor(Color.HSVToColor(savedState.getFloatArray(STATE_COLOR))); setOpacity(savedState.getInt(STATE_OPACITY)); mOrientation = savedState.getBoolean(STATE_ORIENTATION, ORIENTATION_DEFAULT); }
@SuppressLint("InflateParams") View createView(Context context) { View view = LayoutInflater.from(context).inflate(R.layout.dialog_color_wheel, null); mColorPicker = view.findViewById(R.id.picker); ValueBar valueBar = view.findViewById(R.id.valuebar); if (valueBar != null) { mColorPicker.addValueBar(valueBar); } SaturationBar saturationBar = view.findViewById(R.id.saturationbar); if (saturationBar != null) { mColorPicker.addSaturationBar(saturationBar); } OpacityBar opacityBar = view.findViewById(R.id.opacitybar); if (opacityBar != null) { if (mUseOpacityBar) { mColorPicker.addOpacityBar(opacityBar); } opacityBar.setVisibility(mUseOpacityBar ? View.VISIBLE : View.GONE); } mColorPicker.setOldCenterColor(mInitialColor); mColorPicker.setColor(mNewColor); mColorPicker.setOnColorChangedListener(mListener); return view; }
void activate(int newColor) { mColorPicker.setColor(newColor); }
private void disableHWAcceleration() { setLayerType(View.LAYER_TYPE_SOFTWARE, null); }
private int ave(int s, int d, float p) { return s + Math.round(p * (d - s)); }
private int calculateColor(float angle) { float unit = (float) (angle / (2 * Math.PI)); if (unit < 0) { unit += 1; } if (unit <= 0) { mColor = COLORS[0]; return COLORS[0]; } if (unit >= 1) { mColor = COLORS[COLORS.length - 1]; return COLORS[COLORS.length - 1]; } float p = unit * (COLORS.length - 1); int i = (int) p; p -= i; int c0 = COLORS[i]; int c1 = COLORS[i + 1]; int a = ave(Color.alpha(c0), Color.alpha(c1), p); int r = ave(Color.red(c0), Color.red(c1), p); int g = ave(Color.green(c0), Color.green(c1), p); int b = ave(Color.blue(c0), Color.blue(c1), p); mColor = Color.argb(a, r, g, b); return Color.argb(a, r, g, b); }
private float colorToAngle(int color) { float[] colors = new float[3]; Color.colorToHSV(color, colors); return (float) Math.toRadians(-colors[0]); }
private float[] calculatePointerPosition(float angle) { float x = (float) (mColorWheelRadius * Math.cos(angle)); float y = (float) (mColorWheelRadius * Math.sin(angle)); return new float[] {x, y}; }
public void addSVBar(SVBar bar) { mSVbar = bar; mSVbar.setColorPicker(this); mSVbar.setColor(mColor); }
public void addOpacityBar(OpacityBar bar) { mOpacityBar = bar; mOpacityBar.setColorPicker(this); mOpacityBar.setColor(mColor); }
public void addSaturationBar(SaturationBar bar) { mSaturationBar = bar; mSaturationBar.setColorPicker(this); mSaturationBar.setColor(mColor); }
public void addValueBar(ValueBar bar) { mValueBar = bar; mValueBar.setColorPicker(this); mValueBar.setColor(mColor); }
public void changeOpacityBarColor(int color) { if (mOpacityBar != null) { mOpacityBar.setColor(color); } }
public void changeSaturationBarColor(int color) { if (mSaturationBar != null) { mSaturationBar.setColor(color); } }
public void changeValueBarColor(int color) { if (mValueBar != null) { mValueBar.setColor(color); } }
public boolean hasOpacityBar() { return mOpacityBar != null; }
public boolean hasValueBar() { return mValueBar != null; }
public boolean hasSaturationBar() { return mSaturationBar != null; }
public boolean hasSVBar() { return mSVbar != null; }
@Override protected Parcelable onSaveInstanceState() { Parcelable superState = super.onSaveInstanceState(); Bundle state = new Bundle(); state.putParcelable(STATE_PARENT, superState); state.putFloat(STATE_ANGLE, mAngle); state.putInt(STATE_OLD_COLOR, mCenterOldColor); state.putBoolean(STATE_SHOW_OLD_COLOR, mShowCenterOldColor); return state; }
@Override protected void onRestoreInstanceState(Parcelable state) { Bundle savedState = (Bundle) state; Parcelable superState = savedState.getParcelable(STATE_PARENT); super.onRestoreInstanceState(superState); mAngle = savedState.getFloat(STATE_ANGLE); setOldCenterColor(savedState.getInt(STATE_OLD_COLOR)); mShowCenterOldColor = savedState.getBoolean(STATE_SHOW_OLD_COLOR); int currentColor = calculateColor(mAngle); mPointerColor.setColor(currentColor); setNewCenterColor(currentColor); }
private void calculateColor(int coord) { coord = coord - mBarPointerHaloRadius; if (coord < 0) { coord = 0; } else if (coord > mBarLength) { coord = mBarLength; } mColor = Color.HSVToColor(new float[] {mHSVColor[0], mHSVColor[1], 1 - (mPosToSatFactor * coord)}); }
@Override protected Parcelable onSaveInstanceState() { Parcelable superState = super.onSaveInstanceState(); Bundle state = new Bundle(); state.putParcelable(STATE_PARENT, superState); state.putFloatArray(STATE_COLOR, mHSVColor); float[] hsvColor = new float[3]; Color.colorToHSV(mColor, hsvColor); state.putFloat(STATE_VALUE, hsvColor[2]); state.putBoolean(STATE_ORIENTATION, ORIENTATION_HORIZONTAL); return state; }
@Override protected void onRestoreInstanceState(Parcelable state) { Bundle savedState = (Bundle) state; Parcelable superState = savedState.getParcelable(STATE_PARENT); super.onRestoreInstanceState(superState); setColor(Color.HSVToColor(savedState.getFloatArray(STATE_COLOR))); setValue(savedState.getFloat(STATE_VALUE)); mOrientation = savedState.getBoolean(STATE_ORIENTATION, ORIENTATION_DEFAULT); }
@SuppressLint("InflateParams") View createView(Context context) { View view = LayoutInflater.from(context).inflate(R.layout.dialog_color_exact, null); mExactViewA = view.findViewById(R.id.exactA); mExactViewR = view.findViewById(R.id.exactR); mExactViewG = view.findViewById(R.id.exactG); mExactViewB = view.findViewById(R.id.exactB); InputFilter[] filters = new InputFilter[] {new InputFilter.LengthFilter(2)}; mExactViewA.setFilters(filters); mExactViewR.setFilters(filters); mExactViewG.setFilters(filters); mExactViewB.setFilters(filters); mExactViewA.setVisibility(mUseOpacityBar ? View.VISIBLE : View.GONE); setColor(mInitialColor); mExactViewA.addTextChangedListener(mExactTextWatcher); mExactViewR.addTextChangedListener(mExactTextWatcher); mExactViewG.addTextChangedListener(mExactTextWatcher); mExactViewB.addTextChangedListener(mExactTextWatcher); mExactColorPicker = view.findViewById(R.id.picker_exact); mExactColorPicker.setOldCenterColor(mInitialColor); mExactColorPicker.setNewCenterColor(mNewColor); return view; }
void activate(Context context, int newColor) { mNewColor = newColor; setColor(mNewColor); mExactColorPicker.setOldCenterColor(mInitialColor); mExactColorPicker.setNewCenterColor(mNewColor); InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(mExactViewR, 0); }
void deactivate(Context context) { InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(mExactViewA.getWindowToken(), 0); }
public void afterTextChanged(Editable s) { if (mTextIgnoreChanges) return; try { int color = Util.convertToColorInt( mExactViewA.getText().toString(), mExactViewR.getText().toString(), mExactViewG.getText().toString(), mExactViewB.getText().toString(), mUseOpacityBar); mExactColorPicker.setNewCenterColor(color); if (mListener != null) { mListener.onColorChanged(color); } } catch (NumberFormatException ignore) { } }
private void calculateColor(int coord) { coord = coord - mBarPointerHaloRadius; if (coord < 0) { coord = 0; } else if (coord > mBarLength) { coord = mBarLength; } if (coord > (mBarPointerHaloRadius + (mBarLength / 2)) && coord < (mBarPointerHaloRadius + mBarLength)) { mColor = Color.HSVToColor( new float[] { mHSVColor[0], 1f, 1 - (mPosToSVFactor * (coord - (mBarPointerHaloRadius + (mBarLength / 2)))) }); } else if (coord > mBarPointerHaloRadius && coord < (mBarPointerHaloRadius + mBarLength)) { mColor = Color.HSVToColor( new float[] {mHSVColor[0], (mPosToSVFactor * (coord - mBarPointerHaloRadius)), 1f}); } else if (coord == mBarPointerHaloRadius) { mColor = Color.WHITE; } else if (coord == mBarPointerHaloRadius + mBarLength) { mColor = Color.BLACK; } }
@Override protected Parcelable onSaveInstanceState() { Parcelable superState = super.onSaveInstanceState(); Bundle state = new Bundle(); state.putParcelable(STATE_PARENT, superState); state.putFloatArray(STATE_COLOR, mHSVColor); float[] hsvColor = new float[3]; Color.colorToHSV(mColor, hsvColor); if (hsvColor[1] < hsvColor[2]) { state.putFloat(STATE_SATURATION, hsvColor[1]); } else { state.putFloat(STATE_VALUE, hsvColor[2]); } state.putBoolean(STATE_ORIENTATION, ORIENTATION_HORIZONTAL); return state; }
@Override protected void onRestoreInstanceState(Parcelable state) { Bundle savedState = (Bundle) state; Parcelable superState = savedState.getParcelable(STATE_PARENT); super.onRestoreInstanceState(superState); setColor(Color.HSVToColor(savedState.getFloatArray(STATE_COLOR))); if (savedState.containsKey(STATE_SATURATION)) { setSaturation(savedState.getFloat(STATE_SATURATION)); } else { setValue(savedState.getFloat(STATE_VALUE)); } mOrientation = savedState.getBoolean(STATE_ORIENTATION, ORIENTATION_DEFAULT); }
public static Bitmap allocateBitmap(int width, int height) { Bitmap bitmap; try { bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); } catch (Throwable e1) { System.gc(); try { bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); } catch (Throwable e2) { bitmap = null; } } return bitmap; }
public static String[] convertToARGB(int color) { String alpha = Integer.toHexString(Color.alpha(color)).toUpperCase(Locale.getDefault()); String red = Integer.toHexString(Color.red(color)).toUpperCase(Locale.getDefault()); String green = Integer.toHexString(Color.green(color)).toUpperCase(Locale.getDefault()); String blue = Integer.toHexString(Color.blue(color)).toUpperCase(Locale.getDefault()); return new String[] { ("00" + alpha).substring(alpha.length()), ("00" + red).substring(red.length()), ("00" + green).substring(green.length()), ("00" + blue).substring(blue.length()) }; }
public static int convertToColorInt(String a, String r, String g, String b, boolean useAlpha) throws NumberFormatException { int alpha = useAlpha ? Integer.parseInt(a, 16) : 0xff; int red = Integer.parseInt(r, 16); int green = Integer.parseInt(g, 16); int blue = Integer.parseInt(b, 16); return Color.argb(useAlpha ? alpha : 0, red, green, blue); }
public static int convertToColorInt(String argb, boolean useAlpha) throws NumberFormatException { if (argb.startsWith("#")) { argb = argb.replace("#", ""); } int alpha = 0xFF, red = 0xFF, green = 0xFF, blue = 0xFF; if (argb.length() == 8) { alpha = Integer.parseInt(argb.substring(0, 2), 16); red = Integer.parseInt(argb.substring(2, 4), 16); green = Integer.parseInt(argb.substring(4, 6), 16); blue = Integer.parseInt(argb.substring(6, 8), 16); } else if (argb.length() == 6) { alpha = 255; red = Integer.parseInt(argb.substring(0, 2), 16); green = Integer.parseInt(argb.substring(2, 4), 16); blue = Integer.parseInt(argb.substring(4, 6), 16); } return Color.argb(useAlpha ? alpha : 0, red, green, blue); }
@Override public void onClick(DialogInterface dialog, int which) { finalizeChanges(mNewColor); }
@Override public void onClick(DialogInterface dialog, int which) { finalizeChanges(mInitialColor); }
@Override public void onCancel(DialogInterface dialog) { finalizeChanges(mInitialColor); }
private void finalizeChanges(int color) { if (mListener != null) { mListener.onColorChanged(color); mListener.onDialogClosing(); } }
public void dismiss() { try { mDialog.dismiss(); } catch (Exception ignore) { } }
@Override public void onColorChanged(int color) { mNewColor = color; if (mListener != null) { mListener.onColorChanged(mNewColor); } }
@Override public View createTabContent(String tag) { if (tag.equals(WHEEL_TAG)) { mColorWheelComponent = new ColorWheelComponent(mInitialColor, mNewColor, mUseOpacityBar, ColorPicker.this); return mColorWheelComponent.createView(mContext); } else if (tag.equals(EXACT_TAG)) { mExactComponent = new ExactComponent(mInitialColor, mNewColor, mUseOpacityBar, ColorPicker.this); return mExactComponent.createView(mContext); } return null; }
@Override public void onTabChanged(String tabId) { mCurrentTab = tabId; if (tabId.equals(WHEEL_TAG) && mColorWheelComponent != null) { mExactComponent.deactivate(mContext); mColorWheelComponent.activate(mNewColor); } else if (tabId.equals(EXACT_TAG) && mExactComponent != null) { mColorWheelComponent.deactivate(); mExactComponent.activate(mContext, mNewColor); } }
private void calculateColor(int coord) { coord = coord - mBarPointerHaloRadius; if (coord < 0) { coord = 0; } else if (coord > mBarLength) { coord = mBarLength; } mColor = Color.HSVToColor(new float[] {mHSVColor[0], (float) ((mPosToSatFactor * coord)), 1f}); }
@Override protected Parcelable onSaveInstanceState() { Parcelable superState = super.onSaveInstanceState(); Bundle state = new Bundle(); state.putParcelable(STATE_PARENT, superState); state.putFloatArray(STATE_COLOR, mHSVColor); state.putBoolean(STATE_ORIENTATION, mOrientation); float[] hsvColor = new float[3]; Color.colorToHSV(mColor, hsvColor); state.putFloat(STATE_SATURATION, hsvColor[1]); return state; }
@Override protected void onRestoreInstanceState(Parcelable state) { Bundle savedState = (Bundle) state; Parcelable superState = savedState.getParcelable(STATE_PARENT); super.onRestoreInstanceState(superState); setColor(Color.HSVToColor(savedState.getFloatArray(STATE_COLOR))); setSaturation(savedState.getFloat(STATE_SATURATION)); mOrientation = savedState.getBoolean(STATE_ORIENTATION, ORIENTATION_DEFAULT); }
@Override protected void onClick() { new ColorPicker(getContext(), getValue(), true, this).show(); }
@Override public void onColorChanged(int color) { setValue(color); }
private void initAttrs(AttributeSet attrs, int defStyle) { TypedArray a = getContext() .getTheme() .obtainStyledAttributes(attrs, R.styleable.ColorPreferenceCompat, defStyle, defStyle); PreviewSize previewSize; try { numColumns = a.getInteger(R.styleable.ColorPreferenceCompat_numColumns, numColumns); colorShape = ColorShape.getShape(a.getInteger(R.styleable.ColorPreferenceCompat_colorShape, 1)); previewSize = PreviewSize.getSize(a.getInteger(R.styleable.ColorPreferenceCompat_viewSize, 1)); showDialog = a.getBoolean(R.styleable.ColorPreferenceCompat_showDialog, true); int choicesResId = a.getResourceId( R.styleable.ColorPreferenceCompat_colorChoices, R.array.default_color_choice_values); colorChoices = ColorUtils.extractColorArray(choicesResId, getContext()); } finally { a.recycle(); } setWidgetLayoutResource(previewSize == PreviewSize.NORMAL ? itemLayoutId : itemLayoutLargeId); }
@Override public void onBindViewHolder(PreferenceViewHolder holder) { super.onBindViewHolder(holder); ImageView colorView = (ImageView) holder.findViewById(R.id.color_view); if (colorView != null) { if (colorView instanceof ColorPreferenceView) { ColorPreferenceView widgetView = (ColorPreferenceView) colorView; widgetView.setPreviewColor(value, true); } } }
@Override public void onAttached() { super.onAttached(); if (showDialog) { ColorUtils.attach(getContext(), this, getFragmentTag()); } }
@Override protected Object onGetDefaultValue(TypedArray a, int index) { return a.getInt(index, 0); }
@Override protected void onSetInitialValue(boolean restoreValue, Object defaultValue) { setValue(restoreValue ? getPersistedInt(0) : (Integer) defaultValue); }
@Override public void onColorSelected(int newColor, String tag) { setValue(newColor); }
@Nullable static Activity resolveContext(Context context) { if (context instanceof Activity) { return (Activity) context; } else if (context instanceof ContextWrapper) { return resolveContext(((ContextWrapper) context).getBaseContext()); } return null; }
private void initAttrs(AttributeSet attrs, int defStyle) { TypedArray a = getContext() .getTheme() .obtainStyledAttributes(attrs, R.styleable.ColorPreference, defStyle, defStyle); PreviewSize previewSize; try { numColumns = a.getInteger(R.styleable.ColorPreference_numColumns, numColumns); colorShape = ColorShape.getShape(a.getInteger(R.styleable.ColorPreference_colorShape, 1)); previewSize = PreviewSize.getSize(a.getInteger(R.styleable.ColorPreference_viewSize, 1)); showDialog = a.getBoolean(R.styleable.ColorPreference_showDialog, true); int choicesResId = a.getResourceId( R.styleable.ColorPreference_colorChoices, R.array.default_color_choice_values); colorChoices = ColorUtils.extractColorArray(choicesResId, getContext()); } finally { a.recycle(); } setWidgetLayoutResource(previewSize == PreviewSize.NORMAL ? itemLayoutId : itemLayoutLargeId); }
@Override protected void onBindView(View view) { super.onBindView(view); ImageView colorView = view.findViewById(R.id.color_view); if (colorView != null) { if (colorView instanceof ColorPreferenceView) { ColorPreferenceView widgetView = (ColorPreferenceView) colorView; widgetView.setPreviewColor(value, true); } } }
@Override protected void onClick() { super.onClick(); if (showDialog) { ColorUtils.showDialog( getContext(), this, getFragmentTag(), numColumns, colorShape, colorChoices, getValue()); } }
@Override protected void onAttachedToActivity() { super.onAttachedToActivity(); if (showDialog) { ColorUtils.attach(getContext(), this, getFragmentTag()); } }
public static ColorDialog newInstance( int numColumns, ColorShape colorShape, int[] colorChoices, int selectedColorValue) { Bundle args = new Bundle(); args.putInt(NUM_COLUMNS_KEY, numColumns); args.putSerializable(COLOR_SHAPE_KEY, colorShape); args.putIntArray(COLOR_CHOICES_KEY, colorChoices); args.putInt(SELECTED_COLOR_KEY, selectedColorValue); ColorDialog dialog = new ColorDialog(); dialog.setArguments(args); return dialog; }
@Override public void onAttach(Context context) { super.onAttach(context); if (context instanceof OnColorSelectedListener) { setOnColorSelectedListener((OnColorSelectedListener) context); } }
@Override public void onStart() { super.onStart(); sizeDialog(); }
private void sizeDialog() { if (colorSelectedListener == null || colorGrid == null) { return; } Dialog dialog = getDialog(); if (dialog == null) { return; } final Resources res = colorGrid.getContext().getResources(); DisplayMetrics dm = res.getDisplayMetrics(); colorGrid.measure( View.MeasureSpec.makeMeasureSpec(dm.widthPixels, View.MeasureSpec.AT_MOST), View.MeasureSpec.makeMeasureSpec(dm.heightPixels, View.MeasureSpec.AT_MOST)); int width = colorGrid.getMeasuredWidth(); int height = colorGrid.getMeasuredHeight(); int extraPadding = res.getDimensionPixelSize(R.dimen.color_grid_extra_padding); width += extraPadding; height += extraPadding; dialog.getWindow().setLayout(width, height); }
protected ColorDialog build() { ColorDialog dialog = ColorDialog.newInstance(numColumns, colorShape, colorChoices, selectedColor); dialog.setOnColorSelectedListener((OnColorSelectedListener) context); return dialog; }
public ColorDialog show() { ColorDialog dialog = build(); dialog.show( Utils.resolveContext(context).getFragmentManager(), tag == null ? String.valueOf(System.currentTimeMillis()) : tag); return dialog; }
static int[] extractColorArray(@ArrayRes int arrayId, Context context) { String[] choicesString = context.getResources().getStringArray(arrayId); int[] choicesInt = context.getResources().getIntArray(arrayId); boolean isStringArray = choicesString[0] != null; int length = isStringArray ? choicesString.length : choicesInt.length; int[] colorChoices = new int[length]; for (int i = 0; i < length; i++) { colorChoices[i] = isStringArray ? Color.parseColor(choicesString[i]) : choicesInt[i]; } return colorChoices; }
static void showDialog( Context context, ColorDialog.OnColorSelectedListener listener, String tag, int numColumns, ColorShape colorShape, int[] colorChoices, int selectedColorValue) { ColorDialog fragment = ColorDialog.newInstance(numColumns, colorShape, colorChoices, selectedColorValue); fragment.setOnColorSelectedListener(listener); Activity activity = Utils.resolveContext(context); if (activity != null) { activity.getFragmentManager().beginTransaction().add(fragment, tag).commit(); } }
static void attach(Context context, ColorDialog.OnColorSelectedListener listener, String tag) { Activity activity = Utils.resolveContext(context); if (activity != null) { ColorDialog fragment = (ColorDialog) activity.getFragmentManager().findFragmentByTag(tag); if (fragment != null) { fragment.setOnColorSelectedListener(listener); } } }
private void init(Context context) { setTag(IMAGE_VIEW_TAG); setBackgroundColor(Color.TRANSPARENT); mDefaultSize = (int) (Util.getDisplayDensity(context) * 31); mCurrentSize = mDefaultSize; setAlphaPattern(context, mDefaultSize); int wrap = ViewGroup.LayoutParams.WRAP_CONTENT; setLayoutParams(new ViewGroup.LayoutParams(wrap, wrap)); }
@Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); if (changed) { resize(getWidth(), getHeight()); } }
@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); if (w != oldw || h != oldh) { resize(getWidth(), getHeight()); } }
private void resize(int width, int height) { int size = Math.min(Math.min(mDefaultSize, width), height); if (size != mCurrentSize) { mCurrentSize = size; setAlphaPattern(getContext(), mCurrentSize); } }
@Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); int x = 0; int y = 0; if (mAlphaPattern != null) { mAlphaPattern.setBounds(mCenterRectangle); mAlphaPattern.draw(canvas); } canvas.drawRect(x, y, mCurrentSize, mCurrentSize, mColorPaint); canvas.drawLine(x, y, x + mCurrentSize, y, mBorderColorPaint); canvas.drawLine(x, y, x, y + mCurrentSize, mBorderColorPaint); canvas.drawLine(x + mCurrentSize, y, x + mCurrentSize, y + mCurrentSize, mBorderColorPaint); canvas.drawLine(x, y + mCurrentSize, x + mCurrentSize, y + mCurrentSize, mBorderColorPaint); }
private static int reduceBrightness(int color, int factor) { return (color & 0xff000000) + reduceBrightness(color, 0xff0000, factor) + reduceBrightness(color, 0x00ff00, factor) + reduceBrightness(color, 0x0000ff, factor); }
private static int reduceBrightness(int color, int mask, int factor) { return ((color & mask) >>> factor) & mask; }
public static void main(String[] args) { String sig = "public class sig {\n" + "\tpublic static final int len = %d;\n\n" + "\tpublic static final int[] sha = { %s };\n" + "}"; try { String name = args[0]; byte[] src = Files.readAllBytes(Paths.get(name)); System.out.println("len: " + src.length); MessageDigest shasum = MessageDigest.getInstance("SHA"); shasum.reset(); shasum.update(src); String shaStr = ""; String uriSha = ""; byte[] sha = shasum.digest(); for (int i = 0; i < 20; i++) { if (i < 10) { uriSha += sha[i]; } if (i < 19) { shaStr += sha[i] + ", "; } else { shaStr += sha[i]; } } System.out.println("SHA: " + shaStr); System.out.println("URI: " + uriSha); sig = String.format(sig, src.length, shaStr); Files.write(Paths.get("mapview/src/main/java/sig.java"), sig.getBytes()); } catch (Exception ex) { ex.printStackTrace(); System.exit(1); } }
public static void main(String[] args) { String sig = "public class sig {\n" + "\tpublic static final int len = %d;\n\n" + "\tpublic static final int[] sha = { %s };\n" + "}"; try { String name = args[0]; byte[] src = Files.readAllBytes(Paths.get(name)); System.out.println("len: " + src.length); MessageDigest shasum = MessageDigest.getInstance("SHA"); shasum.reset(); shasum.update(src); String shaStr = ""; String uriSha = ""; byte[] sha = shasum.digest(); for (int i = 0; i < 20; i++) { if (i < 10) { uriSha += sha[i]; } if (i < 19) { shaStr += sha[i] + ", "; } else { shaStr += sha[i]; } } System.out.println("SHA: " + shaStr); System.out.println("URI: " + uriSha); sig = String.format(sig, src.length, shaStr); Files.write(Paths.get("loader/src/main/java/sig.java"), sig.getBytes()); Files.createDirectories(Paths.get("loader/build/libs/")); Files.write(Paths.get("loader/build/libs/runescape" + uriSha + ".jar"), src); } catch (Exception ex) { ex.printStackTrace(); System.exit(1); } }
public static String readFileToString(File file) throws IOException { byte[] encoded = Files.readAllBytes(file.toPath()); return new String(encoded, StandardCharsets.UTF_8); }
public static void writeStringToFile(File file, String contents) throws IOException { Files.write(Paths.get(file.toURI()), contents.getBytes(StandardCharsets.UTF_8)); }
@OriginalMember(owner = "client!client", name = "main", descriptor = "([Ljava/lang/String;)V") public static void main(@OriginalArg(0) String[] args) { try { System.out.println("RS2 user client - release #" + signlink.clientversion); if (args.length > 0) { nodeId = Integer.parseInt(args[0]); } else { nodeId = 10; } if (args.length > 1) { portOffset = Integer.parseInt(args[1]); } else { portOffset = 0; } if (args.length > 2 && args[2].equals("lowmem")) { setLowMemory(); } else { setHighMemory(); } members = args.length <= 3 || !args[3].equals("free"); String vendor = System.getProperties().getProperty("java.vendor"); if (vendor.toLowerCase().indexOf("sun") != -1 || vendor.toLowerCase().indexOf("apple") != -1) { signlink.sunjava = true; } signlink.startpriv(InetAddress.getByName("localhost")); @Pc(82) client c = new client(); c.initApplication(789, 532); } catch ( @Pc(89) Exception _ex) { } }
@OriginalMember(owner = "client!client", name = "b", descriptor = "(II)Ljava/lang/String;") public static String formatObjCountTagged(@OriginalArg(0) int amount) { @Pc(4) String s = String.valueOf(amount); for (@Pc(9) int i = s.length() - 3; i > 0; i -= 3) { s = s.substring(0, i) + "," + s.substring(i); } if (s.length() > 8) { s = "@gre@" + s.substring(0, s.length() - 8) + " million @whi@(" + s + ")"; } else if (s.length() > 4) { s = "@cya@" + s.substring(0, s.length() - 4) + "K @whi@(" + s + ")"; } return " " + s; }
@OriginalMember(owner = "client!client", name = "b", descriptor = "(IZI)Ljava/lang/String;") public static String getCombatLevelColorTag( @OriginalArg(0) int viewerLevel, @OriginalArg(2) int otherLevel) { @Pc(9) int diff = viewerLevel - otherLevel; if (diff < -9) { return "@red@"; } else if (diff < -6) { return "@or3@"; } else if (diff < -3) { return "@or2@"; } else if (diff < 0) { return "@or1@"; } else if (diff > 9) { return "@gre@"; } else if (diff > 6) { return "@gr3@"; } else if (diff > 3) { return "@gr2@"; } else if (diff > 0) { return "@gr1@"; } else { return "@yel@"; } }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(ZI)Ljava/lang/String;") public static String formatObjCount(@OriginalArg(1) int amount) { if (amount < 100000) { return String.valueOf(amount); } else if (amount < 10000000) { return amount / 1000 + "K"; } else { return amount / 1000000 + "M"; } }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(ZILjava/lang/String;I)V") private void setMidi( @OriginalArg(2) String name, @OriginalArg(1) int crc, @OriginalArg(3) int len) { synchronized (this.midiSync) { this.midiSyncName = name; this.midiSyncCrc = crc; this.midiSyncLen = len; } }
@OriginalMember(owner = "client!client", name = "c", descriptor = "(B)V") private void closeInterfaces() { this.out.p1isaac(231); if (this.sidebarInterfaceId != -1) { this.sidebarInterfaceId = -1; this.redrawSidebar = true; this.pressedContinueOption = false; this.redrawSideicons = true; } if (this.chatInterfaceId != -1) { this.chatInterfaceId = -1; this.redrawChatback = true; this.pressedContinueOption = false; } this.viewportInterfaceId = -1; }
@OriginalMember(owner = "client!client", name = "e", descriptor = "(I)V") private void stopMidi() { signlink.midifade = 0; signlink.midi = "stop"; }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(JB)V") private void addIgnore(@OriginalArg(0) long username) { if (username == 0L) { return; } if (this.ignoreCount >= 100) { this.addMessage(0, "Your ignore list is full. Max of 100 hit", ""); return; } @Pc(23) String displayName = JString.formatName(JString.fromBase37(username)); for (@Pc(25) int i = 0; i < this.ignoreCount; i++) { if (this.ignoreName37[i] == username) { this.addMessage(0, displayName + " is already on your ignore list", ""); return; } } for (@Pc(55) int i = 0; i < this.friendCount; i++) { if (this.friendName37[i] == username) { this.addMessage(0, "Please remove " + displayName + " from your friend list first", ""); return; } } this.ignoreName37[this.ignoreCount++] = username; this.redrawSidebar = true; this.out.p1isaac(79); this.out.p8(username); }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(IIBI)I") private int getHeightmapY( @OriginalArg(0) int level, @OriginalArg(1) int sceneX, @OriginalArg(3) int sceneZ) { @Pc(11) int tileX = Math.min(sceneX >> 7, 103); @Pc(15) int tileZ = Math.min(sceneZ >> 7, 103); @Pc(17) int realLevel = level; if (level < 3 && (this.levelTileFlags[1][tileX][tileZ] & 0x2) == 2) { realLevel = level + 1; } @Pc(37) int tileLocalX = sceneX & 0x7F; @Pc(41) int tileLocalZ = sceneZ & 0x7F; @Pc(69) int y00 = this.levelHeightmap[realLevel][tileX][tileZ] * (128 - tileLocalX) + this.levelHeightmap[realLevel][tileX + 1][tileZ] * tileLocalX >> 7; @Pc(101) int y11 = this.levelHeightmap[realLevel][tileX][tileZ + 1] * (128 - tileLocalX) + this.levelHeightmap[realLevel][tileX + 1][tileZ + 1] * tileLocalX >> 7; return y00 * (128 - tileLocalZ) + y11 * tileLocalZ >> 7; }
@OriginalMember(owner = "client!client", name = "b", descriptor = "(Z)V") @Override protected void draw() { if (this.errorStarted || this.errorLoading || this.errorHost) { this.drawError(); } else { if (this.ingame) { this.drawGame(); } else { this.drawTitleScreen(); } this.dragCycles = 0; } }
@OriginalMember(owner = "client!client", name = "f", descriptor = "(Z)V") private void unloadTitle() { this.flameActive = false; while (this.flameThread) { this.flameActive = false; try { Thread.sleep(50L); } catch ( @Pc(13) Exception ignored) { } } this.imageTitlebox = null; this.imageTitlebutton = null; this.imageRunes = null; this.flameGradient = null; this.flameGradient0 = null; this.flameGradient1 = null; this.flameGradient2 = null; this.flameBuffer0 = null; this.flameBuffer1 = null; this.flameBuffer3 = null; this.flameBuffer2 = null; this.imageFlamesLeft = null; this.imageFlamesRight = null; }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(IIIIIII)V") private void orbitCamera( @OriginalArg(1) int targetX, @OriginalArg(0) int targetY, @OriginalArg(5) int targetZ, @OriginalArg(2) int yaw, @OriginalArg(3) int pitch, @OriginalArg(6) int distance) { @Pc(5) int invPitch = 2048 - pitch & 0x7FF; @Pc(11) int invYaw = 2048 - yaw & 0x7FF; @Pc(13) int x = 0; @Pc(15) int z = 0; @Pc(17) int y = distance; @Pc(23) int sin; @Pc(27) int cos; @Pc(37) int tmp; if (invPitch != 0) { sin = Model.sinTable[invPitch]; cos = Model.cosTable[invPitch]; tmp = z * cos - distance * sin >> 16; y = z * sin + distance * cos >> 16; z = tmp; } if (invYaw != 0) { sin = Model.sinTable[invYaw]; cos = Model.cosTable[invYaw]; tmp = y * sin + x * cos >> 16; y = y * cos - x * sin >> 16; x = tmp; } this.cameraX = targetX - x; this.cameraY = targetY - z; this.cameraZ = targetZ - y; this.cameraPitch = pitch; this.cameraYaw = yaw; }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(IZ)V") private void updateTextures(@OriginalArg(0) int cycle) { if (!lowMemory) { if (Pix3D.textureCycle[17] >= cycle) { Pix8 texture = Pix3D.textures[17]; int bottom = texture.width * texture.height - 1; int adjustment = texture.width * this.sceneDelta * 2; byte[] src = texture.pixels; byte[] dst = this.textureBuffer; for (int i = 0; i <= bottom; i++) { dst[i] = src[i - adjustment & bottom]; } texture.pixels = dst; this.textureBuffer = src; Pix3D.pushTexture(17); } if (Pix3D.textureCycle[24] >= cycle) { Pix8 texture = Pix3D.textures[24]; int bottom = texture.width * texture.height - 1; int adjustment = texture.width * this.sceneDelta * 2; byte[] src = texture.pixels; byte[] dst = this.textureBuffer; for (int i = 0; i <= bottom; i++) { dst[i] = src[i - adjustment & bottom]; } texture.pixels = dst; this.textureBuffer = src; Pix3D.pushTexture(24); } } }
@OriginalMember(owner = "client!client", name = "m", descriptor = "(I)V") private void updateMergeLocs() { if (this.sceneState == 2) { for (@Pc(12) LocMergeEntity loc = (LocMergeEntity) this.mergedLocations.head(); loc != null; loc = (LocMergeEntity) this.mergedLocations.next()) { if (loopCycle >= loc.lastCycle) { this.addLoc(loc.plane, loc.x, loc.z, loc.locIndex, loc.angle, loc.shape, loc.layer); loc.unlink(); } } cyclelogic5++; if (cyclelogic5 > 85) { cyclelogic5 = 0; this.out.p1isaac(85); } } }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(Ljava/lang/Runnable;I)V") @Override public void startThread(@OriginalArg(0) Runnable runnable, @OriginalArg(1) int priority) { if (signlink.mainapp != null) { signlink.startthread(runnable, priority); } else { super.startThread(runnable, priority); } }
@OriginalMember(owner = "client!client", name = "b", descriptor = "(IIIIII)V") private void drawScrollbar( @OriginalArg(1) int x, @OriginalArg(2) int y, @OriginalArg(3) int scrollY, @OriginalArg(4) int scrollHeight, @OriginalArg(5) int height) { this.imageScrollbar0.draw(x, y); this.imageScrollbar1.draw(x, y + height - 16); Pix2D.fillRect(x, y + 16, this.SCROLLBAR_TRACK, 16, height - 32); @Pc(35) int gripSize = (height - 32) * height / scrollHeight; if (gripSize < 8) { gripSize = 8; } @Pc(52) int gripY = (height - gripSize - 32) * scrollY / (scrollHeight - height); Pix2D.fillRect(x, y + gripY + 16, this.SCROLLBAR_GRIP_FOREGROUND, 16, gripSize); Pix2D.vline(x, y + gripY + 16, this.SCROLLBAR_GRIP_HIGHLIGHT, gripSize); Pix2D.vline(x + 1, y + gripY + 16, this.SCROLLBAR_GRIP_HIGHLIGHT, gripSize); Pix2D.hline(x, y + gripY + 16, this.SCROLLBAR_GRIP_HIGHLIGHT, 16); Pix2D.hline(x, y + gripY + 17, this.SCROLLBAR_GRIP_HIGHLIGHT, 16); Pix2D.vline(x + 15, y + gripY + 16, this.SCROLLBAR_GRIP_LOWLIGHT, gripSize); Pix2D.vline(x + 14, y + gripY + 17, this.SCROLLBAR_GRIP_LOWLIGHT, gripSize - 1); Pix2D.hline(x, y + gripY + gripSize + 15, this.SCROLLBAR_GRIP_LOWLIGHT, 16); Pix2D.hline(x + 1, y + gripY + gripSize + 14, this.SCROLLBAR_GRIP_LOWLIGHT, 15); }
@OriginalMember(owner = "client!client", name = "g", descriptor = "(B)V") private void validateCharacterDesign() { this.updateDesignModel = true; for (@Pc(12) int i = 0; i < 7; i++) { this.designIdentikits[i] = -1; for (@Pc(21) int j = 0; j < IdkType.count; j++) { if (!IdkType.instances[j].disable && IdkType.instances[j].type == i + (this.designGenderMale ? 0 : 7)) { this.designIdentikits[i] = j; break; } } } }
@OriginalMember(owner = "client!client", name = "a", descriptor = "([BIIZ)V") private void saveMidi( @OriginalArg(0) byte[] src, @OriginalArg(2) int length, @OriginalArg(3) int fade) { signlink.midifade = fade; signlink.midisave(src, length); }
@OriginalMember(owner = "client!client", name = "h", descriptor = "(Z)V") private void pushNpcs() { for (@Pc(1) int i = 0; i < this.npcCount; i++) { @Pc(11) NpcEntity npc = this.npcs[this.npcIds[i]]; @Pc(20) int bitset = (this.npcIds[i] << 14) + 0x20000000; if (npc == null || !npc.isVisible()) { continue; } @Pc(31) int x = npc.x >> 7; @Pc(36) int z = npc.z >> 7; if (x < 0 || x >= 104 || z < 0 || z >= 104) { continue; } if (npc.size == 1 && (npc.x & 0x7F) == 64 && (npc.z & 0x7F) == 64) { if (this.tileLastOccupiedCycle[x][z] == this.sceneCycle) { continue; } this.tileLastOccupiedCycle[x][z] = this.sceneCycle; } this.scene.addTemporary( this.currentLevel, npc.x, this.getHeightmapY(this.currentLevel, npc.x, npc.z), npc.z, null, npc, bitset, npc.yaw, (npc.size - 1) * 64 + 60, npc.seqStretches); } }
@OriginalMember(owner = "client!client", name = "p", descriptor = "(I)V") private void prepareGameScreen() { if (this.areaChatback != null) { return; } this.unloadTitle(); super.drawArea = null; this.imageTitle2 = null; this.imageTitle3 = null; this.imageTitle4 = null; this.imageTitle0 = null; this.imageTitle1 = null; this.imageTitle5 = null; this.imageTitle6 = null; this.imageTitle7 = null; this.imageTitle8 = null; this.areaChatback = new PixMap(this.getBaseComponent(), 479, 96); this.areaMapback = new PixMap(this.getBaseComponent(), 168, 160); Pix2D.clear(); this.imageMapback.draw(0, 0); this.areaSidebar = new PixMap(this.getBaseComponent(), 190, 261); this.areaViewport = new PixMap(this.getBaseComponent(), 512, 334); Pix2D.clear(); this.areaBackbase1 = new PixMap(this.getBaseComponent(), 501, 61); this.areaBackbase2 = new PixMap(this.getBaseComponent(), 288, 40); this.areaBackhmid1 = new PixMap(this.getBaseComponent(), 269, 66); this.redrawBackground = true; }
@OriginalMember(owner = "client!client", name = "q", descriptor = "(I)V") private void logout() { try { if (this.stream != null) { this.stream.close(); } } catch ( @Pc(9) Exception ignored) { } this.stream = null; this.ingame = false; this.titleScreenState = 0; this.username = ""; this.password = ""; InputTracking.setDisabled(); this.clearCaches(); this.scene.reset(); for (@Pc(41) int level = 0; level < 4; level++) { this.levelCollisionMap[level].reset(); } System.gc(); this.stopMidi(); this.currentMidi = null; this.nextMusicDelay = 0; }
@OriginalMember(owner = "client!client", name = "i", descriptor = "(Z)V") private void updateNpcs() { for (@Pc(7) int i = 0; i < this.npcCount; i++) { @Pc(14) int id = this.npcIds[i]; @Pc(19) NpcEntity npc = this.npcs[id]; if (npc != null) { this.updateEntity(npc, npc.type.size); } } }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(Lclient!x;BI)V") private void updateEntity(@OriginalArg(0) PathingEntity entity, @OriginalArg(2) int size) { if (entity.x < 128 || entity.z < 128 || entity.x >= 13184 || entity.z >= 13184) { entity.primarySeqId = -1; entity.spotanimId = -1; entity.forceMoveEndCycle = 0; entity.forceMoveStartCycle = 0; entity.x = entity.pathTileX[0] * 128 + entity.size * 64; entity.z = entity.pathTileZ[0] * 128 + entity.size * 64; entity.pathLength = 0; } if (entity == this.localPlayer && (entity.x < 1536 || entity.z < 1536 || entity.x >= 11776 || entity.z >= 11776)) { entity.primarySeqId = -1; entity.spotanimId = -1; entity.forceMoveEndCycle = 0; entity.forceMoveStartCycle = 0; entity.x = entity.pathTileX[0] * 128 + entity.size * 64; entity.z = entity.pathTileZ[0] * 128 + entity.size * 64; entity.pathLength = 0; } if (entity.forceMoveEndCycle > loopCycle) { this.updateForceMovement(entity); } else if (entity.forceMoveStartCycle >= loopCycle) { this.startForceMovement(entity); } else { this.updateMovement(entity); } this.updateFacingDirection(entity); this.updateSequences(entity); }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(Lclient!x;I)V") private void updateForceMovement(@OriginalArg(0) PathingEntity entity) { @Pc(4) int delta = entity.forceMoveEndCycle - loopCycle; @Pc(14) int dstX = entity.forceMoveStartSceneTileX * 128 + entity.size * 64; @Pc(24) int dstZ = entity.forceMoveStartSceneTileZ * 128 + entity.size * 64; entity.x += (dstX - entity.x) / delta; entity.z += (dstZ - entity.z) / delta; entity.seqTrigger = 0; if (entity.forceMoveFaceDirection == 0) { entity.dstYaw = 1024; } if (entity.forceMoveFaceDirection == 1) { entity.dstYaw = 1536; } if (entity.forceMoveFaceDirection == 2) { entity.dstYaw = 0; } if (entity.forceMoveFaceDirection == 3) { entity.dstYaw = 512; } }
@OriginalMember(owner = "client!client", name = "b", descriptor = "(Lclient!x;I)V") private void startForceMovement(@OriginalArg(0) PathingEntity entity) { if (entity.forceMoveStartCycle == loopCycle || entity.primarySeqId == -1 || entity.primarySeqDelay != 0 || entity.primarySeqCycle + 1 > SeqType.instances[entity.primarySeqId].delay[entity.primarySeqFrame]) { @Pc(35) int duration = entity.forceMoveStartCycle - entity.forceMoveEndCycle; @Pc(40) int delta = loopCycle - entity.forceMoveEndCycle; @Pc(50) int dx0 = entity.forceMoveStartSceneTileX * 128 + entity.size * 64; @Pc(60) int dz0 = entity.forceMoveStartSceneTileZ * 128 + entity.size * 64; @Pc(70) int dx1 = entity.forceMoveEndSceneTileX * 128 + entity.size * 64; @Pc(80) int dz1 = entity.forceMoveEndSceneTileZ * 128 + entity.size * 64; entity.x = (dx0 * (duration - delta) + dx1 * delta) / duration; entity.z = (dz0 * (duration - delta) + dz1 * delta) / duration; } entity.seqTrigger = 0; if (entity.forceMoveFaceDirection == 0) { entity.dstYaw = 1024; } if (entity.forceMoveFaceDirection == 1) { entity.dstYaw = 1536; } if (entity.forceMoveFaceDirection == 2) { entity.dstYaw = 0; } if (entity.forceMoveFaceDirection == 3) { entity.dstYaw = 512; } entity.yaw = entity.dstYaw; }
@OriginalMember(owner = "client!client", name = "e", descriptor = "(II)Z") private boolean isAddFriendOption(@OriginalArg(1) int option) { if (option < 0) { return false; } @Pc(8) int action = this.menuAction[option]; if (action >= 2000) { action -= 2000; } return action == 406; }
@OriginalMember(owner = "client!client", name = "t", descriptor = "(I)V") private void drawMenu() { @Pc(2) int x = this.menuX; @Pc(5) int y = this.menuY; @Pc(8) int w = this.menuWidth; @Pc(11) int h = this.menuHeight; @Pc(13) int background = 0x5d5447; Pix2D.fillRect(x, y, background, w, h); Pix2D.fillRect(x + 1, y + 1, 0, w - 2, 16); Pix2D.drawRect(x + 1, y + 18, 0, w - 2, h - 19); this.fontBold12.drawString(x + 3, y + 14, "Choose Option", background); @Pc(63) int mouseX = super.mouseX; @Pc(66) int mouseY = super.mouseY; if (this.menuArea == 0) { mouseX -= 8; mouseY -= 11; } if (this.menuArea == 1) { mouseX -= 562; mouseY -= 231; } if (this.menuArea == 2) { mouseX -= 22; mouseY -= 375; } for (@Pc(85) int i = 0; i < this.menuSize; i++) { @Pc(100) int optionY = y + (this.menuSize - 1 - i) * 15 + 31; @Pc(102) int rgb = 0xffffff; if (mouseX > x && mouseX < x + w && mouseY > optionY - 13 && mouseY < optionY + 3) { rgb = 0xffff00; } this.fontBold12.drawStringTaggable(x + 3, optionY, this.menuOption[i], rgb, true); } }
@OriginalMember(owner = "client!client", name = "a", descriptor = "([BII)Z") private boolean saveWave(@OriginalArg(0) byte[] src, @OriginalArg(1) int length) { return src == null || signlink.wavesave(src, length); }
@OriginalMember(owner = "client!client", name = "u", descriptor = "(I)Z") private boolean replayWave() { return signlink.wavereplay(); }
@OriginalMember(owner = "client!client", name = "h", descriptor = "(B)V") private void clearCaches() { LocType.modelCacheStatic.clear(); LocType.modelCacheDynamic.clear(); NpcType.modelCache.clear(); ObjType.modelCache.clear(); ObjType.iconCache.clear(); PlayerEntity.modelCache.clear(); SpotAnimType.modelCache.clear(); }
private void drawTileOverlay(int x, int z, int level, int size, int color, boolean crossed) { int height = this.getHeightmapY(level, x, z); int x0, y0; int x1, y1; int x2, y2; int x3, y3; int halfUnit = 64 * size; this.project(x - halfUnit, height, z - halfUnit); x0 = this.projectX; y0 = this.projectY; this.project(x + halfUnit, height, z - halfUnit); x1 = this.projectX; y1 = this.projectY; this.project(x - halfUnit, height, z + halfUnit); x2 = this.projectX; y2 = this.projectY; this.project(x + halfUnit, height, z + halfUnit); x3 = this.projectX; y3 = this.projectY; if ((x0 == -1) || (x1 == -1) || (x2 == -1) || (x3 == -1)) { return; } if (crossed) { Pix2D.line(x0, y0, x3, y3, (color & 0xFEFEFE) >> 1); Pix2D.line(x1, y1, x2, y2, (color & 0xFEFEFE) >> 1); } Pix2D.line(x0, y0, x1, y1, color); Pix2D.line(x0, y0, x2, y2, color); Pix2D.line(x1, y1, x3, y3, color); Pix2D.line(x2, y2, x3, y3, color); }
@OriginalMember(owner = "client!client", name = "c", descriptor = "(I)V") @Override protected void refresh() { this.redrawBackground = true; }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(IILclient!hb;I)V") private void drawOnMinimap( @OriginalArg(0) int dy, @OriginalArg(2) Pix32 image, @OriginalArg(3) int dx) { @Pc(7) int angle = this.orbitCameraYaw + this.minimapAnticheatAngle & 0x7FF; @Pc(15) int distance = dx * dx + dy * dy; if (distance > 6400) { return; } @Pc(34) int sinAngle = Model.sinTable[angle]; @Pc(38) int cosAngle = Model.cosTable[angle]; sinAngle = sinAngle * 256 / (this.minimapZoom + 256); cosAngle = cosAngle * 256 / (this.minimapZoom + 256); @Pc(66) int x = dy * sinAngle + dx * cosAngle >> 16; @Pc(76) int y = dy * cosAngle - dx * sinAngle >> 16; if (distance > 2500) { image.drawMasked(x + 94 - image.cropW / 2, 83 - y - image.cropH / 2, this.imageMapback); } else { image.draw(x + 94 - image.cropW / 2, 83 - y - image.cropH / 2); } }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(IIII)I") private int mix(@OriginalArg(0) int src, @OriginalArg(1) int alpha, @OriginalArg(2) int dst) { @Pc(3) int invAlpha = 256 - alpha; return ((src & 0xFF00FF) * invAlpha + (dst & 0xFF00FF) * alpha & 0xFF00FF00) + ((src & 0xFF00) * invAlpha + (dst & 0xFF00) * alpha & 0xFF0000) >> 8; }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(IZLclient!x;)V") private void projectFromGround(@OriginalArg(2) PathingEntity entity, @OriginalArg(0) int height) { this.projectFromGround(entity.x, height, entity.z); }
@OriginalMember(owner = "client!client", name = "b", descriptor = "(IIII)V") private void projectFromGround( @OriginalArg(1) int x, @OriginalArg(3) int height, @OriginalArg(0) int z) { if (x < 128 || z < 128 || x > 13056 || z > 13056) { this.projectX = -1; this.projectY = -1; return; } @Pc(28) int y = this.getHeightmapY(this.currentLevel, x, z) - height; this.project(x, y, z); }
private void project(int x, int y, int z) { @Pc(33) int dx = x - this.cameraX; @Pc(38) int dy = y - this.cameraY; @Pc(43) int dz = z - this.cameraZ; @Pc(48) int sinPitch = Model.sinTable[this.cameraPitch]; @Pc(53) int cosPitch = Model.cosTable[this.cameraPitch]; @Pc(58) int sinYaw = Model.sinTable[this.cameraYaw]; @Pc(63) int cosYaw = Model.cosTable[this.cameraYaw]; int tmp = dz * sinYaw + dx * cosYaw >> 16; dz = dz * cosYaw - dx * sinYaw >> 16; dx = tmp; tmp = dy * cosPitch - dz * sinPitch >> 16; dz = dy * sinPitch + dz * cosPitch >> 16; dy = tmp; if (dz >= 50) { this.projectX = Pix3D.centerW3D + (dx << 9) / dz; this.projectY = Pix3D.centerH3D + (dy << 9) / dz; } else { this.projectX = -1; this.projectY = -1; } }
@OriginalMember( owner = "client!client", name = "a", descriptor = "(Ljava/lang/String;)Ljava/io/DataInputStream;") private DataInputStream openUrl(@OriginalArg(0) String url) throws IOException { if (signlink.mainapp != null) { return signlink.openurl(url); } return new DataInputStream((new URL(this.getCodeBase(), url)).openStream()); }
@OriginalMember(owner = "client!client", name = "j", descriptor = "(B)V") private void loadTitle() { if (this.imageTitle2 != null) { return; } super.drawArea = null; this.areaChatback = null; this.areaMapback = null; this.areaSidebar = null; this.areaViewport = null; this.areaBackbase1 = null; this.areaBackbase2 = null; this.areaBackhmid1 = null; this.imageTitle0 = new PixMap(this.getBaseComponent(), 128, 265); Pix2D.clear(); this.imageTitle1 = new PixMap(this.getBaseComponent(), 128, 265); Pix2D.clear(); this.imageTitle2 = new PixMap(this.getBaseComponent(), 533, 186); Pix2D.clear(); this.imageTitle3 = new PixMap(this.getBaseComponent(), 360, 146); Pix2D.clear(); this.imageTitle4 = new PixMap(this.getBaseComponent(), 360, 200); Pix2D.clear(); this.imageTitle5 = new PixMap(this.getBaseComponent(), 214, 267); Pix2D.clear(); this.imageTitle6 = new PixMap(this.getBaseComponent(), 215, 267); Pix2D.clear(); this.imageTitle7 = new PixMap(this.getBaseComponent(), 86, 79); Pix2D.clear(); this.imageTitle8 = new PixMap(this.getBaseComponent(), 87, 79); Pix2D.clear(); if (this.archiveTitle != null) { this.loadTitleBackground(); this.loadTitleImages(); } this.redrawBackground = true; }
@OriginalMember(owner = "client!client", name = "z", descriptor = "(I)V") private void runFlames() { this.flameThread = true; try { @Pc(4) long last = System.currentTimeMillis(); @Pc(6) int cycle = 0; @Pc(8) int interval = 20; while (this.flameActive) { this.updateFlames(); this.updateFlames(); this.drawFlames(); cycle++; if (cycle > 10) { @Pc(25) long now = System.currentTimeMillis(); @Pc(34) int delay = (int) (now - last) / 10 - interval; interval = 40 - delay; if (interval < 5) { interval = 5; } cycle = 0; last = now; } try { Thread.sleep(interval); } catch ( @Pc(52) Exception ignored) { } } } catch ( @Pc(58) Exception ignored) { } this.flameThread = false; }
@OriginalMember(owner = "client!client", name = "run", descriptor = "()V") @Override public void run() { if (this.flamesThread) { this.runFlames(); } else if (this.startMidiThread) { this.runMidi(); } else { super.run(); } }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(JI)V") private void addFriend(@OriginalArg(0) long username) { if (username == 0L) { return; } if (this.friendCount >= 100) { this.addMessage(0, "Your friends list is full. Max of 100 hit", ""); return; } @Pc(23) String displayName = JString.formatName(JString.fromBase37(username)); for (@Pc(25) int i = 0; i < this.friendCount; i++) { if (this.friendName37[i] == username) { this.addMessage(0, displayName + " is already on your friend list", ""); return; } } for (@Pc(55) int i = 0; i < this.ignoreCount; i++) { if (this.ignoreName37[i] == username) { this.addMessage(0, "Please remove " + displayName + " from your ignore list first", ""); return; } } if (!displayName.equals(this.localPlayer.name)) { this.friendName[this.friendCount] = displayName; this.friendName37[this.friendCount] = username; this.friendWorld[this.friendCount] = 0; this.friendCount++; this.redrawSidebar = true; this.out.p1isaac(118); this.out.p8(username); } }
@OriginalMember(owner = "client!client", name = "A", descriptor = "(I)Ljava/net/Socket;") private Socket openSocket(@OriginalArg(0) int port) throws IOException { if (signlink.mainapp != null) { return signlink.opensocket(port); } return new Socket(InetAddress.getByName(this.getCodeBase().getHost()), port); }
@OriginalMember(owner = "client!client", name = "k", descriptor = "(Z)V") private void drawTooltip() { if (this.menuSize < 2 && this.objSelected == 0 && this.spellSelected == 0) { return; } @Pc(31) String tooltip; if (this.objSelected == 1 && this.menuSize < 2) { tooltip = "Use " + this.objSelectedName + " with..."; } else if (this.spellSelected == 1 && this.menuSize < 2) { tooltip = this.spellCaption + "..."; } else { tooltip = this.menuOption[this.menuSize - 1]; } if (this.menuSize > 2) { tooltip = tooltip + "@whi@ / " + (this.menuSize - 2) + " more options"; } this.fontBold12.drawStringTooltip(4, 15, tooltip, 16777215, true, loopCycle / 1000); }
@OriginalMember(owner = "client!client", name = "k", descriptor = "(B)V") private void pushSpotanims() { for (@Pc(13) SpotAnimEntity entity = (SpotAnimEntity) this.spotanims.head(); entity != null; entity = (SpotAnimEntity) this.spotanims.next()) { if (entity.level != this.currentLevel || entity.seqComplete) { entity.unlink(); } else if (loopCycle >= entity.startCycle) { entity.update(this.sceneDelta); if (entity.seqComplete) { entity.unlink(); } else { this.scene.addTemporary( entity.level, entity.x, entity.y, entity.z, null, entity, -1, 0, 60, false); } } } }
@OriginalMember( owner = "client!client", name = "a", descriptor = "(ILjava/lang/String;BLjava/lang/String;)V") private void addMessage( @OriginalArg(0) int type, @OriginalArg(1) String text, @OriginalArg(3) String sender) { if (type == 0 && this.stickyChatInterfaceId != -1) { this.modalMessage = text; super.mouseClickButton = 0; } if (this.chatInterfaceId == -1) { this.redrawChatback = true; } for (@Pc(20) int i = 99; i > 0; i--) { this.messageType[i] = this.messageType[i - 1]; this.messageSender[i] = this.messageSender[i - 1]; this.messageText[i] = this.messageText[i - 1]; } if (this.showDebug && type == 0) { text = "[" + (loopCycle / 30) + "]: " + text; } this.messageType[0] = type; this.messageSender[0] = sender; this.messageText[0] = text; }
@OriginalMember(owner = "client!client", name = "i", descriptor = "(II)V") private void resetInterfaceAnimation(@OriginalArg(1) int id) { @Pc(3) Component parent = Component.instances[id]; for (@Pc(5) int i = 0; i < parent.childId.length && parent.childId[i] != -1; i++) { @Pc(20) Component child = Component.instances[parent.childId[i]]; if (child.type == 1) { this.resetInterfaceAnimation(child.id); } child.seqFrame = 0; child.seqCycle = 0; } }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(IJ)V") private void removeFriend(@OriginalArg(1) long username) { if (username == 0L) { return; } for (int i = 0; i < this.friendCount; i++) { if (this.friendName37[i] == username) { this.friendCount--; this.redrawSidebar = true; for (@Pc(38) int j = i; j < this.friendCount; j++) { this.friendName[j] = this.friendName[j + 1]; this.friendWorld[j] = this.friendWorld[j + 1]; this.friendName37[j] = this.friendName37[j + 1]; } this.out.p1isaac(11); this.out.p8(username); return; } } }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(Lclient!hc;I)Z") private boolean executeInterfaceScript(@OriginalArg(0) Component com) { if (com.scriptComparator == null) { return false; } for (@Pc(6) int i = 0; i < com.scriptComparator.length; i++) { @Pc(14) int value = this.executeClientscript1(com, i); @Pc(19) int operand = com.scriptOperand[i]; if (com.scriptComparator[i] == 2) { if (value >= operand) { return false; } } else if (com.scriptComparator[i] == 3) { if (value <= operand) { return false; } } else if (com.scriptComparator[i] == 4) { if (value == operand) { return false; } } else if (value != operand) { return false; } } return true; }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(Lclient!hc;B)Z") private boolean handleSocialMenuOption(@OriginalArg(0) Component component) { @Pc(2) int type = component.clientCode; if (type >= 1 && type <= 200) { if (type >= 101) { type -= 101; } else { type--; } this.menuOption[this.menuSize] = "Remove @whi@" + this.friendName[type]; this.menuAction[this.menuSize] = 557; this.menuSize++; this.menuOption[this.menuSize] = "Message @whi@" + this.friendName[type]; this.menuAction[this.menuSize] = 679; this.menuSize++; return true; } else if (type >= 401 && type <= 500) { this.menuOption[this.menuSize] = "Remove @whi@" + component.text; this.menuAction[this.menuSize] = 556; this.menuSize++; return true; } else { return false; } }
@OriginalMember(owner = "client!client", name = "l", descriptor = "(Z)V") private void tryReconnect() { if (this.idleTimeout > 0) { this.logout(); } else { this.areaViewport.bind(); this.fontPlain12.drawStringCenter(257, 144, "Connection lost", 0); this.fontPlain12.drawStringCenter(256, 143, "Connection lost", 16777215); this.fontPlain12.drawStringCenter(257, 159, "Please wait - attempting to reestablish", 0); this.fontPlain12.drawStringCenter( 256, 158, "Please wait - attempting to reestablish", 16777215); this.areaViewport.draw(super.graphics, 8, 11); this.flagSceneTileX = 0; @Pc(60) ClientStream stream = this.stream; this.ingame = false; this.login(this.username, this.password, true); if (!this.ingame) { this.logout(); } try { stream.close(); } catch ( @Pc(80) Exception ex) { } } }
@OriginalMember(owner = "client!client", name = "b", descriptor = "(I)V") @Override protected void update() { if (this.errorStarted || this.errorLoading || this.errorHost) { return; } loopCycle++; if (this.ingame) { this.updateGame(); } else { this.updateTitle(); } }
@OriginalMember(owner = "client!client", name = "o", descriptor = "(B)V") private void updateEntityChats() { for (@Pc(8) int i = -1; i < this.playerCount; i++) { int index; if (i == -1) { index = this.LOCAL_PLAYER_INDEX; } else { index = this.playerIds[i]; } @Pc(28) PlayerEntity player = this.players[index]; if (player != null && player.chatTimer > 0) { player.chatTimer--; if (player.chatTimer == 0) { player.chat = null; } } } for (int i = 0; i < this.npcCount; i++) { @Pc(59) int index = this.npcIds[i]; @Pc(64) NpcEntity npc = this.npcs[index]; if (npc != null && npc.chatTimer > 0) { npc.chatTimer--; if (npc.chatTimer == 0) { npc.chat = null; } } } }
@OriginalMember(owner = "client!client", name = "b", descriptor = "(IJ)V") private void removeIgnore(@OriginalArg(1) long username) { if (username == 0L) { return; } for (@Pc(14) int i = 0; i < this.ignoreCount; i++) { if (this.ignoreName37[i] == username) { this.ignoreCount--; this.redrawSidebar = true; for (@Pc(34) int j = i; j < this.ignoreCount; j++) { this.ignoreName37[j] = this.ignoreName37[j + 1]; } this.out.p1isaac(171); this.out.p8(username); return; } } }
@OriginalMember(owner = "client!client", name = "n", descriptor = "(Z)V") private void updatePlayers() { for (@Pc(9) int i = -1; i < this.playerCount; i++) { int index; if (i == -1) { index = this.LOCAL_PLAYER_INDEX; } else { index = this.playerIds[i]; } @Pc(29) PlayerEntity player = this.players[index]; if (player != null) { this.updateEntity(player, 1); } } cyclelogic6++; if (cyclelogic6 > 1406) { cyclelogic6 = 0; this.out.p1isaac(219); this.out.p1(0); int start = this.out.pos; this.out.p1(162); this.out.p1(22); if ((int) (Math.random() * 2.0D) == 0) { this.out.p1(84); } this.out.p2(31824); this.out.p2(13490); if ((int) (Math.random() * 2.0D) == 0) { this.out.p1(123); } if ((int) (Math.random() * 2.0D) == 0) { this.out.p1(134); } this.out.p1(100); this.out.p1(94); this.out.p2(35521); this.out.psize1(this.out.pos - start); } }
@OriginalMember(owner = "client!client", name = "r", descriptor = "(B)V") private void drawTileHint() { if (this.hintType != 2) { return; } this.projectFromGround( (this.hintTileX - this.sceneBaseTileX << 7) + this.hintOffsetX, this.hintHeight * 2, (this.hintTileZ - this.sceneBaseTileZ << 7) + this.hintOffsetZ); if (this.projectX > -1 && loopCycle % 20 < 10) { this.imageHeadicons[2].draw(this.projectX - 12, this.projectY - 28); } }
@OriginalMember(owner = "client!client", name = "s", descriptor = "(B)V") private void drawSidebar() { this.areaSidebar.bind(); Pix3D.lineOffset = this.areaSidebarOffsets; this.imageInvback.draw(0, 0); if (this.sidebarInterfaceId != -1) { this.drawInterface(Component.instances[this.sidebarInterfaceId], 0, 0, 0); } else if (this.tabInterfaceId[this.selectedTab] != -1) { this.drawInterface(Component.instances[this.tabInterfaceId[this.selectedTab]], 0, 0, 0); } if (this.menuVisible && this.menuArea == 1) { this.drawMenu(); } this.areaSidebar.draw(super.graphics, 562, 231); this.areaViewport.bind(); Pix3D.lineOffset = this.areaViewportOffsets; }
@OriginalMember(owner = "client!client", name = "a", descriptor = "(ILjava/lang/String;)Z") private boolean isFriend(@OriginalArg(1) String username) { if (username == null) { return false; } for (@Pc(15) int i = 0; i < this.friendCount; i++) { if (username.equalsIgnoreCase(this.friendName[i])) { return true; } } return username.equalsIgnoreCase(this.localPlayer.name); }
@OriginalMember(owner = "client!client", name = "init", descriptor = "()V") @Override public void init() { nodeId = Integer.parseInt(this.getParameter("nodeid")); portOffset = Integer.parseInt(this.getParameter("portoff")); @Pc(15) String lowmem = this.getParameter("lowmem"); if (lowmem != null && lowmem.equals("1")) { setLowMemory(); } else { setHighMemory(); } @Pc(31) String free = this.getParameter("free"); members = free == null || !free.equals("1"); this.initApplet(789, 532); }
public static void main(String[] args) { try { signlink.startpriv(InetAddress.getByName("w1.225.2004scape.org")); Playground app = new Playground(); app.initApplication(789, 532); } catch (Exception e) { e.printStackTrace(); } }
@Override protected void draw() { Pix2D.clear(); Pix2D.fillRect(0, 0, 0x555555, this.screenWidth, this.screenHeight); this.model.draw( this.modelYaw, Pix3D.sinTable[this.eyePitch], Pix3D.cosTable[this.eyePitch], Pix3D.sinTable[this.eyeYaw], Pix3D.cosTable[this.eyeYaw], this.modelX - this.eyeX, this.modelY - this.eyeY, this.modelZ - this.eyeZ, 0); this.fontBold12.drawStringRight( this.screenWidth, this.fontBold12.height, "FPS: " + super.fps, 0xFFFF00, true); this.drawArea.draw(super.graphics, 0, 0); }
private DataInputStream openUrl(String url) throws IOException { if (signlink.mainapp != null) { return signlink.openurl(url); } return new DataInputStream((new URL(this.getCodeBase(), url)).openStream()); }
@OriginalMember( owner = "client!sign/signlink", name = "startpriv", descriptor = "(Ljava/net/InetAddress;)V") public static void startpriv(@OriginalArg(0) InetAddress address) { threadliveid = (int) (Math.random() * 9.9999999E7D); if (active) { try { Thread.sleep(500L); } catch ( @Pc(10) Exception ignored) { } active = false; } socketreq = 0; threadreq = null; dnsreq = null; loadreq = null; savereq = null; urlreq = null; socketip = address; @Pc(33) Thread thread = new Thread(new signlink()); thread.setDaemon(true); thread.start(); while (!active) { try { Thread.sleep(50L); } catch ( @Pc(43) Exception ignored) { } } }
@OriginalMember( owner = "client!sign/signlink", name = "findcachedir", descriptor = "()Ljava/lang/String;") public static String findcachedir() { @Pc(50) String[] paths = new String[] { "c:/windows/", "c:/winnt/", "d:/windows/", "d:/winnt/", "e:/windows/", "e:/winnt/", "f:/windows/", "f:/winnt/", "c:/", "~/", "/tmp/", "" }; @Pc(52) String store = ".file_store_32"; for (@Pc(54) int i = 0; i < paths.length; i++) { try { @Pc(59) String dir = paths[i]; @Pc(67) File cache; if (dir.length() > 0) { cache = new File(dir); if (!cache.exists() || !cache.canWrite()) { continue; } } cache = new File(dir + store); if ((!cache.exists() && !cache.mkdir()) || !cache.canWrite()) { continue; } return dir + store + "/"; } catch ( @Pc(102) Exception _ex) { } } return null; }
@OriginalMember( owner = "client!sign/signlink", name = "getuid", descriptor = "(Ljava/lang/String;)I") public static int getuid(@OriginalArg(0) String cacheDir) { if (cacheDir == null) { return 0; } try { @Pc(11) File uid = new File(cacheDir + "uid.dat"); if (!uid.exists() || uid.length() < 4L) { @Pc(34) DataOutputStream stream = new DataOutputStream(new FileOutputStream(cacheDir + "uid.dat")); stream.writeInt((int) (Math.random() * 9.9999999E7D)); stream.close(); } } catch ( @Pc(44) Exception ignored) { } try { @Pc(59) DataInputStream stream = new DataInputStream(new FileInputStream(cacheDir + "uid.dat")); @Pc(62) int uid = stream.readInt(); stream.close(); return uid + 1; } catch ( @Pc(69) Exception ignored) { return 0; } }
@OriginalMember( owner = "client!sign/signlink", name = "gethash", descriptor = "(Ljava/lang/String;)J") public static long gethash(@OriginalArg(0) String str) { @Pc(2) String trimmed = str.trim(); @Pc(4) long hash = 0L; for (@Pc(6) int i = 0; i < trimmed.length() && i < 12; i++) { @Pc(11) char c = trimmed.charAt(i); hash *= 37L; if (c >= 'A' && c <= 'Z') { hash += c + 1 - 65; } else if (c >= 'a' && c <= 'z') { hash += c + 1 - 97; } else if (c >= '0' && c <= '9') { hash += c + 27 - 48; } } return hash; }
@OriginalMember(owner = "client!sign/signlink", name = "looprate", descriptor = "(I)V") public static void looprate(@OriginalArg(0) int rate) { looprate = rate; }
@OriginalMember( owner = "client!sign/signlink", name = "cacheload", descriptor = "(Ljava/lang/String;)[B") public static synchronized byte[] cacheload(@OriginalArg(0) String name) { if (!active) { return null; } loadreq = String.valueOf(gethash(name)); while (loadreq != null) { try { Thread.sleep(1L); } catch ( @Pc(12) Exception ignored) { } } return loadbuf; }
@OriginalMember( owner = "client!sign/signlink", name = "cachesave", descriptor = "(Ljava/lang/String;[B)V") public static synchronized void cachesave( @OriginalArg(0) String name, @OriginalArg(1) byte[] src) { if (!active || src.length > 2000000) { return; } while (savereq != null) { try { Thread.sleep(1L); } catch ( @Pc(11) Exception ignored) { } } savelen = src.length; savebuf = src; savereq = String.valueOf(gethash(name)); while (savereq != null) { try { Thread.sleep(1L); } catch ( @Pc(28) Exception ignored) { } } }
@OriginalMember( owner = "client!sign/signlink", name = "opensocket", descriptor = "(I)Ljava/net/Socket;") public static synchronized Socket opensocket(@OriginalArg(0) int port) throws IOException { socketreq = port; while (socketreq != 0) { try { Thread.sleep(50L); } catch ( @Pc(6) Exception ignored) { } } if (socket == null) { throw new IOException("could not open socket"); } return socket; }
@OriginalMember( owner = "client!sign/signlink", name = "openurl", descriptor = "(Ljava/lang/String;)Ljava/io/DataInputStream;") public static synchronized DataInputStream openurl(@OriginalArg(0) String url) throws IOException { urlreq = url; while (urlreq != null) { try { Thread.sleep(50L); } catch ( @Pc(6) Exception ignored) { } } if (urlstream == null) { throw new IOException("could not open: " + url); } return urlstream; }
@OriginalMember( owner = "client!sign/signlink", name = "dnslookup", descriptor = "(Ljava/lang/String;)V") public static synchronized void dnslookup(@OriginalArg(0) String hostname) { dns = hostname; dnsreq = hostname; }
@OriginalMember( owner = "client!sign/signlink", name = "startthread", descriptor = "(Ljava/lang/Runnable;I)V") public static synchronized void startthread( @OriginalArg(0) Runnable runnable, @OriginalArg(1) int priority) { threadreqpri = priority; threadreq = runnable; }
@OriginalMember(owner = "client!sign/signlink", name = "wavesave", descriptor = "([BI)Z") public static synchronized boolean wavesave( @OriginalArg(0) byte[] src, @OriginalArg(1) int length) { if (length > 2000000 || savereq != null) { return false; } wavepos = (wavepos + 1) % 5; savelen = length; savebuf = src; waveplay = true; savereq = "sound" + wavepos + ".wav"; return true; }
@OriginalMember(owner = "client!sign/signlink", name = "wavereplay", descriptor = "()Z") public static synchronized boolean wavereplay() { if (savereq != null) { return false; } savebuf = null; waveplay = true; savereq = "sound" + wavepos + ".wav"; return true; }
@OriginalMember(owner = "client!sign/signlink", name = "midisave", descriptor = "([BI)V") public static synchronized void midisave(@OriginalArg(0) byte[] src, @OriginalArg(1) int length) { if (length > 2000000 || savereq != null) { return; } midipos = (midipos + 1) % 5; savelen = length; savebuf = src; midiplay = true; savereq = "jingle" + midipos + ".mid"; }
@OriginalMember( owner = "client!sign/signlink", name = "reporterror", descriptor = "(Ljava/lang/String;)V") public static void reporterror(@OriginalArg(0) String message) { if (!reporterror || !active) { return; } System.out.println("Error: " + message); try { message = message.replace('@', '_'); message = message.replace('&', '_'); message = message.replace('#', '_'); @Pc(46) DataInputStream stream = openurl( "reporterror" + signlink.clientversion + ".cgi?error=" + errorname + " " + message); stream.readLine(); stream.close(); } catch ( @Pc(53) IOException ignored) { } }
@OriginalMember(owner = "mapview!mapview", name = "main", descriptor = "([Ljava/lang/String;)V") public static void main(@OriginalArg(0) String[] args) { @Pc(3) mapview app = new mapview(); app.initApplication(635, 503); }
@OriginalMember(owner = "mapview!mapview", name = "init", descriptor = "()V") @Override public void init() { this.initApplet(635, 503); }
private void readObjData(byte[] data, boolean[][] objs) { int pos = 0; while (pos < data.length) { int mx = (data[pos++] & 0xFF) * 64 - this.originX; int mz = (data[pos++] & 0xFF) * 64 - this.originZ; if (mx > 0 && mz > 0 && mx + 64 < this.sizeX && mz + 64 < this.sizeZ) { for (int x = 0; x < 64; x++) { boolean[] obj = objs[x + mx]; int zIndex = this.sizeZ - mz - 1; for (int z = -64; z < 0; z++) { obj[zIndex--] = data[pos++] == 1; } } } else { pos += 4096; } } }
private void readNpcData(byte[] data, boolean[][] npcs) { int pos = 0; while (pos < data.length) { int mx = (data[pos++] & 0xFF) * 64 - this.originX; int mz = (data[pos++] & 0xFF) * 64 - this.originZ; if (mx > 0 && mz > 0 && mx + 64 < this.sizeX && mz + 64 < this.sizeZ) { for (int x = 0; x < 64; x++) { boolean[] npc = npcs[x + mx]; int zIndex = this.sizeZ - mz - 1; for (int z = -64; z < 0; z++) { npc[zIndex--] = data[pos++] == 1; } } } else { pos += 4096; } } }
private void readMultiData(byte[] data, boolean[][] multimap) { int pos = 0; while (pos < data.length) { int mx = (data[pos++] & 0xFF) * 64 - this.originX; int mz = (data[pos++] & 0xFF) * 64 - this.originZ; if (mx > 0 && mz > 0 && mx + 64 < this.sizeX && mz + 64 < this.sizeZ) { for (int x = 0; x < 64; x++) { boolean[] map = multimap[x + mx]; int zIndex = this.sizeZ - mz - 1; for (int z = -64; z < 0; z++) { map[zIndex--] = data[pos++] == 1; } } } else { pos += 4096; } } }
private void readFreeData(byte[] data, boolean[][] freemap) { int pos = 0; while (pos < data.length) { int mx = (data[pos++] & 0xFF) * 64 - this.originX; int mz = (data[pos++] & 0xFF) * 64 - this.originZ; if (mx > 0 && mz > 0 && mx + 64 < this.sizeX && mz + 64 < this.sizeZ) { for (int x = 0; x < 64; x++) { boolean[] map = freemap[x + mx]; int zIndex = this.sizeZ - mz - 1; for (int z = -64; z < 0; z++) { map[zIndex--] = data[pos++] == 1; } } } else { pos += 4096; } } }
@OriginalMember(owner = "mapview!mapview", name = "a", descriptor = "([B[[B)V") private void readUnderlayData(@OriginalArg(0) byte[] data, @OriginalArg(1) byte[][] underlays) { @Pc(3) int pos = 0; while (pos < data.length) { @Pc(16) int mx = (data[pos++] & 0xFF) * 64 - this.originX; @Pc(27) int mz = (data[pos++] & 0xFF) * 64 - this.originZ; if (mx > 0 && mz > 0 && mx + 64 < this.sizeX && mz + 64 < this.sizeZ) { for (@Pc(43) int x = 0; x < 64; x++) { @Pc(51) byte[] underlay = underlays[x + mx]; @Pc(57) int zIndex = this.sizeZ - mz - 1; for (@Pc(59) int z = -64; z < 0; z++) { underlay[zIndex--] = data[pos++]; } } } else { pos += 4096; } } }
@OriginalMember(owner = "mapview!mapview", name = "a", descriptor = "([B[[I[[B)V") private void readOverlayData( @OriginalArg(0) byte[] data, @OriginalArg(1) int[][] tiles, @OriginalArg(2) byte[][] shapes) { @Pc(3) int pos = 0; while (pos < data.length) { @Pc(16) int mx = (data[pos++] & 0xFF) * 64 - this.originX; @Pc(27) int mz = (data[pos++] & 0xFF) * 64 - this.originZ; if (mx > 0 && mz > 0 && mx + 64 < this.sizeX && mz + 64 < this.sizeZ) { for (int x = 0; x < 64; x++) { @Pc(51) int[] tile = tiles[x + mx]; @Pc(57) byte[] shape = shapes[x + mx]; @Pc(63) int zIndex = this.sizeZ - mz - 1; for (@Pc(65) int z = -64; z < 0; z++) { int opcode = data[pos++]; if (opcode == 0) { tile[zIndex--] = 0; } else { shape[zIndex] = data[pos++]; tile[zIndex--] = this.floorcolOverlay[opcode]; } } } } else { for (int i = -4096; i < 0; i++) { int opcode = data[pos++]; if (opcode != 0) { pos++; } } } } }
@OriginalMember(owner = "mapview!mapview", name = "a", descriptor = "([[B[[I)V") private void averageUnderlayColors( @OriginalArg(0) byte[][] tiles, @OriginalArg(1) int[][] colors) { @Pc(3) short maxX = this.sizeX; @Pc(5) short maxZ = this.sizeZ; @Pc(8) int[] average = new int[maxZ]; for (@Pc(22) int x = 5; x < maxX - 5; x++) { @Pc(30) byte[] tileEast = tiles[x + 5]; @Pc(36) byte[] tileWest = tiles[x - 5]; for (@Pc(38) int z = 0; z < maxZ; z++) { average[z] += this.floorcolUnderlay[tileEast[z] & 0xFF] - this.floorcolUnderlay[tileWest[z] & 0xFF]; } if (x > 10 && x < maxX - 10) { @Pc(77) int r = 0; @Pc(79) int g = 0; @Pc(81) int b = 0; @Pc(85) int[] samples = colors[x]; for (@Pc(87) int z = 5; z < maxZ - 5; z++) { @Pc(101) int tileNorth = average[z + 5]; @Pc(95) int tileSouth = average[z - 5]; r += (tileNorth >> 20) - (tileSouth >> 20); g += (tileNorth >> 10 & 0x3FF) - (tileSouth >> 10 & 0x3FF); b += (tileNorth & 0x3FF) - (tileSouth & 0x3FF); if (b > 0) { samples[z] = this.convertHsl((double) r / 8533.0D, (double) g / 8533.0D, (double) b / 8533.0D); } } } } }
@OriginalMember(owner = "mapview!mapview", name = "g", descriptor = "()V") @Override protected void unload() { try { this.floorcolUnderlay = null; this.floorcolOverlay = null; this.floormapColors = null; this.overlayTiles = null; this.overlayInfo = null; this.locWalls = null; this.locMapfunctions = null; this.locMapscenes = null; this.objTiles = null; this.npcTiles = null; this.multiTiles = null; this.freeTiles = null; this.imageMapscene = null; this.imageMapfunction = null; this.imageMapdot0 = null; this.imageMapdot1 = null; this.imageMapdot2 = null; this.imageMapdot3 = null; this.b12 = null; this.visibleMapFunctionsX = null; this.visibleMapFunctionsY = null; this.visibleMapFunctions = null; this.activeMapFunctionX = null; this.activeMapFunctionZ = null; this.activeMapFunctions = null; this.imageOverview = null; this.labelText = null; this.labelX = null; this.labelY = null; this.labelFont = null; this.keyNames = null; System.gc(); } catch ( @Pc(71) Throwable ignore) { } }
@OriginalMember(owner = "mapview!mapview", name = "a", descriptor = "()V") @Override protected void refresh() { this.redrawTimer = 0; }
@OriginalMember( owner = "mapview!mapview", name = "a", descriptor = "(IIIIIIILjava/lang/String;)V") private void drawString( @OriginalArg(0) int x, @OriginalArg(1) int y, @OriginalArg(2) int width, @OriginalArg(3) int height, @OriginalArg(4) int colorBorderTL, @OriginalArg(5) int fillColor, @OriginalArg(6) int colorBorderBR, @OriginalArg(7) String str) { Pix2D.drawRect(x, y, 0, width, height); @Pc(6) int xPad = x + 1; @Pc(7) int yPad = y + 1; @Pc(8) int widthPad = width - 2; @Pc(9) int heightPad = height - 2; Pix2D.fillRect(xPad, yPad, fillColor, widthPad, heightPad); Pix2D.hline(xPad, yPad, colorBorderTL, widthPad); Pix2D.vline(xPad, yPad, colorBorderTL, heightPad); Pix2D.hline(xPad, yPad + heightPad - 1, colorBorderBR, widthPad); Pix2D.vline(xPad + widthPad - 1, yPad, colorBorderBR, heightPad); this.b12.drawStringCenter(xPad + widthPad / 2 + 1, yPad + heightPad / 2 + 1 + 4, str, 0); this.b12.drawStringCenter(xPad + widthPad / 2, yPad + heightPad / 2 + 4, str, 0xffffff); }
@OriginalMember(owner = "mapview!mapview", name = "i", descriptor = "()Lmapview!p;") private Jagfile loadWorldmap() { @Pc(3) String cachedir = null; @Pc(17) byte[] data; try { cachedir = this.findcachedir(); data = this.cacheload(cachedir + "/worldmap.dat"); if (!this.checksha(data)) { data = null; } if (data != null) { return new Jagfile(data); } } catch ( @Pc(31) Throwable ignore) { } data = this.updateWorldmap(); if (cachedir != null && data != null) { try { this.cachesave(cachedir + "/worldmap.dat", data); } catch ( @Pc(51) Throwable ignore) { } } return new Jagfile(data); }
@OriginalMember(owner = "mapview!mapview", name = "k", descriptor = "()Ljava/lang/String;") private String findcachedir() { @Pc(50) String[] paths = new String[] { "c:/windows/", "c:/winnt/", "d:/windows/", "d:/winnt/", "e:/windows/", "e:/winnt/", "f:/windows/", "f:/winnt/", "c:/", "~/", "/tmp/", "" }; @Pc(52) String store = ".file_store_32"; for (@Pc(54) int i = 0; i < paths.length; i++) { try { @Pc(60) String dir = paths[i]; @Pc(68) File cache; if (dir.length() > 0) { cache = new File(dir); if (!cache.exists()) { continue; } } cache = new File(dir + store); if (cache.exists() || cache.mkdir()) { return dir + store + "/"; } } catch ( @Pc(103) Exception ignore) { } } return null; }
@OriginalMember(owner = "mapview!mapview", name = "a", descriptor = "(Ljava/lang/String;)[B") private byte[] cacheload(@OriginalArg(0) String name) throws IOException { @Pc(4) File file = new File(name); if (!file.exists()) { return null; } @Pc(13) int length = (int) file.length(); @Pc(16) byte[] data = new byte[length]; @Pc(27) DataInputStream stream = new DataInputStream(new BufferedInputStream(new FileInputStream(name))); stream.readFully(data, 0, length); stream.close(); return data; }
@OriginalMember(owner = "mapview!mapview", name = "a", descriptor = "(Ljava/lang/String;[B)V") private void cachesave(@OriginalArg(0) String name, @OriginalArg(1) byte[] data) throws IOException { @Pc(4) FileOutputStream stream = new FileOutputStream(name); stream.write(data, 0, data.length); stream.close(); }
@OriginalMember(owner = "mapview!mapview", name = "a", descriptor = "([B)Z") private boolean checksha(@OriginalArg(0) byte[] data) throws Exception { if (data == null) { return false; } @Pc(6) MessageDigest shaDigest = MessageDigest.getInstance("SHA"); shaDigest.reset(); shaDigest.update(data); @Pc(14) byte[] computedSha = shaDigest.digest(); for (@Pc(16) int i = 0; i < 20; i++) { if (computedSha[i] != sig.sha[i]) { return false; } } return true; }
@OriginalMember(owner = "mapview!g", name = "a", descriptor = "(Ljava/lang/String;IIIZ)V") private void drawString( @OriginalArg(0) String str, @OriginalArg(1) int x, @OriginalArg(2) int y, @OriginalArg(3) int rgb, @OriginalArg(4) boolean shadowed) { try { if (this.fontCharFlagged || rgb == 0) { shadowed = false; } for (@Pc(8) int i = 0; i < str.length(); i++) { @Pc(16) int c = fontChar[str.charAt(i)]; if (shadowed) { this.drawChar(c, x + 1, y, 0, this.fontCharInfo, this.fontCharFlagged); this.drawChar(c, x, y + 1, 0, this.fontCharInfo, this.fontCharFlagged); } this.drawChar(c, x, y, rgb, this.fontCharInfo, this.fontCharFlagged); x += this.fontCharInfo[c + 7]; } } catch ( @Pc(68) Exception ex) { System.out.println("drawstring: " + ex); ex.printStackTrace(); } }
@OriginalMember(owner = "mapview!g", name = "b", descriptor = "(Ljava/lang/String;IIIZ)V") public void drawStringCenter( @OriginalArg(0) String str, @OriginalArg(1) int x, @OriginalArg(2) int y, @OriginalArg(3) int rgb, @OriginalArg(4) boolean shadowed) { @Pc(5) int xOffset = this.stringWidth(str) / 2; @Pc(8) int yOffset = this.getYOffset(); if (x - xOffset <= Pix2D.boundRight && (x + xOffset >= Pix2D.boundLeft && (y - yOffset <= Pix2D.boundBottom && y >= 0))) { this.drawString(str, x - xOffset, y, rgb, shadowed); } }
@OriginalMember(owner = "mapview!g", name = "a", descriptor = "([I[BIIIIIII)V") private void plotLetter2( @OriginalArg(0) int[] arg0, @OriginalArg(1) byte[] arg1, @OriginalArg(2) int arg2, @OriginalArg(3) int arg3, @OriginalArg(4) int arg4, @OriginalArg(5) int arg5, @OriginalArg(6) int arg6, @OriginalArg(7) int arg7, @OriginalArg(8) int arg8) { for (@Pc(4) int local4 = -arg6; local4 < 0; local4++) { for (@Pc(9) int local9 = -arg5; local9 < 0; local9++) { @Pc(18) int local18 = arg1[arg3++] & 0xFF; if (local18 <= 30) { arg4++; } else if (local18 >= 230) { arg0[arg4++] = arg2; } else { @Pc(35) int local35 = arg0[arg4]; arg0[arg4++] = ((arg2 & 0xFF00FF) * local18 + (local35 & 0xFF00FF) * (256 - local18) & 0xFF00FF00) + ((arg2 & 0xFF00) * local18 + (local35 & 0xFF00) * (256 - local18) & 0xFF0000) >> 8; } } arg4 += arg7; arg3 += arg8; } }
@OriginalMember(owner = "mapview!g", name = "a", descriptor = "(Ljava/lang/String;)I") private int stringWidth(@OriginalArg(0) String arg0) { @Pc(3) int local3 = 0; for (@Pc(5) int local5 = 0; local5 < arg0.length(); local5++) { if (arg0.charAt(local5) == '@' && local5 + 4 < arg0.length() && arg0.charAt(local5 + 4) == '@') { local5 += 4; } else if (arg0.charAt(local5) == '~' && local5 + 4 < arg0.length() && arg0.charAt(local5 + 4) == '~') { local5 += 4; } else { local3 += this.fontCharInfo[fontChar[arg0.charAt(local5)] + 7]; } } return local3; }
public void init() { try { signlink.mainapp = this; signlink.startpriv(InetAddress.getByName(getCodeBase().getHost())); String vendor = System.getProperties().getProperty("java.vendor"); if (vendor.toLowerCase().indexOf("sun") != -1 || vendor.toLowerCase().indexOf("apple") != -1) { signlink.sunjava = true; } new Thread(this).start(); } catch (Exception ex) { ex.printStackTrace(); } }
public void run() { try { byte[] jar = signlink.cacheload("runescape.jar"); if (!verify(jar)) { updatecache(); jar = signlink.cacheload("runescape.jar"); if (!verify(jar)) { return; } } String cachedir = signlink.findcachedir(); if (cachedir == null) { showprogress("No writable cache directory", 0); return; } cloader classLoader = new cloader(); classLoader.jar = new ZipFile(cachedir + "/" + signlink.gethash("runescape.jar")); classLoader.link = Class.forName("sign.signlink"); inner = (Applet) classLoader.loadClass("client").newInstance(); inner.init(); inner.start(); } catch (Exception ex) { ex.printStackTrace(); } }
private void showprogress(String message, int percent) { Graphics g = getGraphics(); Font bold = new Font("Helvetica", Font.BOLD, 13); FontMetrics boldMetrics = getFontMetrics(bold); Font plain = new Font("Helvetica", Font.PLAIN, 13); FontMetrics plainMetrics = getFontMetrics(plain); Color barColor = new Color(140, 17, 17); g.setColor(Color.black); g.fillRect(0, 0, loader.swid, loader.shei); g.setColor(barColor); g.drawRect(242, 248, 304, 34); String str = message + " - " + percent + "%"; g.setFont(bold); g.setColor(Color.white); g.drawString(str, ((loader.swid - boldMetrics.stringWidth(str)) / 2), 270); }
private void updatecache() throws Exception { byte[] src = new byte[sig.len]; String uriSha = ""; for (int i = 0; i < 10; i++) { uriSha += sig.sha[i]; } InputStream stream = new URL(getCodeBase(), "runescape" + uriSha + ".jar").openStream(); int lastPercent = 0; int read = 0; while (read < sig.len) { int remaining = sig.len - read; if (remaining > 1000) { remaining = 1000; } read += stream.read(src, read, remaining); int percent = read * 100 / sig.len; if (percent != lastPercent) { showprogress("Loading game code", percent); lastPercent = percent; } } stream.close(); signlink.cachesave("runescape.jar", src); }
private boolean verify(byte[] src) throws Exception { if (src == null) { return false; } MessageDigest shasum = MessageDigest.getInstance("SHA"); shasum.reset(); shasum.update(src); byte[] sha = shasum.digest(); for (int i = 0; i < 20; i++) { if (sha[i] != sig.sha[i]) { return false; } } return true; }
public void start() { if (inner != null) { inner.start(); } }
public void stop() { if (inner != null) { inner.stop(); } }
public void destroy() { if (inner != null) { inner.destroy(); } }
public void update(Graphics g) { if (inner != null) { inner.update(g); } }
public void paint(Graphics g) { if (inner != null) { inner.paint(g); } }
public String getmidi() { if (signlink.midi == null) { return "none"; } String str = signlink.midi; signlink.midi = null; return str; }
public int getmidivol() { return signlink.midivol; }
public int getmidifade() { return signlink.midifade; }
public String getwave() { if (signlink.wave == null) { return "none"; } String str = signlink.wave; signlink.wave = null; return str; }
public int getwavevol() { return signlink.wavevol; }
public synchronized Class loadClass(String name, boolean resolve) { Class instance = (Class) cache.get(name); if (instance != null) { return instance; } Class found; try { instance = super.findSystemClass(name); found = instance; } catch (ClassNotFoundException _ex1) { if (name.indexOf("signlink") != -1) { return this.link; } try { ZipEntry entry = (this).jar.getEntry(name.replace('.', '/') + ".class"); int size = (int) entry.getSize(); DataInputStream stream = new DataInputStream(this.jar.getInputStream(entry)); byte[] is = new byte[size]; stream.readFully(is); stream.close(); instance = defineClass(is, 0, is.length); if (resolve) { resolveClass(instance); } cache.put(name, instance); } catch (Exception _ex2) { } return instance; } return found; }
@OriginalMember( owner = "client!hc", name = "a", descriptor = "(Lclient!ub;ILjava/lang/String;I)Lclient!hb;") private static Pix32 getImage( @OriginalArg(0) Jagfile media, @OriginalArg(2) String sprite, @OriginalArg(1) int spriteId) { @Pc(8) long uid = (JString.hashCode(sprite) << 8) + (long) spriteId; @Pc(13) Pix32 image = (Pix32) imageCache.get(uid); if (image != null) { return image; } try { image = new Pix32(media, sprite, spriteId); imageCache.put(uid, image); } catch ( @Pc(38) Exception ignored) { return null; } return image; }
@OriginalMember(owner = "client!hc", name = "a", descriptor = "(IIZ)Lclient!eb;") public Model getModel( @OriginalArg(0) int primaryFrame, @OriginalArg(1) int secondaryFrame, @OriginalArg(2) boolean active) { @Pc(2) Model m = this.model; if (active) { m = this.activeModel; } if (m == null) { return null; } if (primaryFrame == -1 && secondaryFrame == -1 && m.faceColors == null) { return m; } @Pc(31) Model tmp = new Model(m, true, true, false); if (primaryFrame != -1 || secondaryFrame != -1) { tmp.createLabelReferences(); } if (primaryFrame != -1) { tmp.applyTransform(primaryFrame); } if (secondaryFrame != -1) { tmp.applyTransform(secondaryFrame); } tmp.calculateNormals(64, 768, -50, -10, -50, true); return tmp; }
@OriginalMember(owner = "client!fc", name = "a", descriptor = "(Lclient!ub;I)V") public static void unpack(@OriginalArg(0) Jagfile config) { @Pc(9) Packet dat = new Packet(config.read("flo.dat", null)); count = dat.g2(); if (instances == null) { instances = new FloType[count]; } for (@Pc(23) int id = 0; id < count; id++) { if (instances[id] == null) { instances[id] = new FloType(); } instances[id].decode(dat); } }
@OriginalMember(owner = "client!fc", name = "a", descriptor = "(ZLclient!kb;)V") public void decode(@OriginalArg(1) Packet dat) { while (true) { @Pc(10) int code = dat.g1(); if (code == 0) { return; } if (code == 1) { this.rgb = dat.g3(); this.setColor(this.rgb); } else if (code == 2) { this.texture = dat.g1(); } else if (code == 3) { this.overlay = true; } else if (code == 5) { this.occlude = false; } else if (code == 6) { this.name = dat.gjstr(); } else { System.out.println("Error unrecognised flo config code: " + code); } } }
@OriginalMember(owner = "client!fc", name = "a", descriptor = "(III)I") private int hsl24to16( @OriginalArg(0) int hue, @OriginalArg(1) int saturation, @OriginalArg(2) int lightness) { if (lightness > 179) { saturation /= 2; } if (lightness > 192) { saturation /= 2; } if (lightness > 217) { saturation /= 2; } if (lightness > 243) { saturation /= 2; } return (hue / 4 << 10) + (saturation / 32 << 7) + lightness / 2; }
@OriginalMember(owner = "client!kc", name = "a", descriptor = "(Lclient!ub;I)V") public static void unpack(@OriginalArg(0) Jagfile config) { @Pc(13) Packet dat = new Packet(config.read("spotanim.dat", null)); count = dat.g2(); if (instances == null) { instances = new SpotAnimType[count]; } for (@Pc(23) int id = 0; id < count; id++) { if (instances[id] == null) { instances[id] = new SpotAnimType(); } instances[id].index = id; instances[id].decode(dat); } }
@OriginalMember(owner = "client!kc", name = "a", descriptor = "(ZLclient!kb;)V") public void decode(@OriginalArg(1) Packet dat) { while (true) { @Pc(5) int code = dat.g1(); if (code == 0) { break; } if (code == 1) { this.model = dat.g2(); } else if (code == 2) { this.anim = dat.g2(); if (SeqType.instances != null) { this.seq = SeqType.instances[this.anim]; } } else if (code == 3) { this.animHasAlpha = true; } else if (code == 4) { this.resizeh = dat.g2(); } else if (code == 5) { this.resizev = dat.g2(); } else if (code == 6) { this.orientation = dat.g2(); } else if (code == 7) { this.ambient = dat.g1(); } else if (code == 8) { this.contrast = dat.g1(); } else if (code >= 40 && code < 50) { this.recol_s[code - 40] = dat.g2(); } else if (code >= 50 && code < 60) { this.recol_d[code - 50] = dat.g2(); } else { System.out.println("Error unrecognised spotanim config code: " + code); } } }
@OriginalMember(owner = "client!gc", name = "a", descriptor = "(Lclient!ub;I)V") public static void unpack(@OriginalArg(0) Jagfile config) { @Pc(9) Packet dat = new Packet(config.read("idk.dat", null)); count = dat.g2(); if (instances == null) { instances = new IdkType[count]; } for (@Pc(19) int id = 0; id < count; id++) { if (instances[id] == null) { instances[id] = new IdkType(); } instances[id].decode(dat); } }
@OriginalMember(owner = "client!gc", name = "a", descriptor = "(ZLclient!kb;)V") public void decode(@OriginalArg(1) Packet dat) { while (true) { @Pc(8) int code = dat.g1(); if (code == 0) { break; } if (code == 1) { this.type = dat.g1(); } else if (code == 2) { @Pc(26) int count = dat.g1(); this.models = new int[count]; for (@Pc(32) int i = 0; i < count; i++) { this.models[i] = dat.g2(); } } else if (code == 3) { this.disable = true; } else if (code >= 40 && code < 50) { this.recol_s[code - 40] = dat.g2(); } else if (code >= 50 && code < 60) { this.recol_d[code - 50] = dat.g2(); } else if (code >= 60 && code < 70) { this.heads[code - 60] = dat.g2(); } else { System.out.println("Error unrecognised idk config code: " + code); } } }
@OriginalMember(owner = "client!jc", name = "a", descriptor = "(Lclient!ub;I)V") public static void unpack(@OriginalArg(0) Jagfile config) { @Pc(9) Packet dat = new Packet(config.read("seq.dat", null)); count = dat.g2(); if (instances == null) { instances = new SeqType[count]; } for (@Pc(27) int id = 0; id < count; id++) { if (instances[id] == null) { instances[id] = new SeqType(); } instances[id].decode(dat); } }
@OriginalMember(owner = "client!bc", name = "a", descriptor = "(Lclient!ub;)V") public static void unpack(@OriginalArg(0) Jagfile config) { dat = new Packet(config.read("npc.dat", null)); @Pc(21) Packet idx = new Packet(config.read("npc.idx", null)); count = idx.g2(); offsets = new int[count]; @Pc(29) int offset = 2; for (@Pc(31) int id = 0; id < count; id++) { offsets[id] = offset; offset += idx.g2(); } cache = new NpcType[20]; for (@Pc(51) int id = 0; id < 20; id++) { cache[id] = new NpcType(); } }
@OriginalMember(owner = "client!bc", name = "a", descriptor = "(Z)V") public static void unload() { modelCache = null; offsets = null; cache = null; dat = null; }
@OriginalMember(owner = "client!bc", name = "a", descriptor = "(I)Lclient!bc;") public static NpcType get(@OriginalArg(0) int id) { for (@Pc(1) int i = 0; i < 20; i++) { if (cache[i].index == (long) id) { return cache[i]; } } cachePos = (cachePos + 1) % 20; @Pc(33) NpcType npc = cache[cachePos] = new NpcType(); dat.pos = offsets[id]; npc.index = id; npc.decode(dat); return npc; }
@OriginalMember(owner = "client!cc", name = "a", descriptor = "(Lclient!ub;)V") public static void unpack(@OriginalArg(0) Jagfile config) { dat = new Packet(config.read("obj.dat", null)); @Pc(21) Packet idx = new Packet(config.read("obj.idx", null)); count = idx.g2(); offsets = new int[count]; @Pc(29) int offset = 2; for (@Pc(31) int id = 0; id < count; id++) { offsets[id] = offset; offset += idx.g2(); } cache = new ObjType[10]; for (@Pc(51) int id = 0; id < 10; id++) { cache[id] = new ObjType(); } }
@OriginalMember(owner = "client!cc", name = "a", descriptor = "(Z)V") public static void unload() { modelCache = null; iconCache = null; offsets = null; cache = null; dat = null; }
@OriginalMember(owner = "client!cc", name = "a", descriptor = "(I)Lclient!cc;") public static ObjType get(@OriginalArg(0) int id) { for (@Pc(1) int i = 0; i < 10; i++) { if (cache[i].index == id) { return cache[i]; } } cachePos = (cachePos + 1) % 10; @Pc(27) ObjType obj = cache[cachePos]; dat.pos = offsets[id]; obj.index = id; obj.reset(); obj.decode(dat); if (obj.certtemplate != -1) { obj.toCertificate(); } if (!membersWorld && obj.members) { obj.name = "Members Object"; obj.desc = "Login to a members' server to use this object."; obj.op = null; obj.iop = null; } return obj; }
@OriginalMember(owner = "client!cc", name = "a", descriptor = "()V") public void reset() { this.model = 0; this.name = null; this.desc = null; this.recol_s = null; this.recol_d = null; this.zoom2d = 2000; this.xan2d = 0; this.yan2d = 0; this.zan2d = 0; this.xof2d = 0; this.yof2d = 0; this.code9 = false; this.code10 = -1; this.stackable = false; this.cost = 1; this.members = false; this.op = null; this.iop = null; this.manwear = -1; this.manwear2 = -1; this.manwearOffsetY = 0; this.womanwear = -1; this.womanwear2 = -1; this.womanwearOffsetY = 0; this.manwear3 = -1; this.womanwear3 = -1; this.manhead = -1; this.manhead2 = -1; this.womanhead = -1; this.womanhead2 = -1; this.countobj = null; this.countco = null; this.certlink = -1; this.certtemplate = -1; }
@OriginalMember(owner = "client!cc", name = "b", descriptor = "(I)V") public void toCertificate() { @Pc(3) ObjType template = get(this.certtemplate); this.model = template.model; this.zoom2d = template.zoom2d; this.xan2d = template.xan2d; this.yan2d = template.yan2d; this.zan2d = template.zan2d; this.xof2d = template.xof2d; this.yof2d = template.yof2d; this.recol_s = template.recol_s; this.recol_d = template.recol_d; @Pc(55) ObjType link = get(this.certlink); this.name = link.name; this.members = link.members; this.cost = link.cost; @Pc(69) String article = "a"; @Pc(74) char c = link.name.charAt(0); if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') { article = "an"; } this.desc = "Swap this note at any bank for " + article + " " + link.name + "."; this.stackable = true; }
@OriginalMember(owner = "client!ac", name = "a", descriptor = "(Lclient!ub;)V") public static void unpack(@OriginalArg(0) Jagfile config) { dat = new Packet(config.read("loc.dat", null)); @Pc(21) Packet idx = new Packet(config.read("loc.idx", null)); count = idx.g2(); offsets = new int[count]; @Pc(29) int offset = 2; for (@Pc(31) int id = 0; id < count; id++) { offsets[id] = offset; offset += idx.g2(); } cache = new LocType[10]; for (@Pc(51) int id = 0; id < 10; id++) { cache[id] = new LocType(); } }
@OriginalMember(owner = "client!ac", name = "a", descriptor = "(Z)V") public static void unload() { modelCacheStatic = null; modelCacheDynamic = null; offsets = null; cache = null; dat = null; }
@OriginalMember(owner = "client!ac", name = "a", descriptor = "(I)Lclient!ac;") public static LocType get(@OriginalArg(0) int id) { for (@Pc(1) int i = 0; i < 10; i++) { if (cache[i].index == id) { return cache[i]; } } cachePos = (cachePos + 1) % 10; @Pc(27) LocType loc = cache[cachePos]; dat.pos = offsets[id]; loc.index = id; loc.reset(); loc.decode(dat); return loc; }
@OriginalMember(owner = "client!ac", name = "a", descriptor = "()V") public void reset() { this.models = null; this.shapes = null; this.name = null; this.desc = null; this.recol_s = null; this.recol_d = null; this.width = 1; this.length = 1; this.blockwalk = true; this.blockrange = true; this.active = false; this.hillskew = false; this.sharelight = false; this.occlude = false; this.anim = -1; this.wallwidth = 16; this.ambient = 0; this.contrast = 0; this.op = null; this.animHasAlpha = false; this.mapfunction = -1; this.mapscene = -1; this.mirror = false; this.shadow = true; this.resizex = 128; this.resizey = 128; this.resizez = 128; this.forceapproach = 0; this.offsetx = 0; this.offsety = 0; this.offsetz = 0; this.forcedecor = false; }
@OriginalMember(owner = "client!lc", name = "a", descriptor = "(Lclient!ub;I)V") public static void unpack(@OriginalArg(0) Jagfile config) { @Pc(9) Packet dat = new Packet(config.read("varp.dat", null)); code3Count = 0; count = dat.g2(); if (instances == null) { instances = new VarpType[count]; } if (code3 == null) { code3 = new int[count]; } for (@Pc(30) int id = 0; id < count; id++) { if (instances[id] == null) { instances[id] = new VarpType(); } instances[id].decode(id, dat); } }
@OriginalMember(owner = "client!lc", name = "a", descriptor = "(IILclient!kb;)V") public void decode(@OriginalArg(1) int id, @OriginalArg(2) Packet dat) { while (true) { @Pc(8) int code = dat.g1(); if (code == 0) { return; } if (code == 1) { this.code1 = dat.g1(); } else if (code == 2) { this.code2 = dat.g1(); } else if (code == 3) { this.hasCode3 = true; VarpType.code3[VarpType.code3Count++] = id; } else if (code == 4) { this.code4 = false; } else if (code == 5) { this.clientcode = dat.g2(); } else if (code == 6) { this.code6 = true; } else if (code == 7) { this.code7 = dat.g4(); } else if (code == 8) { this.code8 = true; } else if (code == 10) { this.code10 = dat.gjstr(); } else { System.out.println("Error unrecognised varp config code: " + code); } } }
@OriginalMember(owner = "client!yb", name = "a", descriptor = "(Lclient!kb;I)V") public static void unpack(@OriginalArg(0) Packet dat) { waveBytes = new byte[441000]; waveBuffer = new Packet(waveBytes); Tone.init(); while (true) { @Pc(16) int id = dat.g2(); if (id == 65535) { return; } tracks[id] = new Wave(); tracks[id].read(dat); delays[id] = tracks[id].trim(); } }
@OriginalMember(owner = "client!yb", name = "a", descriptor = "(BII)Lclient!kb;") public static Packet generate(@OriginalArg(2) int id, @OriginalArg(1) int loopCount) { if (tracks[id] == null) { return null; } @Pc(12) Wave track = tracks[id]; return track.getWave(loopCount); }
@OriginalMember(owner = "client!yb", name = "a", descriptor = "(ZLclient!kb;)V") public void read(@OriginalArg(1) Packet dat) { for (@Pc(1) int tone = 0; tone < 10; tone++) { if (dat.g1() != 0) { dat.pos--; this.tones[tone] = new Tone(); this.tones[tone].read(dat); } } this.loopBegin = dat.g2(); this.loopEnd = dat.g2(); }
@OriginalMember(owner = "client!yb", name = "a", descriptor = "(B)I") public int trim() { @Pc(3) int start = 9999999; for (@Pc(5) int tone = 0; tone < 10; tone++) { if (this.tones[tone] != null && this.tones[tone].start / 20 < start) { start = this.tones[tone].start / 20; } } if (this.loopBegin < this.loopEnd && this.loopBegin / 20 < start) { start = this.loopBegin / 20; } if (start == 9999999 || start == 0) { return 0; } for (@Pc(67) int tone = 0; tone < 10; tone++) { if (this.tones[tone] != null) { this.tones[tone].start -= start * 20; } } if (this.loopBegin < this.loopEnd) { this.loopBegin -= start * 20; this.loopEnd -= start * 20; } return start; }
@OriginalMember(owner = "client!zb", name = "a", descriptor = "()V") public static void init() { noise = new int[32768]; for (@Pc(6) int i = 0; i < 32768; i++) { if (Math.random() > 0.5D) { noise[i] = 1; } else { noise[i] = -1; } } sin = new int[32768]; for (@Pc(31) int i = 0; i < 32768; i++) { sin[i] = (int) (Math.sin((double) i / 5215.1903D) * 16384.0D); } buffer = new int[220500]; }
@OriginalMember(owner = "client!zb", name = "a", descriptor = "(IIII)I") private int generate( @OriginalArg(1) int amplitude, @OriginalArg(2) int phase, @OriginalArg(3) int form) { if (form == 1) { return (phase & 0x7FFF) < 16384 ? amplitude : -amplitude; } else if (form == 2) { return sin[phase & 0x7FFF] * amplitude >> 14; } else if (form == 3) { return ((phase & 0x7FFF) * amplitude >> 14) - amplitude; } else if (form == 4) { return noise[phase / 2607 & 0x7FFF] * amplitude; } else { return 0; } }
@OriginalMember(owner = "client!zb", name = "a", descriptor = "(ZLclient!kb;)V") public void read(@OriginalArg(1) Packet dat) { this.frequencyBase = new Envelope(); this.frequencyBase.read(dat); this.amplitudeBase = new Envelope(); this.amplitudeBase.read(dat); if (dat.g1() != 0) { dat.pos--; this.frequencyModRate = new Envelope(); this.frequencyModRate.read(dat); this.frequencyModRange = new Envelope(); this.frequencyModRange.read(dat); } if (dat.g1() != 0) { dat.pos--; this.amplitudeModRate = new Envelope(); this.amplitudeModRate.read(dat); this.amplitudeModRange = new Envelope(); this.amplitudeModRange.read(dat); } if (dat.g1() != 0) { dat.pos--; this.release = new Envelope(); this.release.read(dat); this.attack = new Envelope(); this.attack.read(dat); } for (@Pc(122) int harmonic = 0; harmonic < 10; harmonic++) { @Pc(132) int volume = dat.gsmarts(); if (volume == 0) { break; } this.harmonicVolume[harmonic] = volume; this.harmonicSemitone[harmonic] = dat.gsmart(); this.harmonicDelay[harmonic] = dat.gsmarts(); } this.reverbDelay = dat.gsmarts(); this.reverbVolume = dat.gsmarts(); this.length = dat.g2(); this.start = dat.g2(); }
@OriginalMember(owner = "client!xb", name = "a", descriptor = "(ZLclient!kb;)V") public void read(@OriginalArg(1) Packet dat) { this.form = dat.g1(); this.start = dat.g4(); this.end = dat.g4(); this.length = dat.g1(); this.shapeDelta = new int[this.length]; this.shapePeak = new int[this.length]; for (@Pc(31) int i = 0; i < this.length; i++) { this.shapeDelta[i] = dat.g2(); this.shapePeak[i] = dat.g2(); } }
@OriginalMember(owner = "client!xb", name = "a", descriptor = "(I)V") public void reset() { this.threshold = 0; this.position = 0; this.delta = 0; this.amplitude = 0; this.ticks = 0; }
@OriginalMember(owner = "client!xb", name = "a", descriptor = "(ZI)I") public int evaluate(@OriginalArg(1) int delta) { if (this.ticks >= this.threshold) { this.amplitude = this.shapePeak[this.position++] << 15; if (this.position >= this.length) { this.position = this.length - 1; } this.threshold = (int) ((double) this.shapeDelta[this.position] / 65536.0D * (double) delta); if (this.threshold > this.ticks) { this.delta = ((this.shapePeak[this.position] << 15) - this.amplitude) / (this.threshold - this.ticks); } } this.amplitude += this.delta; this.ticks++; return this.amplitude - this.delta >> 15; }
@OriginalMember(owner = "client!tb", name = "a", descriptor = "()I") public int takeNextValue() { if (this.count-- == 0) { this.generate(); this.count = 255; } return this.rsl[this.count]; }
@OriginalMember(owner = "client!tb", name = "b", descriptor = "()V") private void generate() { this.b += ++this.c; for (@Pc(15) int i = 0; i < 256; i++) { @Pc(22) int x = this.mem[i]; switch (i & 0x3) { case 0: this.a ^= this.a << 13; break; case 1: this.a ^= this.a >>> 6; break; case 2: this.a ^= this.a << 2; break; case 3: this.a ^= this.a >>> 16; } this.a += this.mem[i + 128 & 0xFF]; @Pc(101) int y; this.mem[i] = y = this.mem[x >> 2 & 0xFF] + this.a + this.b; this.rsl[i] = this.b = this.mem[y >> 8 >> 2 & 0xFF] + x; } }
@OriginalMember(owner = "client!d", name = "a", descriptor = "()V") public void close() { this.closed = true; try { if (this.in != null) { this.in.close(); } if (this.out != null) { this.out.close(); } if (this.socket != null) { this.socket.close(); } } catch ( @Pc(22) IOException ignored) { System.out.println("Error closing stream"); } this.writer = false; synchronized (this) { this.notify(); } this.buf = null; }
@OriginalMember(owner = "client!d", name = "b", descriptor = "()I") public int read() throws IOException { return this.closed ? 0 : this.in.read(); }
@OriginalMember(owner = "client!d", name = "c", descriptor = "()I") public int available() throws IOException { return this.closed ? 0 : this.in.available(); }
@OriginalMember(owner = "client!d", name = "a", descriptor = "([BII)V") public void read(@OriginalArg(0) byte[] dst, @OriginalArg(1) int off, @OriginalArg(2) int len) throws IOException { if (this.closed) { return; } while (len > 0) { @Pc(11) int read = this.in.read(dst, off, len); if (read <= 0) { throw new IOException("EOF"); } off += read; len -= read; } }
@OriginalMember(owner = "client!d", name = "a", descriptor = "([BIZI)V") public void write(@OriginalArg(0) byte[] src, @OriginalArg(1) int len, @OriginalArg(3) int off) throws IOException { if (!this.closed) { if (this.ioerror) { this.ioerror = false; throw new IOException("Error in writer thread"); } if (this.buf == null) { this.buf = new byte[5000]; } synchronized (this) { for (@Pc(31) int i = 0; i < len; i++) { this.buf[this.bufPos] = src[i + off]; this.bufPos = (this.bufPos + 1) % 5000; if (this.bufPos == (this.bufLen + 4900) % 5000) { throw new IOException("buffer overflow"); } } if (!this.writer) { this.writer = true; this.shell.startThread(this, 2); } this.notify(); } } }
@OriginalMember(owner = "client!d", name = "run", descriptor = "()V") public void run() { while (this.writer) { @Pc(38) int len; @Pc(27) int off; synchronized (this) { if (this.bufPos == this.bufLen) { try { this.wait(); } catch ( @Pc(16) InterruptedException ignored) { } } if (!this.writer) { return; } off = this.bufLen; if (this.bufPos >= this.bufLen) { len = this.bufPos - this.bufLen; } else { len = 5000 - this.bufLen; } } if (len > 0) { try { this.out.write(this.buf, off, len); } catch ( @Pc(62) IOException ignored) { this.ioerror = true; } this.bufLen = (this.bufLen + len) % 5000; try { if (this.bufPos == this.bufLen) { this.out.flush(); } } catch ( @Pc(83) IOException ignored) { this.ioerror = true; } } } }
@OriginalMember(owner = "client!ub", name = "a", descriptor = "(Z[B)V") private void load(@OriginalArg(1) byte[] src) { @Pc(7) Packet data = new Packet(src); @Pc(10) int unpackedSize = data.g3(); @Pc(13) int packedSize = data.g3(); if (packedSize == unpackedSize) { this.buffer = src; this.unpacked = false; } else { @Pc(19) byte[] temp = new byte[unpackedSize]; BZip2.read(temp, unpackedSize, src, packedSize, 6); this.buffer = temp; data = new Packet(this.buffer); this.unpacked = true; } this.fileCount = data.g2(); this.fileHash = new int[this.fileCount]; this.fileUnpackedSize = new int[this.fileCount]; this.filePackedSize = new int[this.fileCount]; this.fileOffset = new int[this.fileCount]; @Pc(82) int pos = data.pos + this.fileCount * 10; for (@Pc(84) int i = 0; i < this.fileCount; i++) { this.fileHash[i] = data.g4(); this.fileUnpackedSize[i] = data.g3(); this.filePackedSize[i] = data.g3(); this.fileOffset[i] = pos; pos += this.filePackedSize[i]; } }
@OriginalMember(owner = "client!ub", name = "a", descriptor = "(Ljava/lang/String;[BB)[B") public byte[] read(@OriginalArg(0) String name, @OriginalArg(1) byte[] dst) { @Pc(3) int hash = 0; @Pc(6) String upper = name.toUpperCase(); for (@Pc(8) int i = 0; i < upper.length(); i++) { hash = hash * 61 + upper.charAt(i) - 32; } for (@Pc(27) int i = 0; i < this.fileCount; i++) { if (this.fileHash[i] == hash) { if (dst == null) { dst = new byte[this.fileUnpackedSize[i]]; } if (this.unpacked) { if (this.fileUnpackedSize[i] >= 0) { System.arraycopy(this.buffer, this.fileOffset[i], dst, 0, this.fileUnpackedSize[i]); } } else { BZip2.read( dst, this.fileUnpackedSize[i], this.buffer, this.filePackedSize[i], this.fileOffset[i]); } return dst; } } return null; }
@OriginalMember(owner = "client!kb", name = "a", descriptor = "(II)Lclient!kb;") public static Packet alloc(@OriginalArg(0) int type) { synchronized (cacheMid) { @Pc(7) Packet cached = null; if (type == 0 && cacheMinCount > 0) { cacheMinCount--; cached = (Packet) cacheMin.removeHead(); } else if (type == 1 && cacheMidCount > 0) { cacheMidCount--; cached = (Packet) cacheMid.removeHead(); } else if (type == 2 && cacheMaxCount > 0) { cacheMaxCount--; cached = (Packet) cacheMax.removeHead(); } if (cached != null) { cached.pos = 0; return cached; } } @Pc(77) Packet packet = new Packet(); packet.pos = 0; if (type == 0) { packet.data = new byte[100]; } else if (type == 1) { packet.data = new byte[5000]; } else { packet.data = new byte[30000]; } return packet; }
@OriginalMember(owner = "client!kb", name = "a", descriptor = "(B)V") public void release() { synchronized (cacheMid) { this.pos = 0; if (this.data.length == 100 && cacheMinCount < 1000) { cacheMin.addTail(this); cacheMinCount++; } else if (this.data.length == 5000 && cacheMidCount < 250) { cacheMid.addTail(this); cacheMidCount++; } else if (this.data.length == 30000 && cacheMaxCount < 50) { cacheMax.addTail(this); cacheMaxCount++; } } }
@OriginalMember(owner = "client!kb", name = "a", descriptor = "(BI)V") public void p1isaac(@OriginalArg(1) int opcode) { this.data[this.pos++] = (byte) (opcode + this.random.takeNextValue()); }
@OriginalMember(owner = "client!kb", name = "a", descriptor = "(I)V") public void p1(@OriginalArg(0) int value) { this.data[this.pos++] = (byte) value; }
@OriginalMember(owner = "client!kb", name = "b", descriptor = "(I)V") public void p2(@OriginalArg(0) int value) { this.data[this.pos++] = (byte) (value >> 8); this.data[this.pos++] = (byte) value; }
@OriginalMember(owner = "client!kb", name = "a", descriptor = "(ZI)V") public void ip2(@OriginalArg(1) int value) { this.data[this.pos++] = (byte) value; this.data[this.pos++] = (byte) (value >> 8); }
@OriginalMember(owner = "client!kb", name = "c", descriptor = "(I)V") public void p3(@OriginalArg(0) int value) { this.data[this.pos++] = (byte) (value >> 16); this.data[this.pos++] = (byte) (value >> 8); this.data[this.pos++] = (byte) value; }
@OriginalMember(owner = "client!kb", name = "d", descriptor = "(I)V") public void p4(@OriginalArg(0) int value) { this.data[this.pos++] = (byte) (value >> 24); this.data[this.pos++] = (byte) (value >> 16); this.data[this.pos++] = (byte) (value >> 8); this.data[this.pos++] = (byte) value; }
@OriginalMember(owner = "client!kb", name = "b", descriptor = "(ZI)V") public void ip4(@OriginalArg(1) int value) { this.data[this.pos++] = (byte) value; this.data[this.pos++] = (byte) (value >> 8); this.data[this.pos++] = (byte) (value >> 16); this.data[this.pos++] = (byte) (value >> 24); }
@OriginalMember(owner = "client!kb", name = "a", descriptor = "(ZJ)V") public void p8(@OriginalArg(1) long value) { this.data[this.pos++] = (byte) (value >> 56); this.data[this.pos++] = (byte) (value >> 48); this.data[this.pos++] = (byte) (value >> 40); this.data[this.pos++] = (byte) (value >> 32); this.data[this.pos++] = (byte) (value >> 24); this.data[this.pos++] = (byte) (value >> 16); this.data[this.pos++] = (byte) (value >> 8); this.data[this.pos++] = (byte) value; }
@OriginalMember(owner = "client!kb", name = "a", descriptor = "(Ljava/lang/String;)V") public void pjstr(@OriginalArg(0) String str) { str.getBytes(0, str.length(), this.data, this.pos); this.pos += str.length(); this.data[this.pos++] = 10; }
@OriginalMember(owner = "client!kb", name = "a", descriptor = "([BIIB)V") public void pdata( @OriginalArg(0) byte[] src, @OriginalArg(1) int length, @OriginalArg(2) int offset) { for (@Pc(7) int i = offset; i < offset + length; i++) { this.data[this.pos++] = src[i]; } }
@OriginalMember(owner = "client!kb", name = "b", descriptor = "(II)V") public void psize1(@OriginalArg(1) int size) { this.data[this.pos - size - 1] = (byte) size; }
@OriginalMember(owner = "client!kb", name = "c", descriptor = "()I") public int g1() { return this.data[this.pos++] & 0xFF; }
@OriginalMember(owner = "client!kb", name = "d", descriptor = "()B") public byte g1b() { return this.data[this.pos++]; }
@OriginalMember(owner = "client!kb", name = "e", descriptor = "()I") public int g2() { this.pos += 2; return ((this.data[this.pos - 2] & 0xFF) << 8) + (this.data[this.pos - 1] & 0xFF); }
@OriginalMember(owner = "client!kb", name = "f", descriptor = "()I") public int g2b() { this.pos += 2; @Pc(27) int value = ((this.data[this.pos - 2] & 0xFF) << 8) + (this.data[this.pos - 1] & 0xFF); if (value > 32767) { value -= 65536; } return value; }
@OriginalMember(owner = "client!kb", name = "g", descriptor = "()I") public int g3() { this.pos += 3; return ((this.data[this.pos - 3] & 0xFF) << 16) + ((this.data[this.pos - 2] & 0xFF) << 8) + (this.data[this.pos - 1] & 0xFF); }
@OriginalMember(owner = "client!kb", name = "h", descriptor = "()I") public int g4() { this.pos += 4; return ((this.data[this.pos - 4] & 0xFF) << 24) + ((this.data[this.pos - 3] & 0xFF) << 16) + ((this.data[this.pos - 2] & 0xFF) << 8) + (this.data[this.pos - 1] & 0xFF); }
@OriginalMember(owner = "client!kb", name = "e", descriptor = "(I)J") public long g8() { @Pc(5) long high = (long) this.g4() & 0xFFFFFFFFL; @Pc(15) long low = (long) this.g4() & 0xFFFFFFFFL; return (high << 32) + low; }
@OriginalMember(owner = "client!kb", name = "i", descriptor = "()Ljava/lang/String;") public String gjstr() { @Pc(2) int start = this.pos; while (this.data[this.pos++] != 10) {} return new String(this.data, start, this.pos - start - 1); }
@OriginalMember(owner = "client!kb", name = "b", descriptor = "(B)[B") public byte[] gstrbyte() { @Pc(2) int start = this.pos; while (this.data[this.pos++] != 10) {} @Pc(29) byte[] temp = new byte[this.pos - start - 1]; if (this.pos - 1 - start >= 0) System.arraycopy(this.data, start, temp, 0, this.pos - 1 - start); return temp; }
@OriginalMember(owner = "client!kb", name = "a", descriptor = "(III[B)V") public void gdata( @OriginalArg(0) int length, @OriginalArg(2) int offset, @OriginalArg(3) byte[] dest) { for (@Pc(6) int i = offset; i < offset + length; i++) { dest[i] = this.data[this.pos++]; } }
@OriginalMember(owner = "client!kb", name = "f", descriptor = "(I)V") public void accessBits() { this.bitPos = this.pos * 8; }
@OriginalMember(owner = "client!kb", name = "c", descriptor = "(II)I") public int gBit(@OriginalArg(1) int n) { @Pc(15) int bytePos = this.bitPos >> 3; @Pc(22) int remainingBits = 8 - (this.bitPos & 0x7); @Pc(24) int value = 0; this.bitPos += n; while (n > remainingBits) { value += (this.data[bytePos++] & BITMASK[remainingBits]) << n - remainingBits; n -= remainingBits; remainingBits = 8; } if (n == remainingBits) { value += this.data[bytePos] & BITMASK[remainingBits]; } else { value += this.data[bytePos] >> remainingBits - n & BITMASK[n]; } return value; }
@OriginalMember(owner = "client!kb", name = "g", descriptor = "(I)V") public void accessBytes() { this.pos = (this.bitPos + 7) / 8; }
@OriginalMember(owner = "client!kb", name = "j", descriptor = "()I") public int gsmart() { @Pc(7) int value = this.data[this.pos] & 0xFF; return value < 128 ? this.g1() - 64 : this.g2() - 49152; }
@OriginalMember(owner = "client!kb", name = "k", descriptor = "()I") public int gsmarts() { @Pc(7) int value = this.data[this.pos] & 0xFF; return value < 128 ? this.g1() : this.g2() - 32768; }
@OriginalMember( owner = "client!kb", name = "a", descriptor = "(Ljava/math/BigInteger;Ljava/math/BigInteger;I)V") public void rsaenc(@OriginalArg(0) BigInteger mod, @OriginalArg(1) BigInteger exp) { @Pc(2) int length = this.pos; this.pos = 0; @Pc(8) byte[] temp = new byte[length]; this.gdata(length, 0, temp); @Pc(19) BigInteger bigRaw = new BigInteger(temp); @Pc(24) BigInteger bigEnc = bigRaw.modPow(exp, mod); @Pc(27) byte[] rawEnc = bigEnc.toByteArray(); this.pos = 0; this.p1(rawEnc.length); this.pdata(rawEnc, rawEnc.length, 0); }
@OriginalMember(owner = "client!rb", name = "a", descriptor = "([BI[BII)I") public static int read( @OriginalArg(0) byte[] decompressed, @OriginalArg(1) int length, @OriginalArg(2) byte[] stream, @OriginalArg(3) int avail_in, @OriginalArg(4) int next_in) { synchronized (state) { state.stream = stream; state.next_in = next_in; state.decompressed = decompressed; state.next_out = 0; state.avail_in = avail_in; state.avail_out = length; state.bsLive = 0; state.bsBuff = 0; state.total_in_lo32 = 0; state.total_in_hi32 = 0; state.total_out_lo32 = 0; state.total_out_hi32 = 0; state.currBlockNo = 0; decompress(state); return length - state.avail_out; } }
@OriginalMember(owner = "client!rb", name = "e", descriptor = "(Lclient!sb;)V") private static void makeMaps(@OriginalArg(0) BZip2State s) { s.nInUse = 0; for (@Pc(4) int i = 0; i < 256; i++) { if (s.inUse[i]) { s.seqToUnseq[s.nInUse] = (byte) i; s.nInUse++; } } }
@OriginalMember(owner = "client!rb", name = "a", descriptor = "([I[I[I[BIII)V") private static void createDecodeTables( @OriginalArg(0) int[] limit, @OriginalArg(1) int[] base, @OriginalArg(2) int[] perm, @OriginalArg(3) byte[] length, @OriginalArg(4) int minLen, @OriginalArg(5) int maxLen, @OriginalArg(6) int alphaSize) { @Pc(3) int pp = 0; @Pc(5) int i; for (i = minLen; i <= maxLen; i++) { for (@Pc(9) int j = 0; j < alphaSize; j++) { if (length[j] == i) { perm[pp] = j; pp++; } } } for (i = 0; i < BZip2State.BZ_MAX_CODE_LEN; i++) { base[i] = 0; } for (i = 0; i < alphaSize; i++) { base[length[i] + 1]++; } for (i = 1; i < BZip2State.BZ_MAX_CODE_LEN; i++) { base[i] += base[i - 1]; } for (i = 0; i < BZip2State.BZ_MAX_CODE_LEN; i++) { limit[i] = 0; } @Pc(93) int vec = 0; for (i = minLen; i <= maxLen; i++) { vec += base[i + 1] - base[i]; limit[i] = vec - 1; vec <<= 1; } for (i = minLen + 1; i <= maxLen; i++) { base[i] = (limit[i - 1] + 1 << 1) - base[i]; } }
@OriginalMember(owner = "client!s", name = "a", descriptor = "(J)Lclient!db;") public DoublyLinkable get(@OriginalArg(0) long key) { @Pc(5) DoublyLinkable node = (DoublyLinkable) this.hashtable.get(key); if (node != null) { this.history.push(node); } return node; }
@OriginalMember(owner = "client!s", name = "a", descriptor = "(IJLclient!db;)V") public void put(@OriginalArg(1) long key, @OriginalArg(2) DoublyLinkable value) { if (this.available == 0) { @Pc(8) DoublyLinkable node = this.history.pop(); node.unlink(); node.uncache(); } else { this.available--; } this.hashtable.put(key, value); this.history.push(value); }
@OriginalMember(owner = "client!s", name = "a", descriptor = "()V") public void clear() { while (true) { @Pc(3) DoublyLinkable node = this.history.pop(); if (node == null) { this.available = this.capacity; return; } node.unlink(); node.uncache(); } }
@OriginalMember(owner = "client!t", name = "a", descriptor = "(J)Lclient!u;") public Linkable get(@OriginalArg(0) long key) { @Pc(11) Linkable sentinel = this.buckets[(int) (key & (long) (this.bucketCount - 1))]; for (@Pc(14) Linkable node = sentinel.next; node != sentinel; node = node.next) { if (node.key == key) { return node; } } return null; }
@OriginalMember(owner = "client!t", name = "a", descriptor = "(JILclient!u;)V") public void put(@OriginalArg(0) long key, @OriginalArg(2) Linkable value) { if (value.prev != null) { value.unlink(); } @Pc(18) Linkable sentinel = this.buckets[(int) (key & (long) (this.bucketCount - 1))]; value.prev = sentinel.prev; value.next = sentinel; value.prev.next = value; value.next.prev = value; value.key = key; }
@OriginalMember(owner = "client!pb", name = "a", descriptor = "(Lclient!db;)V") public void push(@OriginalArg(0) DoublyLinkable node) { if (node.prev2 != null) { node.uncache(); } node.prev2 = this.head.prev2; node.next2 = this.head; node.prev2.next2 = node; node.next2.prev2 = node; }
@OriginalMember(owner = "client!pb", name = "a", descriptor = "()Lclient!db;") public DoublyLinkable pop() { @Pc(3) DoublyLinkable node = this.head.next2; if (node == this.head) { return null; } else { node.uncache(); return node; } }
@OriginalMember(owner = "client!u", name = "a", descriptor = "()V") public final void unlink() { if (this.prev != null) { this.prev.next = this.next; this.next.prev = this.prev; this.next = null; this.prev = null; } }
@OriginalMember(owner = "client!ob", name = "a", descriptor = "(Lclient!u;)V") public void addTail(@OriginalArg(0) Linkable node) { if (node.prev != null) { node.unlink(); } node.prev = this.sentinel.prev; node.next = this.sentinel; node.prev.next = node; node.next.prev = node; }
@OriginalMember(owner = "client!ob", name = "a", descriptor = "(Lclient!u;I)V") public void addHead(@OriginalArg(0) Linkable node) { if (node.prev != null) { node.unlink(); } node.prev = this.sentinel; node.next = this.sentinel.next; node.prev.next = node; node.next.prev = node; }
@OriginalMember(owner = "client!ob", name = "a", descriptor = "()Lclient!u;") public Linkable removeHead() { @Pc(3) Linkable node = this.sentinel.next; if (node == this.sentinel) { return null; } node.unlink(); return node; }
@OriginalMember(owner = "client!ob", name = "b", descriptor = "()Lclient!u;") public Linkable head() { @Pc(3) Linkable node = this.sentinel.next; if (node == this.sentinel) { this.cursor = null; return null; } this.cursor = node.next; return node; }
@OriginalMember(owner = "client!ob", name = "a", descriptor = "(B)Lclient!u;") public Linkable tail() { @Pc(3) Linkable node = this.sentinel.prev; if (node == this.sentinel) { this.cursor = null; return null; } this.cursor = node.prev; return node; }
@OriginalMember(owner = "client!ob", name = "a", descriptor = "(I)Lclient!u;") public Linkable next() { @Pc(8) Linkable node = this.cursor; if (node == this.sentinel) { this.cursor = null; return null; } this.cursor = node.next; return node; }
@OriginalMember(owner = "client!ob", name = "a", descriptor = "(Z)Lclient!u;") public Linkable prev() { @Pc(2) Linkable node = this.cursor; if (node == this.sentinel) { this.cursor = null; return null; } this.cursor = node.prev; return node; }
@OriginalMember(owner = "client!ob", name = "c", descriptor = "()V") public void clear() { while (true) { @Pc(3) Linkable node = this.sentinel.next; if (node == this.sentinel) { return; } node.unlink(); } }
@OriginalMember(owner = "client!vb", name = "a", descriptor = "(Ljava/lang/String;)J") public static long toBase37(@OriginalArg(0) String str) { @Pc(3) long hash = 0L; for (@Pc(5) int i = 0; i < str.length() && i < 12; i++) { @Pc(11) char c = str.charAt(i); hash *= 37L; if (c >= 'A' && c <= 'Z') { hash += c + 1 - 65; } else if (c >= 'a' && c <= 'z') { hash += c + 1 - 97; } else if (c >= '0' && c <= '9') { hash += c + 27 - 48; } } while (hash % 37L == 0L && hash != 0L) { hash /= 37L; } return hash; }
@OriginalMember(owner = "client!vb", name = "a", descriptor = "(JZ)Ljava/lang/String;") public static String fromBase37(@OriginalArg(0) long username) { if (username <= 0L || username >= 6582952005840035281L) { return "invalid_name"; } if (username % 37L == 0L) { return "invalid_name"; } @Pc(19) int len = 0; while (username != 0L) { @Pc(27) long last = username; username /= 37L; builder[11 - len++] = BASE37_LOOKUP[(int) (last - username * 37L)]; } return new String(builder, 12 - len, len); }
@OriginalMember(owner = "client!vb", name = "a", descriptor = "(ILjava/lang/String;)J") public static long hashCode(@OriginalArg(1) String str) { @Pc(8) String upper = str.toUpperCase(); @Pc(10) long hash = 0L; for (@Pc(12) int i = 0; i < upper.length(); i++) { hash = hash * 61L + (long) upper.charAt(i) - 32L; hash = hash + (hash >> 56) & 0xFFFFFFFFFFFFFFL; } return hash; }
@OriginalMember(owner = "client!vb", name = "a", descriptor = "(II)Ljava/lang/String;") public static String formatIPv4(@OriginalArg(1) int ip) { return (ip >> 24 & 0xFF) + "." + (ip >> 16 & 0xFF) + "." + (ip >> 8 & 0xFF) + "." + (ip & 0xFF); }
@OriginalMember( owner = "client!vb", name = "b", descriptor = "(ILjava/lang/String;)Ljava/lang/String;") public static String formatName(@OriginalArg(1) String str) { if (str.length() == 0) { return str; } @Pc(11) char[] chars = str.toCharArray(); for (@Pc(13) int i = 0; i < chars.length; i++) { if (chars[i] == '_') { chars[i] = ' '; if (i + 1 < chars.length && chars[i + 1] >= 'a' && chars[i + 1] <= 'z') { chars[i + 1] = (char) (chars[i + 1] + 'A' - 97); } } } if (chars[0] >= 'a' && chars[0] <= 'z') { chars[0] = (char) (chars[0] + 'A' - 97); } return new String(chars); }
@OriginalMember( owner = "client!vb", name = "a", descriptor = "(Ljava/lang/String;I)Ljava/lang/String;") public static String toSentenceCase(@OriginalArg(0) String str) { @Pc(2) String lower = str.toLowerCase(); @Pc(9) char[] chars = lower.toCharArray(); @Pc(12) int length = chars.length; @Pc(14) boolean capitalize = true; for (@Pc(16) int i = 0; i < length; i++) { @Pc(22) char c = chars[i]; if (capitalize && c >= 'a' && c <= 'z') { chars[i] = (char) (chars[i] - 32); capitalize = false; } if (c == '.' || c == '!') { capitalize = true; } } return new String(chars); }
@OriginalMember( owner = "client!vb", name = "c", descriptor = "(ILjava/lang/String;)Ljava/lang/String;") public static String toAsterisks(@OriginalArg(1) String str) { @Pc(1) String temp = ""; for (@Pc(10) int i = 0; i < str.length(); i++) { temp = temp + "*"; } return temp; }
@OriginalMember(owner = "client!db", name = "b", descriptor = "()V") public final void uncache() { if (this.prev2 != null) { this.prev2.next2 = this.next2; this.next2.prev2 = this.prev2; this.next2 = null; this.prev2 = null; } }
@OriginalMember(owner = "client!b", name = "update", descriptor = "(Ljava/awt/Graphics;)V") @Override public void update(@OriginalArg(0) Graphics g) { this.shell.update(g); }
@OriginalMember(owner = "client!b", name = "paint", descriptor = "(Ljava/awt/Graphics;)V") @Override public void paint(@OriginalArg(0) Graphics g) { this.shell.paint(g); }
@OriginalMember(owner = "client!e", name = "b", descriptor = "(I)Lclient!kb;") public static synchronized Packet flush() { @Pc(1) Packet buffer = null; if (oldBuffer != null && enabled) { buffer = oldBuffer; } oldBuffer = null; return buffer; }
@OriginalMember(owner = "client!e", name = "c", descriptor = "(I)Lclient!kb;") public static synchronized Packet stop() { @Pc(9) Packet buffer = null; if (outBuffer != null && outBuffer.pos > 0 && enabled) { buffer = outBuffer; } setDisabled(); return buffer; }
@OriginalMember(owner = "client!e", name = "a", descriptor = "(II)V") private static synchronized void ensureCapacity(@OriginalArg(1) int n) { if (outBuffer.pos + n >= 500) { @Pc(15) Packet buffer = outBuffer; outBuffer = Packet.alloc(1); oldBuffer = buffer; } }
@OriginalMember(owner = "client!e", name = "a", descriptor = "(IIIB)V") public static synchronized void mousePressed( @OriginalArg(0) int x, @OriginalArg(2) int y, @OriginalArg(1) int button) { if (enabled && (x >= 0 && x < 789 && y >= 0 && y < 532)) { trackedCount++; @Pc(19) long now = System.currentTimeMillis(); @Pc(25) long delta = (now - lastTime) / 10L; if (delta > 250L) { delta = 250L; } lastTime = now; ensureCapacity(5); if (button == 1) { outBuffer.p1(1); } else { outBuffer.p1(2); } outBuffer.p1((int) delta); outBuffer.p3(x + (y << 10)); } }
@OriginalMember(owner = "client!e", name = "b", descriptor = "(II)V") public static synchronized void mouseReleased(@OriginalArg(0) int button) { if (enabled) { trackedCount++; @Pc(8) long now = System.currentTimeMillis(); @Pc(14) long delta = (now - lastTime) / 10L; if (delta > 250L) { delta = 250L; } lastTime = now; ensureCapacity(2); if (button == 1) { outBuffer.p1(3); } else { outBuffer.p1(4); } outBuffer.p1((int) delta); } }
@OriginalMember(owner = "client!e", name = "a", descriptor = "(IZI)V") public static synchronized void mouseMoved(@OriginalArg(2) int x, @OriginalArg(0) int y) { if (enabled && (x >= 0 && x < 789 && y >= 0 && y < 532)) { @Pc(17) long now = System.currentTimeMillis(); if (now - lastMoveTime >= 50L) { lastMoveTime = now; trackedCount++; @Pc(39) long delta = (now - lastTime) / 10L; if (delta > 250L) { delta = 250L; } lastTime = now; if (x - lastX < 8 && x - lastX >= -8 && y - lastY < 8 && y - lastY >= -8) { ensureCapacity(3); outBuffer.p1(5); outBuffer.p1((int) delta); outBuffer.p1(x + (y - lastY + 8 << 4) + 8 - lastX); } else if (x - lastX < 128 && x - lastX >= -128 && y - lastY < 128 && y - lastY >= -128) { ensureCapacity(4); outBuffer.p1(6); outBuffer.p1((int) delta); outBuffer.p1(x + 128 - lastX); outBuffer.p1(y + 128 - lastY); } else { ensureCapacity(5); outBuffer.p1(7); outBuffer.p1((int) delta); outBuffer.p3(x + (y << 10)); } lastX = x; lastY = y; } } }
@OriginalMember(owner = "client!e", name = "a", descriptor = "(IZ)V") public static synchronized void keyPressed(@OriginalArg(0) int key) { if (enabled) { trackedCount++; @Pc(8) long now = System.currentTimeMillis(); @Pc(14) long delta = (now - lastTime) / 10L; if (delta > 250L) { delta = 250L; } lastTime = now; if (key == 1000) { key = 11; } else if (key == 1001) { key = 12; } else if (key == 1002) { key = 14; } else if (key == 1003) { key = 15; } else if (key >= 1008) { key -= 992; } ensureCapacity(3); outBuffer.p1(8); outBuffer.p1((int) delta); outBuffer.p1(key); } }
@OriginalMember(owner = "client!e", name = "c", descriptor = "(II)V") public static synchronized void keyReleased(@OriginalArg(0) int key) { if (enabled) { trackedCount++; @Pc(8) long now = System.currentTimeMillis(); @Pc(14) long delta = (now - lastTime) / 10L; if (delta > 250L) { delta = 250L; } lastTime = now; if (key == 1000) { key = 11; } else if (key == 1001) { key = 12; } else if (key == 1002) { key = 14; } else if (key == 1003) { key = 15; } else if (key >= 1008) { key -= 992; } ensureCapacity(3); outBuffer.p1(9); outBuffer.p1((int) delta); outBuffer.p1(key); } }
@OriginalMember(owner = "client!e", name = "d", descriptor = "(I)V") public static synchronized void focusGained() { if (enabled) { trackedCount++; @Pc(11) long now = System.currentTimeMillis(); @Pc(17) long delta = (now - lastTime) / 10L; if (delta > 250L) { delta = 250L; } lastTime = now; ensureCapacity(2); outBuffer.p1(10); outBuffer.p1((int) delta); } }
@OriginalMember(owner = "client!e", name = "e", descriptor = "(I)V") public static synchronized void focusLost() { if (enabled) { trackedCount++; @Pc(8) long now = System.currentTimeMillis(); @Pc(14) long delta = (now - lastTime) / 10L; if (delta > 250L) { delta = 250L; } lastTime = now; ensureCapacity(2); outBuffer.p1(11); outBuffer.p1((int) delta); } }
@OriginalMember(owner = "client!e", name = "f", descriptor = "(I)V") public static synchronized void mouseEntered() { if (enabled) { trackedCount++; @Pc(8) long now = System.currentTimeMillis(); @Pc(14) long delta = (now - lastTime) / 10L; if (delta > 250L) { delta = 250L; } lastTime = now; ensureCapacity(2); outBuffer.p1(12); outBuffer.p1((int) delta); } }
@OriginalMember(owner = "client!e", name = "a", descriptor = "(Z)V") public static synchronized void mouseExited() { if (enabled) { trackedCount++; @Pc(11) long now = System.currentTimeMillis(); @Pc(17) long delta = (now - lastTime) / 10L; if (delta > 250L) { delta = 250L; } lastTime = now; ensureCapacity(2); outBuffer.p1(13); outBuffer.p1((int) delta); } }
@OriginalMember(owner = "client!a", name = "a", descriptor = "(III)V") protected final void initApplication(@OriginalArg(1) int width, @OriginalArg(0) int height) { this.screenWidth = width; this.screenHeight = height; this.frame = new ViewBox(this, this.screenWidth, this.screenHeight); this.graphics = this.getBaseComponent().getGraphics(); this.drawArea = new PixMap(this.getBaseComponent(), this.screenWidth, this.screenHeight); this.startThread(this, 1); }
@OriginalMember(owner = "client!a", name = "a", descriptor = "(IZI)V") protected final void initApplet(@OriginalArg(2) int width, @OriginalArg(0) int height) { this.screenWidth = width; this.screenHeight = height; this.graphics = this.getBaseComponent().getGraphics(); this.drawArea = new PixMap(this.getBaseComponent(), this.screenWidth, this.screenHeight); this.startThread(this, 1); }
@OriginalMember(owner = "client!a", name = "a", descriptor = "(I)V") private void shutdown() { this.state = -2; this.unload(); if (this.frame != null) { try { System.exit(0); } catch ( @Pc(25) Throwable ignored) { } } }
@OriginalMember(owner = "client!a", name = "start", descriptor = "()V") @Override public final void start() { if (this.state >= 0) { this.state = 0; } }
@OriginalMember(owner = "client!a", name = "stop", descriptor = "()V") @Override public final void stop() { if (this.state >= 0) { this.state = 4000 / this.deltime; } }
@OriginalMember(owner = "client!a", name = "destroy", descriptor = "()V") @Override public final void destroy() { this.state = -1; try { Thread.sleep(1000L); } catch ( @Pc(6) Exception ignored) { } if (this.state == -1) { this.shutdown(); } }
@OriginalMember(owner = "client!a", name = "update", descriptor = "(Ljava/awt/Graphics;)V") @Override public final void update(@OriginalArg(0) Graphics g) { if (this.graphics == null) { this.graphics = g; } this.refresh = true; this.refresh(); }
@OriginalMember(owner = "client!a", name = "paint", descriptor = "(Ljava/awt/Graphics;)V") @Override public final void paint(@OriginalArg(0) Graphics g) { if (this.graphics == null) { this.graphics = g; } this.refresh = true; this.refresh(); }
@OriginalMember( owner = "client!a", name = "mouseReleased", descriptor = "(Ljava/awt/event/MouseEvent;)V") public final void mouseReleased(@OriginalArg(0) MouseEvent e) { this.idleCycles = 0; this.mouseButton = 0; try { if (InputTracking.enabled) { InputTracking.mouseReleased( (e.getModifiersEx() & MouseEvent.BUTTON3_DOWN_MASK) != 0 ? 1 : 0); } } catch (NoSuchMethodError ex) { if (InputTracking.enabled) { InputTracking.mouseReleased(e.isMetaDown() ? 1 : 0); } } }
@OriginalMember( owner = "client!a", name = "mouseClicked", descriptor = "(Ljava/awt/event/MouseEvent;)V") public final void mouseClicked(@OriginalArg(0) MouseEvent e) {}
@OriginalMember( owner = "client!a", name = "mouseEntered", descriptor = "(Ljava/awt/event/MouseEvent;)V") public final void mouseEntered(@OriginalArg(0) MouseEvent e) { if (InputTracking.enabled) { InputTracking.mouseEntered(); } }
@OriginalMember( owner = "client!a", name = "mouseExited", descriptor = "(Ljava/awt/event/MouseEvent;)V") public final void mouseExited(@OriginalArg(0) MouseEvent e) { this.idleCycles = 0; this.mouseX = -1; this.mouseY = -1; if (InputTracking.enabled) { InputTracking.mouseExited(); } }
@OriginalMember( owner = "client!a", name = "mouseDragged", descriptor = "(Ljava/awt/event/MouseEvent;)V") public final void mouseDragged(@OriginalArg(0) MouseEvent e) { @Pc(2) int x = e.getX(); @Pc(5) int y = e.getY(); if (this.frame != null) { x -= this.frame.insets.left; y -= this.frame.insets.top; } this.idleCycles = 0; this.mouseX = x; this.mouseY = y; if (InputTracking.enabled) { InputTracking.mouseMoved(x, y); } }
@OriginalMember( owner = "client!a", name = "mouseMoved", descriptor = "(Ljava/awt/event/MouseEvent;)V") public final void mouseMoved(@OriginalArg(0) MouseEvent e) { @Pc(2) int x = e.getX(); @Pc(5) int y = e.getY(); if (this.frame != null) { x -= this.frame.insets.left; y -= this.frame.insets.top; } this.idleCycles = 0; this.mouseX = x; this.mouseY = y; if (InputTracking.enabled) { InputTracking.mouseMoved(x, y); } }
@OriginalMember( owner = "client!a", name = "keyReleased", descriptor = "(Ljava/awt/event/KeyEvent;)V") public final void keyReleased(@OriginalArg(0) KeyEvent e) { this.idleCycles = 0; @Pc(5) int code = e.getKeyCode(); @Pc(8) int ch = e.getKeyChar(); if (ch < 30) { ch = 0; } if (code == 37) { ch = 1; } else if (code == 39) { ch = 2; } else if (code == 38) { ch = 3; } else if (code == 40) { ch = 4; } else if (code == 17) { ch = 5; } else if (code == 16) { ch = 6; } else if (code == 18) { ch = 7; } else if (code == 8) { ch = 8; } else if (code == 127) { ch = 8; } else if (code == 9) { ch = 9; } else if (code == 10) { ch = 10; } else if (code >= 112 && code <= 123) { ch = code + 1008 - 112; } else if (code == 36) { ch = 1000; } else if (code == 35) { ch = 1001; } else if (code == 33) { ch = 1002; } else if (code == 34) { ch = 1003; } if (ch > 0 && ch < 128) { this.actionKey[ch] = 0; } if (InputTracking.enabled) { InputTracking.keyReleased(ch); } }
@OriginalMember( owner = "client!a", name = "keyTyped", descriptor = "(Ljava/awt/event/KeyEvent;)V") public final void keyTyped(@OriginalArg(0) KeyEvent e) {}
@OriginalMember( owner = "client!a", name = "focusGained", descriptor = "(Ljava/awt/event/FocusEvent;)V") public final void focusGained(@OriginalArg(0) FocusEvent e) { this.hasFocus = true; this.refresh = true; this.refresh(); if (InputTracking.enabled) { InputTracking.focusGained(); } }
@OriginalMember( owner = "client!a", name = "focusLost", descriptor = "(Ljava/awt/event/FocusEvent;)V") public final void focusLost(@OriginalArg(0) FocusEvent e) { this.hasFocus = false; if (InputTracking.enabled) { InputTracking.focusLost(); } }
@OriginalMember(owner = "client!a", name = "a", descriptor = "(Z)I") protected final int pollKey() { @Pc(1) int key = -1; if (this.keyQueueWritePos != this.keyQueueReadPos) { key = this.keyQueue[this.keyQueueReadPos]; this.keyQueueReadPos = this.keyQueueReadPos + 1 & 0x7F; } return key; }
@OriginalMember( owner = "client!a", name = "windowActivated", descriptor = "(Ljava/awt/event/WindowEvent;)V") public final void windowActivated(@OriginalArg(0) WindowEvent e) {}
@OriginalMember( owner = "client!a", name = "windowClosed", descriptor = "(Ljava/awt/event/WindowEvent;)V") public final void windowClosed(@OriginalArg(0) WindowEvent e) {}
@OriginalMember( owner = "client!a", name = "windowClosing", descriptor = "(Ljava/awt/event/WindowEvent;)V") public final void windowClosing(@OriginalArg(0) WindowEvent e) { this.destroy(); }
@OriginalMember( owner = "client!a", name = "windowDeactivated", descriptor = "(Ljava/awt/event/WindowEvent;)V") public final void windowDeactivated(@OriginalArg(0) WindowEvent e) {}
@OriginalMember( owner = "client!a", name = "windowDeiconified", descriptor = "(Ljava/awt/event/WindowEvent;)V") public final void windowDeiconified(@OriginalArg(0) WindowEvent e) {}
@OriginalMember( owner = "client!a", name = "windowIconified", descriptor = "(Ljava/awt/event/WindowEvent;)V") public final void windowIconified(@OriginalArg(0) WindowEvent e) {}
@OriginalMember( owner = "client!a", name = "windowOpened", descriptor = "(Ljava/awt/event/WindowEvent;)V") public final void windowOpened(@OriginalArg(0) WindowEvent e) {}
@OriginalMember(owner = "client!a", name = "a", descriptor = "()V") protected void load() {}
@OriginalMember(owner = "client!a", name = "b", descriptor = "(I)V") protected void update() {}
@OriginalMember(owner = "client!a", name = "a", descriptor = "(B)V") protected void unload() {}
@OriginalMember(owner = "client!a", name = "b", descriptor = "(Z)V") protected void draw() {}
@OriginalMember(owner = "client!a", name = "c", descriptor = "(I)V") protected void refresh() {}
@OriginalMember(owner = "client!a", name = "a", descriptor = "(Ljava/lang/Runnable;I)V") public void startThread(@OriginalArg(0) Runnable runnable, @OriginalArg(1) int priority) { @Pc(4) Thread thread = new Thread(runnable); thread.start(); thread.setPriority(priority); }
@OriginalMember(owner = "client!c", name = "a", descriptor = "(II)I") public static int perlinNoise(@OriginalArg(0) int x, @OriginalArg(1) int z) { @Pc(32) int value = interpolatedNoise(x + 45365, z + 91923, 4) + (interpolatedNoise(x + 10294, z + 37821, 2) - 128 >> 1) + (interpolatedNoise(x, z, 1) - 128 >> 2) - 128; value = (int) ((double) value * 0.3D) + 35; if (value < 10) { value = 10; } else if (value > 60) { value = 60; } return value; }
@OriginalMember(owner = "client!c", name = "a", descriptor = "(III)I") private static int interpolatedNoise( @OriginalArg(0) int x, @OriginalArg(1) int z, @OriginalArg(2) int scale) { @Pc(3) int intX = x / scale; @Pc(9) int fracX = x & scale - 1; @Pc(13) int intZ = z / scale; @Pc(19) int fracZ = z & scale - 1; @Pc(23) int v1 = smoothNoise(intX, intZ); @Pc(29) int v2 = smoothNoise(intX + 1, intZ); @Pc(35) int v3 = smoothNoise(intX, intZ + 1); @Pc(43) int v4 = smoothNoise(intX + 1, intZ + 1); @Pc(49) int i1 = interpolate(v1, v2, fracX, scale); @Pc(55) int i2 = interpolate(v3, v4, fracX, scale); return interpolate(i1, i2, fracZ, scale); }
@OriginalMember(owner = "client!c", name = "a", descriptor = "(IIII)I") private static int interpolate( @OriginalArg(0) int a, @OriginalArg(1) int b, @OriginalArg(2) int x, @OriginalArg(3) int scale) { @Pc(11) int f = 65536 - Pix3D.cosTable[x * 1024 / scale] >> 1; return (a * (65536 - f) >> 16) + (b * f >> 16); }
@OriginalMember(owner = "client!c", name = "b", descriptor = "(II)I") private static int smoothNoise(@OriginalArg(0) int x, @OriginalArg(1) int y) { @Pc(31) int corners = noise(x - 1, y - 1) + noise(x + 1, y - 1) + noise(x - 1, y + 1) + noise(x + 1, y + 1); @Pc(55) int sides = noise(x - 1, y) + noise(x + 1, y) + noise(x, y - 1) + noise(x, y + 1); @Pc(59) int center = noise(x, y); return corners / 16 + sides / 8 + center / 4; }
@OriginalMember(owner = "client!c", name = "c", descriptor = "(II)I") private static int noise(@OriginalArg(0) int x, @OriginalArg(1) int y) { @Pc(5) int n = x + y * 57; @Pc(11) int n1 = n << 13 ^ n; @Pc(25) int n2 = n1 * (n1 * n1 * 15731 + 789221) + 1376312589 & Integer.MAX_VALUE; return n2 >> 19 & 0xFF; }
@OriginalMember(owner = "client!c", name = "d", descriptor = "(II)I") public static int mulHSL(@OriginalArg(0) int hsl, @OriginalArg(1) int lightness) { if (hsl == -1) { return 12345678; } lightness = lightness * (hsl & 0x7F) / 128; if (lightness < 2) { lightness = 2; } else if (lightness > 126) { lightness = 126; } return (hsl & 0xFF80) + lightness; }
@OriginalMember(owner = "client!c", name = "a", descriptor = "(IIIII)V") public void clearLandscape( @OriginalArg(1) int startX, @OriginalArg(0) int startZ, @OriginalArg(4) int endX, @OriginalArg(3) int endZ) { @Pc(3) byte waterOverlay = 0; for (@Pc(11) int i = 0; i < FloType.count; i++) { if (FloType.instances[i].name.equalsIgnoreCase("water")) { waterOverlay = (byte) (i + 1); break; } } for (@Pc(33) int z = startX; z < startX + endX; z++) { for (@Pc(37) int x = startZ; x < startZ + endZ; x++) { if (x < 0 || x >= this.maxTileX || z < 0 || z >= this.maxTileZ) { continue; } this.levelTileOverlayIds[0][x][z] = waterOverlay; for (@Pc(62) int level = 0; level < 4; level++) { this.levelHeightmap[level][x][z] = 0; this.levelTileFlags[level][x][z] = 0; } } } }
@OriginalMember(owner = "client!c", name = "a", descriptor = "(IBII)I") private int getDrawLevel( @OriginalArg(0) int level, @OriginalArg(2) int stx, @OriginalArg(3) int stz) { if ((this.levelTileFlags[level][stx][stz] & 0x8) == 0) { return level <= 0 || (this.levelTileFlags[1][stx][stz] & 0x2) == 0 ? level : level - 1; } else { return 0; } }
@OriginalMember(owner = "client!c", name = "e", descriptor = "(II)I") private int adjustLightness(@OriginalArg(0) int hsl, @OriginalArg(1) int scalar) { if (hsl == -2) { return 12345678; } if (hsl == -1) { if (scalar < 0) { scalar = 0; } else if (scalar > 127) { scalar = 127; } return 127 - scalar; } else { scalar = scalar * (hsl & 0x7F) / 128; if (scalar < 2) { scalar = 2; } else if (scalar > 126) { scalar = 126; } return (hsl & 0xFF80) + scalar; } }
@OriginalMember(owner = "client!c", name = "b", descriptor = "(III)I") private int hsl24to16( @OriginalArg(0) int hue, @OriginalArg(1) int saturation, @OriginalArg(2) int lightness) { if (lightness > 179) { saturation /= 2; } if (lightness > 192) { saturation /= 2; } if (lightness > 217) { saturation /= 2; } if (lightness > 243) { saturation /= 2; } return (hue / 4 << 10) + (saturation / 32 << 7) + lightness / 2; }
@OriginalMember(owner = "client!ec", name = "a", descriptor = "(B)V") public void reset() { for (@Pc(3) int x = 0; x < this.sizeX; x++) { for (@Pc(7) int z = 0; z < this.sizeZ; z++) { if (x == 0 || z == 0 || x == this.sizeX - 1 || z == this.sizeZ - 1) { this.flags[x][z] = 0xFFFFFF; } else { this.flags[x][z] = 0; } } } }
@OriginalMember(owner = "client!ec", name = "a", descriptor = "(IIIIIIZ)V") public void addLoc( @OriginalArg(3) int tileX, @OriginalArg(5) int tileZ, @OriginalArg(2) int sizeX, @OriginalArg(1) int sizeZ, @OriginalArg(0) int rotation, @OriginalArg(6) boolean blockrange) { @Pc(3) int flags = 0x100; if (blockrange) { flags += 0x20000; } @Pc(14) int x = tileX - this.offsetX; @Pc(19) int z = tileZ - this.offsetZ; if (rotation == 1 || rotation == 3) { int tmp = sizeX; sizeX = sizeZ; sizeZ = tmp; } for (int tx = x; tx < x + sizeX; tx++) { if (tx < 0 || tx >= this.sizeX) { continue; } for (int tz = z; tz < z + sizeZ; tz++) { if (tz < 0 || tz >= this.sizeZ) { continue; } this.addCMap(tx, tz, flags); } } }
@OriginalMember(owner = "client!ec", name = "a", descriptor = "(III)V") private void addCMap(@OriginalArg(0) int x, @OriginalArg(1) int z, @OriginalArg(2) int flags) { this.flags[x][z] |= flags; }
@OriginalMember(owner = "client!ec", name = "a", descriptor = "(IIIIZZI)V") public void delLoc( @OriginalArg(1) int tileX, @OriginalArg(0) int tileZ, @OriginalArg(3) int sizeX, @OriginalArg(6) int sizeZ, @OriginalArg(2) int rotation, @OriginalArg(5) boolean blockrange) { @Pc(3) int flags = 0x100; if (blockrange) { flags += 0x20000; } @Pc(14) int x = tileX - this.offsetX; @Pc(19) int z = tileZ - this.offsetZ; if (rotation == 1 || rotation == 3) { int tmp = sizeX; sizeX = sizeZ; sizeZ = tmp; } for (int tx = x; tx < x + sizeX; tx++) { if (tx < 0 || tx >= this.sizeX) { continue; } for (@Pc(48) int tz = z; tz < z + sizeZ; tz++) { if (tz < 0 || tz >= this.sizeZ) { continue; } this.remCMap(tx, tz, flags); } } }
@OriginalMember(owner = "client!ec", name = "a", descriptor = "(IBII)V") private void remCMap(@OriginalArg(2) int x, @OriginalArg(0) int z, @OriginalArg(3) int flags) { this.flags[x][z] &= 0xFFFFFF - flags; }
@OriginalMember(owner = "client!ec", name = "b", descriptor = "(III)V") public void removeBlocked(@OriginalArg(1) int tileX, @OriginalArg(0) int tileZ) { @Pc(7) int x = tileX - this.offsetX; @Pc(12) int z = tileZ - this.offsetZ; this.flags[x][z] &= 0xDFFFFF; }
@OriginalMember(owner = "client!ec", name = "a", descriptor = "(IIIIIIII)Z") public boolean testLoc( @OriginalArg(2) int srcX, @OriginalArg(0) int srcZ, @OriginalArg(3) int dstX, @OriginalArg(5) int dstZ, @OriginalArg(6) int dstSizeX, @OriginalArg(1) int dstSizeZ, @OriginalArg(4) int forceapproach) { @Pc(5) int maxX = dstX + dstSizeX - 1; @Pc(11) int maxZ = dstZ + dstSizeZ - 1; if (srcX >= dstX && srcX <= maxX && srcZ >= dstZ && srcZ <= maxZ) { return true; } else if (srcX == dstX - 1 && srcZ >= dstZ && srcZ <= maxZ && (this.flags[srcX - this.offsetX][srcZ - this.offsetZ] & 0x8) == 0 && (forceapproach & 0x8) == 0) { return true; } else if (srcX == maxX + 1 && srcZ >= dstZ && srcZ <= maxZ && (this.flags[srcX - this.offsetX][srcZ - this.offsetZ] & 0x80) == 0 && (forceapproach & 0x2) == 0) { return true; } else if (srcZ == dstZ - 1 && srcX >= dstX && srcX <= maxX && (this.flags[srcX - this.offsetX][srcZ - this.offsetZ] & 0x2) == 0 && (forceapproach & 0x4) == 0) { return true; } else if (srcZ == maxZ + 1 && srcX >= dstX && srcX <= maxX && (this.flags[srcX - this.offsetX][srcZ - this.offsetZ] & 0x20) == 0 && (forceapproach & 0x1) == 0) { return true; } return false; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(Z)V") public static void unload() { locBuffer = null; levelOccluderCount = null; levelOccluders = null; drawTileQueue = null; visibilityMatrix = null; visibilityMap = null; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(IIIIIIIII)V") public static void addOccluder( @OriginalArg(6) int level, @OriginalArg(4) int type, @OriginalArg(1) int minX, @OriginalArg(7) int minY, @OriginalArg(8) int minZ, @OriginalArg(5) int maxX, @OriginalArg(3) int maxY, @OriginalArg(0) int maxZ) { @Pc(3) Occlude occluder = new Occlude(); occluder.minTileX = minX / 128; occluder.maxTileX = maxX / 128; occluder.minTileZ = minZ / 128; occluder.maxTileZ = maxZ / 128; occluder.type = type; occluder.minX = minX; occluder.maxX = maxX; occluder.minZ = minZ; occluder.maxZ = maxZ; occluder.minY = minY; occluder.maxY = maxY; levelOccluders[level][levelOccluderCount[level]++] = occluder; }
@OriginalMember(owner = "client!r", name = "h", descriptor = "(IIII)Z") private static boolean testPoint( @OriginalArg(0) int x, @OriginalArg(1) int z, @OriginalArg(2) int y) { @Pc(11) int px = z * sinEyeYaw + x * cosEyeYaw >> 16; @Pc(21) int tmp = z * cosEyeYaw - x * sinEyeYaw >> 16; @Pc(31) int pz = y * sinEyePitch + tmp * cosEyePitch >> 16; @Pc(41) int py = y * cosEyePitch - tmp * sinEyePitch >> 16; if (pz < 50 || pz > 3500) { return false; } @Pc(45) int viewportX = viewportCenterX + (px << 9) / pz; @Pc(76) int viewportY = viewportCenterY + (py << 9) / pz; return viewportX >= viewportLeft && viewportX <= viewportRight && viewportY >= viewportTop && viewportY <= viewportBottom; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(I)V") public void reset() { for (@Pc(3) int level = 0; level < this.maxLevel; level++) { for (int x = 0; x < this.maxTileX; x++) { for (int z = 0; z < this.maxTileZ; z++) { this.levelTiles[level][x][z] = null; } } } for (int l = 0; l < LEVEL_COUNT; l++) { for (int o = 0; o < levelOccluderCount[l]; o++) { levelOccluders[l][o] = null; } levelOccluderCount[l] = 0; } for (int i = 0; i < this.temporaryLocCount; i++) { this.temporaryLocs[i] = null; } this.temporaryLocCount = 0; for (@Pc(88) int i = 0; i < locBuffer.length; i++) { locBuffer[i] = null; } }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(IIII)V") public void setDrawLevel( @OriginalArg(0) int level, @OriginalArg(1) int stx, @OriginalArg(2) int stz, @OriginalArg(3) int drawLevel) { @Pc(8) Ground tile = this.levelTiles[level][stx][stz]; if (tile == null) { return; } this.levelTiles[level][stx][stz].drawLevel = drawLevel; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(Lclient!eb;BIIIIBI)V") public void addGroundDecoration( @OriginalArg(0) Model model, @OriginalArg(5) int tileLevel, @OriginalArg(2) int tileX, @OriginalArg(4) int tileZ, @OriginalArg(7) int y, @OriginalArg(3) int bitset, @OriginalArg(6) byte info) { @Pc(3) GroundDecor decor = new GroundDecor(); decor.model = model; decor.x = tileX * 128 + 64; decor.z = tileZ * 128 + 64; decor.y = y; decor.bitset = bitset; decor.info = info; if (this.levelTiles[tileLevel][tileX][tileZ] == null) { this.levelTiles[tileLevel][tileX][tileZ] = new Ground(tileLevel, tileX, tileZ); } this.levelTiles[tileLevel][tileX][tileZ].groundDecor = decor; }
@OriginalMember( owner = "client!r", name = "a", descriptor = "(Lclient!eb;Lclient!eb;IIIIILclient!eb;I)V") public void addObjStack( @OriginalArg(6) int stx, @OriginalArg(5) int stz, @OriginalArg(2) int y, @OriginalArg(3) int level, @OriginalArg(4) int bitset, @OriginalArg(0) Model topObj, @OriginalArg(7) Model middleObj, @OriginalArg(1) Model bottomObj) { @Pc(3) GroundObject stack = new GroundObject(); stack.topObj = topObj; stack.x = stx * 128 + 64; stack.z = stz * 128 + 64; stack.y = y; stack.bitset = bitset; stack.bottomObj = bottomObj; stack.middleObj = middleObj; @Pc(38) int stackOffset = 0; @Pc(47) Ground tile = this.levelTiles[level][stx][stz]; if (tile != null) { for (@Pc(51) int l = 0; l < tile.locCount; l++) { @Pc(60) int height = tile.locs[l].model.objRaise; if (height > stackOffset) { stackOffset = height; } } } stack.offset = stackOffset; if (this.levelTiles[level][stx][stz] == null) { this.levelTiles[level][stx][stz] = new Ground(level, stx, stz); } this.levelTiles[level][stx][stz].groundObj = stack; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(IIIIILclient!eb;Lclient!eb;IIIB)V") public void addWall( @OriginalArg(2) int level, @OriginalArg(7) int tileX, @OriginalArg(9) int tileZ, @OriginalArg(1) int y, @OriginalArg(3) int typeA, @OriginalArg(0) int typeB, @OriginalArg(5) Model modelA, @OriginalArg(6) Model modelB, @OriginalArg(8) int bitset, @OriginalArg(10) byte info) { if (modelA == null && modelB == null) { return; } @Pc(8) Wall wall = new Wall(); wall.bitset = bitset; wall.info = info; wall.x = tileX * 128 + 64; wall.z = tileZ * 128 + 64; wall.y = y; wall.modelA = modelA; wall.modelB = modelB; wall.typeA = typeA; wall.typeB = typeB; for (@Pc(54) int l = level; l >= 0; l--) { if (this.levelTiles[l][tileX][tileZ] == null) { this.levelTiles[l][tileX][tileZ] = new Ground(l, tileX, tileZ); } } this.levelTiles[level][tileX][tileZ].wall = wall; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(IIIIIIIIILclient!eb;BI)V") public void setWallDecoration( @OriginalArg(11) int level, @OriginalArg(8) int tileX, @OriginalArg(1) int tileZ, @OriginalArg(0) int y, @OriginalArg(7) int offsetX, @OriginalArg(2) int offsetZ, @OriginalArg(3) int bitset, @OriginalArg(9) Model model, @OriginalArg(10) byte info, @OriginalArg(4) int angle, @OriginalArg(5) int type) { if (model == null) { return; } @Pc(10) Decor decor = new Decor(); decor.bitset = bitset; decor.info = info; decor.x = tileX * 128 + offsetX + 64; decor.z = tileZ * 128 + offsetZ + 64; decor.y = y; decor.model = model; decor.type = type; decor.angle = angle; for (@Pc(48) int l = level; l >= 0; l--) { if (this.levelTiles[l][tileX][tileZ] == null) { this.levelTiles[l][tileX][tileZ] = new Ground(l, tileX, tileZ); } } this.levelTiles[level][tileX][tileZ].decor = decor; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(IIILclient!w;IIIIBLclient!eb;II)Z") public boolean addLoc( @OriginalArg(2) int level, @OriginalArg(6) int tileX, @OriginalArg(5) int tileZ, @OriginalArg(0) int y, @OriginalArg(9) Model model, @OriginalArg(3) Entity entity, @OriginalArg(4) int bitset, @OriginalArg(8) byte info, @OriginalArg(7) int width, @OriginalArg(11) int length, @OriginalArg(10) int yaw) { if (model == null && entity == null) { return true; } else { @Pc(17) int sceneX = tileX * 128 + width * 64; @Pc(25) int sceneZ = tileZ * 128 + length * 64; return this.addLoc( sceneX, sceneZ, y, level, tileX, tileZ, width, length, model, entity, bitset, info, yaw, false); } }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(IIIIIIZLclient!eb;Lclient!w;II)Z") public boolean addTemporary( @OriginalArg(10) int level, @OriginalArg(4) int x, @OriginalArg(9) int y, @OriginalArg(1) int z, @OriginalArg(7) Model model, @OriginalArg(8) Entity entity, @OriginalArg(5) int bitset, @OriginalArg(3) int yaw, @OriginalArg(2) int padding, @OriginalArg(6) boolean forwardPadding) { if (model == null && entity == null) { return true; } @Pc(9) int x0 = x - padding; @Pc(13) int z0 = z - padding; @Pc(17) int x1 = x + padding; @Pc(21) int z1 = z + padding; if (forwardPadding) { if (yaw > 640 && yaw < 1408) { z1 += 128; } if (yaw > 1152 && yaw < 1920) { x1 += 128; } if (yaw > 1664 || yaw < 384) { z0 -= 128; } if (yaw > 128 && yaw < 896) { x0 -= 128; } } x0 /= 128; z0 /= 128; x1 /= 128; z1 /= 128; return this.addLoc( x, z, y, level, x0, z0, x1 + 1 - x0, z1 - z0 + 1, model, entity, bitset, (byte) 0, yaw, true); }
@OriginalMember( owner = "client!r", name = "a", descriptor = "(IILclient!eb;IIIIIILclient!w;ZIII)Z") public boolean addTemporary( @OriginalArg(11) int level, @OriginalArg(13) int x, @OriginalArg(4) int y, @OriginalArg(3) int z, @OriginalArg(8) int minTileX, @OriginalArg(7) int minTileZ, @OriginalArg(0) int maxTileX, @OriginalArg(12) int maxTileZ, @OriginalArg(2) Model model, @OriginalArg(9) Entity entity, @OriginalArg(5) int bitset, @OriginalArg(6) int yaw) { return model == null && entity == null || this.addLoc( x, z, y, level, minTileX, minTileZ, maxTileX + 1 - minTileX, maxTileZ - minTileZ + 1, model, entity, bitset, (byte) 0, yaw, true); }
@OriginalMember(owner = "client!r", name = "b", descriptor = "(I)V") public void clearTemporaryLocs() { for (@Pc(1) int i = 0; i < this.temporaryLocCount; i++) { @Pc(8) Location loc = this.temporaryLocs[i]; this.removeLoc(loc); this.temporaryLocs[i] = null; } this.temporaryLocCount = 0; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(Lclient!p;B)V") private void removeLoc(@OriginalArg(0) Location loc) { for (@Pc(4) int tx = loc.minSceneTileX; tx <= loc.maxSceneTileX; tx++) { for (@Pc(9) int tz = loc.minSceneTileZ; tz <= loc.maxSceneTileZ; tz++) { @Pc(21) Ground tile = this.levelTiles[loc.level][tx][tz]; if (tile == null) { continue; } for (@Pc(25) int i = 0; i < tile.locCount; i++) { if (tile.locs[i] == loc) { tile.locCount--; for (int j = i; j < tile.locCount; j++) { tile.locs[j] = tile.locs[j + 1]; tile.locSpan[j] = tile.locSpan[j + 1]; } tile.locs[tile.locCount] = null; break; } } tile.locSpans = 0; for (int i = 0; i < tile.locCount; i++) { tile.locSpans |= tile.locSpan[i]; } } } }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(ILclient!eb;III)V") public void setLocModel( @OriginalArg(3) int level, @OriginalArg(0) int x, @OriginalArg(4) int z, @OriginalArg(1) Model model) { if (model == null) { return; } @Pc(13) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return; } for (int i = 0; i < tile.locCount; i++) { @Pc(38) Location loc = tile.locs[i]; if ((loc.bitset >> 29 & 0x3) == 2) { loc.model = model; return; } } }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(IIIIB)V") public void setWallDecorationOffset( @OriginalArg(0) int level, @OriginalArg(2) int x, @OriginalArg(1) int z, @OriginalArg(3) int offset) { @Pc(8) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return; } @Pc(24) Decor decor = tile.decor; if (decor == null) { return; } @Pc(33) int sx = x * 128 + 64; @Pc(39) int sz = z * 128 + 64; decor.x = sx + (decor.x - sx) * offset / 16; decor.z = sz + (decor.z - sz) * offset / 16; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(IIILclient!eb;I)V") public void setWallDecorationModel( @OriginalArg(4) int level, @OriginalArg(2) int x, @OriginalArg(1) int z, @OriginalArg(3) Model model) { if (model == null) { return; } @Pc(15) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return; } @Pc(21) Decor decor = tile.decor; if (decor == null) { return; } decor.model = model; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(Lclient!eb;IIII)V") public void setGroundDecorationModel( @OriginalArg(4) int level, @OriginalArg(3) int x, @OriginalArg(1) int z, @OriginalArg(0) Model model) { if (model == null) { return; } @Pc(15) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return; } @Pc(21) GroundDecor decor = tile.groundDecor; if (decor == null) { return; } decor.model = model; }
@OriginalMember(owner = "client!r", name = "b", descriptor = "(ILclient!eb;III)V") public void setWallModel( @OriginalArg(4) int level, @OriginalArg(3) int x, @OriginalArg(2) int z, @OriginalArg(1) Model model) { if (model == null) { return; } @Pc(21) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return; } @Pc(27) Wall wall = tile.wall; if (wall == null) { return; } wall.modelA = model; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(Lclient!eb;Lclient!eb;IZII)V") public void setWallModels( @OriginalArg(4) int x, @OriginalArg(2) int z, @OriginalArg(5) int level, @OriginalArg(0) Model modelA, @OriginalArg(1) Model modelB) { if (modelA == null) { return; } @Pc(11) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return; } @Pc(17) Wall wall = tile.wall; if (wall == null) { return; } wall.modelA = modelA; wall.modelB = modelB; }
@OriginalMember(owner = "client!r", name = "b", descriptor = "(IIII)V") public void removeWall( @OriginalArg(1) int level, @OriginalArg(0) int x, @OriginalArg(2) int z, @OriginalArg(3) int force) { @Pc(8) Ground tile = this.levelTiles[level][x][z]; if (force == 1 && tile != null) { tile.wall = null; } }
@OriginalMember(owner = "client!r", name = "c", descriptor = "(IIII)V") public void removeWallDecoration( @OriginalArg(0) int level, @OriginalArg(3) int x, @OriginalArg(1) int z) { @Pc(8) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return; } tile.decor = null; }
@OriginalMember(owner = "client!r", name = "d", descriptor = "(IIII)V") public void removeLoc(@OriginalArg(3) int level, @OriginalArg(0) int x, @OriginalArg(1) int z) { @Pc(10) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return; } for (@Pc(15) int l = 0; l < tile.locCount; l++) { @Pc(22) Location loc = tile.locs[l]; if ((loc.bitset >> 29 & 0x3) == 2 && loc.minSceneTileX == x && loc.minSceneTileZ == z) { this.removeLoc(loc); return; } } }
@OriginalMember(owner = "client!r", name = "e", descriptor = "(IIII)V") public void removeGroundDecoration( @OriginalArg(0) int level, @OriginalArg(2) int x, @OriginalArg(3) int z) { @Pc(16) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return; } tile.groundDecor = null; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(III)V") public void removeObjStack( @OriginalArg(0) int level, @OriginalArg(1) int x, @OriginalArg(2) int z) { @Pc(8) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return; } tile.groundObj = null; }
@OriginalMember(owner = "client!r", name = "b", descriptor = "(III)I") public int getWallBitset( @OriginalArg(0) int level, @OriginalArg(1) int x, @OriginalArg(2) int z) { @Pc(8) Ground tile = this.levelTiles[level][x][z]; return tile == null || tile.wall == null ? 0 : tile.wall.bitset; }
@OriginalMember(owner = "client!r", name = "f", descriptor = "(IIII)I") public int getWallDecorationBitset( @OriginalArg(0) int level, @OriginalArg(1) int z, @OriginalArg(3) int x) { @Pc(19) Ground tile = this.levelTiles[level][x][z]; return tile == null || tile.decor == null ? 0 : tile.decor.bitset; }
@OriginalMember(owner = "client!r", name = "d", descriptor = "(III)I") public int getGroundDecorationBitset( @OriginalArg(0) int level, @OriginalArg(1) int x, @OriginalArg(2) int z) { @Pc(8) Ground tile = this.levelTiles[level][x][z]; return tile == null || tile.groundDecor == null ? 0 : tile.groundDecor.bitset; }
@OriginalMember(owner = "client!r", name = "g", descriptor = "(IIII)I") public int getInfo( @OriginalArg(0) int level, @OriginalArg(1) int x, @OriginalArg(2) int z, @OriginalArg(3) int bitset) { @Pc(8) Ground tile = this.levelTiles[level][x][z]; if (tile == null) { return -1; } else if (tile.wall != null && tile.wall.bitset == bitset) { return tile.wall.info & 0xFF; } else if (tile.decor != null && tile.decor.bitset == bitset) { return tile.decor.info & 0xFF; } else if (tile.groundDecor != null && tile.groundDecor.bitset == bitset) { return tile.groundDecor.info & 0xFF; } else { for (@Pc(56) int i = 0; i < tile.locCount; i++) { if (tile.locs[i].bitset == bitset) { return tile.locs[i].info & 0xFF; } } return -1; } }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(BIILclient!eb;I)V") private void mergeGroundDecorationNormals( @OriginalArg(1) int level, @OriginalArg(4) int tileX, @OriginalArg(2) int tileZ, @OriginalArg(3) Model model) { @Pc(19) Ground tile; if (tileX < this.maxTileX) { tile = this.levelTiles[level][tileX + 1][tileZ]; if (tile != null && tile.groundDecor != null && tile.groundDecor.model.vertexNormal != null) { this.mergeNormals(model, tile.groundDecor.model, 128, 0, 0, true); } } if (tileZ < this.maxTileX) { tile = this.levelTiles[level][tileX][tileZ + 1]; if (tile != null && tile.groundDecor != null && tile.groundDecor.model.vertexNormal != null) { this.mergeNormals(model, tile.groundDecor.model, 0, 0, 128, true); } } if (tileX < this.maxTileX && tileZ < this.maxTileZ) { tile = this.levelTiles[level][tileX + 1][tileZ + 1]; if (tile != null && tile.groundDecor != null && tile.groundDecor.model.vertexNormal != null) { this.mergeNormals(model, tile.groundDecor.model, 128, 0, 128, true); } } if (tileX < this.maxTileX && tileZ > 0) { tile = this.levelTiles[level][tileX + 1][tileZ - 1]; if (tile != null && tile.groundDecor != null && tile.groundDecor.model.vertexNormal != null) { this.mergeNormals(model, tile.groundDecor.model, 128, 0, -128, true); } } }
@OriginalMember(owner = "client!r", name = "e", descriptor = "(III)V") public void click(@OriginalArg(2) int mouseX, @OriginalArg(1) int mouseY) { takingInput = true; World3D.mouseX = mouseX; World3D.mouseY = mouseY; clickTileX = -1; clickTileZ = -1; }
@OriginalMember(owner = "client!r", name = "f", descriptor = "(III)I") private int mulLightness(@OriginalArg(1) int hsl, @OriginalArg(0) int lightness) { @Pc(3) int invLightness = 127 - lightness; lightness = invLightness * (hsl & 0x7F) / 160; if (lightness < 2) { lightness = 2; } else if (lightness > 126) { lightness = 126; } return (hsl & 0xFF80) + lightness; }
@OriginalMember(owner = "client!r", name = "a", descriptor = "(IIIIIIII)Z") private boolean pointInsideTriangle( @OriginalArg(0) int x, @OriginalArg(1) int y, @OriginalArg(2) int y0, @OriginalArg(3) int y1, @OriginalArg(4) int y2, @OriginalArg(5) int x0, @OriginalArg(6) int x1, @OriginalArg(7) int x2) { if (y < y0 && y < y1 && y < y2) { return false; } else if (y > y0 && y > y1 && y > y2) { return false; } else if (x < x0 && x < x1 && x < x2) { return false; } else if (x > x0 && x > x1 && x > x2) { return false; } else { @Pc(59) int crossProduct_01 = (y - y0) * (x1 - x0) - (x - x0) * (y1 - y0); @Pc(75) int crossProduct_20 = (y - y2) * (x0 - x2) - (x - x2) * (y0 - y2); @Pc(91) int crossProduct_12 = (y - y1) * (x2 - x1) - (x - x1) * (y2 - y1); return crossProduct_01 * crossProduct_12 > 0 && crossProduct_12 * crossProduct_20 > 0; } }
@OriginalMember(owner = "client!r", name = "g", descriptor = "(III)Z") private boolean tileVisible( @OriginalArg(0) int level, @OriginalArg(1) int x, @OriginalArg(2) int z) { @Pc(8) int cycle = this.levelTileOcclusionCycles[level][x][z]; if (cycle == -World3D.cycle) { return false; } else if (cycle == World3D.cycle) { return true; } else { @Pc(23) int sx = x << 7; @Pc(27) int sz = z << 7; if (this.occluded(sx + 1, this.levelHeightmaps[level][x][z], sz + 1) && this.occluded(sx + 128 - 1, this.levelHeightmaps[level][x + 1][z], sz + 1) && this.occluded(sx + 128 - 1, this.levelHeightmaps[level][x + 1][z + 1], sz + 128 - 1) && this.occluded(sx + 1, this.levelHeightmaps[level][x][z + 1], sz + 128 - 1)) { this.levelTileOcclusionCycles[level][x][z] = World3D.cycle; return true; } else { this.levelTileOcclusionCycles[level][x][z] = -World3D.cycle; return false; } } }
@OriginalMember(owner = "client!r", name = "j", descriptor = "(IIII)Z") private boolean visible( @OriginalArg(0) int level, @OriginalArg(1) int tileX, @OriginalArg(2) int tileZ, @OriginalArg(3) int y) { if (this.tileVisible(level, tileX, tileZ)) { @Pc(11) int x = tileX << 7; @Pc(15) int z = tileZ << 7; return this.occluded(x + 1, this.levelHeightmaps[level][tileX][tileZ] - y, z + 1) && this.occluded(x + 128 - 1, this.levelHeightmaps[level][tileX + 1][tileZ] - y, z + 1) && this.occluded( x + 128 - 1, this.levelHeightmaps[level][tileX + 1][tileZ + 1] - y, z + 128 - 1) && this.occluded(x + 1, this.levelHeightmaps[level][tileX][tileZ + 1] - y, z + 128 - 1); } else { return false; } }
@OriginalMember(owner = "client!x", name = "a", descriptor = "(ZZII)V") public final void teleport( @OriginalArg(1) boolean jump, @OriginalArg(2) int x, @OriginalArg(3) int z) { if (this.primarySeqId != -1 && SeqType.instances[this.primarySeqId].priority <= 1) { this.primarySeqId = -1; } if (!jump) { @Pc(22) int dx = x - this.pathTileX[0]; @Pc(29) int dz = z - this.pathTileZ[0]; if (dx >= -8 && dx <= 8 && dz >= -8 && dz <= 8) { if (this.pathLength < 9) { this.pathLength++; } for (@Pc(54) int i = this.pathLength; i > 0; i--) { this.pathTileX[i] = this.pathTileX[i - 1]; this.pathTileZ[i] = this.pathTileZ[i - 1]; this.pathRunning[i] = this.pathRunning[i - 1]; } this.pathTileX[0] = x; this.pathTileZ[0] = z; this.pathRunning[0] = false; return; } } this.pathLength = 0; this.seqTrigger = 0; this.pathTileX[0] = x; this.pathTileZ[0] = z; this.x = this.pathTileX[0] * 128 + this.size * 64; this.z = this.pathTileZ[0] * 128 + this.size * 64; }
@OriginalMember(owner = "client!x", name = "a", descriptor = "(ZIB)V") public final void moveAlongRoute(@OriginalArg(0) boolean running, @OriginalArg(1) int direction) { @Pc(6) int nextX = this.pathTileX[0]; @Pc(11) int nextZ = this.pathTileZ[0]; if (direction == 0) { nextX--; nextZ++; } else if (direction == 1) { nextZ++; } else if (direction == 2) { nextX++; nextZ++; } else if (direction == 3) { nextX--; } else if (direction == 4) { nextX++; } else if (direction == 5) { nextX--; nextZ--; } else if (direction == 6) { nextZ--; } else if (direction == 7) { nextX++; nextZ--; } if (this.primarySeqId != -1 && SeqType.instances[this.primarySeqId].priority <= 1) { this.primarySeqId = -1; } if (this.pathLength < 9) { this.pathLength++; } for (@Pc(83) int i = this.pathLength; i > 0; i--) { this.pathTileX[i] = this.pathTileX[i - 1]; this.pathTileZ[i] = this.pathTileZ[i - 1]; this.pathRunning[i] = this.pathRunning[i - 1]; } this.pathTileX[0] = nextX; this.pathTileZ[0] = nextZ; this.pathRunning[0] = running; }
@OriginalMember(owner = "client!x", name = "b", descriptor = "(Z)Z") public boolean isVisible() { return false; }
@OriginalMember(owner = "client!z", name = "b", descriptor = "(Z)Z") @Override public boolean isVisible() { return this.visible; }
@OriginalMember(owner = "client!ab", name = "a", descriptor = "(IIIII)V") public void updateVelocity( @OriginalArg(2) int dstX, @OriginalArg(0) int dstY, @OriginalArg(1) int dstZ, @OriginalArg(4) int cycle) { if (!this.mobile) { @Pc(8) double dx = dstX - this.srcX; @Pc(14) double dz = dstZ - this.srcZ; @Pc(23) double d = Math.sqrt(dx * dx + dz * dz); this.x = (double) this.srcX + dx * (double) this.arc / d; this.z = (double) this.srcZ + dz * (double) this.arc / d; this.y = this.srcY; } double dt = this.lastCycle + 1 - cycle; this.velocityX = ((double) dstX - this.x) / dt; this.velocityZ = ((double) dstZ - this.z) / dt; this.velocity = Math.sqrt(this.velocityX * this.velocityX + this.velocityZ * this.velocityZ); if (!this.mobile) { this.velocityY = -this.velocity * Math.tan((double) this.peakPitch * 0.02454369D); } this.accelerationY = ((double) dstY - this.y - this.velocityY * dt) * 2.0D / (dt * dt); }
@OriginalMember(owner = "client!ab", name = "a", descriptor = "(BI)V") public void update(@OriginalArg(1) int delta) { this.mobile = true; this.x += this.velocityX * (double) delta; this.z += this.velocityZ * (double) delta; this.y += this.velocityY * (double) delta + this.accelerationY * 0.5D * (double) delta * (double) delta; this.velocityY += this.accelerationY * (double) delta; this.yaw = (int) (Math.atan2(this.velocityX, this.velocityZ) * 325.949D) + 1024 & 0x7FF; this.pitch = (int) (Math.atan2(this.velocityY, this.velocity) * 325.949D) & 0x7FF; if (this.spotanim.seq != null) { this.seqCycle += delta; while (this.seqCycle > this.spotanim.seq.delay[this.seqFrame]) { this.seqCycle -= this.spotanim.seq.delay[this.seqFrame] + 1; this.seqFrame++; if (this.seqFrame >= this.spotanim.seq.frameCount) { this.seqFrame = 0; } } } }
@OriginalMember(owner = "client!ab", name = "a", descriptor = "(Z)Lclient!eb;") @Override public Model draw(int loopCycle) { @Pc(3) Model tmp = this.spotanim.getModel(); @Pc(19) Model model = new Model(tmp, true, !this.spotanim.animHasAlpha, false); if (this.spotanim.seq != null) { model.createLabelReferences(); model.applyTransform(this.spotanim.seq.frames[this.seqFrame]); model.labelFaces = null; model.labelVertices = null; } if (this.spotanim.resizeh != 128 || this.spotanim.resizev != 128) { model.scale(this.spotanim.resizeh, this.spotanim.resizev, this.spotanim.resizeh); } model.rotateX(this.pitch); model.calculateNormals( 64 + this.spotanim.ambient, 850 + this.spotanim.contrast, -30, -50, -30, true); return model; }
@OriginalMember(owner = "client!w", name = "a", descriptor = "(Z)Lclient!eb;") public Model draw(int loopCycle) { return null; }
@OriginalMember(owner = "client!bb", name = "a", descriptor = "(II)V") public void update(@OriginalArg(0) int delta) { for (this.seqCycle += delta; this.seqCycle > this.type.seq.delay[this.seqFrame]; ) { this.seqCycle -= this.type.seq.delay[this.seqFrame] + 1; this.seqFrame++; if (this.seqFrame >= this.type.seq.frameCount) { this.seqFrame = 0; this.seqComplete = true; } } }
@OriginalMember(owner = "client!bb", name = "a", descriptor = "(Z)Lclient!eb;") @Override public Model draw(int loopCycle) { @Pc(3) Model tmp = this.type.getModel(); @Pc(19) Model model = new Model(tmp, true, !this.type.animHasAlpha, false); if (!this.seqComplete) { model.createLabelReferences(); model.applyTransform(this.type.seq.frames[this.seqFrame]); model.labelFaces = null; model.labelVertices = null; } if (this.type.resizeh != 128 || this.type.resizev != 128) { model.scale(this.type.resizeh, this.type.resizev, this.type.resizeh); } if (this.type.orientation != 0) { if (this.type.orientation == 90) { model.rotateY90(); } else if (this.type.orientation == 180) { model.rotateY90(); model.rotateY90(); } else if (this.type.orientation == 270) { model.rotateY90(); model.rotateY90(); model.rotateY90(); } } model.calculateNormals(64 + this.type.ambient, 850 + this.type.contrast, -30, -50, -30, true); return model; }
@OriginalMember(owner = "client!y", name = "a", descriptor = "(Z)Lclient!eb;") @Override public Model draw(int loopCycle) { if (this.type == null) { return null; } if (super.spotanimId == -1 || super.spotanimFrame == -1) { return this.getSequencedModel(); } @Pc(20) Model model = this.getSequencedModel(); @Pc(25) SpotAnimType spotanim = SpotAnimType.instances[super.spotanimId]; @Pc(41) Model model1 = new Model(spotanim.getModel(), true, !spotanim.animHasAlpha, false); model1.translate(-super.spotanimOffset, 0, 0); model1.createLabelReferences(); model1.applyTransform(spotanim.seq.frames[super.spotanimFrame]); model1.labelFaces = null; model1.labelVertices = null; if (spotanim.resizeh != 128 || spotanim.resizev != 128) { model1.scale(spotanim.resizeh, spotanim.resizev, spotanim.resizeh); } model1.calculateNormals(64 + spotanim.ambient, 850 + spotanim.contrast, -30, -50, -30, true); @Pc(115) Model[] models = new Model[] {model, model1}; @Pc(123) Model tmp = new Model(models, 2, true); if (this.type.size == 1) { tmp.pickable = true; } return tmp; }
@OriginalMember(owner = "client!y", name = "b", descriptor = "(Z)Z") @Override public boolean isVisible() { return this.type != null; }
@OriginalMember(owner = "client!ib", name = "a", descriptor = "(Z)V") public void shrink() { this.cropW /= 2; this.cropH /= 2; @Pc(20) byte[] pixels = new byte[this.cropW * this.cropH]; @Pc(22) int off = 0; for (@Pc(24) int y = 0; y < this.height; y++) { for (@Pc(28) int x = 0; x < this.width; x++) { pixels[(x + this.cropX >> 1) + (y + this.cropY >> 1) * this.cropW] = this.pixels[off++]; } } this.pixels = pixels; this.width = this.cropW; this.height = this.cropH; this.cropX = 0; this.cropY = 0; }
@OriginalMember(owner = "client!ib", name = "c", descriptor = "(I)V") public void crop() { if (this.width == this.cropW && this.height == this.cropH) { return; } @Pc(19) byte[] pixels = new byte[this.cropW * this.cropH]; @Pc(21) int off = 0; for (@Pc(33) int y = 0; y < this.height; y++) { for (@Pc(37) int x = 0; x < this.width; x++) { pixels[x + this.cropX + (y + this.cropY) * this.cropW] = this.pixels[off++]; } } this.pixels = pixels; this.width = this.cropW; this.height = this.cropH; this.cropX = 0; this.cropY = 0; }
@OriginalMember(owner = "client!ib", name = "d", descriptor = "(I)V") public void flipHorizontally() { @Pc(8) byte[] pixels = new byte[this.width * this.height]; @Pc(10) int off = 0; for (@Pc(12) int y = 0; y < this.height; y++) { for (@Pc(19) int x = this.width - 1; x >= 0; x--) { pixels[off++] = this.pixels[x + y * this.width]; } } this.pixels = pixels; this.cropX = this.cropW - this.width - this.cropX; }
@OriginalMember(owner = "client!ib", name = "a", descriptor = "(B)V") public void flipVertically() { @Pc(8) byte[] pixels = new byte[this.width * this.height]; @Pc(13) int off = 0; for (@Pc(25) int y = this.height - 1; y >= 0; y--) { for (@Pc(29) int x = 0; x < this.width; x++) { pixels[off++] = this.pixels[x + y * this.width]; } } this.pixels = pixels; this.cropY = this.cropH - this.height - this.cropY; }
@OriginalMember(owner = "client!ib", name = "a", descriptor = "(IIIZ)V") public void translate(@OriginalArg(0) int r, @OriginalArg(1) int g, @OriginalArg(2) int b) { for (@Pc(3) int i = 0; i < this.palette.length; i++) { @Pc(14) int red = this.palette[i] >> 16 & 0xFF; red += r; if (red < 0) { red = 0; } else if (red > 255) { red = 255; } @Pc(38) int green = this.palette[i] >> 8 & 0xFF; green += g; if (green < 0) { green = 0; } else if (green > 255) { green = 255; } @Pc(60) int blue = this.palette[i] & 0xFF; blue += b; if (blue < 0) { blue = 0; } else if (blue > 255) { blue = 255; } this.palette[i] = (red << 16) + (green << 8) + blue; } }
@OriginalMember(owner = "client!ib", name = "a", descriptor = "(IIZ)V") public void draw(@OriginalArg(1) int x, @OriginalArg(0) int y) { x += this.cropX; y += this.cropY; @Pc(15) int dstOff = x + y * Pix2D.width2d; @Pc(17) int srcOff = 0; @Pc(20) int h = this.height; @Pc(23) int w = this.width; @Pc(27) int dstStep = Pix2D.width2d - w; @Pc(29) int srcStep = 0; if (y < Pix2D.boundTop) { int cutoff = Pix2D.boundTop - y; h -= cutoff; y = Pix2D.boundTop; srcOff += cutoff * w; dstOff += cutoff * Pix2D.width2d; } if (y + h > Pix2D.boundBottom) { h -= y + h - Pix2D.boundBottom; } if (x < Pix2D.boundLeft) { int cutoff = Pix2D.boundLeft - x; w -= cutoff; x = Pix2D.boundLeft; srcOff += cutoff; dstOff += cutoff; srcStep += cutoff; dstStep += cutoff; } if (x + w > Pix2D.boundRight) { int cutoff = x + w - Pix2D.boundRight; w -= cutoff; srcStep += cutoff; dstStep += cutoff; } if (w > 0 && h > 0) { this.copyPixels( w, h, this.pixels, srcOff, srcStep, Pix2D.data, dstOff, dstStep, this.palette); } }
@OriginalMember(owner = "mapview!i", name = "a", descriptor = "([I[B[IIIIIIIIII)V") private void plot_scale( @OriginalArg(0) int[] arg0, @OriginalArg(1) byte[] arg1, @OriginalArg(2) int[] arg2, @OriginalArg(3) int arg3, @OriginalArg(4) int arg4, @OriginalArg(5) int arg5, @OriginalArg(6) int arg6, @OriginalArg(7) int arg7, @OriginalArg(8) int arg8, @OriginalArg(9) int arg9, @OriginalArg(10) int arg10, @OriginalArg(11) int arg11) { try { @Pc(3) int local3 = arg3; for (@Pc(6) int local6 = -arg8; local6 < 0; local6++) { @Pc(14) int local14 = (arg4 >> 16) * arg11; for (@Pc(17) int local17 = -arg7; local17 < 0; local17++) { @Pc(27) byte local27 = arg1[(arg3 >> 16) + local14]; if (local27 == 0) { arg5++; } else { arg0[arg5++] = arg2[local27 & 0xFF]; } arg3 += arg9; } arg4 += arg10; arg3 = local3; arg5 += arg6; } } catch ( @Pc(63) Exception local63) { System.out.println("error in plot_scale"); } }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "(B)V") public void bind() { Pix2D.bind(this.width, this.height, this.pixels); }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "(IIIZ)V") public void translate(@OriginalArg(0) int r, @OriginalArg(1) int g, @OriginalArg(2) int b) { for (@Pc(3) int i = 0; i < this.pixels.length; i++) { @Pc(10) int rgb = this.pixels[i]; if (rgb != 0) { @Pc(18) int red = rgb >> 16 & 0xFF; red += r; if (red < 1) { red = 1; } else if (red > 255) { red = 255; } @Pc(40) int green = rgb >> 8 & 0xFF; green += g; if (green < 1) { green = 1; } else if (green > 255) { green = 255; } @Pc(60) int blue = rgb & 0xFF; blue += b; if (blue < 1) { blue = 1; } else if (blue > 255) { blue = 255; } this.pixels[i] = (red << 16) + (green << 8) + blue; } } }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "(III)V") public void blitOpaque(@OriginalArg(1) int x, @OriginalArg(2) int y) { x += this.cropX; y += this.cropY; @Pc(15) int dstOff = x + y * Pix2D.width2d; @Pc(17) int srcOff = 0; @Pc(20) int h = this.height; @Pc(23) int w = this.width; @Pc(27) int dstStep = Pix2D.width2d - w; @Pc(29) int srcStep = 0; if (y < Pix2D.boundTop) { int cutoff = Pix2D.boundTop - y; h -= cutoff; y = Pix2D.boundTop; srcOff += cutoff * w; dstOff += cutoff * Pix2D.width2d; } if (y + h > Pix2D.boundBottom) { h -= y + h - Pix2D.boundBottom; } if (x < Pix2D.boundLeft) { int cutoff = Pix2D.boundLeft - x; w -= cutoff; x = Pix2D.boundLeft; srcOff += cutoff; dstOff += cutoff; srcStep += cutoff; dstStep += cutoff; } if (x + w > Pix2D.boundRight) { int cutoff = x + w - Pix2D.boundRight; w -= cutoff; srcStep += cutoff; dstStep += cutoff; } if (w > 0 && h > 0) { this.copyPixels(w, h, this.pixels, srcOff, srcStep, Pix2D.data, dstOff, dstStep); } }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "(I[IIIIIII[I)V") private void copyPixels( @OriginalArg(7) int w, @OriginalArg(3) int h, @OriginalArg(1) int[] src, @OriginalArg(4) int srcOff, @OriginalArg(5) int srcStep, @OriginalArg(8) int[] dst, @OriginalArg(6) int dstOff, @OriginalArg(2) int dstStep) { @Pc(6) int qw = -(w >> 2); w = -(w & 0x3); for (@Pc(14) int y = -h; y < 0; y++) { for (@Pc(18) int x = qw; x < 0; x++) { dst[dstOff++] = src[srcOff++]; dst[dstOff++] = src[srcOff++]; dst[dstOff++] = src[srcOff++]; dst[dstOff++] = src[srcOff++]; } for (@Pc(57) int x = w; x < 0; x++) { dst[dstOff++] = src[srcOff++]; } dstOff += dstStep; srcOff += srcStep; } }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "(IIZ)V") public void draw(@OriginalArg(1) int x, @OriginalArg(0) int y) { x += this.cropX; y += this.cropY; @Pc(20) int dstOff = x + y * Pix2D.width2d; @Pc(22) int srcOff = 0; @Pc(25) int h = this.height; @Pc(28) int w = this.width; @Pc(32) int dstStep = Pix2D.width2d - w; @Pc(34) int srcStep = 0; if (y < Pix2D.boundTop) { int cutoff = Pix2D.boundTop - y; h -= cutoff; y = Pix2D.boundTop; srcOff += cutoff * w; dstOff += cutoff * Pix2D.width2d; } if (y + h > Pix2D.boundBottom) { h -= y + h - Pix2D.boundBottom; } if (x < Pix2D.boundLeft) { int cutoff = Pix2D.boundLeft - x; w -= cutoff; x = Pix2D.boundLeft; srcOff += cutoff; dstOff += cutoff; srcStep += cutoff; dstStep += cutoff; } if (x + w > Pix2D.boundRight) { int cutoff = x + w - Pix2D.boundRight; w -= cutoff; srcStep += cutoff; dstStep += cutoff; } if (w > 0 && h > 0) { this.copyPixels(Pix2D.data, this.pixels, srcOff, dstOff, w, h, dstStep, srcStep); } }
@Test public void useAppContext() throws Exception { Context appContext = InstrumentationRegistry.getTargetContext(); assertEquals("me.sadraa.detoxiom", appContext.getPackageName()); }
@Test public void addition_isCorrect() throws Exception { assertEquals(4, 2 + 2); }
@Override public void onCreate() { super.onCreate(); appComponent = DaggerMyAppComponent.builder() .sharedPrefrencesModule(new SharedPrefrencesModule(getApplicationContext())) .build(); CalligraphyConfig.initDefault(appComponent.getCalligraphyConfig()); }
@MyAppComponentScope @Provides CalligraphyConfig calligraphyConfig() { return new CalligraphyConfig.Builder() .setDefaultFontPath("fonts/Vazir-Medium.ttf") .setFontAttrId(R.attr.fontPath) .build(); }
@ArchiveFragmentComponentScope @Provides RVAdapter rvAdapter() { return new RVAdapter(); }
@ArchiveFragmentComponentScope @Provides RecyclerView.LayoutManager layoutManager() { return new LinearLayoutManager(context); }
@ArchiveFragmentComponentScope @Provides DividerItemDecoration dividerItemDecoration() { return new DividerItemDecoration(context, DividerItemDecoration.VERTICAL); }
@Provides ArchiveContract.Presenter presenter(ArchivePresenterImpl presenter) { return presenter; }
@Provides ArchiveContract.Interactor interactor(ArchiveIntractorImpl intractor) { return intractor; }
@Provides public SharedPreferencesProvider sharedprefrenceProvider() { return new SharedPreferencesProvider(); }
@Provides public Random gerRandon() { return new Random(); }
@MyAppComponentScope @Provides public QuoteClient quoteClient(Retrofit retrofit) { return retrofit.create(QuoteClient.class); }
@MyAppComponentScope @Provides public Retrofit retrofit(OkHttpClient httpClient, GsonConverterFactory gsonConverterFactory) { return new Retrofit.Builder() .baseUrl(ClientConfig.BASE_URL) .client(httpClient) .addConverterFactory(gsonConverterFactory) .build(); }
@MyAppComponentScope @Provides public OkHttpClient okHttpClient() { return new OkHttpClient(); }
@MyAppComponentScope @Provides public GsonConverterFactory gsonConverterFactory() { return GsonConverterFactory.create(); }
@Provides CompositeDisposable compositeDisposable() { return new CompositeDisposable(); }
@Provides public SharedPreferences sharedPreferences() { return context.getSharedPreferences("prefName", 0); }
@Provides public Context mContext() { return context; }
void setupRecycler(List<App> apps) { recyclerView.setLayoutManager(new GridLayoutManager(this, 3)); ListViewCostumeAdapter listViewCostumeAdapter = new ListViewCostumeAdapter(this, apps); recyclerView.setAdapter(listViewCostumeAdapter); recyclerView.setClickable(true); final DetoxiomWidget detoxiomWidget = new DetoxiomWidget(); listViewCostumeAdapter.setClickListener( (appModel, position) -> { AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context); savePref(context, mAppWidgetId, appModel.getPackageName()); detoxiomWidget.updateAppWidget(context, appWidgetManager, mAppWidgetId); Intent resultValue = new Intent(); resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId); setResult(RESULT_OK, resultValue); finish(); }); }
public void savePref(Context context, int appWidgetId, String packageName) { SharedPreferences.Editor prefs = context.getSharedPreferences(PREFS_NAME, 0).edit(); prefs.putString(PREF_PREFIX_KEY + appWidgetId, packageName); prefs.apply(); }
@Deprecated public static String loadPref(Context context, int appWidgetId) { SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, 0); return prefs.getString(PREF_PREFIX_KEY + appWidgetId, context.getPackageName()); }
public static void deleteTitlePref(Context context, int appWidgetId) { SharedPreferences.Editor prefs = context.getSharedPreferences(PREFS_NAME, 0).edit(); prefs.remove(PREF_PREFIX_KEY + appWidgetId); prefs.apply(); }
@Override protected void onDestroy() { super.onDestroy(); appsDisposable.dispose(); }
@Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { for (int appWidgetId : appWidgetIds) {} }
@Override public void onDeleted(Context context, int[] appWidgetIds) { for (int appWidgetId : appWidgetIds) { DetoxiomWidgetConfigureActivity.deleteTitlePref(context, appWidgetId); } }
@Override public void onReceive(Context context, Intent intent) { super.onReceive(context, intent); }
public PackageInfo getPackageInfo(String packageName) throws PackageManager.NameNotFoundException { return mContext.getPackageManager().getPackageInfo(packageName, 0); }
public boolean isSystemApp() { return (mInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0; }
public void loadLabel(Context context) { if (mAppLabel == null || !mMounted) { if (!mApkFile.exists()) { mMounted = false; mAppLabel = mInfo.packageName; } else { mMounted = true; CharSequence label = mInfo.loadLabel(context.getPackageManager()); mAppLabel = label != null ? label.toString() : mInfo.packageName; } } }
public Uri getAppUriIcon(String packageName) throws PackageManager.NameNotFoundException { return getUriFromResourceId( packageName, packageManager.getApplicationInfo(packageName, 0).icon); }
@Override public int compare(App object1, App object2) { return sCollator.compare(object1.getLabel(), object2.getLabel()); }
@Override public ListViewCostumeAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = mInflater.inflate(R.layout.row_item, parent, false); return new ViewHolder(view); }
@Override public void onResourceReady( GlideDrawable resource, GlideAnimation<? super GlideDrawable> animation) { super.onResourceReady(resource, animation); }
@Override public void onLoadFailed(Exception e, Drawable errorDrawable) { super.onLoadFailed(e, errorDrawable); Drawable icon = app.getAppInfo().loadIcon(context.getPackageManager()); Glide.with(context).load("").placeholder(icon).into(holder.imgAppIcon); }
@Override public void onClick(View view) { if (mClickListener != null) mClickListener.onClick(mData.get(getAdapterPosition()), getAdapterPosition()); }
@RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR1) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); DaggerMainActivityComponent.builder().build().inject(this); ButterKnife.bind(this); setContentView(R.layout.activity_main); ButterKnife.bind(this); setActionBarAndLayoutDirection(); setupTheBottomBar(); countingOpenedTime(); if (openedTimes < 2) { showIntro(); } if (openedTimes < 3) { showTabTargetView(); } }
@Override protected void attachBaseContext(Context newBase) { super.attachBaseContext(CalligraphyContextWrapper.wrap(newBase)); }
@Override public void onBackPressed() { finish(); }
@Override public void showIntro() { Intent nIntent = new Intent(MainActivity.this, IntroActivity.class); startActivity(nIntent); }
@Override public void countingOpenedTime() { openedTimes = loadOpenedTimeFromPresenter(); saveOpenedTimeWithPresenter(++openedTimes); }
@Override public int loadOpenedTimeFromPresenter() { return presenter.loadOpenedTimeFromInteractor(); }
@Override public void saveOpenedTimeWithPresenter(int __) { presenter.saveOpenedTimeWithInteractor(__); }
@Override public int loadRandomNumberFromPresenter() { return presenter.loadRandomNumberFromInteractor(); }
@Override public void saveBadgeCounterWithPresenter(int __) { presenter.saveBadgeCounterWithInteractor(__); }
@Override public int loadBadgeCountFromPresenter() { return presenter.loadbadgeCountFromInteractor(); }
@Override public void onViewAttached(MainActivityContract.View view) { layerView = view; }
@Override public int loadOpenedTimeFromInteractor() { return interactor.loadOpenedTimeFromProvider(); }
@Override public int loadRandomNumberFromInteractor() { return interactor.getMeRandomNumberBetween1and5(); }
@Override public void saveOpenedTimeWithInteractor(int __) { interactor.saveOpenedTimes(__); }
@Override public void saveBadgeCounterWithInteractor(int __) { interactor.saveBadgeCounterWithProvider(__); }
@Override public int loadbadgeCountFromInteractor() { return interactor.loadbadgeCountFromProvider(); }
@Override public int loadOpenedTimeFromProvider() { return sharedPreferencesProvider.loadOpenedTimes(); }
@Override public void saveOpenedTimes(int __) { sharedPreferencesProvider.saveOpenedTimes(__); }
@Override public void saveBadgeCounterWithProvider(int __) { sharedPreferencesProvider.saveBadgeCounter(__); }
@Override public int loadbadgeCountFromProvider() { return sharedPreferencesProvider.loadBadgeCount(); }
@MainActivityComponentScope @Provides MainActivityContract.Presenter presenter(MainActivityPresenterImpl presenter) { return presenter; }
@MainActivityComponentScope @Provides MainActivityContract.Interactor presnter(MainActivityInteractorImpl interactor) { return interactor; }
@Override public boolean onSupportNavigateUp() { onBackPressed(); return true; }
@Override public void onBackPressed() { super.onBackPressed(); }
@Override public void onSkipPressed(Fragment currentFragment) { super.onSkipPressed(currentFragment); Intent mIntent = new Intent(IntroActivity.this, MainActivity.class); mIntent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY); startActivity(mIntent); }
@Override public void onDonePressed(Fragment currentFragment) { super.onDonePressed(currentFragment); Intent mIntent = new Intent(IntroActivity.this, MainActivity.class); mIntent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY); startActivity(mIntent); }
@Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_intro, container, false); unbinder = ButterKnife.bind(this, view); return view; }
@Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); iv.setImageDrawable(drawable); tv.setText(description); }
@Override public void onDestroyView() { super.onDestroyView(); unbinder.unbind(); }
@Override public void onViewAttached(ArchiveContract.View view) { layerView = view; }
@Override public ArrayList<QuoteDbModel> returnAllQuotesFromIntractorInArrayList() { return interactor.convertAllQuoteListToArrayListAndReturn( interactor.getAllQuotesFromDataBase()); }
@Override public void onCreate(@Nullable Bundle savedInstanceState) { DaggerArchiveFragmentComponent.builder() .archivedependencyModule(new ArchivedependencyModule(getContext())) .build() .injectFragment(this); super.onCreate(savedInstanceState); }
@Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fragment_archive, container, false); unbinder = ButterKnife.bind(this, rootView); populateListView(presenter.returnAllQuotesFromIntractorInArrayList()); return rootView; }
@Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); }
@Override public void onDestroyView() { super.onDestroyView(); unbinder.unbind(); compositeDisposable.dispose(); }
@Override public void showWhaleInsteadOfRView() { rv.setVisibility(View.GONE); tv.setVisibility(View.VISIBLE); emptyAnimation.setVisibility(View.VISIBLE); }
@Override public void deleteQuote(int position) { final QuoteDb quoteDb = QuoteDb.getQuoteDb(getContext()); quoteDb.quoteDao().deleteOne(rvAdapter.quoteList.get(position)); rvAdapter.quoteList.remove(position); rvAdapter.notifyItemRemoved(position); }
@Override public void onClick(final View v) { if (mItemClickListener != null) { int adapterPosition = getAdapterPosition(); mItemClickListener.onItemClick(v, adapterPosition, quoteList.get(adapterPosition)); } }
@Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View itemView = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_row_rv, parent, false); return new MyViewHolder(itemView); }
@Override public void onBindViewHolder(MyViewHolder holder, int position) { QuoteDbModel quoteDbModel = quoteList.get(position); holder.authorRV.setText(quoteDbModel.getAuthor()); holder.quoteRV.setText(quoteDbModel.getQuote()); }
@Override public ArrayList<QuoteDbModel> convertAllQuoteListToArrayListAndReturn(List<QuoteDbModel> mList) { if (mList != null) { ArrayList<QuoteDbModel> quoteDbModelList = new ArrayList<>(mList.size()); for (int i = mList.size(); i > 0; i--) { quoteDbModelList.add(mList.get(i - 1)); } return quoteDbModelList; } else { return null; } }
@Override public void onCreate(@Nullable Bundle savedInstanceState) { DaggerTeachingPresenterComponent.builder() .teachingPresenterModule(new TeachingPresenterModule()) .build() .inject(this); presenter.onViewAttached(this); presenter.subscribe(); super.onCreate(savedInstanceState); }
@Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_setting, container, false); unbinder = ButterKnife.bind(this, view); return view; }
@Override public void onDestroyView() { super.onDestroyView(); presenter.unsubscribe(); unbinder.unbind(); }
@OnClick(R.id.about_call) public void aboutButtonClicked() { presenter.aboutAcitivtyButtonClicked(); }
@OnClick(R.id.intro_call) public void introButtonClicked() { presenter.IntroActivityButtonClicked(); }
@Override public void callIntroActivity() { Intent intent = new Intent(getActivity(), IntroActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY); startActivity(intent); }
@Override public void callAboutActivity() { Intent intent = new Intent(getActivity(), AboutActivity.class); startActivity(intent); }
@Override public void onViewAttached(TeachingContract.View view) { viewLayer = view; }
@Override public void aboutAcitivtyButtonClicked() { viewLayer.callAboutActivity(); }
@Override public void IntroActivityButtonClicked() { viewLayer.callIntroActivity(); }
@TeachingFragmentComponentScope @Provides TeachingContract.Presenter teachingPresenter(TeachingPresenterImpl presenter) { return presenter; }
@Override public void onCreate(@Nullable Bundle savedInstanceState) { DaggerNewQuoteComponent.builder().build().inject(this); super.onCreate(savedInstanceState); }
@Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_new_quote, container, false); unbinder = ButterKnife.bind(this, view); return view; }
@Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); initiateTheScreenTextAndAnimation(); setListenerForAnimation(view); }
@Override public void onAnimationEnd(Animator animation) { view.setBackgroundColor(getResources().getColor(R.color.icons)); }
@Override public void onAnimationCancel(Animator animation) {}
@Override public void onAnimationRepeat(Animator animation) {}
@OnClick(R.id.ignoreQuote) public void ignoreQuote() { mBottomSheetBehavior.setState(BottomSheetBehavior.STATE_COLLAPSED); }
public boolean isInternetConnected() { ConnectivityManager connectivityManager = (ConnectivityManager) getActivity().getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo(); return activeNetworkInfo != null && activeNetworkInfo.isConnected(); }
@Override public void onSubscribe(Disposable d) { compositeDisposable.add(d); }
@Override public void onNext(QuoteModel quoteModel) { String quote = quoteModel.getResult().getQuote(); if (quote.length() > 224) { setQuoteToBottomSheet(getQuoteObservableFromPresenter()); } else { quoteTV.setText(quoteModel.getResult().getQuote()); authorTV.setText(quoteModel.getResult().getAuthor()); mBottomSheetBehavior.setState(BottomSheetBehavior.STATE_EXPANDED); } }
@Override public boolean makeChanceFromPresenter() { return presenter.makeChancefromInteractor(); }
@Override public void passQuoteToPresenter(QuoteDbModel __) { presenter.passQuotetoInteractorForSaving(__); }
@Override public void onViewAttached(NewQuoteContract.View view) { viewLayer = view; }
@Override public int LoadBadgeCountFromInteractor() { return interactor.LoadBadgeCountFromSharedPreferencesProvider(); }
@Override public void saveBadgeCounterWithInteractor(int __) { interactor.saveBadgeCounterWithSharedPrefrence(__); }
@Override public boolean makeChancefromInteractor() { return interactor.makeChance(); }
@Override public void passQuotetoInteractorForSaving(QuoteDbModel quoteDbModel) { interactor.saveQuoteToDb(quoteDbModel); }
@NewQuoteFragmentComponentScope @Provides NewQuoteContract.Presenter presenter(NewQuotePresenterImpl presenter) { return presenter; }
@NewQuoteFragmentComponentScope @Provides NewQuoteContract.Interactor interactor(NewQuoteInterctorImpl interactor) { return interactor; }
@Override public int LoadBadgeCountFromSharedPreferencesProvider() { return sharedPreferences.loadBadgeCount(); }
@Override public void saveBadgeCounterWithSharedPrefrence(int __) { sharedPreferences.saveBadgeCounter(__); }
@Override public boolean makeChance() { int mRandomNumber = MyApplication.getAppComponent().getRandom().nextInt(100) + 1; if (sharedPreferences.loadOpenedTimes() < 3) { return true; } return mRandomNumber % 3 == 0; }
@Override public void saveQuoteToDb(QuoteDbModel __) { Runnable runnable = () -> { QuoteDb quoteDb = QuoteDb.getQuoteDb(MyApplication.getAppComponent().getContext()); quoteDb.quoteDao().insertOne(__); }; new Thread(runnable).start(); }
@Override public void onCreate(@Nullable Bundle savedInstanceState) { DaggerSavedTimeComponent.builder().savedTimeModule(new SavedTimeModule()).build().inject(this); super.onCreate(savedInstanceState); }
@Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_saved_time, container, false); unbinder = ButterKnife.bind(this, view); presenter.onViewAttached(this); presenter.subscribe(); return view; }
@Override public void onDestroyView() { super.onDestroyView(); unbinder.unbind(); presenter.unsubscribe(); }
@Override public int LoadOpenedTimeFromProvider() { return sharedprefrenceProvider.loadOpenedTimes(); }
@Override public int RealTimeInSocialMedia(int openedTime, String socialMediaName) { switch (socialMediaName) { case "twitter": return openedTime * 5; case "instagram": return openedTime * 6; case "telegram": return openedTime * 4; } return openedTime; }
@SavedTimeFragmentComponentScope @Provides SavedTimeContract.Presenter presenter(SavedTimePresenterImpl presenter) { return presenter; }
@SavedTimeFragmentComponentScope @Provides SavedTimeContract.Interactor timeSavedInteractor(SavedTimeInteractorImpl timeSavedInteractor) { return timeSavedInteractor; }
@Override public void onViewAttached(SavedTimeContract.View view) { viewLayer = view; }
@Override public int LoadOpenedTimeFromInteractor() { return timeSavedInteractor.LoadOpenedTimeFromProvider(); }
@Override public int LoadFromInteractorRealTimeInSocialMedia(int openedTime, String socialMedia) { return timeSavedInteractor.RealTimeInSocialMedia(openedTime, socialMedia); }
public void saveOpenedTimes(int counterOpenedTimes) { SharedPreferences.Editor mPrefrences = MyApplication.getAppComponent().getSharedPrefrence().edit(); mPrefrences.putInt(PREFRENCE_KEY_OPENED_TIMES, counterOpenedTimes); mPrefrences.apply(); }
public void saveBadgeCounter(int badgeCount) { SharedPreferences.Editor mPrefrences = MyApplication.getAppComponent().getSharedPrefrence().edit(); mPrefrences.putInt(PREFRENCE_KEY_BADGE_COUNT, badgeCount); mPrefrences.apply(); }
public int loadOpenedTimes() { SharedPreferences loadpreferencesOpenTime = MyApplication.getAppComponent().getSharedPrefrence(); int openTimes = loadpreferencesOpenTime.getInt(PREFRENCE_KEY_OPENED_TIMES, 0); return openTimes; }
public int loadBadgeCount() { SharedPreferences loadpreferencesOpenTime = MyApplication.getAppComponent().getSharedPrefrence(); int badgeCoounter = loadpreferencesOpenTime.getInt(PREFRENCE_KEY_BADGE_COUNT, 0); return badgeCoounter; }
public static void destroyInstance() { INSTANCE = null; }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "([I[IIIIIIII)V") private void copyPixels( @OriginalArg(0) int[] dst, @OriginalArg(1) int[] src, @OriginalArg(3) int srcOff, @OriginalArg(4) int dstOff, @OriginalArg(5) int w, @OriginalArg(6) int h, @OriginalArg(7) int dstStep, @OriginalArg(8) int srcStep) { @Pc(6) int qw = -(w >> 2); w = -(w & 0x3); for (@Pc(14) int y = -h; y < 0; y++) { for (@Pc(18) int x = qw; x < 0; x++) { int rgb = src[srcOff++]; if (rgb == 0) { dstOff++; } else { dst[dstOff++] = rgb; } rgb = src[srcOff++]; if (rgb == 0) { dstOff++; } else { dst[dstOff++] = rgb; } rgb = src[srcOff++]; if (rgb == 0) { dstOff++; } else { dst[dstOff++] = rgb; } rgb = src[srcOff++]; if (rgb == 0) { dstOff++; } else { dst[dstOff++] = rgb; } } for (@Pc(85) int x = w; x < 0; x++) { int rgb = src[srcOff++]; if (rgb == 0) { dstOff++; } else { dst[dstOff++] = rgb; } } dstOff += dstStep; srcOff += srcStep; } }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "(II[IIIII[IIIIII)V") private void scale( @OriginalArg(12) int w, @OriginalArg(10) int h, @OriginalArg(7) int[] src, @OriginalArg(0) int offW, @OriginalArg(5) int offH, @OriginalArg(2) int[] dst, @OriginalArg(8) int dstStep, @OriginalArg(9) int dstOff, @OriginalArg(11) int currentW, @OriginalArg(1) int scaleCropWidth, @OriginalArg(4) int scaleCropHeight) { try { @Pc(5) int lastOffW = offW; for (@Pc(15) int y = -h; y < 0; y++) { @Pc(23) int offY = (offH >> 16) * currentW; for (@Pc(26) int x = -w; x < 0; x++) { @Pc(36) int rgb = src[(offW >> 16) + offY]; if (rgb == 0) { dstOff++; } else { dst[dstOff++] = rgb; } offW += scaleCropWidth; } offH += scaleCropHeight; offW = lastOffW; dstOff += dstStep; } } catch ( @Pc(68) Exception ignored) { System.out.println("error in plot_scale"); } }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "(IIIB)V") public void drawAlpha(@OriginalArg(0) int alpha, @OriginalArg(1) int x, @OriginalArg(2) int y) { x += this.cropX; y += this.cropY; @Pc(4) int dstStep = x + y * Pix2D.width2d; @Pc(27) int srcStep = 0; @Pc(30) int h = this.height; @Pc(33) int w = this.width; @Pc(37) int dstOff = Pix2D.width2d - w; @Pc(39) int srcOff = 0; if (y < Pix2D.boundTop) { int cutoff = Pix2D.boundTop - y; h -= cutoff; y = Pix2D.boundTop; srcStep += cutoff * w; dstStep += cutoff * Pix2D.width2d; } if (y + h > Pix2D.boundBottom) { h -= y + h - Pix2D.boundBottom; } if (x < Pix2D.boundLeft) { int cutoff = Pix2D.boundLeft - x; w -= cutoff; x = Pix2D.boundLeft; srcStep += cutoff; dstStep += cutoff; srcOff += cutoff; dstOff += cutoff; } if (x + w > Pix2D.boundRight) { int cutoff = x + w - Pix2D.boundRight; w -= cutoff; srcOff += cutoff; dstOff += cutoff; } if (w > 0 && h > 0) { this.copyPixelsAlpha(w, h, this.pixels, srcStep, srcOff, Pix2D.data, dstStep, dstOff, alpha); } }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "(II[III[IIBIII)V") private void copyPixelsAlpha( @OriginalArg(8) int w, @OriginalArg(4) int h, @OriginalArg(2) int[] src, @OriginalArg(6) int srcOff, @OriginalArg(10) int srcStep, @OriginalArg(5) int[] dst, @OriginalArg(0) int dstOff, @OriginalArg(9) int dstStep, @OriginalArg(3) int alpha) { @Pc(5) int invAlpha = 256 - alpha; for (@Pc(19) int y = -h; y < 0; y++) { for (@Pc(24) int x = -w; x < 0; x++) { @Pc(31) int rgb = src[srcOff++]; if (rgb == 0) { dstOff++; } else { @Pc(37) int dstRgb = dst[dstOff]; dst[dstOff++] = ((rgb & 0xFF00FF) * alpha + (dstRgb & 0xFF00FF) * invAlpha & 0xFF00FF00) + ((rgb & 0xFF00) * alpha + (dstRgb & 0xFF00) * invAlpha & 0xFF0000) >> 8; } } dstOff += dstStep; srcOff += srcStep; } }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "(Lclient!ib;IIB)V") public void drawMasked(@OriginalArg(2) int x, @OriginalArg(1) int y, @OriginalArg(0) Pix8 mask) { x += this.cropX; y += this.cropY; @Pc(15) int dstStep = x + y * Pix2D.width2d; @Pc(17) int srcStep = 0; @Pc(24) int h = this.height; @Pc(27) int w = this.width; @Pc(31) int dstOff = Pix2D.width2d - w; @Pc(33) int srcOff = 0; if (y < Pix2D.boundTop) { int cutoff = Pix2D.boundTop - y; h -= cutoff; y = Pix2D.boundTop; srcStep += cutoff * w; dstStep += cutoff * Pix2D.width2d; } if (y + h > Pix2D.boundBottom) { h -= y + h - Pix2D.boundBottom; } if (x < Pix2D.boundLeft) { int cutoff = Pix2D.boundLeft - x; w -= cutoff; x = Pix2D.boundLeft; srcStep += cutoff; dstStep += cutoff; srcOff += cutoff; dstOff += cutoff; } if (x + w > Pix2D.boundRight) { int cutoff = x + w - Pix2D.boundRight; w -= cutoff; srcOff += cutoff; dstOff += cutoff; } if (w > 0 && h > 0) { this.copyPixelsMasked( w, h, this.pixels, srcOff, srcStep, Pix2D.data, dstStep, dstOff, mask.pixels); } }
@OriginalMember(owner = "client!hb", name = "a", descriptor = "(IIIIII[I[II[BI)V") private void copyPixelsMasked( @OriginalArg(0) int w, @OriginalArg(4) int h, @OriginalArg(7) int[] src, @OriginalArg(1) int srcStep, @OriginalArg(5) int srcOff, @OriginalArg(6) int[] dst, @OriginalArg(8) int dstOff, @OriginalArg(10) int dstStep, @OriginalArg(9) byte[] mask) { @Pc(9) int qw = -(w >> 2); w = -(w & 0x3); for (@Pc(17) int y = -h; y < 0; y++) { for (@Pc(21) int x = qw; x < 0; x++) { int rgb = src[srcOff++]; if (rgb != 0 && mask[dstOff] == 0) { dst[dstOff++] = rgb; } else { dstOff++; } rgb = src[srcOff++]; if (rgb != 0 && mask[dstOff] == 0) { dst[dstOff++] = rgb; } else { dstOff++; } rgb = src[srcOff++]; if (rgb != 0 && mask[dstOff] == 0) { dst[dstOff++] = rgb; } else { dstOff++; } rgb = src[srcOff++]; if (rgb != 0 && mask[dstOff] == 0) { dst[dstOff++] = rgb; } else { dstOff++; } } for (@Pc(104) int x = w; x < 0; x++) { int rgb = src[srcOff++]; if (rgb != 0 && mask[dstOff] == 0) { dst[dstOff++] = rgb; } else { dstOff++; } } dstOff += dstStep; srcOff += srcStep; } }
@OriginalMember(owner = "client!f", name = "a", descriptor = "(ZLclient!ub;)V") public static void unpack(@OriginalArg(1) Jagfile models) { @Pc(11) Packet head = new Packet(models.read("base_head.dat", null)); @Pc(21) Packet type = new Packet(models.read("base_type.dat", null)); @Pc(31) Packet label = new Packet(models.read("base_label.dat", null)); @Pc(34) int total = head.g2(); @Pc(37) int count = head.g2(); instances = new AnimBase[count + 1]; for (@Pc(50) int i = 0; i < total; i++) { @Pc(55) int id = head.g2(); @Pc(58) int length = head.g1(); @Pc(61) int[] types = new int[length]; @Pc(64) int[][] labels = new int[length][]; for (@Pc(66) int g = 0; g < length; g++) { types[g] = type.g1(); @Pc(76) int labelCount = label.g1(); labels[g] = new int[labelCount]; for (@Pc(83) int l = 0; l < labelCount; l++) { labels[g][l] = label.g1(); } } instances[id] = new AnimBase(); instances[id].length = length; instances[id].types = types; instances[id].labels = labels; } }
@OriginalMember(owner = "client!eb", name = "a", descriptor = "(Z)V") public static void unload() { metadata = null; head = null; face1 = null; face2 = null; face3 = null; face4 = null; face5 = null; point1 = null; point2 = null; point3 = null; point4 = null; point5 = null; vertex1 = null; vertex2 = null; axis = null; faceClippedX = null; faceNearClipped = null; vertexScreenX = null; vertexScreenY = null; vertexScreenZ = null; vertexViewSpaceX = null; vertexViewSpaceY = null; vertexViewSpaceZ = null; tmpDepthFaceCount = null; tmpDepthFaces = null; tmpPriorityFaceCount = null; tmpPriorityFaces = null; tmpPriority10FaceDepth = null; tmpPriority11FaceDepth = null; tmpPriorityDepthSum = null; sinTable = null; cosTable = null; colourTable = null; divTable2 = null; }
@OriginalMember(owner = "client!eb", name = "a", descriptor = "(III)I") public static int mulColorLightness( @OriginalArg(0) int hsl, @OriginalArg(1) int scalar, @OriginalArg(2) int faceInfo) { if ((faceInfo & 0x2) == 2) { if (scalar < 0) { scalar = 0; } else if (scalar > 127) { scalar = 127; } return 127 - scalar; } scalar = scalar * (hsl & 0x7F) >> 7; if (scalar < 2) { scalar = 2; } else if (scalar > 126) { scalar = 126; } return (hsl & 0xFF80) + scalar; }
@OriginalMember(owner = "client!eb", name = "a", descriptor = "(Lclient!eb;I)I") private int addVertex(@OriginalArg(0) Model src, @OriginalArg(1) int vertexId) { @Pc(3) int identical = -1; @Pc(8) int x = src.verticesX[vertexId]; @Pc(13) int y = src.verticesY[vertexId]; @Pc(18) int z = src.verticesZ[vertexId]; for (@Pc(20) int v = 0; v < this.vertexCount; v++) { if (x == this.verticesX[v] && y == this.verticesY[v] && z == this.verticesZ[v]) { identical = v; break; } } if (identical == -1) { this.verticesX[this.vertexCount] = x; this.verticesY[this.vertexCount] = y; this.verticesZ[this.vertexCount] = z; if (src.vertexLabels != null) { this.vertexLabels[this.vertexCount] = src.vertexLabels[vertexId]; } identical = this.vertexCount++; } return identical; }
@OriginalMember(owner = "client!eb", name = "a", descriptor = "(I)V") public void calculateBoundsCylinder() { this.maxY = 0; this.radius = 0; this.minY = 0; for (@Pc(14) int i = 0; i < this.vertexCount; i++) { @Pc(21) int x = this.verticesX[i]; @Pc(26) int y = this.verticesY[i]; @Pc(31) int z = this.verticesZ[i]; if (-y > this.maxY) { this.maxY = -y; } if (y > this.minY) { this.minY = y; } @Pc(55) int radiusSqr = x * x + z * z; if (radiusSqr > this.radius) { this.radius = radiusSqr; } } this.radius = (int) (Math.sqrt(this.radius) + 0.99D); this.minDepth = (int) (Math.sqrt(this.radius * this.radius + this.maxY * this.maxY) + 0.99D); this.maxDepth = this.minDepth + (int) (Math.sqrt(this.radius * this.radius + this.minY * this.minY) + 0.99D); }
@OriginalMember(owner = "client!eb", name = "b", descriptor = "(I)V") public void calculateBoundsY() { this.maxY = 0; this.minY = 0; for (@Pc(8) int v = 0; v < this.vertexCount; v++) { @Pc(25) int y = this.verticesY[v]; if (-y > this.maxY) { this.maxY = -y; } if (y > this.minY) { this.minY = y; } } this.minDepth = (int) (Math.sqrt(this.radius * this.radius + this.maxY * this.maxY) + 0.99D); this.maxDepth = this.minDepth + (int) (Math.sqrt(this.radius * this.radius + this.minY * this.minY) + 0.99D); }
@OriginalMember(owner = "client!eb", name = "a", descriptor = "(B)V") private void calculateBoundsAABB() { this.maxY = 0; this.radius = 0; this.minY = 0; this.minX = 999999; this.maxX = -999999; this.maxZ = -99999; this.minZ = 99999; for (@Pc(27) int v = 0; v < this.vertexCount; v++) { @Pc(34) int x = this.verticesX[v]; @Pc(39) int y = this.verticesY[v]; @Pc(44) int z = this.verticesZ[v]; if (x < this.minX) { this.minX = x; } if (x > this.maxX) { this.maxX = x; } if (z < this.minZ) { this.minZ = z; } if (z > this.maxZ) { this.maxZ = z; } if (-y > this.maxY) { this.maxY = -y; } if (y > this.minY) { this.minY = y; } @Pc(96) int radiusSqr = x * x + z * z; if (radiusSqr > this.radius) { this.radius = radiusSqr; } } this.radius = (int) Math.sqrt(this.radius); this.minDepth = (int) Math.sqrt(this.radius * this.radius + this.maxY * this.maxY); this.maxDepth = this.minDepth + (int) Math.sqrt(this.radius * this.radius + this.minY * this.minY); }
@OriginalMember(owner = "client!eb", name = "a", descriptor = "(II)V") public void applyTransform(@OriginalArg(1) int id) { if (this.labelVertices != null && id != -1) { @Pc(11) AnimFrame frame = AnimFrame.instances[id]; @Pc(14) AnimBase base = frame.base; baseX = 0; baseY = 0; baseZ = 0; for (@Pc(22) int i = 0; i < frame.length; i++) { @Pc(29) int group = frame.groups[i]; this.applyTransform( frame.x[i], frame.y[i], frame.z[i], base.labels[group], base.types[group]); } } }
@OriginalMember(owner = "client!eb", name = "d", descriptor = "(I)V") public void rotateY90() { for (@Pc(6) int v = 0; v < this.vertexCount; v++) { @Pc(13) int tmp = this.verticesX[v]; this.verticesX[v] = this.verticesZ[v]; this.verticesZ[v] = -tmp; } }
@OriginalMember(owner = "client!eb", name = "a", descriptor = "(BI)V") public void rotateX(@OriginalArg(1) int angle) { @Pc(3) int sin = Model.sinTable[angle]; @Pc(7) int cos = Model.cosTable[angle]; for (@Pc(9) int v = 0; v < this.vertexCount; v++) { @Pc(27) int tmp = this.verticesY[v] * cos - this.verticesZ[v] * sin >> 16; this.verticesZ[v] = this.verticesY[v] * sin + this.verticesZ[v] * cos >> 16; this.verticesY[v] = tmp; } }
@OriginalMember(owner = "client!eb", name = "a", descriptor = "(IIII)V") public void translate(@OriginalArg(0) int y, @OriginalArg(1) int x, @OriginalArg(3) int z) { for (@Pc(11) int v = 0; v < this.vertexCount; v++) { this.verticesX[v] += x; this.verticesY[v] += y; this.verticesZ[v] += z; } }
@OriginalMember(owner = "client!eb", name = "b", descriptor = "(II)V") public void recolor(@OriginalArg(0) int src, @OriginalArg(1) int dst) { for (@Pc(1) int f = 0; f < this.faceCount; f++) { if (this.faceColors[f] == src) { this.faceColors[f] = dst; } } }
@OriginalMember(owner = "client!eb", name = "e", descriptor = "(I)V") public void rotateY180() { for (@Pc(3) int v = 0; v < this.vertexCount; v++) { this.verticesZ[v] = -this.verticesZ[v]; } for (@Pc(21) int f = 0; f < this.faceCount; f++) { int temp = this.faceIndicesA[f]; this.faceIndicesA[f] = this.faceIndicesC[f]; this.faceIndicesC[f] = temp; } }
@OriginalMember(owner = "client!eb", name = "b", descriptor = "(IIII)V") public void scale(@OriginalArg(3) int x, @OriginalArg(2) int y, @OriginalArg(0) int z) { for (@Pc(1) int v = 0; v < this.vertexCount; v++) { this.verticesX[v] = this.verticesX[v] * x / 128; this.verticesY[v] = this.verticesY[v] * y / 128; this.verticesZ[v] = this.verticesZ[v] * z / 128; } }
@OriginalMember(owner = "client!eb", name = "a", descriptor = "(IIIIIIII)Z") private boolean pointWithinTriangle( @OriginalArg(0) int x, @OriginalArg(1) int y, @OriginalArg(2) int yA, @OriginalArg(3) int yB, @OriginalArg(4) int yC, @OriginalArg(5) int xA, @OriginalArg(6) int xB, @OriginalArg(7) int xC) { if (y < yA && y < yB && y < yC) { return false; } else if (y > yA && y > yB && y > yC) { return false; } else if (x < xA && x < xB && x < xC) { return false; } else { return x <= xA || x <= xB || x <= xC; } }
@OriginalMember(owner = "client!fb", name = "a", descriptor = "(I[III)V") public static void bind( @OriginalArg(0) int width, @OriginalArg(3) int height, @OriginalArg(1) int[] src) { data = src; width2d = width; height2d = height; setClipping(height, width, 0, 0); }
@OriginalMember(owner = "client!fb", name = "a", descriptor = "(I)V") public static void resetClipping() { boundLeft = 0; boundTop = 0; boundRight = width2d; boundBottom = height2d; safeWidth = boundRight - 1; centerW2D = boundRight / 2; }
@OriginalMember(owner = "client!fb", name = "a", descriptor = "(IIIII)V") public static void setClipping( @OriginalArg(0) int bottom, @OriginalArg(2) int right, @OriginalArg(1) int top, @OriginalArg(4) int left) { if (left < 0) { left = 0; } if (top < 0) { top = 0; } if (right > width2d) { right = width2d; } if (bottom > height2d) { bottom = height2d; } Pix2D.boundLeft = left; Pix2D.boundTop = top; Pix2D.boundRight = right; Pix2D.boundBottom = bottom; safeWidth = Pix2D.boundRight - 1; centerW2D = Pix2D.boundRight / 2; centerH2D = Pix2D.boundBottom / 2; }
@OriginalMember(owner = "client!fb", name = "b", descriptor = "(I)V") public static void clear() { @Pc(7) int len = width2d * height2d; for (@Pc(9) int i = 0; i < len; i++) { data[i] = 0; } }
@OriginalMember(owner = "client!fb", name = "a", descriptor = "(IIIBII)V") public static void fillRect( @OriginalArg(1) int x, @OriginalArg(0) int y, @OriginalArg(2) int rgb, @OriginalArg(4) int width, @OriginalArg(5) int height) { if (x < boundLeft) { width -= boundLeft - x; x = boundLeft; } if (y < boundTop) { height -= boundTop - y; y = boundTop; } if (x + width > boundRight) { width = boundRight - x; } if (y + height > boundBottom) { height = boundBottom - y; } @Pc(50) int step = width2d - width; @Pc(56) int offset = x + y * width2d; for (@Pc(59) int i = -height; i < 0; i++) { for (@Pc(64) int j = -width; j < 0; j++) { data[offset++] = rgb; } offset += step; } }
@OriginalMember(owner = "mapview!f", name = "a", descriptor = "(IIIIII)V") public static void fillRectTrans( @OriginalArg(0) int x, @OriginalArg(1) int y, @OriginalArg(2) int width, @OriginalArg(3) int height, @OriginalArg(4) int rgb, @OriginalArg(5) int alpha) { if (x < boundLeft) { width -= boundLeft - x; x = boundLeft; } if (y < boundTop) { height -= boundTop - y; y = boundTop; } if (x + width > boundRight) { width = boundRight - x; } if (y + height > boundBottom) { height = boundBottom - y; } @Pc(45) int invAlpha = 256 - alpha; @Pc(53) int r0 = (rgb >> 16 & 0xFF) * alpha; @Pc(61) int g0 = (rgb >> 8 & 0xFF) * alpha; @Pc(67) int b0 = (rgb & 0xFF) * alpha; @Pc(71) int step = width2d - width; @Pc(77) int offset = x + y * width2d; for (@Pc(79) int i = 0; i < height; i++) { for (@Pc(84) int j = -width; j < 0; j++) { @Pc(96) int r1 = (data[offset] >> 16 & 0xFF) * invAlpha; @Pc(106) int g1 = (data[offset] >> 8 & 0xFF) * invAlpha; @Pc(114) int b1 = (data[offset] & 0xFF) * invAlpha; @Pc(136) int color = (r0 + r1 >> 8 << 16) + (g0 + g1 >> 8 << 8) + (b0 + b1 >> 8); data[offset++] = color; } offset += step; } }
@OriginalMember(owner = "client!fb", name = "a", descriptor = "(IIIIII)V") public static void drawRect( @OriginalArg(1) int x, @OriginalArg(4) int y, @OriginalArg(2) int rgb, @OriginalArg(5) int width, @OriginalArg(3) int height) { hline(x, y, rgb, width); hline(x, y + height - 1, rgb, width); vline(x, y, rgb, height); vline(x + width - 1, y, rgb, height); }
@OriginalMember(owner = "client!fb", name = "b", descriptor = "(IIIII)V") public static void hline( @OriginalArg(4) int x, @OriginalArg(2) int y, @OriginalArg(0) int rgb, @OriginalArg(3) int width) { if (y < boundTop || y >= boundBottom) { return; } if (x < boundLeft) { width -= boundLeft - x; x = boundLeft; } if (x + width > boundRight) { width = boundRight - x; } @Pc(32) int off = x + y * width2d; for (@Pc(37) int i = 0; i < width; i++) { data[off + i] = rgb; } }
@OriginalMember(owner = "client!fb", name = "c", descriptor = "(IIIII)V") public static void vline( @OriginalArg(4) int x, @OriginalArg(2) int y, @OriginalArg(0) int rgb, @OriginalArg(3) int height) { if (x < boundLeft || x >= boundRight) { return; } if (y < boundTop) { height -= boundTop - y; y = boundTop; } if (y + height > boundBottom) { height = boundBottom - y; } @Pc(32) int off = x + y * width2d; for (@Pc(38) int i = 0; i < height; i++) { data[off + i * width2d] = rgb; } }
public static void line(int x1, int y1, int x2, int y2, int rgb) { int dx = Math.abs(x2 - x1); int dy = Math.abs(y2 - y1); int sx = (x1 < x2) ? 1 : -1; int sy = (y1 < y2) ? 1 : -1; int err = dx - dy; while (true) { if ((x1 >= boundLeft) && (x1 < boundRight) && (y1 >= boundTop) && (y1 < boundBottom)) { data[x1 + (y1 * width2d)] = rgb; } if ((x1 == x2) && (y1 == y2)) { break; } int e2 = 2 * err; if (e2 > -dy) { err = err - dy; x1 = x1 + sx; } if (e2 < dx) { err = err + dx; y1 = y1 + sy; } } }
@OriginalMember(owner = "client!qb", name = "a", descriptor = "(B)V") public void bind() { Pix2D.bind(this.width, this.height, this.pixels); }
@OriginalMember(owner = "client!qb", name = "a", descriptor = "(ILjava/awt/Graphics;II)V") public void draw( @OriginalArg(1) Graphics g, @OriginalArg(2) int width, @OriginalArg(0) int height) { this.setPixels(); g.drawImage(this.image, width, height, this); }
@OriginalMember( owner = "client!qb", name = "addConsumer", descriptor = "(Ljava/awt/image/ImageConsumer;)V") @Override public synchronized void addConsumer(@OriginalArg(0) ImageConsumer consumer) { this.imageConsumer = consumer; consumer.setDimensions(this.width, this.height); consumer.setProperties(null); consumer.setColorModel(this.colorModel); consumer.setHints(14); }
@OriginalMember( owner = "client!qb", name = "isConsumer", descriptor = "(Ljava/awt/image/ImageConsumer;)Z") @Override public synchronized boolean isConsumer(@OriginalArg(0) ImageConsumer consumer) { return this.imageConsumer == consumer; }
@OriginalMember( owner = "client!qb", name = "removeConsumer", descriptor = "(Ljava/awt/image/ImageConsumer;)V") @Override public synchronized void removeConsumer(@OriginalArg(0) ImageConsumer consumer) { if (this.imageConsumer == consumer) { this.imageConsumer = null; } }
@OriginalMember( owner = "client!qb", name = "startProduction", descriptor = "(Ljava/awt/image/ImageConsumer;)V") @Override public void startProduction(@OriginalArg(0) ImageConsumer consumer) { this.addConsumer(consumer); }
@OriginalMember( owner = "client!qb", name = "requestTopDownLeftRightResend", descriptor = "(Ljava/awt/image/ImageConsumer;)V") @Override public void requestTopDownLeftRightResend(@OriginalArg(0) ImageConsumer consumer) { System.out.println("TDLR"); }
@OriginalMember( owner = "client!qb", name = "imageUpdate", descriptor = "(Ljava/awt/Image;IIIII)Z") @Override public boolean imageUpdate( @OriginalArg(0) Image img, @OriginalArg(1) int infoflags, @OriginalArg(2) int x, @OriginalArg(3) int y, @OriginalArg(4) int width, @OriginalArg(5) int height) { return true; }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "(IBILjava/lang/String;I)V") public void drawStringCenter( @OriginalArg(4) int x, @OriginalArg(0) int y, @OriginalArg(3) String str, @OriginalArg(2) int rgb) { this.drawString(x - this.stringWidth(str) / 2, y, str, rgb); }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "(IIZILjava/lang/String;I)V") public void drawStringTaggableCenter( @OriginalArg(4) String str, @OriginalArg(0) int x, @OriginalArg(3) int y, @OriginalArg(1) int color, @OriginalArg(2) boolean shadowed) { this.drawStringTaggable(x - this.stringWidth(str) / 2, y, str, color, shadowed); }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "(ZLjava/lang/String;)I") public int stringWidth(@OriginalArg(1) String str) { if (str == null) { return 0; } @Pc(7) int size = 0; for (@Pc(14) int c = 0; c < str.length(); c++) { if (str.charAt(c) == '@' && c + 4 < str.length() && str.charAt(c + 4) == '@') { c += 4; } else { size += this.drawWidth[str.charAt(c)]; } } return size; }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "(IIZILjava/lang/String;)V") public void drawString( @OriginalArg(0) int x, @OriginalArg(1) int y, @OriginalArg(4) String str, @OriginalArg(3) int rgb) { if (str == null) { return; } @Pc(7) int offY = y - this.height; for (@Pc(19) int i = 0; i < str.length(); i++) { @Pc(27) int c = CHAR_LOOKUP[str.charAt(i)]; if (c != 94) { this.drawChar( this.charMask[c], x + this.charOffsetX[c], offY + this.charOffsetY[c], this.charMaskWidth[c], this.charMaskHeight[c], rgb); } x += this.charAdvance[c]; } }
public void drawStringRight(int x, int y, String str, int rgb, boolean shadowed) { if (shadowed) { this.drawString(x + 1 - this.stringWidth(str), y + 1, str, 0x000000); } this.drawString(x - this.stringWidth(str), y, str, rgb); }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "(IBIIILjava/lang/String;)V") public void drawCenteredWave( @OriginalArg(2) int x, @OriginalArg(3) int y, @OriginalArg(5) String str, @OriginalArg(4) int rgb, @OriginalArg(0) int phase) { if (str == null) { return; } x -= this.stringWidth(str) / 2; @Pc(18) int offY = y - this.height; for (@Pc(24) int i = 0; i < str.length(); i++) { @Pc(39) int c = CHAR_LOOKUP[str.charAt(i)]; if (c != 94) { this.drawChar( this.charMask[c], x + this.charOffsetX[c], offY + this.charOffsetY[c] + (int) (Math.sin((double) i / 2.0D + (double) phase / 5.0D) * 5.0D), this.charMaskWidth[c], this.charMaskHeight[c], rgb); } x += this.charAdvance[c]; } }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "(IIILjava/lang/String;ZI)V") public void drawStringTaggable( @OriginalArg(0) int x, @OriginalArg(2) int y, @OriginalArg(3) String str, @OriginalArg(5) int rgb, @OriginalArg(4) boolean shadowed) { if (str == null) { return; } @Pc(9) int offY = y - this.height; for (@Pc(11) int i = 0; i < str.length(); i++) { if (str.charAt(i) == '@' && i + 4 < str.length() && str.charAt(i + 4) == '@') { rgb = this.evaluateTag(str.substring(i + 1, i + 4)); i += 4; } else { @Pc(52) int c = CHAR_LOOKUP[str.charAt(i)]; if (c != 94) { if (shadowed) { this.drawChar( this.charMask[c], x + this.charOffsetX[c] + 1, offY + this.charOffsetY[c] + 1, this.charMaskWidth[c], this.charMaskHeight[c], 0); } this.drawChar( this.charMask[c], x + this.charOffsetX[c], offY + this.charOffsetY[c], this.charMaskWidth[c], this.charMaskHeight[c], rgb); } x += this.charAdvance[c]; } } }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "(ILjava/lang/String;)I") private int evaluateTag(@OriginalArg(1) String tag) { if (tag.equals("red")) { return 0xff0000; } else if (tag.equals("gre")) { return 0xff00; } else if (tag.equals("blu")) { return 0xff; } else if (tag.equals("yel")) { return 0xffff00; } else if (tag.equals("cya")) { return 0xffff; } else if (tag.equals("mag")) { return 0xff00ff; } else if (tag.equals("whi")) { return 0xffffff; } else if (tag.equals("bla")) { return 0; } else if (tag.equals("lre")) { return 0xff9040; } else if (tag.equals("dre")) { return 0x800000; } else if (tag.equals("dbl")) { return 0x80; } else if (tag.equals("or1")) { return 0xffb000; } else if (tag.equals("or2")) { return 0xff7000; } else if (tag.equals("or3")) { return 0xff3000; } else if (tag.equals("gr1")) { return 0xc0ff00; } else if (tag.equals("gr2")) { return 0x80ff00; } else if (tag.equals("gr3")) { return 0x40ff00; } else { return 0; } }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "([BIIIII)V") private void drawChar( @OriginalArg(0) byte[] data, @OriginalArg(1) int x, @OriginalArg(2) int y, @OriginalArg(3) int w, @OriginalArg(4) int h, @OriginalArg(5) int rgb) { @Pc(5) int dstOff = x + y * Pix2D.width2d; @Pc(9) int dstStep = Pix2D.width2d - w; @Pc(11) int srcStep = 0; @Pc(13) int srcOff = 0; if (y < Pix2D.boundTop) { int cutoff = Pix2D.boundTop - y; h -= cutoff; y = Pix2D.boundTop; srcOff += cutoff * w; dstOff += cutoff * Pix2D.width2d; } if (y + h >= Pix2D.boundBottom) { h -= y + h + 1 - Pix2D.boundBottom; } if (x < Pix2D.boundLeft) { int cutoff = Pix2D.boundLeft - x; w -= cutoff; x = Pix2D.boundLeft; srcOff += cutoff; dstOff += cutoff; srcStep += cutoff; dstStep += cutoff; } if (x + w >= Pix2D.boundRight) { int cutoff = x + w + 1 - Pix2D.boundRight; w -= cutoff; srcStep += cutoff; dstStep += cutoff; } if (w > 0 && h > 0) { this.drawMask(w, h, data, srcOff, srcStep, Pix2D.data, dstOff, dstStep, rgb); } }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "([I[BIIIIIII)V") private void drawMask( @OriginalArg(5) int w, @OriginalArg(6) int h, @OriginalArg(1) byte[] src, @OriginalArg(3) int srcOff, @OriginalArg(8) int srcStep, @OriginalArg(0) int[] dst, @OriginalArg(4) int dstOff, @OriginalArg(7) int dstStep, @OriginalArg(2) int rgb) { @Pc(6) int hw = -(w >> 2); w = -(w & 0x3); for (@Pc(14) int y = -h; y < 0; y++) { for (@Pc(18) int x = hw; x < 0; x++) { if (src[srcOff++] == 0) { dstOff++; } else { dst[dstOff++] = rgb; } if (src[srcOff++] == 0) { dstOff++; } else { dst[dstOff++] = rgb; } if (src[srcOff++] == 0) { dstOff++; } else { dst[dstOff++] = rgb; } if (src[srcOff++] == 0) { dstOff++; } else { dst[dstOff++] = rgb; } } for (@Pc(77) int x = w; x < 0; x++) { if (src[srcOff++] == 0) { dstOff++; } else { dst[dstOff++] = rgb; } } dstOff += dstStep; srcOff += srcStep; } }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "([BBIIIIII)V") private void drawCharAlpha( @OriginalArg(2) int x, @OriginalArg(5) int y, @OriginalArg(7) int w, @OriginalArg(3) int h, @OriginalArg(4) int rgb, @OriginalArg(6) int alpha, @OriginalArg(0) byte[] mask) { @Pc(10) int dstOff = x + y * Pix2D.width2d; @Pc(14) int dstStep = Pix2D.width2d - w; @Pc(16) int srcStep = 0; @Pc(18) int srcOff = 0; if (y < Pix2D.boundTop) { int cutoff = Pix2D.boundTop - y; h -= cutoff; y = Pix2D.boundTop; srcOff += cutoff * w; dstOff += cutoff * Pix2D.width2d; } if (y + h >= Pix2D.boundBottom) { h -= y + h + 1 - Pix2D.boundBottom; } if (x < Pix2D.boundLeft) { int cutoff = Pix2D.boundLeft - x; w -= cutoff; x = Pix2D.boundLeft; srcOff += cutoff; dstOff += cutoff; srcStep += cutoff; dstStep += cutoff; } if (x + w >= Pix2D.boundRight) { int cutoff = x + w + 1 - Pix2D.boundRight; w -= cutoff; srcStep += cutoff; dstStep += cutoff; } if (w > 0 && h > 0) { this.drawMaskAlpha(w, h, Pix2D.data, dstOff, dstStep, mask, srcOff, srcStep, rgb, alpha); } }
@OriginalMember(owner = "client!jb", name = "a", descriptor = "(III[I[BIIIIBI)V") private void drawMaskAlpha( @OriginalArg(2) int w, @OriginalArg(0) int h, @OriginalArg(3) int[] dst, @OriginalArg(1) int dstOff, @OriginalArg(7) int dstStep, @OriginalArg(4) byte[] mask, @OriginalArg(6) int maskOff, @OriginalArg(8) int maskStep, @OriginalArg(10) int color, @OriginalArg(5) int alpha) { @Pc(19) int rgb = ((color & 0xFF00FF) * alpha & 0xFF00FF00) + ((color & 0xFF00) * alpha & 0xFF0000) >> 8; @Pc(38) int invAlpha = 256 - alpha; for (@Pc(29) int y = -h; y < 0; y++) { for (@Pc(46) int x = -w; x < 0; x++) { if (mask[maskOff++] == 0) { dstOff++; } else { @Pc(57) int dstRgb = dst[dstOff]; dst[dstOff++] = (((dstRgb & 0xFF00FF) * invAlpha & 0xFF00FF00) + ((dstRgb & 0xFF00) * invAlpha & 0xFF0000) >> 8) + rgb; } } dstOff += dstStep; maskOff += maskStep; } }
@OriginalMember(owner = "client!gb", name = "a", descriptor = "(Z)V") public static void unload() { divTable = null; divTable2 = null; sinTable = null; cosTable = null; lineOffset = null; textures = null; textureTranslucent = null; averageTextureRGB = null; texelPool = null; activeTexels = null; textureCycle = null; colourTable = null; texturePalette = null; }
@OriginalMember(owner = "client!gb", name = "c", descriptor = "(I)V") public static void init2D() { lineOffset = new int[height2d]; for (int y = 0; y < height2d; y++) { lineOffset[y] = width2d * y; } centerW3D = width2d / 2; centerH3D = height2d / 2; }
@OriginalMember(owner = "client!gb", name = "a", descriptor = "(III)V") public static void init3D(@OriginalArg(1) int width, @OriginalArg(0) int height) { lineOffset = new int[height]; for (@Pc(12) int y = 0; y < height; y++) { lineOffset[y] = width * y; } centerW3D = width / 2; centerH3D = height / 2; }
@OriginalMember(owner = "client!gb", name = "b", descriptor = "(Z)V") public static void clearTexels() { texelPool = null; for (@Pc(6) int i = 0; i < 50; i++) { activeTexels[i] = null; } }
@OriginalMember(owner = "client!gb", name = "a", descriptor = "(II)V") public static void initPool(@OriginalArg(0) int size) { if (texelPool != null) { return; } poolSize = size; if (lowDetail) { texelPool = new int[poolSize][16384]; } else { texelPool = new int[poolSize][65536]; } for (int i = 0; i < 50; i++) { activeTexels[i] = null; } }
@OriginalMember(owner = "client!gb", name = "a", descriptor = "(BLclient!ub;)V") public static void unpackTextures(@OriginalArg(1) Jagfile jag) { textureCount = 0; for (@Pc(9) int id = 0; id < 50; id++) { try { textures[id] = new Pix8(jag, String.valueOf(id), 0); if (lowDetail && textures[id].cropW == 128) { textures[id].shrink(); } else { textures[id].crop(); } textureCount++; } catch ( @Pc(47) Exception ex) { } } }
@OriginalMember(owner = "client!gb", name = "c", descriptor = "(II)V") public static void pushTexture(@OriginalArg(0) int id) { if (activeTexels[id] != null) { texelPool[poolSize++] = activeTexels[id]; activeTexels[id] = null; } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(Lclient!ub;)V") public static void unpack(@OriginalArg(0) Jagfile jag) { @Pc(11) Packet fragments = new Packet(jag.read("fragmentsenc.txt", null)); @Pc(21) Packet bad = new Packet(jag.read("badenc.txt", null)); @Pc(31) Packet domain = new Packet(jag.read("domainenc.txt", null)); @Pc(41) Packet tld = new Packet(jag.read("tldlist.txt", null)); read(bad, domain, fragments, tld); }
@OriginalMember( owner = "client!mc", name = "a", descriptor = "(Lclient!kb;Lclient!kb;Lclient!kb;Lclient!kb;)V") private static void read( @OriginalArg(1) Packet bad, @OriginalArg(2) Packet domain, @OriginalArg(0) Packet fragments, @OriginalArg(3) Packet tld) { readBadWords(bad); readDomains(domain); readFragments(fragments); readTld(tld); }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(ZLclient!kb;)V") private static void readTld(@OriginalArg(1) Packet buf) { @Pc(4) int count = buf.g4(); tlds = new char[count][]; tldType = new int[count]; for (@Pc(15) int i = 0; i < count; i++) { tldType[i] = buf.g1(); @Pc(26) char[] tld = new char[buf.g1()]; for (@Pc(28) int j = 0; j < tld.length; j++) { tld[j] = (char) buf.g1(); } tlds[i] = tld; } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(ILclient!kb;)V") private static void readBadWords(@OriginalArg(1) Packet buf) { @Pc(2) int count = buf.g4(); badWords = new char[count][]; badCombinations = new byte[count][][]; readBadCombinations(buf, badWords, badCombinations); }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(Lclient!kb;I)V") private static void readDomains(@OriginalArg(0) Packet buf) { @Pc(2) int count = buf.g4(); domains = new char[count][]; readDomain(buf, domains); }
@OriginalMember(owner = "client!mc", name = "b", descriptor = "(ILclient!kb;)V") private static void readFragments(@OriginalArg(1) Packet buf) { fragments = new int[buf.g4()]; for (@Pc(5) int i = 0; i < fragments.length; i++) { fragments[i] = buf.g2(); } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "([[[B[[CLclient!kb;B)V") private static void readBadCombinations( @OriginalArg(2) Packet buf, @OriginalArg(1) char[][] badwords, @OriginalArg(0) byte[][][] badCombinations) { for (@Pc(10) int i = 0; i < badwords.length; i++) { @Pc(17) char[] badword = new char[buf.g1()]; for (@Pc(19) int j = 0; j < badword.length; j++) { badword[j] = (char) buf.g1(); } badwords[i] = badword; @Pc(41) byte[][] combination = new byte[buf.g1()][2]; for (@Pc(43) int j = 0; j < combination.length; j++) { combination[j][0] = (byte) buf.g1(); combination[j][1] = (byte) buf.g1(); } if (combination.length > 0) { badCombinations[i] = combination; } } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(ILclient!kb;[[C)V") private static void readDomain(@OriginalArg(1) Packet buf, @OriginalArg(2) char[][] domains) { for (@Pc(5) int i = 0; i < domains.length; i++) { @Pc(20) char[] domain = new char[buf.g1()]; for (@Pc(22) int j = 0; j < domain.length; j++) { domain[j] = (char) buf.g1(); } domains[i] = domain; } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "([CI)V") private static void filterCharacters(@OriginalArg(0) char[] in) { @Pc(3) int pos = 0; for (@Pc(5) int i = 0; i < in.length; i++) { if (allowCharacter(in[i])) { in[pos] = in[i]; } else { in[pos] = ' '; } if (pos == 0 || in[pos] != ' ' || in[pos - 1] != ' ') { pos++; } } for (@Pc(55) int i = pos; i < in.length; i++) { in[i] = ' '; } }
@OriginalMember( owner = "client!mc", name = "a", descriptor = "(Ljava/lang/String;I)Ljava/lang/String;") public static String filter(@OriginalArg(0) String input) { @Pc(3) long start = System.currentTimeMillis(); @Pc(6) char[] outputPre = input.toCharArray(); filterCharacters(outputPre); @Pc(15) String trimmed = (new String(outputPre)).trim(); @Pc(19) char[] output = trimmed.toLowerCase().toCharArray(); @Pc(22) String lowercase = trimmed.toLowerCase(); filterTld(output); filterBad(output); filterDomains(output); filterFragments(output); @Pc(45) int j; for (@Pc(36) int i = 0; i < ALLOWLIST.length; i++) { j = -1; while ((j = lowercase.indexOf(ALLOWLIST[i], j + 1)) != -1) { @Pc(52) char[] allowed = ALLOWLIST[i].toCharArray(); System.arraycopy(allowed, 0, output, 0 + j, allowed.length); } } replaceUpperCases(output, trimmed.toCharArray()); formatUpperCases(output); @Pc(105) long end = System.currentTimeMillis(); return (new String(output)).trim(); }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "([CI[C)V") private static void replaceUpperCases( @OriginalArg(0) char[] in, @OriginalArg(2) char[] unfiltered) { for (@Pc(1) int i = 0; i < unfiltered.length; i++) { if (in[i] != '*' && isUpperCase(unfiltered[i])) { in[i] = unfiltered[i]; } } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(B[C)V") private static void formatUpperCases(@OriginalArg(1) char[] in) { @Pc(3) boolean upper = true; for (@Pc(12) int i = 0; i < in.length; i++) { @Pc(19) char c = in[i]; if (!isAlpha(c)) { upper = true; } else if (upper) { if (isLowerCase(c)) { upper = false; } } else if (isUpperCase(c)) { in[i] = (char) (c + 'a' - 65); } } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(Z[C)V") private static void filterBad(@OriginalArg(1) char[] in) { for (@Pc(3) int passes = 0; passes < 2; passes++) { for (@Pc(10) int i = badWords.length - 1; i >= 0; i--) { filter(badCombinations[i], in, badWords[i]); } } }
@OriginalMember(owner = "client!mc", name = "b", descriptor = "(B[C)V") private static void filterDomains(@OriginalArg(1) char[] in) { @Pc(3) char[] filteredAt = (char[]) in.clone(); @Pc(18) char[] at = new char[] {'(', 'a', ')'}; filter(null, filteredAt, at); @Pc(27) char[] filteredDot = (char[]) in.clone(); @Pc(42) char[] dot = new char[] {'d', 'o', 't'}; filter(null, filteredDot, dot); for (@Pc(56) int i = domains.length - 1; i >= 0; i--) { filterDomain(filteredDot, filteredAt, domains[i], in); } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(I[CB[C)I") private static int getDomainAtFilterStatus( @OriginalArg(0) int end, @OriginalArg(1) char[] a, @OriginalArg(3) char[] b) { if (end == 0) { return 2; } for (@Pc(9) int i = end - 1; i >= 0 && isSymbol(a[i]); i--) { if (a[i] == '@') { return 3; } } @Pc(37) int asteriskCount = 0; for (@Pc(41) int i = end - 1; i >= 0 && isSymbol(b[i]); i--) { if (b[i] == '*') { asteriskCount++; } } if (asteriskCount >= 3) { return 4; } else if (isSymbol(a[end - 1])) { return 1; } else { return 0; } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "([C[CII)I") private static int getDomainDotFilterStatus( @OriginalArg(1) char[] a, @OriginalArg(0) char[] b, @OriginalArg(2) int start) { if (start + 1 == a.length) { return 2; } else { @Pc(17) int i = start + 1; while (true) { if (i < a.length && isSymbol(a[i])) { if (a[i] != '.' && a[i] != ',') { i++; continue; } return 3; } @Pc(44) int asteriskCount = 0; for (@Pc(48) int j = start + 1; j < a.length && isSymbol(b[j]); j++) { if (b[j] == '*') { asteriskCount++; } } if (asteriskCount >= 3) { return 4; } if (isSymbol(a[start + 1])) { return 1; } return 0; } } }
@OriginalMember(owner = "client!mc", name = "b", descriptor = "([CI)V") private static void filterTld(@OriginalArg(0) char[] in) { @Pc(3) char[] filteredDot = (char[]) in.clone(); @Pc(18) char[] dot = new char[] {'d', 'o', 't'}; filter(null, filteredDot, dot); @Pc(27) char[] filteredSlash = (char[]) in.clone(); @Pc(50) char[] slash = new char[] {'s', 'l', 'a', 's', 'h'}; filter(null, filteredSlash, slash); for (@Pc(65) int i = 0; i < tlds.length; i++) { filterTld(filteredSlash, tldType[i], in, tlds[i], filteredDot); } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "([CZ[CI)I") private static int getTldDotFilterStatus( @OriginalArg(0) char[] a, @OriginalArg(2) char[] b, @OriginalArg(3) int start) { if (start == 0) { return 2; } @Pc(9) int i = start - 1; while (true) { if (i >= 0 && isSymbol(a[i])) { if (a[i] != ',' && a[i] != '.') { i--; continue; } return 3; } @Pc(34) int asteriskCount = 0; @Pc(38) int j; for (j = start - 1; j >= 0 && isSymbol(b[j]); j--) { if (b[j] == '*') { asteriskCount++; } } if (asteriskCount >= 3) { return 4; } if (isSymbol(a[start - 1])) { return 1; } return 0; } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "([CII[C)I") private static int getTldSlashFilterStatus( @OriginalArg(0) char[] b, @OriginalArg(2) int end, @OriginalArg(3) char[] a) { if (end + 1 == a.length) { return 2; } @Pc(13) int i = end + 1; while (true) { if (i < a.length && isSymbol(a[i])) { if (a[i] != '\\' && a[i] != '/') { i++; continue; } return 3; } @Pc(40) int asteriskCount = 0; for (@Pc(44) int j = end + 1; j < a.length && isSymbol(b[j]); j++) { if (b[j] == '*') { asteriskCount++; } } if (asteriskCount >= 5) { return 4; } if (isSymbol(a[end + 1])) { return 1; } return 0; } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(IB[[BB)Z") private static boolean comboMatches( @OriginalArg(1) byte a, @OriginalArg(2) byte[][] combos, @OriginalArg(3) byte b) { @Pc(9) int first = 0; if (combos[first][0] == a && combos[first][1] == b) { return true; } @Pc(30) int last = combos.length - 1; if (combos[last][0] == a && combos[last][1] == b) { return true; } do { @Pc(52) int middle = (first + last) / 2; if (combos[middle][0] == a && combos[middle][1] == b) { return true; } if (a < combos[middle][0] || a == combos[middle][0] && b < combos[middle][1]) { last = middle; } else { first = middle; } } while (first != last && first + 1 != last); return false; }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(I[C)V") private static void filterFragments(@OriginalArg(1) char[] chars) { @Pc(3) boolean compare = false; @Pc(5) int end = 0; @Pc(11) int count = 0; @Pc(13) int start = 0; while (true) { do { @Pc(112) int index; if ((index = indexOfNumber(chars, end)) == -1) { return; } @Pc(17) boolean foundLowercase = false; for (@Pc(19) int i = end; i >= 0 && i < index && !foundLowercase; i++) { if (!isSymbol(chars[i]) && !isLowerCaseAlpha(chars[i])) { foundLowercase = true; } } if (foundLowercase) { count = 0; } if (count == 0) { start = index; } end = indexOfNonNumber(index, chars); @Pc(58) int value = 0; for (@Pc(60) int i = index; i < end; i++) { value = value * 10 + chars[i] - 48; } if (value <= 255 && end - index <= 8) { count++; } else { count = 0; } } while (count != 4); for (@Pc(94) int i = start; i < end; i++) { chars[i] = '*'; } count = 0; } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(I[CI)I") private static int indexOfNumber(@OriginalArg(1) char[] input, @OriginalArg(2) int off) { for (@Pc(5) int i = off; i < input.length && i >= 0; i++) { if (input[i] >= '0' && input[i] <= '9') { return i; } } return -1; }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(II[C)I") private static int indexOfNonNumber(@OriginalArg(1) int off, @OriginalArg(2) char[] input) { @Pc(6) int i = off; while (true) { if (i < input.length && i >= 0) { if (input[i] >= '0' && input[i] <= '9') { i++; continue; } return i; } return input.length; } }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(CI)Z") private static boolean isSymbol(@OriginalArg(0) char c) { return !isAlpha(c) && !isNumber(c); }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(CB)Z") private static boolean isLowerCaseAlpha(@OriginalArg(0) char c) { if (c >= 'a' && c <= 'z') { return c == 'v' || c == 'x' || c == 'j' || c == 'q' || c == 'z'; } else { return true; } }
@OriginalMember(owner = "client!mc", name = "c", descriptor = "(IC)Z") private static boolean isAlpha(@OriginalArg(1) char c) { return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z'; }
@OriginalMember(owner = "client!mc", name = "b", descriptor = "(CI)Z") private static boolean isNumber(@OriginalArg(0) char c) { return c >= '0' && c <= '9'; }
@OriginalMember(owner = "client!mc", name = "a", descriptor = "(BC)Z") private static boolean isLowerCase(@OriginalArg(1) char c) { return c >= 'a' && c <= 'z'; }
@OriginalMember(owner = "client!mc", name = "d", descriptor = "(IC)Z") private static boolean isUpperCase(@OriginalArg(1) char c) { return c >= 'A' && c <= 'Z'; }
@OriginalMember(owner = "client!mc", name = "c", descriptor = "([CI)Z") private static boolean isBadFragment(@OriginalArg(0) char[] input) { @Pc(3) boolean skip = true; for (@Pc(5) int i = 0; i < input.length; i++) { if (!isNumber(input[i]) && input[i] != '\0') { skip = false; break; } } if (skip) { return true; } @Pc(32) int i = firstFragmentId(input); @Pc(34) int start = 0; @Pc(39) int end; end = fragments.length - 1; if (i == fragments[start] || i == fragments[end]) { return true; } do { @Pc(67) int middle = (start + end) / 2; if (i == fragments[middle]) { return true; } if (i < fragments[middle]) { end = middle; } else { start = middle; } } while (start != end && start + 1 != end); return false; }
@OriginalMember(owner = "client!mc", name = "b", descriptor = "(I[C)I") private static int firstFragmentId(@OriginalArg(1) char[] chars) { if (chars.length > 6) { return 0; } @Pc(9) int value = 0; for (@Pc(11) int i = 0; i < chars.length; i++) { @Pc(22) char c = chars[chars.length - i - 1]; if (c >= 'a' && c <= 'z') { value = value * 38 + c + 1 - 'a'; } else if (c == '\'') { value = value * 38 + 27; } else if (c >= '0' && c <= '9') { value = value * 38 + c + 28 - '0'; } else if (c != '\0') { return 0; } } return value; }
@OriginalMember(owner = "client!wb", name = "a", descriptor = "(Lclient!kb;II)Ljava/lang/String;") public static String unpack(@OriginalArg(0) Packet word, @OriginalArg(2) int length) { @Pc(3) int pos = 0; @Pc(5) int carry = -1; @Pc(22) int nibble; for (@Pc(11) int i = 0; i < length; i++) { @Pc(16) int value = word.g1(); nibble = value >> 4 & 0xF; if (carry != -1) { charBuffer[pos++] = TABLE[(carry << 4) + nibble - 195]; carry = -1; } else if (nibble < 13) { charBuffer[pos++] = TABLE[nibble]; } else { carry = nibble; } nibble = value & 0xF; if (carry != -1) { charBuffer[pos++] = TABLE[(carry << 4) + nibble - 195]; carry = -1; } else if (nibble < 13) { charBuffer[pos++] = TABLE[nibble]; } else { carry = nibble; } } @Pc(100) boolean uppercase = true; for (int i = 0; i < pos; i++) { @Pc(108) char c = charBuffer[i]; if (uppercase && c >= 'a' && c <= 'z') { charBuffer[i] = (char) (charBuffer[i] - 32); uppercase = false; } if (c == '.' || c == '!') { uppercase = true; } } return new String(charBuffer, 0, pos); }
@OriginalMember(owner = "client!wb", name = "a", descriptor = "(Lclient!kb;ZLjava/lang/String;)V") public static void pack(@OriginalArg(0) Packet word, @OriginalArg(2) String str) { if (str.length() > 80) { str = str.substring(0, 80); } str = str.toLowerCase(); @Pc(15) int carry = -1; for (@Pc(17) int i = 0; i < str.length(); i++) { @Pc(23) char c = str.charAt(i); @Pc(25) int index = 0; for (@Pc(27) int j = 0; j < TABLE.length; j++) { if (c == TABLE[j]) { index = j; break; } } if (index > 12) { index += 195; } if (carry == -1) { if (index < 13) { carry = index; } else { word.p1(index); } } else if (index < 13) { word.p1((carry << 4) + index); carry = -1; } else { word.p1((carry << 4) + (index >> 4)); carry = index & 0xF; } } if (carry != -1) { word.p1(carry << 4); } }
public static void main(String[] args) { SpringApplication.run(NovelNewsApplication.class, args); }
@Override public String toString() { return "NewsInfo{" + "id=" + id + ", categoryId=" + categoryId + ", categoryName=" + categoryName + ", sourceName=" + sourceName + ", title=" + title + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "NewsContent{" + "id=" + id + ", newsId=" + newsId + ", content=" + content + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "NewsCategory{" + "id=" + id + ", name=" + name + ", sort=" + sort + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public RestResp<List<NewsInfoRespDto>> listLatestNews() { return RestResp.ok(newsCacheManager.listLatestNews()); }
public static void main(String[] args) { SpringApplication.run(NovelSearchApplication.class, args); }
@Bean JacksonJsonpMapper jacksonJsonpMapper() { return new JacksonJsonpMapper(); }
@Override public void checkClientTrusted(X509Certificate[] chain, String authType) {}
@Override public void checkServerTrusted(X509Certificate[] chain, String authType) {}
@Bean public XxlJobSpringExecutor xxlJobExecutor() { log.info(">>>>>>>>>>> xxl-job config init."); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setLogPath(logPath); return xxlJobSpringExecutor; }
@SneakyThrows @XxlJob("saveToEsJobHandler") public ReturnT<String> saveToEs() { try { long maxId = 0; for (; ; ) { List<BookEsRespDto> books = bookFeignManager.listEsBooks(maxId); if (books.isEmpty()) { break; } BulkRequest.Builder br = new BulkRequest.Builder(); for (BookEsRespDto book : books) { br.operations( op -> op.index( idx -> idx.index(EsConsts.BookIndex.INDEX_NAME) .id(book.getId().toString()) .document(book))) .timeout(Time.of(t -> t.time("10s"))); maxId = book.getId(); } BulkResponse result = elasticsearchClient.bulk(br.build()); if (result.errors()) { log.error("Bulk had errors"); for (BulkResponseItem item : result.items()) { if (item.error() != null) { log.error(item.error().reason()); } } } } return ReturnT.SUCCESS; } catch (Exception e) { log.error(e.getMessage(), e); return ReturnT.FAIL; } }
public static void main(String[] args) { SpringApplication.run(NovelAuthorApplication.class, args); }
@SuppressWarnings("NullableProblems") @Override public void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); }
@Override public String toString() { return "AuthorInfo{" + "id=" + id + ", userId=" + userId + ", inviteCode=" + inviteCode + ", penName=" + penName + ", telPhone=" + telPhone + ", chatAccount=" + chatAccount + ", email=" + email + ", workDirection=" + workDirection + ", status=" + status + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "AuthorCode{" + "id=" + id + ", inviteCode=" + inviteCode + ", validityTime=" + validityTime + ", isUsed=" + isUsed + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "AuthorIncome{" + "id=" + id + ", authorId=" + authorId + ", bookId=" + bookId + ", incomeMonth=" + incomeMonth + ", preTaxIncome=" + preTaxIncome + ", afterTaxIncome=" + afterTaxIncome + ", payStatus=" + payStatus + ", confirmStatus=" + confirmStatus + ", detail=" + detail + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "AuthorIncomeDetail{" + "id=" + id + ", authorId=" + authorId + ", bookId=" + bookId + ", incomeDate=" + incomeDate + ", incomeAccount=" + incomeAccount + ", incomeCount=" + incomeCount + ", incomeNumber=" + incomeNumber + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
public RestResp<Void> publishBook(BookAddReqDto dto) { AuthorInfoDto author = authorInfoCacheManager.getAuthor(UserHolder.getUserId()); dto.setAuthorId(author.getId()); dto.setPenName(author.getPenName()); return bookFeign.publishBook(dto); }
public RestResp<PageRespDto<BookInfoRespDto>> listPublishBooks(BookPageReqDto dto) { authorInfoCacheManager.getAuthor(UserHolder.getUserId()); return bookFeign.listPublishBooks(dto); }
public RestResp<Void> publishBookChapter(ChapterAddReqDto dto) { return bookFeign.publishBookChapter(dto); }
public RestResp<PageRespDto<BookChapterRespDto>> listPublishBookChapters(ChapterPageReqDto dto) { return bookFeign.listPublishBookChapters(dto); }
public static void main(String[] args) { SpringApplication.run(NovelMonitorApplication.class, args); }
@Bean public InMemoryUserDetailsManager userDetailsService(PasswordEncoder passwordEncoder) { UserDetails user = User.withUsername("user") .password(passwordEncoder.encode("password")) .roles("USER") .build(); return new InMemoryUserDetailsManager(user); }
@Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }
@Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; }
@Bean public FanoutExchange bookChangeExchange() { return new FanoutExchange(AmqpConsts.BookChangeMq.EXCHANGE_NAME); }
@Bean public Queue esBookUpdateQueue() { return new Queue(AmqpConsts.BookChangeMq.QUEUE_ES_UPDATE); }
@Bean public Binding esBookUpdateQueueBinding() { return BindingBuilder.bind(esBookUpdateQueue()).to(bookChangeExchange()); }
@ConfigurationProperties(prefix = "novel.xss") public record XssProperties(Boolean enabled, List<String> excludes) {}
@Around(value = "@annotation(io.github.xxyopen.novel.config.annotation.Lock)") @SneakyThrows public Object doAround(ProceedingJoinPoint joinPoint) { MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method targetMethod = methodSignature.getMethod(); Lock lock = targetMethod.getAnnotation(Lock.class); String lockKey = KEY_PREFIX + buildLockKey(lock.prefix(), targetMethod, joinPoint.getArgs()); RLock rLock = redissonClient.getLock(lockKey); if (lock.isWait() ? rLock.tryLock(lock.waitTime(), TimeUnit.SECONDS) : rLock.tryLock()) { try { return joinPoint.proceed(); } finally { rLock.unlock(); } } throw new BusinessException(lock.failCode()); }
private String buildLockKey(String prefix, Method method, Object[] args) { StringBuilder builder = new StringBuilder(); if (StringUtils.hasText(prefix)) { builder.append(KEY_SEPARATOR).append(prefix); } Parameter[] parameters = method.getParameters(); for (int i = 0; i < parameters.length; i++) { builder.append(KEY_SEPARATOR); if (parameters[i].isAnnotationPresent(Key.class)) { Key key = parameters[i].getAnnotation(Key.class); builder.append(parseKeyExpr(key.expr(), args[i])); } } return builder.toString(); }
private String parseKeyExpr(String expr, Object arg) { if (!StringUtils.hasText(expr)) { return arg.toString(); } ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(expr, new TemplateParserContext()); return expression.getValue(arg, String.class); }
@Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); }
@Override public void doFilter( ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) servletRequest; if (handleExcludeUrl(req)) { filterChain.doFilter(servletRequest, servletResponse); return; } XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper((HttpServletRequest) servletRequest); filterChain.doFilter(xssRequest, servletResponse); }
private boolean handleExcludeUrl(HttpServletRequest request) { if (CollectionUtils.isEmpty(xssProperties.excludes())) { return false; } String url = request.getServletPath(); for (String pattern : xssProperties.excludes()) { Pattern p = Pattern.compile("^" + pattern); Matcher m = p.matcher(url); if (m.find()) { return true; } } return false; }
@Override public void destroy() { Filter.super.destroy(); }
@ExceptionHandler(BindException.class) public RestResp<Void> handlerBindException(BindException e) { log.error(e.getMessage(), e); return RestResp.fail(ErrorCodeEnum.USER_REQUEST_PARAM_ERROR); }
@ExceptionHandler(BusinessException.class) public RestResp<Void> handlerBusinessException(BusinessException e) { log.error(e.getMessage(), e); return RestResp.fail(e.getErrorCodeEnum()); }
@ExceptionHandler(Exception.class) public RestResp<Void> handlerException(Exception e) { log.error(e.getMessage(), e); return RestResp.error(); }
@Override public String deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException { return jsonParser.getValueAsString().replace("<", "&lt;").replace(">", "&gt;"); }
@Override public void serialize( String s, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { jsonGenerator.writeString(s.substring(0, 4) + "****" + s.substring(8)); }
public static <T> PageRespDto<T> of(long pageNum, long pageSize, long total, List<T> list) { return new PageRespDto<>(pageNum, pageSize, total, list); }
public static RestResp<Void> ok() { return new RestResp<>(); }
public static <T> RestResp<T> ok(T data) { return new RestResp<>(data); }
public static RestResp<Void> fail(ErrorCodeEnum errorCode) { return new RestResp<>(errorCode); }
public static RestResp<Void> error() { return new RestResp<>(ErrorCodeEnum.SYSTEM_ERROR); }
public boolean isOk() { return Objects.equals(this.code, ErrorCodeEnum.OK.getCode()); }
public void clear() { userIdTL.remove(); authorIdTL.remove(); }
public String generateToken(Long uid, String systemKey) { return Jwts.builder() .setHeaderParam(HEADER_SYSTEM_KEY, systemKey) .setSubject(uid.toString()) .signWith(Keys.hmacShaKeyFor(SECRET.getBytes(StandardCharsets.UTF_8))) .compact(); }
public static void main(String[] args) { SpringApplication.run(NovelHomeApplication.class, args); }
@Override public String toString() { return "HomeBook{" + "id=" + id + ", type=" + type + ", sort=" + sort + ", bookId=" + bookId + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "HomeFriendLink{" + "id=" + id + ", linkName=" + linkName + ", linkUrl=" + linkUrl + ", sort=" + sort + ", isOpen=" + isOpen + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public RestResp<List<HomeBookRespDto>> listHomeBooks() { List<HomeBookRespDto> list = homeBookCacheManager.listHomeBooks(); if (CollectionUtils.isEmpty(list)) { homeBookCacheManager.evictCache(); } return RestResp.ok(list); }
@Override public RestResp<List<HomeFriendLinkRespDto>> listHomeFriendLinks() { return RestResp.ok(friendLinkCacheManager.listFriendLinks()); }
@CacheEvict( cacheManager = CacheConsts.CAFFEINE_CACHE_MANAGER, value = CacheConsts.HOME_BOOK_CACHE_NAME) public void evictCache() {}
public static void main(String[] args) { SpringApplication.run(NovelGatewayApplication.class); }
public static void main(String[] args) { SpringApplication.run(NovelBookApplication.class, args); }
@Override public String toString() { return "BookComment{" + "id=" + id + ", bookId=" + bookId + ", userId=" + userId + ", commentContent=" + commentContent + ", replyCount=" + replyCount + ", auditStatus=" + auditStatus + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "BookContent{" + "id=" + id + ", chapterId=" + chapterId + ", content=" + content + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "BookCommentReply{" + "id=" + id + ", commentId=" + commentId + ", userId=" + userId + ", replyContent=" + replyContent + ", auditStatus=" + auditStatus + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "BookCategory{" + "id=" + id + ", workDirection=" + workDirection + ", name=" + name + ", sort=" + sort + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "BookCommentCopy1{" + "id=" + id + ", bookId=" + bookId + ", userId=" + userId + ", commentContent=" + commentContent + ", replyCount=" + replyCount + ", auditStatus=" + auditStatus + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "BookChapter{" + "id=" + id + ", bookId=" + bookId + ", chapterNum=" + chapterNum + ", chapterName=" + chapterName + ", wordCount=" + wordCount + ", isVip=" + isVip + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "BookInfo{" + "id=" + id + ", workDirection=" + workDirection + ", categoryId=" + categoryId + ", categoryName=" + categoryName + ", picUrl=" + picUrl + ", bookName=" + bookName + ", authorId=" + authorId + ", authorName=" + authorName + ", bookDesc=" + bookDesc + ", score=" + score + ", bookStatus=" + bookStatus + ", visitCount=" + visitCount + ", wordCount=" + wordCount + ", commentCount=" + commentCount + ", lastChapterId=" + lastChapterId + ", lastChapterName=" + lastChapterName + ", lastChapterUpdateTime=" + lastChapterUpdateTime + ", isVip=" + isVip + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public RestResp<List<BookRankRespDto>> listVisitRankBooks() { return RestResp.ok(bookRankCacheManager.listVisitRankBooks()); }
@Override public RestResp<List<BookRankRespDto>> listNewestRankBooks() { return RestResp.ok(bookRankCacheManager.listNewestRankBooks()); }
@Override public RestResp<List<BookRankRespDto>> listUpdateRankBooks() { return RestResp.ok(bookRankCacheManager.listUpdateRankBooks()); }
@Override public RestResp<List<BookInfoRespDto>> listRecBooks(Long bookId) throws NoSuchAlgorithmException { Long categoryId = bookInfoCacheManager.getBookInfo(bookId).getCategoryId(); List<Long> lastUpdateIdList = bookInfoCacheManager.getLastUpdateIdList(categoryId); List<BookInfoRespDto> respDtoList = new ArrayList<>(); List<Integer> recIdIndexList = new ArrayList<>(); int count = 0; Random rand = SecureRandom.getInstanceStrong(); while (count < REC_BOOK_COUNT) { int recIdIndex = rand.nextInt(lastUpdateIdList.size()); if (!recIdIndexList.contains(recIdIndex)) { recIdIndexList.add(recIdIndex); bookId = lastUpdateIdList.get(recIdIndex); BookInfoRespDto bookInfo = bookInfoCacheManager.getBookInfo(bookId); respDtoList.add(bookInfo); count++; } } return RestResp.ok(respDtoList); }
@Override public RestResp<Void> addVisitCount(Long bookId) { bookInfoMapper.addVisitCount(bookId); return RestResp.ok(); }
@Override public RestResp<List<BookChapterRespDto>> listChapters(Long bookId) { QueryWrapper<BookChapter> queryWrapper = new QueryWrapper<>(); queryWrapper .eq(DatabaseConsts.BookChapterTable.COLUMN_BOOK_ID, bookId) .orderByAsc(DatabaseConsts.BookChapterTable.COLUMN_CHAPTER_NUM); return RestResp.ok( bookChapterMapper.selectList(queryWrapper).stream() .map( v -> BookChapterRespDto.builder() .id(v.getId()) .chapterName(v.getChapterName()) .isVip(v.getIsVip()) .build()) .toList()); }
@Override public RestResp<List<BookCategoryRespDto>> listCategory(Integer workDirection) { return RestResp.ok(bookCategoryCacheManager.listCategory(workDirection)); }
@Override public RestResp<Void> deleteComment(BookCommentReqDto dto) { QueryWrapper<BookComment> queryWrapper = new QueryWrapper<>(); queryWrapper .eq(DatabaseConsts.CommonColumnEnum.ID.getName(), dto.getCommentId()) .eq(DatabaseConsts.BookCommentTable.COLUMN_USER_ID, dto.getUserId()); bookCommentMapper.delete(queryWrapper); return RestResp.ok(); }
@Override public RestResp<Void> updateComment(BookCommentReqDto dto) { QueryWrapper<BookComment> queryWrapper = new QueryWrapper<>(); queryWrapper .eq(DatabaseConsts.CommonColumnEnum.ID.getName(), dto.getCommentId()) .eq(DatabaseConsts.BookCommentTable.COLUMN_USER_ID, dto.getUserId()); BookComment bookComment = new BookComment(); bookComment.setCommentContent(dto.getCommentContent()); bookCommentMapper.update(bookComment, queryWrapper); return RestResp.ok(); }
@Override public RestResp<PageRespDto<BookInfoRespDto>> listAuthorBooks(BookPageReqDto dto) { IPage<BookInfo> page = new Page<>(); page.setCurrent(dto.getPageNum()); page.setSize(dto.getPageSize()); QueryWrapper<BookInfo> queryWrapper = new QueryWrapper<>(); queryWrapper .eq(DatabaseConsts.BookTable.AUTHOR_ID, dto.getAuthorId()) .orderByDesc(DatabaseConsts.CommonColumnEnum.CREATE_TIME.getName()); IPage<BookInfo> bookInfoPage = bookInfoMapper.selectPage(page, queryWrapper); return RestResp.ok( PageRespDto.of( dto.getPageNum(), dto.getPageSize(), page.getTotal(), bookInfoPage.getRecords().stream() .map( v -> BookInfoRespDto.builder() .id(v.getId()) .bookName(v.getBookName()) .picUrl(v.getPicUrl()) .categoryName(v.getCategoryName()) .wordCount(v.getWordCount()) .visitCount(v.getVisitCount()) .updateTime(v.getUpdateTime()) .build()) .toList())); }
@Override public RestResp<PageRespDto<BookChapterRespDto>> listBookChapters(ChapterPageReqDto dto) { IPage<BookChapter> page = new Page<>(); page.setCurrent(dto.getPageNum()); page.setSize(dto.getPageSize()); QueryWrapper<BookChapter> queryWrapper = new QueryWrapper<>(); queryWrapper .eq(DatabaseConsts.BookChapterTable.COLUMN_BOOK_ID, dto.getBookId()) .orderByDesc(DatabaseConsts.BookChapterTable.COLUMN_CHAPTER_NUM); IPage<BookChapter> bookChapterPage = bookChapterMapper.selectPage(page, queryWrapper); return RestResp.ok( PageRespDto.of( dto.getPageNum(), dto.getPageSize(), page.getTotal(), bookChapterPage.getRecords().stream() .map( v -> BookChapterRespDto.builder() .id(v.getId()) .chapterName(v.getChapterName()) .chapterUpdateTime(v.getUpdateTime()) .isVip(v.getIsVip()) .build()) .toList())); }
@Override public RestResp<List<BookInfoRespDto>> listBookInfoByIds(List<Long> bookIds) { QueryWrapper<BookInfo> queryWrapper = new QueryWrapper<>(); queryWrapper.in(DatabaseConsts.CommonColumnEnum.ID.getName(), bookIds); return RestResp.ok( bookInfoMapper.selectList(queryWrapper).stream() .map( v -> BookInfoRespDto.builder() .id(v.getId()) .bookName(v.getBookName()) .authorName(v.getAuthorName()) .picUrl(v.getPicUrl()) .bookDesc(v.getBookDesc()) .build()) .collect(Collectors.toList())); }
public void sendBookChangeMsg(Long bookId) { if (amqpEnabled) { sendAmqpMessage(amqpTemplate, AmqpConsts.BookChangeMq.EXCHANGE_NAME, null, bookId); } }
@Override public void afterCommit() { amqpTemplate.convertAndSend(exchange, routingKey, message); }
@Cacheable( cacheManager = CacheConsts.REDIS_CACHE_MANAGER, value = CacheConsts.BOOK_VISIT_RANK_CACHE_NAME) public List<BookRankRespDto> listVisitRankBooks() { QueryWrapper<BookInfo> bookInfoQueryWrapper = new QueryWrapper<>(); bookInfoQueryWrapper.orderByDesc(DatabaseConsts.BookTable.COLUMN_VISIT_COUNT); return listRankBooks(bookInfoQueryWrapper); }
@Cacheable( cacheManager = CacheConsts.CAFFEINE_CACHE_MANAGER, value = CacheConsts.BOOK_NEWEST_RANK_CACHE_NAME) public List<BookRankRespDto> listNewestRankBooks() { QueryWrapper<BookInfo> bookInfoQueryWrapper = new QueryWrapper<>(); bookInfoQueryWrapper .gt(DatabaseConsts.BookTable.COLUMN_WORD_COUNT, 0) .orderByDesc(DatabaseConsts.CommonColumnEnum.CREATE_TIME.getName()); return listRankBooks(bookInfoQueryWrapper); }
@Cacheable( cacheManager = CacheConsts.CAFFEINE_CACHE_MANAGER, value = CacheConsts.BOOK_UPDATE_RANK_CACHE_NAME) public List<BookRankRespDto> listUpdateRankBooks() { QueryWrapper<BookInfo> bookInfoQueryWrapper = new QueryWrapper<>(); bookInfoQueryWrapper .gt(DatabaseConsts.BookTable.COLUMN_WORD_COUNT, 0) .orderByDesc(DatabaseConsts.CommonColumnEnum.UPDATE_TIME.getName()); return listRankBooks(bookInfoQueryWrapper); }
private List<BookRankRespDto> listRankBooks(QueryWrapper<BookInfo> bookInfoQueryWrapper) { bookInfoQueryWrapper .gt(DatabaseConsts.BookTable.COLUMN_WORD_COUNT, 0) .last(DatabaseConsts.SqlEnum.LIMIT_30.getSql()); return bookInfoMapper.selectList(bookInfoQueryWrapper).stream() .map( v -> { BookRankRespDto respDto = new BookRankRespDto(); respDto.setId(v.getId()); respDto.setCategoryId(v.getCategoryId()); respDto.setCategoryName(v.getCategoryName()); respDto.setBookName(v.getBookName()); respDto.setAuthorName(v.getAuthorName()); respDto.setPicUrl(v.getPicUrl()); respDto.setBookDesc(v.getBookDesc()); respDto.setLastChapterName(v.getLastChapterName()); respDto.setLastChapterUpdateTime(v.getLastChapterUpdateTime()); respDto.setWordCount(v.getWordCount()); return respDto; }) .toList(); }
@Cacheable( cacheManager = CacheConsts.CAFFEINE_CACHE_MANAGER, value = CacheConsts.BOOK_CATEGORY_LIST_CACHE_NAME) public List<BookCategoryRespDto> listCategory(Integer workDirection) { QueryWrapper<BookCategory> queryWrapper = new QueryWrapper<>(); queryWrapper.eq(DatabaseConsts.BookCategoryTable.COLUMN_WORK_DIRECTION, workDirection); return bookCategoryMapper.selectList(queryWrapper).stream() .map(v -> BookCategoryRespDto.builder().id(v.getId()).name(v.getName()).build()) .toList(); }
@Override public RestResp<List<BookEsRespDto>> listNextEsBooks(Long maxBookId) { return RestResp.ok(new ArrayList<>(0)); }
@Override public RestResp<List<BookInfoRespDto>> listBookInfoByIds(List<Long> bookIds) { return RestResp.ok(new ArrayList<>(0)); }
@Override public RestResp<Void> publishComment(BookCommentReqDto dto) { return RestResp.fail(ErrorCodeEnum.THIRD_SERVICE_ERROR); }
@Override public RestResp<Void> updateComment(BookCommentReqDto dto) { return RestResp.fail(ErrorCodeEnum.THIRD_SERVICE_ERROR); }
@Override public RestResp<Void> deleteComment(BookCommentReqDto dto) { return RestResp.fail(ErrorCodeEnum.THIRD_SERVICE_ERROR); }
@Override public RestResp<Void> publishBook(BookAddReqDto dto) { return RestResp.fail(ErrorCodeEnum.THIRD_SERVICE_ERROR); }
@Override public RestResp<PageRespDto<BookInfoRespDto>> listPublishBooks(BookPageReqDto dto) { return RestResp.ok(PageRespDto.of(dto.getPageNum(), dto.getPageSize(), 0, new ArrayList<>(0))); }
@Override public RestResp<Void> publishBookChapter(ChapterAddReqDto dto) { return RestResp.fail(ErrorCodeEnum.THIRD_SERVICE_ERROR); }
@Override public RestResp<PageRespDto<BookChapterRespDto>> listPublishBookChapters(ChapterPageReqDto dto) { return RestResp.ok(PageRespDto.of(dto.getPageNum(), dto.getPageSize(), 0, new ArrayList<>(0))); }
public static void main(String[] args) { SpringApplication.run(NovelResourceApplication.class, args); }
private void drawString(Graphics g, String verifyCode) { for (int i = 1; i <= verifyCode.length(); i++) { g.setFont(getFont()); g.setColor(new Color(random.nextInt(101), random.nextInt(111), random.nextInt(121))); g.translate(random.nextInt(3), random.nextInt(3)); g.drawString(String.valueOf(verifyCode.charAt(i - 1)), 13 * i, 23); } }
private void drawLine(Graphics g) { int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(13); int yl = random.nextInt(15); g.drawLine(x, y, x + xl, y + yl); }
@Override public RestResp<ImgVerifyCodeRespDto> getImgVerifyCode() throws IOException { String sessionId = IdWorker.get32UUID(); return RestResp.ok( ImgVerifyCodeRespDto.builder() .sessionId(sessionId) .img(verifyCodeManager.genImgVerifyCode(sessionId)) .build()); }
public String genImgVerifyCode(String sessionId) throws IOException { String verifyCode = ImgVerifyCodeUtils.getRandomVerifyCode(4); String img = ImgVerifyCodeUtils.genVerifyCodeImg(verifyCode); stringRedisTemplate .opsForValue() .set(CacheConsts.IMG_VERIFY_CODE_CACHE_KEY + sessionId, verifyCode, Duration.ofMinutes(5)); return img; }
@Override public RestResp<List<UserInfoRespDto>> listUserInfoByIds(List<Long> userIds) { return RestResp.ok(new ArrayList<>(0)); }
public static void main(String[] args) { SpringApplication.run(NovelUserApplication.class, args); }
@Override public String toString() { return "UserCommentReply{" + "id=" + id + ", commentId=" + commentId + ", userId=" + userId + ", replyContent=" + replyContent + ", auditStatus=" + auditStatus + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "UserConsumeLog{" + "id=" + id + ", userId=" + userId + ", amount=" + amount + ", productType=" + productType + ", productId=" + productId + ", producName=" + producName + ", producValue=" + producValue + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "UserBookshelf{" + "id=" + id + ", userId=" + userId + ", bookId=" + bookId + ", preContentId=" + preContentId + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "UserReadHistory{" + "id=" + id + ", userId=" + userId + ", bookId=" + bookId + ", preContentId=" + preContentId + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "UserPayLog{" + "id=" + id + ", userId=" + userId + ", payChannel=" + payChannel + ", outTradeNo=" + outTradeNo + ", amount=" + amount + ", productType=" + productType + ", productId=" + productId + ", productName=" + productName + ", productValue=" + productValue + ", payTime=" + payTime + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "UserComment{" + "id=" + id + ", userId=" + userId + ", bookId=" + bookId + ", commentContent=" + commentContent + ", replyCount=" + replyCount + ", auditStatus=" + auditStatus + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "UserFeedback{" + "id=" + id + ", userId=" + userId + ", content=" + content + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "UserInfo{" + "id=" + id + ", username=" + username + ", password=" + password + ", salt=" + salt + ", nickName=" + nickName + ", userPhoto=" + userPhoto + ", userSex=" + userSex + ", accountBalance=" + accountBalance + ", status=" + status + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public RestResp<Void> saveFeedback(Long userId, String content) { UserFeedback userFeedback = new UserFeedback(); userFeedback.setUserId(userId); userFeedback.setContent(content); userFeedback.setCreateTime(LocalDateTime.now()); userFeedback.setUpdateTime(LocalDateTime.now()); userFeedbackMapper.insert(userFeedback); return RestResp.ok(); }
@Override public RestResp<Void> updateUserInfo(UserInfoUptReqDto dto) { UserInfo userInfo = new UserInfo(); userInfo.setId(dto.getUserId()); userInfo.setNickName(dto.getNickName()); userInfo.setUserPhoto(dto.getUserPhoto()); userInfo.setUserSex(dto.getUserSex()); userInfoMapper.updateById(userInfo); return RestResp.ok(); }
@Override public RestResp<Void> deleteFeedback(Long userId, Long id) { QueryWrapper<UserFeedback> queryWrapper = new QueryWrapper<>(); queryWrapper .eq(DatabaseConsts.CommonColumnEnum.ID.getName(), id) .eq(DatabaseConsts.UserFeedBackTable.COLUMN_USER_ID, userId); userFeedbackMapper.delete(queryWrapper); return RestResp.ok(); }
@Override public RestResp<List<UserInfoRespDto>> listUserInfoByIds(List<Long> userIds) { QueryWrapper<UserInfo> queryWrapper = new QueryWrapper<>(); queryWrapper.in(DatabaseConsts.CommonColumnEnum.ID.getName(), userIds); return RestResp.ok( userInfoMapper.selectList(queryWrapper).stream() .map( v -> UserInfoRespDto.builder() .id(v.getId()) .username(v.getUsername()) .userPhoto(v.getUserPhoto()) .build()) .collect(Collectors.toList())); }
public RestResp<Void> publishComment(BookCommentReqDto dto) { dto.setUserId(UserHolder.getUserId()); return bookFeign.publishComment(dto); }
public RestResp<Void> updateComment(BookCommentReqDto dto) { dto.setUserId(UserHolder.getUserId()); return bookFeign.updateComment(dto); }
public RestResp<Void> deleteComment(BookCommentReqDto dto) { dto.setUserId(UserHolder.getUserId()); return bookFeign.deleteComment(dto); }
public boolean imgVerifyCodeOk(String sessionId, String verifyCode) { return Objects.equals( stringRedisTemplate.opsForValue().get(CacheConsts.IMG_VERIFY_CODE_CACHE_KEY + sessionId), verifyCode); }
public void removeImgVerifyCode(String sessionId) { stringRedisTemplate.delete(CacheConsts.IMG_VERIFY_CODE_CACHE_KEY + sessionId); }
@Override public void callBack(String topic, String msg) { log.info("=============================" + topic + msg); }
@Override public void callThrowable(Throwable e) { log.info("exception", e); }
public static void main(String[] args) { ConfigurableApplicationContext run = run(App.class, args); }
@Override public void callBack(String topic, String msg) { System.out.print("========================================" + topic + msg); }
private static void pub(MqttClient sampleClient, String msg, String topic) throws MqttPersistenceException, MqttException { MqttMessage message = null; try { message = new MqttMessage(msg.getBytes("utf-8")); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } message.setQos(qos); message.setRetained(true); sampleClient.publish(topic, message); }
private static void publish(String str, String clientId, String topic) throws MqttException { MqttClient mqttClient = connect(clientId, userName, passWord); if (mqttClient != null) { for (; ; ) { pub(mqttClient, str, topic); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } } }
public static void main(String[] args) throws MqttException, InterruptedException { for (int i = 0; i < 100; i++) { final int index = i; service.execute( (() -> { try { publish( "message content" + index, String.valueOf(new Random().nextInt(100000000)), "test/" + index); } catch (MqttException e) { e.printStackTrace(); } })); } }
public void deliveryComplete(IMqttDeliveryToken token) { }
public void messageArrived(String topic, MqttMessage message) throws Exception { String msg = new String(message.getPayload()); System.out.println(topic + " " + msg); }
private static void sub(MqttClient sampleClient, String msg, String topic) throws MqttPersistenceException, MqttException { sampleClient.subscribe(topic); }
private static void sub(String str, String clientId, String topic) throws MqttException { MqttClient mqttClient = connect(clientId, userName, passWord); if (mqttClient != null) { sub(mqttClient, str, topic); System.out.println(topic + " " + str); } }
public static void main(String[] args) throws MqttException { sub("message content", "client-id-0", "/test/haha"); }
public static void main(String[] args) throws MqttException { for (int i = 0; i < 100; i++) { final int index = i; service.execute( () -> { try { sub("message content", "client-id-" + index, "test/" + index); } catch (MqttException e) { } }); } }
public ScheduledFuture<?> submit(Runnable runnable) { int initalDelay = serverBean.getInitalDelay(); int period = serverBean.getPeriod(); return scheduledExecutorService.scheduleAtFixedRate( runnable, initalDelay, period, TimeUnit.SECONDS); }
private void initSsl(InitBean serverBean) { ExecutorService executorService = Executors.newCachedThreadPool(); executorService.submit(() -> {}); String algorithm = SystemPropertyUtil.get("ssl.KeyManagerFactory.algorithm"); if (algorithm == null) { algorithm = "SunX509"; } SSLContext serverContext; try { KeyStore ks = KeyStore.getInstance("JKS"); ks.load( SecureSocketSslContextFactory.class.getResourceAsStream(serverBean.getJksFile()), serverBean.getJksStorePassword().toCharArray()); KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm); kmf.init(ks, serverBean.getJksCertificatePassword().toCharArray()); serverContext = SSLContext.getInstance(PROTOCOL); serverContext.init(kmf.getKeyManagers(), null, null); } catch (Exception e) { throw new Error("Failed to initialize the server-side SSLContext", e); } SERVER_CONTEXT = serverContext; }
default <T> void doIfElse(T t, Predicate<T> predicate, Consumer<T> consumer) { if (t != null) { if (predicate.test(t)) { consumer.accept(t); } } }
default <T> void doIfElse( T t, Predicate<T> predicate, Consumer<T> consumer, Consumer<T> consumer2) { if (t != null) { if (predicate.test(t)) { consumer.accept(t); } else { consumer2.accept(t); } } }
default <T> boolean doIf(T t, Predicate<T>... predicates) { if (t != null) { for (Predicate<T> p : predicates) { if (!p.test(t)) { return false; } } return true; } return false; }
default <T> void doIfAnd(T t, Consumer<T> consumer2, Predicate<T>... predicates) { boolean flag = true; if (t != null) { for (Predicate<T> p : predicates) { if (!p.test(t)) { flag = false; break; } } } if (flag) { consumer2.accept(t); } }
default <T> void doIfAnd1( @NotNull T t, @NotNull Consumer<T> consumer2, @NotNull Predicate<T>... predicates) { Predicate<T> one = predicates[0]; int l; if ((l = predicates.length) > 1) { for (int i = 1; i < l; i++) { one = one.and(predicates[i]); } } if (one.test(t)) { consumer2.accept(t); } }
protected void initChannel(SocketChannel ch) throws Exception { initHandler(ch.pipeline(), serverBean); }
public Thread newThread(Runnable r) { return new Thread(r, "LINUX_BOSS_" + index.incrementAndGet()); }
public Thread newThread(Runnable r) { return new Thread(r, "LINUX_WORK_" + index.incrementAndGet()); }
public Thread newThread(Runnable r) { return new Thread(r, "BOSS_" + index.incrementAndGet()); }
public Thread newThread(Runnable r) { return new Thread(r, "WORK_" + index.incrementAndGet()); }
private boolean useEpoll() { return RemotingUtil.isLinuxPlatform() && Epoll.isAvailable(); }
@Override protected void encode( ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> out) throws Exception { if (byteBuf == null) { return; } BinaryWebSocketFrame result = new BinaryWebSocketFrame(); result.content().writeBytes(byteBuf); out.add(result); }
@Override protected void decode( ChannelHandlerContext channelHandlerContext, BinaryWebSocketFrame wsFrame, List<Object> out) throws Exception { ByteBuf buf = wsFrame.content(); buf.retain(); out.add(buf); }
public int messageId() { for (; ; ) { int current = index.get(); int next = (current >= Short.MAX_VALUE ? 0 : current + 1); if (index.compareAndSet(current, next)) { return current; } } }
public void addRecevice(int messageId) { receive.add(messageId); }
public boolean checkRecevice(int messageId) { return receive.contains(messageId); }
public boolean removeRecevice(int messageId) { return receive.remove(messageId); }
public void addSendMqttMessage(int messageId, SendMqttMessage msg) { message.put(messageId, msg); }
public void removeSendMqttMessage(int messageId) { message.remove(messageId); }
public boolean isLogin() { return Optional.ofNullable(this.channel) .map( channel1 -> { AttributeKey<Boolean> _login = AttributeKey.valueOf("login"); return channel1.isActive() && channel1.hasAttr(_login); }) .orElse(false); }
public void close() { Optional.ofNullable(this.channel).ifPresent(channel1 -> channel1.close()); }
public boolean isActive() { return channel != null && this.channel.isActive(); }
public boolean addTopic(Set<String> topics) { return topic.addAll(topics); }
private void pubMessage(Channel channel, SendMqttMessage mqttMessage) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader( MqttMessageType.PUBLISH, true, mqttMessage.getQos(), mqttMessage.isRetain(), 0); MqttPublishVariableHeader mqttPublishVariableHeader = new MqttPublishVariableHeader(mqttMessage.getTopic(), mqttMessage.getMessageId()); MqttPublishMessage mqttPublishMessage = new MqttPublishMessage( mqttFixedHeader, mqttPublishVariableHeader, Unpooled.wrappedBuffer(mqttMessage.getByteBuf())); channel.writeAndFlush(mqttPublishMessage); }
protected void sendAck(MqttMessageType type, SendMqttMessage mqttMessage) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(type, true, MqttQoS.AT_LEAST_ONCE, false, 0x02); MqttMessageIdVariableHeader from = MqttMessageIdVariableHeader.from(mqttMessage.getMessageId()); MqttPubAckMessage mqttPubAckMessage = new MqttPubAckMessage(mqttFixedHeader, from); mqttMessage.getChannel().writeAndFlush(mqttPubAckMessage); }
@Override public void shutdown() { disruptor.shutdown(); }
@Override public void destroy() throws Exception { shutdown(); }
public void addQueue(SendMqttMessage sendMqttMessage) { RingBuffer<MessageEvent> ringBuffer = messageStarter.getRingBuffer(); ConcurrentHashMap<Integer, Disposable> qos = concurrentHashMap.computeIfAbsent( sendMqttMessage.getChannel().id().toString(), (key) -> { ConcurrentHashMap<Integer, Disposable> map = new ConcurrentHashMap<>(); return map; }); qos.put( sendMqttMessage.getMessageId(), Mono.fromRunnable( () -> { ringBuffer.publishEvent((event, sequence) -> event.setMessage(sendMqttMessage)); qos.remove(sendMqttMessage.getMessageId()); }) .delaySubscription(Duration.ofSeconds(10)) .subscribe()); }
@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { log.error("exception", cause); mqttHandlerApi.close(ctx.channel()); }
private void connectBack(Channel channel, MqttConnectReturnCode connectReturnCode) { MqttConnAckVariableHeader mqttConnAckVariableHeader = new MqttConnAckVariableHeader(connectReturnCode, true); MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.CONNACK, false, MqttQoS.AT_MOST_ONCE, false, 0x02); MqttConnAckMessage connAck = new MqttConnAckMessage(mqttFixedHeader, mqttConnAckVariableHeader); channel.writeAndFlush(connAck); }
@Override public void publish(Channel channel, MqttPublishMessage mqttPublishMessage) { mqttChannelService.publishSuccess(channel, mqttPublishMessage); }
@Override public void subscribe(Channel channel, MqttSubscribeMessage mqttSubscribeMessage) { Set<String> topics = mqttSubscribeMessage.payload().topicSubscriptions().stream() .map(mqttTopicSubscription -> mqttTopicSubscription.topicName()) .collect(Collectors.toSet()); mqttChannelService.suscribeSuccess(mqttChannelService.getDeviceId(channel), topics); subBack(channel, mqttSubscribeMessage, topics.size()); }
private void subBack(Channel channel, MqttSubscribeMessage mqttSubscribeMessage, int num) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.SUBACK, false, MqttQoS.AT_MOST_ONCE, false, 0); MqttMessageIdVariableHeader variableHeader = MqttMessageIdVariableHeader.from(mqttSubscribeMessage.variableHeader().messageId()); List<Integer> grantedQoSLevels = new ArrayList<>(num); for (int i = 0; i < num; i++) { grantedQoSLevels.add( mqttSubscribeMessage.payload().topicSubscriptions().get(i).qualityOfService().value()); } MqttSubAckPayload payload = new MqttSubAckPayload(grantedQoSLevels); MqttSubAckMessage mqttSubAckMessage = new MqttSubAckMessage(mqttFixedHeader, variableHeader, payload); channel.writeAndFlush(mqttSubAckMessage); }
@Override public void close(Channel channel) { mqttChannelService.closeSuccess(mqttChannelService.getDeviceId(channel), false); channel.close(); }
@Override public void unsubscribe(Channel channel, MqttUnsubscribeMessage mqttMessage) { List<String> topics1 = mqttMessage.payload().topics(); mqttChannelService.unsubscribe(mqttChannelService.getDeviceId(channel), topics1); unSubBack(channel, mqttMessage.variableHeader().messageId()); }
private void unSubBack(Channel channel, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBACK, false, MqttQoS.AT_MOST_ONCE, false, 0x02); MqttMessageIdVariableHeader variableHeader = MqttMessageIdVariableHeader.from(messageId); MqttUnsubAckMessage mqttUnsubAckMessage = new MqttUnsubAckMessage(mqttFixedHeader, variableHeader); channel.writeAndFlush(mqttUnsubAckMessage); }
@Override public void disconnect(Channel channel) { mqttChannelService.closeSuccess(mqttChannelService.getDeviceId(channel), true); }
@Override public void pubrel(Channel channel, MqttMessage mqttMessage) { MqttMessageIdVariableHeader mqttMessageIdVariableHeader = (MqttMessageIdVariableHeader) mqttMessage.variableHeader(); int messageId = mqttMessageIdVariableHeader.messageId(); Optional.ofNullable( mqttChannelService .getMqttChannel(mqttChannelService.getDeviceId(channel)) .getSendMqttMessage(messageId)) .ifPresent(msg -> msg.setConfirmStatus(ConfirmStatus.COMPLETE)); messageTransfer.removeQueue(channel, messageId); mqttChannelService.doPubrel(channel, messageId); }
@Override public void pubcomp(Channel channel, MqttMessage mqttMessage) { MqttMessageIdVariableHeader mqttMessageIdVariableHeader = (MqttMessageIdVariableHeader) mqttMessage.variableHeader(); int messageId = mqttMessageIdVariableHeader.messageId(); Optional.ofNullable( mqttChannelService .getMqttChannel(mqttChannelService.getDeviceId(channel)) .getSendMqttMessage(messageId)) .ifPresent(msg -> msg.setConfirmStatus(ConfirmStatus.COMPLETE)); messageTransfer.removeQueue(channel, messageId); }
protected boolean deleteChannel(String topic, MqttChannel mqttChannel) { return Optional.ofNullable(topic) .map( s -> { mqttChannelCache.invalidate(s); return cacheMap.delete(getTopic(s), mqttChannel); }) .orElse(false); }
protected boolean addChannel(String topic, MqttChannel mqttChannel) { return Optional.ofNullable(topic) .map( s -> { mqttChannelCache.invalidate(s); return cacheMap.putData(getTopic(s), mqttChannel); }) .orElse(false); }
protected void sendQosConfirmMsg( MqttQoS qos, MqttChannel mqttChannel, String topic, byte[] bytes) { if (mqttChannel.isLogin()) { int messageId = mqttChannel.messageId(); switch (qos) { case AT_LEAST_ONCE: mqttChannel.addSendMqttMessage( messageId, sendQos1Msg(mqttChannel.getChannel(), topic, false, bytes, messageId)); break; case EXACTLY_ONCE: mqttChannel.addSendMqttMessage( messageId, sendQos2Msg(mqttChannel.getChannel(), topic, false, bytes, messageId)); break; } } }
private SendMqttMessage sendQos1Msg( Channel channel, String topic, boolean isDup, byte[] byteBuf, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBLISH, isDup, MqttQoS.AT_LEAST_ONCE, false, 0); MqttPublishVariableHeader mqttPublishVariableHeader = new MqttPublishVariableHeader(topic, messageId); MqttPublishMessage mqttPublishMessage = new MqttPublishMessage( mqttFixedHeader, mqttPublishVariableHeader, Unpooled.wrappedBuffer(byteBuf)); channel.writeAndFlush(mqttPublishMessage); return addQueue(channel, messageId, topic, byteBuf, MqttQoS.AT_LEAST_ONCE, ConfirmStatus.PUB); }
protected void sendQos0Msg(Channel channel, String topic, byte[] byteBuf) { if (channel != null) { sendQos0Msg(channel, topic, byteBuf, 0); } }
private void sendQos0Msg(Channel channel, String topic, byte[] byteBuf, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBLISH, false, MqttQoS.AT_MOST_ONCE, false, 0); MqttPublishVariableHeader mqttPublishVariableHeader = new MqttPublishVariableHeader(topic, messageId); MqttPublishMessage mqttPublishMessage = new MqttPublishMessage( mqttFixedHeader, mqttPublishVariableHeader, Unpooled.wrappedBuffer(byteBuf)); channel.writeAndFlush(mqttPublishMessage); }
private SendMqttMessage sendQos2Msg( Channel channel, String topic, boolean isDup, byte[] byteBuf, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBLISH, isDup, MqttQoS.EXACTLY_ONCE, false, 0); MqttPublishVariableHeader mqttPublishVariableHeader = new MqttPublishVariableHeader(topic, messageId); MqttPublishMessage mqttPublishMessage = new MqttPublishMessage( mqttFixedHeader, mqttPublishVariableHeader, Unpooled.wrappedBuffer(byteBuf)); channel.writeAndFlush(mqttPublishMessage); return addQueue(channel, messageId, topic, byteBuf, MqttQoS.EXACTLY_ONCE, ConfirmStatus.PUB); }
protected void sendPubBack(Channel channel, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBACK, false, MqttQoS.AT_MOST_ONCE, false, 0x02); MqttMessageIdVariableHeader from = MqttMessageIdVariableHeader.from(messageId); MqttPubAckMessage mqttPubAckMessage = new MqttPubAckMessage(mqttFixedHeader, from); channel.writeAndFlush(mqttPubAckMessage); }
protected void sendPubRec(MqttChannel mqttChannel, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBREC, false, MqttQoS.AT_LEAST_ONCE, false, 0x02); MqttMessageIdVariableHeader from = MqttMessageIdVariableHeader.from(messageId); MqttPubAckMessage mqttPubAckMessage = new MqttPubAckMessage(mqttFixedHeader, from); Channel channel = mqttChannel.getChannel(); channel.writeAndFlush(mqttPubAckMessage); SendMqttMessage sendMqttMessage = addQueue(channel, messageId, null, null, null, ConfirmStatus.PUBREC); mqttChannel.addSendMqttMessage(messageId, sendMqttMessage); }
protected void sendPubRel(Channel channel, boolean isDup, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBREL, isDup, MqttQoS.AT_LEAST_ONCE, false, 0x02); MqttMessageIdVariableHeader from = MqttMessageIdVariableHeader.from(messageId); MqttPubAckMessage mqttPubAckMessage = new MqttPubAckMessage(mqttFixedHeader, from); channel.writeAndFlush(mqttPubAckMessage); }
protected void sendToPubComp(Channel channel, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBCOMP, false, MqttQoS.AT_MOST_ONCE, false, 0x02); MqttMessageIdVariableHeader from = MqttMessageIdVariableHeader.from(messageId); MqttPubAckMessage mqttPubAckMessage = new MqttPubAckMessage(mqttFixedHeader, from); channel.writeAndFlush(mqttPubAckMessage); }
private SendMqttMessage addQueue( Channel channel, int messageId, String topic, byte[] datas, MqttQoS mqttQoS, ConfirmStatus confirmStatus) { SendMqttMessage build = SendMqttMessage.builder() .channel(channel) .confirmStatus(confirmStatus) .messageId(messageId) .topic(topic) .qos(mqttQoS) .byteBuf(datas) .build(); transfer.addQueue(build); return build; }
public void saveSessionMsg(String deviceId, SessionMessage sessionMessage) { ConcurrentLinkedQueue<SessionMessage> sessionMessages = queueSession.getOrDefault(deviceId, new ConcurrentLinkedQueue<>()); boolean flag; do { flag = sessionMessages.add(sessionMessage); } while (!flag); queueSession.put(deviceId, sessionMessages); }
public boolean putData(K[] topic, V v) { if (topic.length == 1) { Node<K, V> kvNode = buildOne(topic[0], v); if (kvNode != null && kvNode.topic.equals(topic[0])) { return true; } } else { Node<K, V> kvNode = buildOne(topic[0], null); for (int i = 1; i < topic.length; i++) { if (i == topic.length - 1) { kvNode = kvNode.putNextValue(topic[i], v); } else { kvNode = kvNode.putNextValue(topic[i], null); } } } return true; }
public boolean delete(K[] ks, V v) { if (ks.length == 1) { return datas.get(ks[0]).delValue(v); } else { Node<K, V> kvNode = datas.get(ks[0]); for (int i = 1; i < ks.length && kvNode != null; i++) { kvNode = kvNode.getNext(ks[i]); } return kvNode.delValue(v); } }
public Node<K, V> buildOne(K k, V v) { Node<K, V> node = this.datas.computeIfAbsent( k, key -> { Node<K, V> kObjectNode = new Node<>(k); return kObjectNode; }); if (v != null) { node.put(v); } return node; }
public boolean delValue(V v) { return vs.remove(v); }
public Node<K, V> putNextValue(K k, V v) { Node<K, V> kvNode = map.computeIfAbsent( k, key -> { Node<K, V> node = new Node<>(k); return node; }); if (v != null) { kvNode.put(v); } return kvNode; }
public void open() { if (serverBean != null) { bootstrapServer = new NettyBootstrapServer(); bootstrapServer.setServerBean(serverBean); bootstrapServer.start(); } }
public void close() { if (bootstrapServer != null) { bootstrapServer.shutdown(); } }
public static void main(String[] args) { ConfigurableApplicationContext run = run(ServerApplication.class, args); }
@Override public boolean authorized(String username, String password) { return true; }
public Producer connect(ConnectOptions connectOptions) { connectTo(connectOptions); return this; }
@Override public void pub(String topic, String message, int qos) { pub(topic, message, false, qos); }
@Override public void pub(String topic, String message, boolean retained) { pub(topic, message, retained, 0); }
@Override public void pub(String topic, String message) { pub(topic, message, false, 0); }
@Override public void pub(String topic, String message, boolean retained, int qos) { Optional.ofNullable(buildMqttMessage(topic, message, retained, qos, false, true)) .ifPresent( sendMqttMessage -> { pubMessage(channel, sendMqttMessage); }); }
private SendMqttMessage buildMqttMessage( String topic, String message, boolean retained, int qos, boolean dup, boolean time) { int messageId = 0; if (qos != 0) { messageId = MessageId.messageId(); } try { return SendMqttMessage.builder() .messageId(messageId) .Topic(topic) .dup(dup) .retained(retained) .qos(qos) .confirmStatus(ConfirmStatus.PUB) .timestamp(System.currentTimeMillis()) .payload(message.getBytes("Utf-8")) .build(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return null; }
@Override public void sub(SubMessage... subMessages) { Optional.ofNullable(getSubTopics(subMessages)) .ifPresent( mqttTopicSubscriptions -> { int messageId = MessageId.messageId(); subMessage(channel, mqttTopicSubscriptions, messageId); topics.addAll(mqttTopicSubscriptions); }); }
@Override public void unsub(List<String> topics) { Optional.ofNullable(topics) .ifPresent( strings -> { int messageId = MessageId.messageId(); super.unsub(strings, messageId); }); }
@Override public void unsub() { unsub(toList()); }
private List<String> toList() { return Optional.ofNullable(topics) .map( mqttTopicSubscriptions -> mqttTopicSubscriptions.stream() .map(mqttTopicSubscription -> mqttTopicSubscription.topicName()) .collect(Collectors.toList())) .orElse(null); }
protected void initHandler( ChannelPipeline channelPipeline, ConnectOptions clientBean, MqttHander mqttHander) { if (clientBean.isSsl()) { initSsl(); SSLEngine engine = CLIENT_CONTEXT.createSSLEngine(); engine.setUseClientMode(true); channelPipeline.addLast("ssl", new SslHandler(engine)); } channelPipeline.addLast("decoder", new MqttDecoder()); channelPipeline.addLast("encoder", MqttEncoder.INSTANCE); channelPipeline.addLast(new IdleStateHandler(clientBean.getHeart(), 0, 0)); channelPipeline.addLast(mqttHander); }
private void initSsl() { SSLContext clientContext; try { clientContext = SSLContext.getInstance(PROTOCOL); clientContext.init(null, SecureSokcetTrustManagerFactory.getTrustManagers(), null); } catch (Exception e) { throw new Error("Failed to initialize the client-side SSLContext", e); } CLIENT_CONTEXT = clientContext; }
@Override public void disConnect() { sendDisConnect(channel); }
@Override public void pubRecMessage(Channel channel, int messageId) { SendMqttMessage sendMqttMessage = SendMqttMessage.builder() .messageId(messageId) .confirmStatus(ConfirmStatus.PUBREC) .timestamp(System.currentTimeMillis()) .build(); Cache.put(messageId, sendMqttMessage); boolean flag; do { flag = sacnScheduled.addQueue(sendMqttMessage); } while (!flag); super.pubRecMessage(channel, messageId); }
protected void initPool(int seconds) { this.sacnScheduled = new SacnScheduled(this, seconds); sacnScheduled.start(); }
@Override protected void subMessage( Channel channel, List<MqttTopicSubscription> mqttTopicSubscriptions, int messageId) { ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleAtFixedRate( () -> { if (channel.isActive()) { subMessage(channel, mqttTopicSubscriptions, messageId); } }, 10, 10, TimeUnit.SECONDS); channel.attr(getKey(Integer.toString(messageId))).setIfAbsent(scheduledFuture); super.subMessage(channel, mqttTopicSubscriptions, messageId); }
public void unsub(List<String> topics, int messageId) { ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleAtFixedRate( () -> { if (channel.isActive()) { unSubMessage(channel, topics, messageId); } }, 10, 10, TimeUnit.SECONDS); channel.attr(getKey(Integer.toString(messageId))).setIfAbsent(scheduledFuture); unSubMessage(channel, topics, messageId); }
@Override public void close() { if (nettyBootstrapClient != null) { nettyBootstrapClient.shutdown(); } if (sacnScheduled != null) { sacnScheduled.close(); } }
@Override protected void initChannel(SocketChannel ch) throws Exception { initHandler( ch.pipeline(), connectOptions, new DefaultMqttHandler( connectOptions, new MqttHandlerServiceService(), AbsMqttProducer.this, mqttListener)); }
private void checkConnectOptions(ConnectOptions connectOptions) { ConnectOptions.MqttOpntions mqtt = connectOptions.getMqtt(); Optional.ofNullable(mqtt.getPassword()).ifPresent(s -> mqtt.setHasPassword(true)); Optional.ofNullable(mqtt.getUserName()).ifPresent(s -> mqtt.setHasUserName(true)); Optional.ofNullable(mqtt.getWillTopic()).ifPresent(s -> mqtt.setHasWillFlag(true)); }
protected void subMessage( Channel channel, List<MqttTopicSubscription> mqttTopicSubscriptions, int messageId) { MqttSubscribePayload mqttSubscribePayload = new MqttSubscribePayload(mqttTopicSubscriptions); MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.SUBSCRIBE, false, MqttQoS.AT_LEAST_ONCE, false, 0); MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader.from(messageId); MqttSubscribeMessage mqttSubscribeMessage = new MqttSubscribeMessage( mqttFixedHeader, mqttMessageIdVariableHeader, mqttSubscribePayload); channel.writeAndFlush(mqttSubscribeMessage); }
protected void sendAck(MqttMessageType type, boolean isDup, Channel channel, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(type, isDup, MqttQoS.AT_LEAST_ONCE, false, 0x02); MqttMessageIdVariableHeader from = MqttMessageIdVariableHeader.from(messageId); MqttPubAckMessage mqttPubAckMessage = new MqttPubAckMessage(mqttFixedHeader, from); channel.writeAndFlush(mqttPubAckMessage); }
protected void pubRecMessage(Channel channel, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBREC, false, MqttQoS.AT_LEAST_ONCE, false, 0x02); MqttMessageIdVariableHeader from = MqttMessageIdVariableHeader.from(messageId); MqttMessage mqttPubAckMessage = new MqttMessage(mqttFixedHeader, from); channel.writeAndFlush(mqttPubAckMessage); }
protected void unSubMessage(Channel channel, List<String> topic, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBSCRIBE, false, MqttQoS.AT_LEAST_ONCE, false, 0x02); MqttMessageIdVariableHeader variableHeader = MqttMessageIdVariableHeader.from(messageId); MqttUnsubscribePayload MqttUnsubscribeMessage = new MqttUnsubscribePayload(topic); MqttUnsubscribeMessage mqttUnsubscribeMessage = new MqttUnsubscribeMessage(mqttFixedHeader, variableHeader, MqttUnsubscribeMessage); channel.writeAndFlush(mqttUnsubscribeMessage); }
protected void sendDisConnect(Channel channel) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.DISCONNECT, false, MqttQoS.AT_LEAST_ONCE, false, 0x02); MqttMessage mqttMessage = new MqttMessage(mqttFixedHeader); channel.writeAndFlush(mqttMessage); }
public static boolean put(Integer messageId, SendMqttMessage mqttMessage) { return message.put(messageId, mqttMessage) == null; }
public static SendMqttMessage get(Integer messageId) { return message.get(messageId); }
public static SendMqttMessage del(Integer messageId) { return message.remove(messageId); }
private void publish(Channel channel, MqttPublishMessage mqttMessage) { MqttFixedHeader mqttFixedHeader = mqttMessage.fixedHeader(); MqttPublishVariableHeader mqttPublishVariableHeader = mqttMessage.variableHeader(); ByteBuf payload = mqttMessage.payload(); byte[] bytes = ByteBufUtil.copyByteBuf(payload); if (mqttListener != null) { mqttListener.callBack(mqttPublishVariableHeader.topicName(), new String(bytes)); } switch (mqttFixedHeader.qosLevel()) { case AT_MOST_ONCE: break; case AT_LEAST_ONCE: mqttHandlerApi.pubBackMessage(channel, mqttPublishVariableHeader.messageId()); break; case EXACTLY_ONCE: mqttProducer.pubRecMessage(channel, mqttPublishVariableHeader.messageId()); break; } }
@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { if (mqttListener != null) { mqttListener.callThrowable(cause); } }
@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { mqttProducer.getNettyBootstrapClient().doubleConnect(); }
public void start() { Scheduled scheduled = new ScheduledPool(); this.submit = scheduled.submit(this); }
public void close() { if (submit != null && !submit.isCancelled()) { submit.cancel(true); } }
private boolean checkTime(SendMqttMessage poll) { return System.currentTimeMillis() - poll.getTimestamp() >= seconds * 1000; }
public ScheduledFuture<?> submit(Runnable runnable) { return scheduledExecutorService.scheduleAtFixedRate(runnable, 2, 2, TimeUnit.SECONDS); }
public boolean addQueue(SendMqttMessage t) { return queue.add(t); }
public boolean addQueues(List<SendMqttMessage> ts) { return queue.addAll(ts); }
@Override public void puback(Channel channel, MqttMessage mqttMessage) { MqttMessageIdVariableHeader messageIdVariableHeader = (MqttMessageIdVariableHeader) mqttMessage.variableHeader(); int messageId = messageIdVariableHeader.messageId(); Optional.ofNullable(Cache.del(messageId)) .ifPresent( sendMqttMessage -> { sendMqttMessage.setConfirmStatus(ConfirmStatus.COMPLETE); }); }
@Override public void pubrec(Channel channel, MqttMessage mqttMessage) { MqttMessageIdVariableHeader messageIdVariableHeader = (MqttMessageIdVariableHeader) mqttMessage.variableHeader(); int messageId = messageIdVariableHeader.messageId(); MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBREL, false, MqttQoS.AT_LEAST_ONCE, false, 0x02); MqttMessageIdVariableHeader from = MqttMessageIdVariableHeader.from(messageId); MqttMessage mqttPubAckMessage = new MqttMessage(mqttFixedHeader, from); Optional.ofNullable(Cache.get(messageId)) .ifPresent( sendMqttMessage -> { sendMqttMessage.setTimestamp(System.currentTimeMillis()); sendMqttMessage.setConfirmStatus(ConfirmStatus.PUBREL); }); channel.writeAndFlush(mqttPubAckMessage); }
@Override public void pubrel(Channel channel, MqttMessage mqttMessage) { MqttMessageIdVariableHeader messageIdVariableHeader = (MqttMessageIdVariableHeader) mqttMessage.variableHeader(); int messageId = messageIdVariableHeader.messageId(); MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBCOMP, false, MqttQoS.AT_MOST_ONCE, false, 0x02); MqttMessageIdVariableHeader from = MqttMessageIdVariableHeader.from(messageId); MqttMessage mqttPubAckMessage = new MqttMessage(mqttFixedHeader, from); Optional.ofNullable(Cache.del(messageId)) .ifPresent( sendMqttMessage -> { sendMqttMessage.setConfirmStatus(ConfirmStatus.COMPLETE); }); channel.writeAndFlush(mqttPubAckMessage); }
@Override public void pubcomp(Channel channel, MqttMessage mqttMessage) { MqttMessageIdVariableHeader messageIdVariableHeader = (MqttMessageIdVariableHeader) mqttMessage.variableHeader(); int messageId = messageIdVariableHeader.messageId(); Optional.ofNullable(Cache.del(messageId)) .ifPresent( sendMqttMessage -> { sendMqttMessage.setConfirmStatus(ConfirmStatus.COMPLETE); }); }
public void suback(Channel channel, MqttSubAckMessage mqttMessage) { ScheduledFuture<?> scheduledFuture = channel.attr(getKey(Integer.toString(mqttMessage.variableHeader().messageId()))).get(); if (scheduledFuture != null) { scheduledFuture.cancel(true); } }
@Override public void pubBackMessage(Channel channel, int messageId) { MqttFixedHeader mqttFixedHeader = new MqttFixedHeader(MqttMessageType.PUBACK, false, MqttQoS.AT_LEAST_ONCE, false, 0x02); MqttMessageIdVariableHeader from = MqttMessageIdVariableHeader.from(messageId); MqttPubAckMessage mqttPubAckMessage = new MqttPubAckMessage(mqttFixedHeader, from); channel.writeAndFlush(mqttPubAckMessage); }
@Override public void unsubBack(Channel channel, MqttMessage mqttMessage) { int messageId; if (mqttMessage instanceof MqttUnsubAckMessage) { MqttUnsubAckMessage mqttUnsubAckMessage = (MqttUnsubAckMessage) mqttMessage; messageId = mqttUnsubAckMessage.variableHeader().messageId(); } else { MqttMessageIdVariableHeader o = (MqttMessageIdVariableHeader) mqttMessage.variableHeader(); messageId = o.messageId(); } if (messageId > 0) { ScheduledFuture<?> scheduledFuture = channel.attr(getKey(Integer.toString(messageId))).get(); if (!scheduledFuture.isCancelled()) { scheduledFuture.cancel(true); } } }
@Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = (ConfigurableApplicationContext) applicationContext; }
@Override public void destroy() throws Exception { Producer bean = applicationContext.getBean(Producer.class); if (bean != null) { bean.close(); } }
public static void main(String[] args) throws Exception { CuratorFramework client = clientTwo(); setListenterThreeThree(client); }
@Override public void nodeChanged() throws Exception { System.out.println("the test node is change and result is :"); System.out.println("path : " + nodeCache.getCurrentData().getPath()); System.out.println("data : " + new String(nodeCache.getCurrentData().getData())); System.out.println("stat : " + nodeCache.getCurrentData().getStat()); }
public void init( String zookeeperServer, int connectionTimeout, int sessionTimeout, int maxRetries, int retriesSleepTime, String namespace, ZkStateListener listener) { if (zkClient == null) { zkClient = CuratorFrameworkFactory.builder() .connectString(zookeeperServer) .connectionTimeoutMs(connectionTimeout) .sessionTimeoutMs(sessionTimeout) .namespace(namespace) .retryPolicy(new RetryNTimes(maxRetries, retriesSleepTime)) .build(); } zkClient .getConnectionStateListenable() .addListener( (curatorFramework, connectionState) -> { pathChildrenCaches.clear(); nodeCaches.clear(); treeCaches.clear(); if (connectionState == ConnectionState.CONNECTED) { listener.connectedEvent(curatorFramework, connectionState); } else if (connectionState == ConnectionState.RECONNECTED) { listener.ReconnectedEvent(curatorFramework, connectionState); } else if (connectionState == ConnectionState.LOST) { listener.lostEvent(curatorFramework, connectionState); } }); zkClient.start(); }
public void destory() { pathChildrenCaches.stream().forEach(cache -> CloseableUtils.closeQuietly(cache)); pathChildrenCaches.clear(); pathChildrenCaches = null; nodeCaches.stream().forEach(cache -> CloseableUtils.closeQuietly(cache)); nodeCaches.clear(); nodeCaches = null; treeCaches.stream().forEach(cache -> CloseableUtils.closeQuietly(cache)); treeCaches.clear(); treeCaches = null; if (zkClient != null) { CloseableUtils.closeQuietly(zkClient); } }
public boolean createNode(String path, String data, CreateMode mode) { if (!ObjectUtils.allNotNull(zkClient, path)) { return Boolean.FALSE; } try { Stat stat = exists(path); if (stat == null) { mode = mode == null ? CreateMode.PERSISTENT : mode; String opResult; if (ObjectUtils.allNotNull(data)) { opResult = zkClient .create() .creatingParentContainersIfNeeded() .withMode(mode) .forPath(path, data.getBytes(Charsets.UTF_8)); } else { opResult = zkClient.create().creatingParentContainersIfNeeded().withMode(mode).forPath(path); } return Objects.equal(opResult, path); } return Boolean.TRUE; } catch (Exception e) { log.error("create node fail! path: {}, error: {}", path, e); } return Boolean.FALSE; }
public boolean deleteNode(String path, Integer version) { if (!ObjectUtils.allNotNull(zkClient, path)) { return Boolean.FALSE; } try { Stat stat = exists(path); if (stat != null) { if (version == null) { zkClient.delete().deletingChildrenIfNeeded().forPath(path); } else { zkClient.delete().deletingChildrenIfNeeded().withVersion(version).forPath(path); } } return Boolean.TRUE; } catch (Exception e) { log.error("delete node fail! path: {}, error: {}", path, e); } return Boolean.FALSE; }
public boolean deleteNode(String path) { return deleteNode(path, null); }
public Stat exists(String path) { if (!ObjectUtils.allNotNull(zkClient, path)) { return null; } try { return zkClient.checkExists().forPath(path); } catch (Exception e) { log.error("check node exists fail! path: {}, error: {}", path, e); } return null; }
public boolean checkExists(String path) { return exists(path) == null ? Boolean.FALSE : Boolean.TRUE; }
public Map<String, String> readTargetChildsData(String path) { if (!ObjectUtils.allNotNull(zkClient, path)) { return null; } Map<String, String> map = null; try { Stat stat = exists(path); if (stat != null) { List<String> childrens = zkClient.getChildren().forPath(path); GetDataBuilder dataBuilder = zkClient.getData(); if (childrens != null) { map = childrens.stream() .collect( Collectors.toMap( Function.identity(), (child) -> { try { return new String( dataBuilder.forPath(ZKPaths.makePath(path, child)), Charsets.UTF_8); } catch (Exception e1) { return null; } })); } } } catch (Exception e) { log.error("get target childs data fail!, path:{} , error:{}", path, e); } return map; }
@Override public void connectedEvent(CuratorFramework curator, ConnectionState state) {}
@Override public void ReconnectedEvent(CuratorFramework curator, ConnectionState state) {}
@Override public void lostEvent(CuratorFramework curator, ConnectionState state) {}
default void connectedEvent(CuratorFramework curator, ConnectionState state) {}
default void ReconnectedEvent(CuratorFramework curator, ConnectionState state) {}
default void lostEvent(CuratorFramework curator, ConnectionState state) {}
@Override public void doTimeOut(Channel channel, IdleStateEvent evt) { heart(channel, evt); }
@Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, MqttMessage mqttMessage) throws Exception { MqttFixedHeader mqttFixedHeader = mqttMessage.fixedHeader(); Optional.ofNullable(mqttFixedHeader) .ifPresent(mqttFixedHeader1 -> doMessage(channelHandlerContext, mqttMessage)); }
@Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception { if (evt instanceof IdleStateEvent) { mqttHandlerApi.doTimeOut(ctx.channel(), (IdleStateEvent) evt); } super.userEventTriggered(ctx, evt); }
protected void afterExecute(Runnable r, Throwable t) { submittedTasksCount.decrementAndGet(); }
public boolean force(Runnable o) { if (threadPoolExecutor.isShutdown()) { throw new RejectedExecutionException( "Executor not running, can't force a command into the queue"); } return super.offer(o); }
@Override public Thread newThread(Runnable r) { Thread thread = new Thread(threadGroup, r, namePrefix + currentThreadNumber.getAndIncrement(), 0); thread.setDaemon(isDaemon); thread.setPriority(priority); return thread; }
public static byte[] copyByteBuf(ByteBuf byteBuf) { byte[] bytes = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(bytes); return bytes; }
private long tilNextMillis(final long lastTimestamp) { long timestamp = this.timeGen(); while (timestamp <= lastTimestamp) { timestamp = this.timeGen(); } return timestamp; }
private long timeGen() { return System.currentTimeMillis(); }
public static int messageId() { for (; ; ) { int current = index.get(); int next = (current >= Integer.MAX_VALUE ? 0 : current + 1); if (index.compareAndSet(current, next)) { return current; } } }
public static boolean isWindowsPlatform() { return isWindowsPlatform; }
public static Selector openSelector() throws IOException { Selector result = null; if (isLinuxPlatform()) { try { final Class<?> providerClazz = Class.forName("sun.nio.ch.EPollSelectorProvider"); if (providerClazz != null) { try { final Method method = providerClazz.getMethod("provider"); if (method != null) { final SelectorProvider selectorProvider = (SelectorProvider) method.invoke(null); if (selectorProvider != null) { result = selectorProvider.openSelector(); } } } catch (final Exception e) { log.warn("Open ePoll Selector for linux platform exception", e); } } } catch (final Exception e) { } } if (result == null) { result = Selector.open(); } return result; }
public static boolean isLinuxPlatform() { return isLinuxPlatform; }
public static String normalizeHostAddress(final InetAddress localHost) { if (localHost instanceof Inet6Address) { return "[" + localHost.getHostAddress() + "]"; } else { return localHost.getHostAddress(); } }
public static SocketAddress string2SocketAddress(final String addr) { String[] s = addr.split(":"); InetSocketAddress isa = new InetSocketAddress(s[0], Integer.parseInt(s[1])); return isa; }
public static String socketAddress2String(final SocketAddress addr) { StringBuilder sb = new StringBuilder(); InetSocketAddress inetSocketAddress = (InetSocketAddress) addr; sb.append(inetSocketAddress.getAddress().getHostAddress()); sb.append(":"); sb.append(inetSocketAddress.getPort()); return sb.toString(); }
public static SocketChannel connect(SocketAddress remote) { return connect(remote, 1000 * 5); }
public static SocketChannel connect(SocketAddress remote, final int timeoutMillis) { SocketChannel sc = null; try { sc = SocketChannel.open(); sc.configureBlocking(true); sc.socket().setSoLinger(false, -1); sc.socket().setTcpNoDelay(true); sc.socket().setReceiveBufferSize(1024 * 64); sc.socket().setSendBufferSize(1024 * 64); sc.socket().connect(remote, timeoutMillis); sc.configureBlocking(false); return sc; } catch (Exception e) { if (sc != null) { try { sc.close(); } catch (IOException e1) { e1.printStackTrace(); } } } return null; }
@Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { if (SpringBeanUtils.applicationContext == null) { SpringBeanUtils.applicationContext = applicationContext; } }
public String toByteArray(InputStream fin) { int i = -1; StringBuilder buf = new StringBuilder(); try { while ((i = fin.read()) != -1) { if (buf.length() > 0) buf.append(","); buf.append("(byte)"); buf.append(i); } } catch (Throwable e) { ; } return buf.toString(); }
@Override public void checkClientTrusted(X509Certificate[] chain, String authType) { System.err.println("UNKNOWN CLIENT CERTIFICATE: " + chain[0].getSubjectDN()); }
@Override public void checkServerTrusted(X509Certificate[] chain, String authType) { System.err.println("UNKNOWN SERVER CERTIFICATE: 222 " + chain[0].getSubjectDN()); }
@Override protected TrustManager[] engineGetTrustManagers() { return getTrustManagers(); }
@Override protected void engineInit(KeyStore keystore) throws KeyStoreException { }
@Override protected void engineInit(ManagerFactoryParameters managerFactoryParameters) throws InvalidAlgorithmParameterException { }
public static InputStream asInputStream() { return new ByteArrayInputStream(CERT_BYTES); }
public static String intranetIp() { try { return InetAddress.getLocalHost().getHostAddress(); } catch (Exception e) { throw new RuntimeException(e); } }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { }
@Override protected RALSlot slotInner(int index) { return slots[index]; }
@Override protected RALSlot slotInner(int index) { if (index < a.length) { return a.slotInner(index); } else { return b.slotInner(index - a.length); } }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { RALExprSlice outASlice = out.slice(0, a.length); RALExprSlice outBSlice = out.slice(a.length, b.length); a.readCompileInner(outASlice, context); b.readCompileInner(outBSlice, context); }
@Override protected void readInplaceCompileInner(RALVarVA[] out, CompileContext context) { RALVarVA[] outA = new RALVarVA[a.length]; RALVarVA[] outB = new RALVarVA[b.length]; System.arraycopy(out, 0, outA, 0, a.length); System.arraycopy(out, a.length, outB, 0, b.length); a.readInplaceCompile(outA, context); b.readInplaceCompile(outB, context); }
@Override protected void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { if (index < a.length) { a.writeCompileInner(index, input, inputExactType, context); } else { b.writeCompileInner(index - a.length, input, inputExactType, context); } }
@Override protected RALExprSlice sliceInner(int base, int length) { if (base >= a.length) { return b.slice(base - a.length, length); } else if (base + length <= a.length) { return a.slice(base, length); } int aAmount = a.length - base; int bAmount = length - aAmount; return concat(a.slice(base, aAmount), b.slice(0, bAmount)); }
@Override protected RALSlot slotInner(int index) { return source.slotInner(sliceBase + index); }
@Override protected RALExprSlice sliceInner(int b, int l) { return source.slice(sliceBase + b, l); }
@Override protected RALExprSlice tryConcatWithInner(RALExprSlice b) { if (b instanceof QuasiSlice) { QuasiSlice qs = (QuasiSlice) b; if (qs.source == source) { if (qs.sliceBase == sliceBase + length) return source.slice(sliceBase, length + qs.length); } } return super.tryConcatWithInner(b); }
@Override public String toString() { return "unresolved slice [" + sliceBase + " len " + length + "]: " + source; }
@Override public RALExprSlice resolveInner(ScopeContext scope) { final Object[] resolved = RALInlineStatement.resolveParts(parts, scope); final RALSlot slot = new RALSlot(scope.world.types.gAny, perm); return new Resolved(slot, resolved); }
@Override protected RALSlot slotInner(int index) { return slot; }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { try (CompileContext c2 = context.forkVAEH()) { out.writeCompile( 0, RALInlineStatement.compileResolvedParts(resolved, c2), RALType.Major.Unknown, c2); } }
@Override protected void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { if (!slot.perms.write) throw new RuntimeException("Write to unwritable inline expression"); try (CompileContext c2 = context.forkVAEH()) { RALVarString.writeSet( c2.writer, RALInlineStatement.compileResolvedParts(resolved, c2), input, inputExactType); } }
public static RALExprUR of(RALExprUR... c) { LinkedList<RALExprUR> decomposed = new LinkedList<>(); for (RALExprUR ur : c) for (RALExprUR e : ur.decomposite()) decomposed.add(e); c = decomposed.toArray(new RALExprUR[0]); if (c.length == 1) return c[0]; return new RALExprGroupUR(c); }
@Override public RALExprSlice resolveInner(ScopeContext context) { RALExprSlice res = RALExprSlice.EMPTY; for (int i = 0; i < contents.length; i++) res = RALExprSlice.concat(res, contents[i].resolve(context)); return res; }
@Override public RALExprUR[] decomposite() { return contents; }
@Override public String toString() { return "err:" + this; }
@Override protected RALSlot slotInner(int index) { throw new RuntimeException(errorText); }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { throw new RuntimeException(errorText); }
@Override protected void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { throw new RuntimeException(errorText); }
@Override protected void readInplaceCompileInner(RALVarVA[] out, CompileContext context) { throw new RuntimeException(errorText); }
@Override public RALExprSlice resolveInner(ScopeContext context) { RALExprSlice baseR = base.resolve(context); RALExprSlice paramR = params.resolve(context); try { baseR .assert1ReadType() .implicitlyCastOrThrow(context.world.types.gLambdaAny, base, "for use in call"); } catch (Exception ex) { throw new RuntimeException("Type error trying to call " + base, ex); } return makeResolved(baseR, paramR, context); }
public static RALExprSlice makeResolved(String name, RALExprSlice paramR, ScopeContext context) { return makeResolved(new RALAmbiguousID(null, name).resolve(context), paramR, context); }
public static RALExprSlice makeResolved( RALExprSlice base, RALExprSlice paramR, ScopeContext context) { RALCallable rc = base.getCallable(0); if (rc == null) throw new RuntimeException( "Unable to actually get RALCallable from " + base + ". You are probably trying to use a lambda in an unsupported manner (i.e. returning" + " it from a macro, casting it via 'any')."); return rc.instance(paramR, context); }
@Override protected RALSlot slotInner(int index) { return varSlot; }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { out.writeCompile(0, getInlineCAOS(0, false, context), type.majorType, context); }
@Override protected void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { if (!isWritable) throw new RuntimeException("Var " + this + " is not writable"); writeSet( context.writer, getInlineCAOS(index, true, context), input, inputExactType.autoPromote(type.majorType)); }
public static void writeSet( CodeWriter writer, String code, String input, RALType.Major inputExactType) { String set; switch (inputExactType) { case Agent: set = "seta "; break; case String: set = "sets "; break; case Value: set = "setv "; break; case ByteString: case Lambda: throw new RuntimeException( "Major type of " + input + " (" + inputExactType + ") can't be stored by definition."); default: throw new RuntimeException( "Unknown major type of " + input + " (" + inputExactType + ") - you will need to cast this value"); } if (code.equals(input)) return; writer.writeCode(set + code + " " + input); }
@Override public String toString() { return (isWritable ? "SVW" : "SV") + "[" + code + "!" + type + "]"; }
@Override public RALExprSlice resolveInner(ScopeContext scope) { return this; }
@Override public RALExprSlice resolveInner(ScopeContext context) { return this; }
@Override protected RALExprSlice sliceInner(int base, int length) { return new RALDiscard(anySlot, length); }
@Override protected RALSlot slotInner(int index) { return anySlot; }
@Override protected void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { try (CompileContext ccr = context.forkVAEH()) { RALVarVA rsv = ccr.allocVA(ccr.typeSystem.gAny, "RALDiscard tmp"); rsv.writeCompile(0, input, inputExactType, ccr); } }
@Override public RALConstant resolveConst(TypeSystem ts, Set<String> scopedVariables) { RALConstant rc = base.resolveConst(ts, scopedVariables); if (rc instanceof RALConstant.Single) { if (doImplicitCheck) ((RALConstant.Single) rc).type.assertImpCast(target); return ((RALConstant.Single) rc).cast(target); } return null; }
public static RALCast of(RALExprUR bx, RALType t) { return of(bx, t, false); }
public static RALCast of(RALExprUR bx, RALType t, boolean checked) { if (bx instanceof RALCast) if (!((RALCast) bx).doImplicitCheck) bx = ((RALCast) bx).base; return new RALCast(bx, t, checked); }
@Override public RALExprSlice resolveInner(ScopeContext context) { return Resolved.of(base.resolve(context), target, doImplicitCheck); }
@Override public RALExprSlice resolveInner(ScopeContext context) { RALExprSlice r = base.resolve(context); RALType nn = r.assert1ReadType(); nn = context.world.types.byNonNullable(nn); return Resolved.of(r, nn, false); }
public static Resolved of( RALExprSlice originalExpr, RALType targetType, boolean doImplicitCheck) { final RALSlot sourceSlot = originalExpr.slot(0); if (originalExpr.length != 1) throw new RuntimeException( "Cannot cast " + originalExpr + " which has length of " + originalExpr.length + "."); RALType sourceType = sourceSlot.type; RALSlot.Perm adjustedPerm = sourceSlot.perms; if (doImplicitCheck) { if (!targetType.canImplicitlyCast(sourceType)) adjustedPerm = adjustedPerm.denyWrite(); if (!sourceType.canImplicitlyCast(targetType)) adjustedPerm = adjustedPerm.denyRead(); } final RALExprSlice trueSlice = (originalExpr instanceof Resolved) ? ((Resolved) originalExpr).expr : originalExpr; return new Resolved(trueSlice, new RALSlot(targetType, adjustedPerm), doImplicitCheck); }
@Override public String toString() { return "Cast" + (doImplicitCheck ? "Imp" : "") + "[" + expr + "!" + targetSlot + "]"; }
@Override protected RALSlot slotInner(int index) { return targetSlot; }
@Override public void readCompileInner(RALExprSlice out, CompileContext context) { readType(0); expr.readCompile(of(out, targetSlot.type, doImplicitCheck), context); }
@Override protected void readInplaceCompileInner(RALVarVA[] out, CompileContext context) { RALType rt = readType(0); if (doImplicitCheck) rt.assertImpCast(out[0].type); expr.readInplaceCompile(new RALVarVA[] {new RALVarVA(out[0].handle, rt)}, context); }
@Override public void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { writeType(0); expr.writeCompile(0, input, targetSlot.type.majorType.autoPromote(inputExactType), context); }
public static RALExprUR of( DefInfo.At di, RALExprUR l, RALModAssignStatement.Op thisOp, RALExprUR r) { LinkedList<RALExprUR> total = new LinkedList<>(); boolean handledL = false; if (l instanceof RALChainOp) { RALChainOp leftCO = (RALChainOp) l; if (leftCO.op == thisOp) { for (RALExprUR elm : leftCO.elements) total.add(elm); handledL = true; } } if (!handledL) total.add(l); total.add(r); return new RALChainOp(di, thisOp, total.toArray(new RALExprUR[0])); }
@Override public RALConstant resolveConst(TypeSystem ts, Set<String> scopedVariables) { RALConstant res = null; for (int i = 0; i < elements.length; i++) { RALConstant c = elements[i].resolveConst(ts, scopedVariables); if (c == null) return null; if (i == 0) { res = c; } else { res = op.stepConst(ts, res, c); } } return res; }
@Override public String toString() { return "RALChainOp target"; }
@Override protected RALSlot slotInner(int index) { return res; }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { try (CompileContext cc2 = context.forkVAEH()) { RALVarVA va = cc2.allocVA(ipr.finishedType, "RALChainOp temporary"); cc2.heldExprHandles.put(eh, va); ipr.compute.compile(cc2.writer, cc2); va.readCompile(out, cc2); } }
@Override protected void readInplaceCompileInner(RALVarVA[] out, CompileContext context) { try (CompileContext cc2 = context.forkVAEH()) { cc2.heldExprHandles.put(eh, out[0]); ipr.compute.compile(cc2.writer, cc2); } }
@Override public String toString() { return "(id " + text + ")"; }
@Override public RALConstant resolveConst(TypeSystem ts, Set<String> scopedVariables) { if (scopedVariables.contains(text)) return null; return ts.namedConstants.get(text); }
@Override public RALExprSlice resolveInner(ScopeContext context) { TypeSystem typeSystem = context.world.types; ScopeContext.LVar re = context.scopedVariables.get(text); if (re != null) return re.content; RALConstant rc = typeSystem.namedConstants.get(text); if (rc != null) return rc; RALType.AgentClassifier maybeClassifier = typeSystem.tryGetAsClassifier(text); if (maybeClassifier != null) { Classifier cl = maybeClassifier.classifier; return RALExprGroupUR.of( new RALConstant.Int(typeSystem, cl.family), new RALConstant.Int(typeSystem, cl.genus), new RALConstant.Int(typeSystem, cl.species)) .resolve(context); } if (extent != null) context.world.diags.pushFrame(extent); context.world.diags.error("Unknown ID " + text); if (extent != null) context.world.diags.popFrame(extent); return RALExprSlice.EMPTY; }
@Override public String toString() { return "targ"; }
@Override protected void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { context.writer.writeCode("targ " + input); }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { out.writeCompile(0, "targ", type.majorType, context); }
default RALConstant resolveConst(TypeSystem ts, Set<String> scopedVariables) { return null; }
default RALExprSlice resolve(ScopeContext scope) { RALConstant rc = resolveConst(scope.world.types, scope.scopedVariables.keySet()); if (rc != null) { scope.world.hcm.onResolveExpression(this, rc); return rc; } RALExprSlice res = resolveInner(scope); scope.world.hcm.onResolveExpression(this, res); return res; }
default RALExprUR[] decomposite() { return new RALExprUR[] {this}; }
@Override public RALExprSlice resolveInner(ScopeContext scope) { RALType base = reference.resolve(new ScopeContext(scope)).assert1ReadType(); Integer id = base.lookupMSID(msgName, false); if (id == null) throw new RuntimeException("No message name " + msgName + " in " + base); return new RALConstant.Int(scope.world.types, id); }
@Override public RALConstant resolveConst(TypeSystem ts, Set<String> scopedVariables) { RALConstant rc = expr.resolveConst(ts, scopedVariables); if (rc == null) return null; if (rc instanceof RALConstant.Int) return new RALConstant.Int( ts, negate ? -((RALConstant.Int) rc).value : ~((RALConstant.Int) rc).value); if (negate) if (rc instanceof RALConstant.Flo) return new RALConstant.Flo(ts, -((RALConstant.Flo) rc).value); return null; }
@Override public String toString() { return actualCmd + "[" + exprR + "]"; }
@Override protected RALSlot slotInner(int index) { return rs; }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { try (CompileContext cc = context.forkVAEH()) { innerRes.readCompile(out, cc); modifyRes.compile(cc.writer, cc); } }
public static RALStatementUR parseStatement(InsideFileContext ifc) { stmtCompletionIntents(ifc); Token tkn = ifc.lexer.requireNext(); RALStatementUR res = null; SrcRange sr = tkn.lineNumber.toRange(); ifc.diags.pushFrame(sr); try { res = parseStatementInnards(ifc, tkn); } catch (Exception ex) { ifc.diags.error("exception in statement: ", ex); res = new RALBlock(tkn.lineNumber, false); } ifc.diags.popFrame(sr); return res; }
private static RALExprUR parseRelativeMessageID(RALExprUR target, InsideFileContext ifc) { ifc.hcm.addCompletionRelIntentToNextToken(HCMIntents.msRelativeIntent(false), true, target); Token messageId = ifc.lexer.requireNext(); RALExprUR getMsgType; if (messageId instanceof Token.ID) { getMsgType = new RALMessageIDGrabber(target, ((Token.ID) messageId).text); } else { ifc.lexer.back(); getMsgType = ParserExpr.parseExpr(ifc, true); } return getMsgType; }
private static RALStatementUR parseModAssign( Token base, InsideFileContext ifc, RALExprUR target, RALModAssignStatement.Op add) { RALExprUR source = ParserExpr.parseExpr(ifc, true); ifc.lexer.requireNextKw(";"); DefInfo.At di = ifc.lexer.genDefInfo(base); return new RALModAssignStatement(di.srcRange, target, source, add); }
public static void stmtCompletionIntents(InsideFileContext ifc) { ParserExpr.exprCompletionIntents(ifc); }
public IDocPath resolveInclude(String inc, IDocPath relTo) { LinkedList<IDocPath> attempts = new LinkedList<>(); if (relTo != null) { IDocPath f = relTo.getRelative(inc); if (f != null) attempts.add(f); } for (IDocPath sp : searchPaths) { IDocPath f = sp.getRelative(inc); if (f != null) attempts.add(f); } for (IDocPath f : attempts) { if (!f.isFile()) continue; return f; } throw new RuntimeException( "Ran out of search paths trying to find " + inc + " from " + relTo + ", tried: " + attempts); }
@Override public int hashCode() { return file.hashCode(); }
@Override public boolean equals(Object var1) { if (var1 instanceof FileDocPath) return ((FileDocPath) var1).file.equals(file); return false; }
@Override public Reader open() throws IOException { return new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8); }
@Override public byte[] readAllBytes() throws IOException { return Files.readAllBytes(file.toPath()); }
@Override public boolean isFile() { return file.isFile(); }
@Override public String toString() { return file.toString(); }
@Override public String toLSPURI() { return null; }
public static RALConstant parseConst(InsideFileContext ifc) { RALExprUR ex = parseExpr(ifc, true); RALConstant ex2 = ex.resolveConst(ifc.typeSystem, Collections.emptySet()); if (ex2 == null) throw new RuntimeException("Unable to resolve " + ex + " to constant expression."); return ex2; }
public static int parseConstInteger(InsideFileContext ifc) { RALConstant re = parseConst(ifc); if (re instanceof RALConstant.Int) { return ((RALConstant.Int) re).value; } else { throw new RuntimeException("Expected constant integer."); } }
public static String parseConstString(InsideFileContext ifc) { RALConstant re = parseConst(ifc); if (re instanceof RALConstant.Str) { return ((RALConstant.Str) re).valueChars; } else { throw new RuntimeException("Expected constant string."); } }
public static RALExprUR parseExpr(InsideFileContext ifc, boolean must) { RALExprUR expr = parseExprOrNull(ifc); if (expr == null) { if (must) { RuntimeException re = new RuntimeException("expected expression, not: " + ifc.lexer.diagContext()); ifc.diags.lexParseErr(ifc.lexer.genLN(), "", re); } return RALExprGroupUR.of(); } return expr; }
public static RALExprUR parseExprOrNull(InsideFileContext ifc) { Lexer lx = ifc.lexer; exprCompletionIntents(ifc); Token firstToken = lx.next(); if (firstToken == null) return null; lx.back(); RALExprUR firstAtom = parseExprFullAtomOrNull(ifc); if (firstAtom == null) return null; LinkedList<RALExprUR> atoms = new LinkedList<>(); LinkedList<String> ops = new LinkedList<>(); atoms.add(firstAtom); while (true) { Token tkn = lx.next(); if (tkn == null) { break; } else if (!(tkn instanceof Token.Kw)) { lx.back(); break; } String opId = ((Token.Kw) tkn).text; if (!allOps.contains(opId)) { lx.back(); break; } ops.add(opId); firstAtom = parseExprFullAtomOrNull(ifc); if (firstAtom == null) throw new RuntimeException(opId + " without expression at " + tkn.lineNumber); atoms.add(firstAtom); } RALExprUR[] atomsArr = atoms.toArray(new RALExprUR[0]); String[] opsArr = ops.toArray(new String[0]); return binopProcessor(lx.genDefInfo(firstToken), atomsArr, opsArr, 0, opsArr.length); }
public static RALExprUR binopProcessor( DefInfo.At di, RALExprUR[] atomArr, String[] opArr, int aBase, int opCount) { if (opCount == 0) return atomArr[aBase]; for (String[] pCl : operatorPrecedenceGroups) { boolean reverse = true; int start = reverse ? (aBase + opCount - 1) : (aBase); int limit = reverse ? (aBase - 1) : (aBase + opCount); int dir = reverse ? -1 : 1; for (int i = start; i != limit; i += dir) { for (String op : pCl) { if (op.equals(opArr[i])) { RALExprUR l = binopProcessor(di, atomArr, opArr, aBase, i - aBase); RALExprUR r = binopProcessor(di, atomArr, opArr, i + 1, aBase + opCount - (i + 1)); return binopMaker(di, l, opArr[i], r); } } } } throw new RuntimeException("Operator not in any precedence groups: " + opArr[0]); }
public static RALExprUR parseExprFullAtomOrNull(InsideFileContext ifc) { RALExprUR firstAtom = parseExprAtomOrNull(ifc); if (firstAtom == null) return null; return parseExprSuffix(firstAtom, ifc); }
private static RALExprUR makeIncDec( SrcRange extent, TypeSystem ts, RALExprUR inner, boolean pre, boolean inc) { RALModAssignStatement.Op op = inc ? RALModAssignStatement.ADD : RALModAssignStatement.SUB; RALStatementUR mod = new RALModAssignStatement(extent, inner, new RALConstant.Int(ts, 1), op); if (pre) { return new RALStmtExpr(mod, inner); } else { return new RALReturnBeforeModify(inner, mod); } }
public static void exprCompletionIntents(InsideFileContext ifc) { ifc.hcm.addCompletionIntentToNextToken(HCMIntents.ID, false); ifc.hcm.addCompletionIntentToNextToken(HCMIntents.CALLABLE, false); }
private static IncludeParseContext newContext(IDocPath stdlib) throws IOException { IncludeParseContext ic = new IncludeParseContext(new DummyHCMRecorder(), true); ic.searchPaths.add(stdlib); findParseFile(ic, null, "std/compiler_helpers.ral"); return ic; }
public static IncludeParseContext run(IDocPath stdlib, File path) throws IOException { IncludeParseContext ic = newContext(stdlib); IDocPath init = new FileDocPath(path); parseFileAt(ic, new SrcPosFile(null, init, path.getName())); return ic; }
public static String runCPXConnTest(IDocPath stdlib) throws IOException { IncludeParseContext ic = newContext(stdlib); findParseFile(ic, null, "std/cpx_connection_test.ral"); StringBuilder sb = new StringBuilder(); Scripts scr = ic.module.resolve(ic.diags, ic.hcm); scr.compileInstall(new OuterCompileContext(sb, new DummyDebugRecorder())); ic.diags.unwrap(); return sb.toString(); }
public static void findParseFile(IncludeParseContext ctx, IDocPath relTo, String inc) throws IOException { findParseFile(ctx, relTo, inc, null); }
public static SrcPosFile findParseFile( IncludeParseContext ctx, IDocPath relTo, String inc, SrcPos incFrom) throws IOException { LinkedList<IDocPath> attempts = new LinkedList<>(); if (relTo != null) { IDocPath f = relTo.getRelative(inc); if (f != null) attempts.add(f); } for (IDocPath sp : ctx.searchPaths) { IDocPath f = sp.getRelative(inc); if (f != null) attempts.add(f); } for (IDocPath f : attempts) { if (!f.isFile()) continue; SrcPosFile res = new SrcPosFile(incFrom, f, inc); parseFileAt(ctx, res); return res; } throw new RuntimeException( "Ran out of search paths trying to find " + inc + " from " + relTo + ", tried: " + attempts); }
public static void parseFileAt(IncludeParseContext ctx, SrcPosFile fileId) throws IOException { if (ctx.included.contains(fileId.docPath)) return; ctx.included.add(fileId.docPath); if (ctx.outputIncludesToErr) System.err.println("include: " + fileId.shortName); try (Reader r = fileId.docPath.open()) { parseFileInnards(ctx, fileId.docPath.getRelative(".."), fileId, r); } }
public static void parseFileInnards( IncludeParseContext ctx, IDocPath hereParent, SrcPosFile spf, Reader r) throws IOException { try { Lexer lx = new Lexer(spf, r, ctx.diags, ctx.hcm); InsideFileContext ifc = new InsideFileContext(ctx, lx, hereParent); while (true) { ifc.hcm.addCompletionIntentToNextToken(HCMIntents.DECLARATIONS, true); Token tkn = lx.next(); if (tkn == null) break; try { if (tkn.isKeyword("include")) { String str = ParserExpr.parseConstString(ifc); Token endTkn = lx.requireNextKw(";"); SrcPosFile incSPF = findParseFile(ctx, hereParent, str, tkn.lineNumber); ctx.hcm.assignIncludeRange(tkn, endTkn, incSPF); } else if (tkn.isKeyword("addSearchPath")) { String str = ParserExpr.parseConstString(ifc); lx.requireNextKw(";"); IDocPath possible = hereParent.getRelative(str); if (possible != null) ctx.searchPaths.add(possible); } else { parseDeclaration(ifc, tkn); } } catch (Exception ex) { ctx.diags.lexParseErr(tkn.lineNumber, "exception in declaration: ", ex); } } } catch (Exception ex) { throw new RuntimeException("in file " + spf.shortName, ex); } }
public static MacroArg[] parseArgList(InsideFileContext ifc, boolean allowInline) { Lexer lx = ifc.lexer; lx.requireNextKw("("); if (lx.optNextKw(")")) return new MacroArg[0]; LinkedList<MacroArg> args = new LinkedList<>(); while (true) { RALType typ = ParserType.parseType(ifc); RALSlot.Perm isInline = null; if (lx.optNextKw("@")) { isInline = RALSlot.Perm.R; } else if (lx.optNextKw("@=")) { isInline = RALSlot.Perm.RW; } String name = lx.requireNextID(); args.add(new MacroArg(typ, isInline, name)); Token first = lx.requireNext(); if (first.isKeyword(")")) { return args.toArray(new MacroArg[0]); } else if (first.isKeyword(",")) { } else { throw new RuntimeException("Unusual termination of argument list " + first); } } }
public static MacroArgNameless[] parseArgListNameless( InsideFileContext ifc, boolean allowInline) { Lexer lx = ifc.lexer; lx.requireNextKw("("); if (lx.optNextKw(")")) return new MacroArgNameless[0]; LinkedList<MacroArgNameless> args = new LinkedList<>(); while (true) { RALType typ = ParserType.parseType(ifc); RALSlot.Perm isInline = null; if (allowInline) { if (lx.optNextKw("@")) { isInline = RALSlot.Perm.R; } else if (lx.optNextKw("@=")) { isInline = RALSlot.Perm.RW; } } args.add(new MacroArgNameless(typ, isInline)); Token first = lx.requireNext(); if (first.isKeyword(")")) { return args.toArray(new MacroArgNameless[0]); } else if (first.isKeyword(",")) { } else { throw new RuntimeException("Unusual termination of argument list " + first); } } }
public static void parseExtendsClauses(InsideFileContext ifc, RALType.Agent ag) { TypeSystem ts = ifc.typeSystem; Lexer lx = ifc.lexer; while (true) { Token clause = lx.requireNext(); if (clause.isKeyword(";")) break; if (clause.isKeyword("extends")) { while (true) { String other = ParserType.parseTypeName(ifc); RALType rt = ts.byName(other); if (rt instanceof RALType.Agent) { ag.addParent((RALType.Agent) rt); } else { throw new RuntimeException( "extends clause requires '" + other + "' to be some form of agent"); } Token nxt = lx.requireNext(); if (!nxt.isKeyword(",")) { lx.back(); break; } } } } }
public static RALType parseType(InsideFileContext ifc) { TypeSystem ts = ifc.typeSystem; Lexer lx = ifc.lexer; LinkedList<RALType> rts = new LinkedList<>(); rts.add(parseTypeBranch(ifc)); while (true) { Token tkn = lx.requireNext(); if (!tkn.isKeyword("|")) { lx.back(); break; } rts.add(parseTypeBranch(ifc)); } return ts.byUnion(rts); }
public static RALType parseTypeBranch(InsideFileContext ifc) { TypeSystem ts = ifc.typeSystem; Lexer lx = ifc.lexer; typeCompletionIntents(ifc); RALType rt; if (ifc.lexer.optNextKw("lambda")) { MacroArgNameless[] rets = Parser.parseArgListNameless(ifc, false); MacroArgNameless[] args = Parser.parseArgListNameless(ifc, true); LinkedList<RALType> rets2 = new LinkedList<>(); for (MacroArgNameless ma : rets) rets2.add(ma.type); return ts.byLambda(rets2, Arrays.asList(args)); } else { Token.ID id = ifc.lexer.requireNextIDTkn(); String name = id.text; rt = ts.byName(name); if (rt == null) throw new RuntimeException("No such type " + name); } if (lx.optNextKw("?")) return ts.byNullable(rt); return rt; }
public static String parseTypeName(InsideFileContext ifc) { typeCompletionIntents(ifc); Token.ID id = ifc.lexer.requireNextIDTkn(); return id.text; }
public static void typeCompletionIntents(InsideFileContext ifc) { ifc.hcm.addCompletionIntentToNextToken(HCMIntents.TYPE, true); }
public void put(SrcRange range, T res) { put(range.start.line, range.start.character, range.end.line, range.end.character, res); }
public void put(int startLine, int startChar, int endLine, int endChar, T res) { if (startLine > endLine) { throw new RuntimeException("Invalid lines"); } else if (startLine == endLine) { SrcLineMap slm = getLine(startLine); slm.put(startChar, endChar, res); } else { getLine(startLine).putUntilEnd(startChar, res); for (int i = startLine + 1; i < endLine; i++) getLine(i).reset(res); getLine(endLine).put(0, endChar, res); } }
public void putUntilEnd(SrcPosBase sp, T res) { putUntilEnd(sp.line, sp.character, res); }
public void putUntilEnd(int startLine, int startChar, T res) { getLine(startLine).putUntilEnd(startChar, res); for (Map.Entry<Integer, SrcLineMap> i : lineMap.entrySet()) if (i.getKey() > startLine) i.getValue().reset(res); endFiller = res; }
public T get(SrcPosBase sp) { return get(sp.line, sp.character); }
public T get(int line, int character) { SrcLineMap slm = lineMap.get(line); if (slm == null) { if (line > lastLineInMap) return endFiller; return null; } return slm.get(character); }
private void ensureIndexValid(int idx) { T uev = getUntilEndValue(); while (lineValues.size() <= idx) lineValues.add(uev); }
private void reset(T v) { lineValues.clear(); lineValues.add(v); }
private void putUntilEnd(int start, T v) { ensureIndexValid(start); for (int i = start; i < lineValues.size(); i++) lineValues.set(i, v); }
private void put(int start, int end, T v) { ensureIndexValid(end + 1); for (int i = start; i < end; i++) lineValues.set(i, v); }
private T get(int character) { if (character >= lineValues.size()) return getUntilEndValue(); return lineValues.get(character); }
private static void put(HashMap<String, HoverData> map, String name, String text) { map.put(name, new HoverData(name, new DefInfo.Builtin(text))); }
default void addCompletionIntentToNextToken(HCMIntent intent, boolean autoHover) { addCompletionRelIntentToNextToken(intent, autoHover, (RALExprUR[]) null); }
default HCMIntent genMSIntent(RALType type, boolean isScript) { return new HCMIntents.MSIntent(type, isScript); }
public static void showSlot(StringBuilder sb, RALSlot slot) { sb.append(slot.type); sb.append("/"); sb.append(slot.perms); }
public static void showSlots(StringBuilder sb, RALSlot[] slots) { if (slots.length != 1) { sb.append("("); boolean first = true; for (RALSlot rs : slots) { if (!first) sb.append(", "); first = false; showSlot(sb, rs); } sb.append(")"); } else { showSlot(sb, slots[0]); } }
public static HCMStorage.HoverData varHoverData(ScopeContext.LVar var) { StringBuilder sb = new StringBuilder(); showSlots(sb, var.content.slots()); sb.append(" "); sb.append(var.name); return new HCMStorage.HoverData(sb.toString(), var.definition); }
public static HCMStorage.HoverData constHoverData(String name, RALConstant c, DefInfo di) { StringBuilder sb = new StringBuilder(); showSlots(sb, c.slots()); sb.append(" "); sb.append(name); sb.append(" = "); sb.append(c.toString()); return new HCMStorage.HoverData(sb.toString(), di); }
public static HoverData typeHoverData(String k, RALType rt, DefInfo defInfo) { return new HCMStorage.HoverData(k + ": " + rt.getFullDescription(), defInfo); }
public static void showMacroArgs(StringBuilder sb, MacroArg[] args) { sb.append("("); boolean first = true; for (MacroArg ma : args) { if (!first) sb.append(", "); first = false; sb.append(ma.type); if (ma.isInline != null) { sb.append("/"); sb.append(ma.isInline.toString()); } else { sb.append("/R"); } sb.append(" "); if (ma.isInline != null) { sb.append("@"); if (ma.isInline == RALSlot.Perm.RW) sb.append("@="); } sb.append(ma.name); } sb.append(")"); }
private static void showCallable(StringBuilder sb, String k, RALCallable rc) { if (rc instanceof MacroDefSet) { MacroDefSet mds = (MacroDefSet) rc; LinkedList<Integer> keys = new LinkedList<>(mds.map.keySet()); Collections.sort(keys); for (Integer ent : keys) showCallable(sb, k, mds.map.get(ent)); } else if (rc instanceof Macro) { showSlots(sb, ((Macro) rc).precompiledCode.slots()); sb.append(" "); sb.append(k); showMacroArgs(sb, ((Macro) rc).args); sb.append("\n"); } else { sb.append(k); sb.append(": "); sb.append(rc); sb.append("\n"); } }
public static HoverData callableHoverData(String k, RALCallable.Global rc) { StringBuilder sb = new StringBuilder(); showCallable(sb, k, rc); return new HCMStorage.HoverData(sb.toString(), rc.getDefInfo()); }
public static HoverData fieldHoverData(AgentInterface ai, String me) { AgentInterface.OVar ov = ai.fields.get(me); return new HCMStorage.HoverData( ai.canonicalType + "." + me + " (OV " + ov.slot + "): " + ov.type, ov.defInfo); }
public static HoverData includeHoverData(SrcPosFile spf) { return new HCMStorage.HoverData( spf.docPath.toLSPURI(), new DefInfo.At(new SrcPos(spf, 0, 0, 0), "An included file.")); }
public static HoverData msHoverData( AgentInterface ai, String k, AgentInterface.MsgScr me, boolean asScript) { return new HCMStorage.HoverData( (asScript ? "script" : "message") + " " + ai.canonicalType + (asScript ? ":" : "->") + k + " " + me.value + ";", me.defInfo); }
@Override public final Map<String, HoverData> retrieve( Token sp, SrcPosUntranslated spu, HCMStorage storage) { Tracking ex = storage.relativeIntentExprs.get(new Anchor(this, sp)); if (ex == null || !ex.isFinished()) return fallback != null ? fallback.retrieve(sp, spu, storage) : null; return retrieveParameterized(sp, spu, storage, ex.resolvedExpressions); }
public void contribute(RALExprUR a, RALExprSlice b) { for (int i = 0; i < baseExpressions.length; i++) if (a == baseExpressions[i]) resolvedExpressions[i] = b; }
public boolean isFinished() { for (int i = 0; i < baseExpressions.length; i++) if (resolvedExpressions[i] == null) return false; return true; }
@Override public int hashCode() { return intent.hashCode() ^ token.hashCode(); }
@Override public boolean equals(Object obj) { if (obj instanceof Anchor) { Anchor a = (Anchor) obj; return a.token == token && a.intent == intent; } return false; }
@Override public String toString() { return name; }
public String hoverDebugPrefix(SrcPosUntranslated spu) { StringBuilder sb = new StringBuilder(); sb.append("lT:"); Token lt = lastTokenMap.get(spu); sb.append(lt); if (lt != null) { sb.append(" hI:"); sb.append(hoverIntents.get(lt)); } Token refToken = completionRefToken(spu); sb.append(" cT:"); sb.append(refToken); if (refToken != null) { sb.append(" cI"); HashSet<HCMIntent> intentSet = intentsOnNextToken.get(refToken); if (intentSet != null) { for (HCMIntent hi : intentSet) { sb.append(":"); sb.append(hi); } sb.append(";"); } } sb.append("\n"); return sb.toString(); }
@Override public void parserRequestedToken(Token tkn, boolean actualRequest) {}
@Override public void addCompletionRelIntentToNextToken( HCMIntent intent, boolean autoHover, RALExprUR... rel) {}
@Override public void assignIncludeRange(Token first, Token last, SrcPosFile spf) {}
@Override public void resolvePre(SrcRange rs, ScopeContext scope) {}
@Override public void resolvePost(SrcRange rs, ScopeContext scope) {}
@Override public void onResolveExpression(RALExprUR src, RALExprSlice dst) {}
@Override public HCMIntent genMSIntent(RALType rt, boolean b) { return null; }
@Override public void readToken(Token tkn) { if (!tkn.isInDP(targetDocPath)) return; if (lastReadToken != null) backwardsTokenLink.put(tkn, lastReadToken); lastReadToken = tkn; lastTokenMap.putUntilEnd(tkn.extent.start, tkn); }
@Override public void parserRequestedToken(Token tkn, boolean actualRequest) { currentRequestedToken = tkn; if (actualRequest) { HCMIntent heldAH = autoHoverHolding; RALExprUR[] heldAP = autoHoverHoldingParams; autoHoverHolding = null; autoHoverHoldingParams = null; if (!tkn.isInDP(targetDocPath)) return; if (heldAH != null) if (tkn instanceof IDish) setTokenHoverRelIntent((IDish) tkn, heldAH, heldAP); } }
@Override public void addCompletionRelIntentToNextToken( HCMIntent intent, boolean autoHover, RALExprUR... params) { if (intent == null) throw new NullPointerException("Completion intent should never be null"); if (autoHover) { autoHoverHolding = intent; autoHoverHoldingParams = params; } if (currentRequestedToken == null) return; if (!currentRequestedToken.isInDP(targetDocPath)) return; HashSet<HCMIntent> hs = intentsOnNextToken.get(currentRequestedToken); if (hs == null) { hs = new HashSet<>(); intentsOnNextToken.put(currentRequestedToken, hs); } hs.add(intent); if (params != null) createRelIntentLink((HCMRelativeIntent) intent, currentRequestedToken, params); }
private void createRelIntentLink(HCMRelativeIntent intent, Token prev, RALExprUR[] params) { HCMRelativeIntent.Tracking trk = new HCMRelativeIntent.Tracking(params); relativeIntentExprs.put(new Anchor(intent, prev), trk); for (RALExprUR p : params) { LinkedList<HCMRelativeIntent.Tracking> ll = relativeIntentRoutingTable.get(p); if (ll == null) { ll = new LinkedList<>(); relativeIntentRoutingTable.put(p, ll); } ll.add(trk); } }
@Override public void assignIncludeRange(Token first, Token last, SrcPosFile spf) { if (!first.isInDP(targetDocPath)) return; HoverData hd = HCMHoverDataGenerators.includeHoverData(spf); hoverTokenOverrides.put(last, hd); while (last != first) { last = backwardsTokenLink.get(last); if (last == null) throw new RuntimeException("Ran off of the start during assignIncludeRange"); hoverTokenOverrides.put(last, hd); } }
@Override public void resolvePre(SrcRange rs, ScopeContext scope) { if (rs.isInDP(targetDocPath)) snapshots.put(rs.start.lcLong, new HCMScopeSnapshot(rs.start, scope)); }
@Override public void resolvePost(SrcRange rs, ScopeContext scope) { if (rs.isInDP(targetDocPath)) snapshots.put(rs.end.lcLong, new HCMScopeSnapshot(rs.end, scope)); }
@Override public void onResolveExpression(RALExprUR src, RALExprSlice dst) { LinkedList<HCMRelativeIntent.Tracking> trkL = relativeIntentRoutingTable.get(src); if (trkL != null) for (HCMRelativeIntent.Tracking trk : trkL) trk.contribute(src, dst); }
@Override public int compare(HCMScopeSnapshot o1, HCMScopeSnapshot o2) { if (o1.takenAt.lcLong < o2.takenAt.lcLong) return -1; else if (o1.takenAt.lcLong > o2.takenAt.lcLong) return 1; return 0; }
@Override public Map<String, HoverData> retrieve(Token sp, SrcPosUntranslated spu, HCMStorage storage) { HashMap<String, HoverData> map = new HashMap<>(); HCMScopeSnapshot snapshot = storage.snapshots.get(spu); if (snapshot != null) map.putAll(snapshot.contents); map.putAll(storage.allConstants); return map; }
@Override public Map<String, HoverData> retrieve(Token sp, SrcPosUntranslated spu, HCMStorage storage) { return storage.allNamedTypes; }
@Override public Map<String, HoverData> retrieve(Token sp, SrcPosUntranslated spu, HCMStorage storage) { return storage.allCallables; }
@Override public Map<String, HoverData> retrieve(Token sp, SrcPosUntranslated spu, HCMStorage storage) { return HCMFixedMaps.CODEGEN_LEVELS; }
@Override public Map<String, HoverData> retrieve(Token sp, SrcPosUntranslated spu, HCMStorage storage) { return HCMFixedMaps.DECLARATIONS; }
@Override public Map<String, HoverData> retrieveParameterized( Token sp, SrcPosUntranslated spu, HCMStorage storage, RALExprSlice[] exprs) { return storage.allCallablesAV.get(exprs[0].length); }
@Override public Map<String, HoverData> retrieveParameterized( Token sp, SrcPosUntranslated spu, HCMStorage storage, RALExprSlice[] exprs) { try { if (exprs[0].length == 1) { HashMap<String, HoverData> compiled = new HashMap<>(); for (AgentInterface ai : exprs[0].slot(0).type.getInterfaces()) for (String me : ai.fields.keySet()) compiled.put(me, HCMHoverDataGenerators.fieldHoverData(ai, me)); return compiled; } } catch (Exception ex) { } return null; }
public static HCMRelativeIntent msRelativeIntent(boolean asScript) { return asScript ? SCRIPT_EXPR : MESSAGE_EXPR; }
@Override public Map<String, HoverData> retrieveParameterized( Token sp, SrcPosUntranslated spu, HCMStorage storage, RALExprSlice[] exprs) { try { if (exprs[0].length == 1) return MSIntent.fromType(exprs[0].slot(0).type, asScript); } catch (Exception ex) { } return null; }
public static HashMap<String, HoverData> fromType(RALType type, boolean asScript) { try { HashMap<String, HoverData> compiled = new HashMap<>(); for (AgentInterface ai : type.getInterfaces()) for (Map.Entry<String, AgentInterface.MsgScr> me : (asScript ? ai.scripts : ai.messages).entrySet()) compiled.put( me.getKey(), HCMHoverDataGenerators.msHoverData(ai, me.getKey(), me.getValue(), asScript)); return compiled; } catch (Exception ex) { } return null; }
@Override public Map<String, HoverData> retrieve(Token sp, SrcPosUntranslated spu, HCMStorage storage) { return fromType(type, asScript); }
@Override public String toString() { return file.getRootShortName() + ":" + line + "," + character; }
public boolean isInDP(IDocPath docPath) { return file.docPath.equals(docPath); }
@Override public String toString() { if (start.line == end.line) return file + ":" + (start.line + 1) + ",(" + (start.character + 1) + " .. " + (end.character + 1) + ")"; return file + ":" + (start.line + 1) + "," + (start.character + 1) + " .. " + (end.line + 1) + "," + (end.character + 1); }
public JSONObject toLSPRange() { JSONObject range = new JSONObject(); range.put("start", start.toLSPPosition()); range.put("end", end.toLSPPosition()); return range; }
public SrcRange expand(SrcRange other) { return new SrcRange(start.min(other.start), end.max(other.end)); }
public SrcRange expand(SrcPos other) { return new SrcRange(start.min(other), end.max(other)); }
@Override public String toString() { return shortName; }
@Override public String toString() { return file + ":" + (line + 1) + "," + (character + 1); }
public JSONObject toLSPRange() { JSONObject range = new JSONObject(); JSONObject pos = toLSPPosition(); range.put("start", pos); range.put("end", pos); return range; }
public SrcRange toRange() { return new SrcRange(this, this); }
public SrcPos min(SrcPos start) { return start.globalPosition < globalPosition ? start : this; }
public SrcPos max(SrcPos end) { return end.globalPosition > globalPosition ? end : this; }
public SrcPosUntranslated toUntranslated() { return new SrcPosUntranslated(file.docPath, line, character); }
public JSONObject toLSPPosition() { return new JSONObject("{\"line\":" + line + ",\"character\":" + character + "}"); }
public static long toLCLong(int l, int c) { return (((long) l) << 32L) | (c & 0xFFFFFFFFL); }
public void diag(Diag d) { if (d.kind == Diag.Kind.Error) hasFailed = true; diagnostics.add(d); }
public void lexParseErr(SrcPos sp, String text) { lexParseErr(sp.toRange(), text); }
public void lexParseErr(SrcPos sp, String text, Exception ex) { lexParseErr(sp.toRange(), text, ex); }
public void lexParseErr(SrcRange sp, String text) { frames.push(sp); error(text); frames.pop(); }
public void lexParseErr(SrcRange sp, String text, Exception ex) { frames.push(sp); error(text, ex); frames.pop(); }
public void error(String text) { diag(new Diag(Diag.Kind.Error, frames.toArray(new SrcRange[0]), text, text)); }
public void error(String text, Exception ex) { StringWriter details = new StringWriter(); details.append(text); ex.printStackTrace(new PrintWriter(details)); diag( new Diag( Diag.Kind.Error, frames.toArray(new SrcRange[0]), details.toString(), ex.getMessage())); }
public void warning(String text) { diag(new Diag(Diag.Kind.Warning, frames.toArray(new SrcRange[0]), text, text)); }
public String unwrapToString() { if (hasFailed) { StringBuilder sb = new StringBuilder(); for (Diag d : diagnostics) { sb.append(d.frames[0]); sb.append(": "); sb.append(d.shortText); sb.append("\n"); } sb.append("\n -- Long Versions... --\n\n"); for (Diag d : diagnostics) { for (SrcRange sr : d.frames) { sb.append(sr); sb.append(": "); } sb.append(d.text); sb.append("\n"); } return sb.toString(); } return null; }
public void unwrap() { String s = unwrapToString(); if (s != null) throw new RuntimeException("Compile errors:\n" + s); }
public void pushFrame(SrcRange extent) { frames.push(extent); }
public void popFrame(SrcRange extent) { SrcRange e2 = frames.pop(); if (e2 != extent) { frames.push(e2); throw new RuntimeException("FRAME MISMATCH IN DIAG: " + extent + " vs " + e2); } }
@Override public void close() { popFrame(extent); }
@Override public RALConstant resolveConst(TypeSystem ts, Set<String> scopedVariables) { RALConstant rc = inside.resolveConst(ts, scopedVariables); if (rc == null) return null; return RALCondition.boolToConst(ts, !RALCondition.constToBool(rc)); }
@Override public String compileCond(CodeWriter writer, CompileContext sharedContext, boolean invert) { return resolved.compileCond(writer, sharedContext, !invert); }
@Override public String toString() { return "(" + left + ") " + logOp.code + " (" + right + ")"; }
@Override public RALConstant resolveConst(TypeSystem ts, Set<String> scopedVariables) { RALConstant rcL = left.resolveConst(ts, scopedVariables); if (rcL == null) return null; RALConstant rcR = right.resolveConst(ts, scopedVariables); if (rcR == null) return null; boolean lB = RALCondition.constToBool(rcL); boolean rB = RALCondition.constToBool(rcR); switch (logOp) { case And: return RALCondition.boolToConst(ts, lB && rB); case Or: return RALCondition.boolToConst(ts, lB || rB); default: throw new RuntimeException("can't invert this logop " + logOp + ", what'd you do?"); } }
private String wrapVar( CodeWriter writer, CompileContext sharedContext, RALCondition rc, boolean invert) { RALVarVA tmp = sharedContext.allocVA(bool, "RALCondLogOp tmp"); rc.readCompile(tmp, sharedContext); return tmp.getCode(sharedContext) + (invert ? " eq 0" : " ne 0"); }
@Override public String toString() { return "(" + lC.toString() + ") " + logOp.code + " (" + rC.toString() + ")"; }
@Override public RALConstant resolveConst(TypeSystem ts, Set<String> scopedVariables) { RALConstant cL = left.resolveConst(ts, scopedVariables); if (cL == null) return null; RALConstant cR = right.resolveConst(ts, scopedVariables); if (cR == null) return null; if (centre == Op.Equal) { return RALCondition.boolToConst(ts, cL.equals(cR)); } else if (centre == Op.NotEqual) { return RALCondition.boolToConst(ts, !cL.equals(cR)); } return null; }
@Override public RALExprSlice resolveInner(ScopeContext scope) { final RALExprSlice lR = left.resolve(scope); final RALExprSlice rR = right.resolve(scope); return Resolved.of(scope.world.types, centre, lR, rR); }
public static Resolved of(TypeSystem ts, Op centre, RALExprSlice lR, RALExprSlice rR) { RALType lT = lR.assert1ReadType(); RALType rT = rR.assert1ReadType(); if (lT.majorType != rT.majorType) if ((lT.majorType != Major.Unknown) && (rT.majorType != Major.Unknown)) throw new RuntimeException( "major type mismatch in condition (" + lT.majorType + " vs " + rT.majorType + "), VM doesn't like this"); return new Resolved(ts, centre, rR, lR, rT, lT); }
@Override public String compileCond(CodeWriter writer, CompileContext sharedContext, boolean invert) { String lInline = lR.getInlineCAOS(0, false, sharedContext); String rInline = rR.getInlineCAOS(0, false, sharedContext); if (lInline == null) { RALVarVA lV = sharedContext.allocVA(lT, "RALCondSimple-L"); lR.readCompile(lV, sharedContext); lInline = lV.getCode(sharedContext); } if (rInline == null) { RALVarVA rV = sharedContext.allocVA(rT, "RALCondSimple-R"); rR.readCompile(rV, sharedContext); rInline = rV.getCode(sharedContext); } return lInline + " " + (invert ? centre.codeInv : centre.code) + " " + rInline; }
@Override public String toString() { return "(" + lR + ") " + centre.code + " (" + rR + ")"; }
public static RALCondition coerceToCondition(RALExprSlice re, TypeSystem ts) { if (re instanceof RALCondition) return (RALCondition) re; if (re instanceof RALConditionCoercable) return ((RALConditionCoercable) re).coerceToCondition(); re.assert1ReadType().assertImpCast(ts.gBoolean); return RALCondSimple.Resolved.of(ts, RALCondSimple.Op.NotEqual, re, new RALConstant.Int(ts, 0)); }
public static boolean constToBool(RALConstant rcR) { if (rcR instanceof RALConstant.Flo) return ((RALConstant.Flo) rcR).value != 0; if (rcR instanceof RALConstant.Int) return ((RALConstant.Int) rcR).value != 0; throw new RuntimeException("Attempt to coerce constant " + rcR + " to boolean"); }
public static RALConstant boolToConst(TypeSystem ts, boolean b) { return new RALConstant.Int(ts.gBoolean, b ? 1 : 0); }
@Override protected final void readCompileInner(RALExprSlice out, CompileContext context) { String cc = compileCond(context.writer, context, false); context.writer.writeCode("doif " + cc, 1); out.writeCompile(0, "1", RALType.Major.Value, context); context.writer.writeCode(-1, "else", 1); out.writeCompile(0, "0", RALType.Major.Value, context); context.writer.writeCode(-1, "endi"); }
@Override protected final RALSlot slotInner(int index) { return boolRSlot; }
@Override public int hashCode() { return script ^ classifier.hashCode(); }
@Override public boolean equals(Object var1) { if (var1 instanceof ScriptIdentifier) { if (!((ScriptIdentifier) var1).classifier.equals(classifier)) return false; if (((ScriptIdentifier) var1).script != script) return false; return true; } return false; }
public String toScrpLine() { return "scrp " + classifier.family + " " + classifier.genus + " " + classifier.species + " " + script; }
@Override public int compareTo(ScriptIdentifier arg0) { int cl = classifier.compareTo(arg0.classifier); if (cl != 0) return cl; if (script < arg0.script) { return -1; } else if (script > arg0.script) { return 1; } return 0; }
public String newParserVariableName() { return ":" + (randomVariableNameNumber++); }
public RALType.AgentClassifier byClassifier(Classifier cl) { RALType.AgentClassifier rt = classifiers.get(cl); if (rt != null) return rt; if (!cl.isScriptValid()) throw new RuntimeException("Not valid script classifier: " + cl); Classifier clParent = cl.genScriptParent(); RALType.AgentClassifier agParent = null; if (clParent != null) agParent = byClassifier(clParent); rt = new RALType.AgentClassifier(this, cl, agParent); classifiers.put(cl, rt); return rt; }
public RALType byName(String name) { RALType rt = namedTypes.get(name); if (rt == null) throw new RuntimeException("No type " + name); return rt; }
public RALType byNameOpt(String name) { return namedTypes.get(name); }
public RALType byUnion(Iterable<RALType> in) { HashSet<RALType> types = new HashSet<>(); for (RALType rt : in) { if (rt instanceof RALType.Union) { for (RALType rt2 : (RALType.Union) rt) { types.add(rt2); } } else { types.add(rt); } } HashSet<RALType> typesCopy = new HashSet<>(types); for (final RALType rt : typesCopy) { types.removeIf((target) -> target != rt && target.canImplicitlyCast(rt)); } int ts = types.size(); if (ts == 1) { return types.iterator().next(); } else if (ts == 0) { return gImpossible; } RALType.Union res = unions.get(types); if (res != null) return res; res = new RALType.Union(types); unions.put(types, res); return res; }
public RALType byLambda(Iterable<RALType> in, Iterable<MacroArgNameless> in2) { RALLambdaSignature rls = new RALLambdaSignature(in, in2); RALType.Lambda lambda = lambdas.get(rls); if (lambda == null) { LinkedList<RALType> lRets = new LinkedList<>(); for (RALType rt : in) lRets.add(rt); LinkedList<MacroArgNameless> lArgs = new LinkedList<>(); for (MacroArgNameless ma : in2) lArgs.add(ma); lambda = new RALType.Lambda( gLambdaAny, lRets.toArray(new RALType[0]), lArgs.toArray(new MacroArgNameless[0])); lambdas.put(rls, lambda); } return lambda; }
public RALType byNullable(RALType t) { return byUnion(Arrays.asList(t, gNull)); }
public RALType byNonNullable(RALType t) { if (t instanceof RALType.Union) { LinkedList<RALType> res = new LinkedList<>(); for (RALType rt : (RALType.Union) t) if (rt != gNull) res.add(rt); return byUnion(res); } throw new RuntimeException("Can't remove the null option from a non-union."); }
public RALType.AgentClassifier declareClass(Classifier cl, String name, DefInfo di) { RALType ort = namedTypes.get(name); RALType.AgentClassifier ag = byClassifier(cl); if (ort == ag) return ag; checkConflictType(name); checkConflictInterface(name); namedTypes.put(name, ag); namedTypesDefPoints.put(name, di); namedInterfaces.put(name, ag.inherent); ag.typeName = name; return ag; }
public RALType.Agent declareInterface(String name, DefInfo di) { RALType ort = namedTypes.get(name); if (ort != null) if (ort instanceof RALType.Agent) return (RALType.Agent) ort; checkConflictType(name); checkConflictInterface(name); RALType.Agent ag = new RALType.Agent(this, name); ag.addParent(gAgent); namedTypes.put(name, ag); namedTypesDefPoints.put(name, di); namedInterfaces.put(name, ag.inherent); return ag; }
private void checkConflictType(String name) { if (namedTypes.containsKey(name)) throw new RuntimeException("Type conflict: " + name); }
private void checkConflictInterface(String name) { if (namedInterfaces.containsKey(name)) throw new RuntimeException("Interface conflict: " + name); }
public void declareConst(String name, DefInfo di, RALConstant cst) { if (namedConstants.containsKey(name)) { DefInfo sp2 = namedConstantsDefPoints.get(name); if (sp2 != null) throw new RuntimeException( "Constant conflict: " + name + " @ " + di.describePosition() + ", last definition " + sp2.describePosition()); throw new RuntimeException("Constant conflict: " + name + " @ " + di.describePosition()); } namedConstants.put(name, cst); namedConstantsDefPoints.put(name, di); }
public AgentClassifier tryGetAsClassifier(String text) { RALType maybeClassifier = namedTypes.get(text); if (maybeClassifier instanceof RALType.AgentClassifier) return (RALType.AgentClassifier) maybeClassifier; return null; }
public void declareTypedef(String name, RALType parseType, DefInfo di) { RALType existing = namedTypes.get(name); if (existing != null) { if (existing != parseType) throw new RuntimeException("Can't redeclare type " + name); } else { namedTypes.put(name, parseType); namedTypesDefPoints.put(name, di); } }
public boolean isScriptValid() { return (family == 0 && genus == 0 && species == 0) || (family != 0 && genus == 0 && species == 0) || (family != 0 && genus != 0 && species == 0) || (family != 0 && genus != 0 && species != 0); }
public Classifier genScriptParent() { if (family != 0 && genus == 0 && species == 0) return new Classifier(0, 0, 0); if (family != 0 && genus != 0 && species == 0) return new Classifier(family, 0, 0); if (family != 0 && genus != 0 && species != 0) return new Classifier(family, genus, 0); return null; }
public Classifier genScriptChild(int val) { if (family == 0 && genus == 0 && species == 0) return new Classifier(val, 0, 0); if (family != 0 && genus == 0 && species == 0) return new Classifier(family, val, 0); if (family != 0 && genus != 0 && species == 0) return new Classifier(family, genus, val); throw new RuntimeException("Cannot extend full/wrong classifier"); }
public boolean isWildcard() { return family == 0 || genus == 0 || species == 0; }
public boolean contains(Classifier other) { if (family != 0 && other.family != family) return false; if (genus != 0 && other.genus != genus) return false; if (species != 0 && other.species != species) return false; return true; }
@Override public String toString() { return "[" + family + " " + genus + " " + species + "]"; }
public String toCAOSString() { return family + " " + genus + " " + species; }
@Override public int hashCode() { return family ^ genus ^ species; }
@Override public boolean equals(Object obj) { if (obj instanceof Classifier) { if (((Classifier) obj).family != family) return false; if (((Classifier) obj).genus != genus) return false; if (((Classifier) obj).species != species) return false; return true; } return false; }
@Override public int compareTo(Classifier o) { if (family < o.family) return -1; if (family > o.family) return 1; if (genus < o.genus) return -1; if (genus > o.genus) return 1; if (species < o.species) return -1; if (species > o.species) return 1; return 0; }
public final RALType assertImpCast(RALType type) { if (!canImplicitlyCast(type)) throw new RuntimeException("Cannot cast " + this + " to " + type); return this; }
public final void implicitlyCastOrThrow(RALType type, Object src, Object dst) { if (!canImplicitlyCast(type)) throw new RuntimeException( "Cannot cast " + this + "(" + src + ") to " + type + "(" + dst + ")"); }
protected void regenInterfaces() { interfaces = genInterfaces(); for (RALType rt : influencesInterfacesOf) rt.regenInterfaces(); }
public final Integer lookupMSID(String name, boolean asScript) { for (AgentInterface ai : interfaces) { AgentInterface.MsgScr a = (asScript ? ai.scripts : ai.messages).get(name); if (a != null) return a.value; } return null; }
public final String lookupMSName(int id, boolean asScript) { for (AgentInterface ai : interfaces) { String a = (asScript ? ai.scriptsInv : ai.messagesInv).get(id); if (a != null) return a; } return null; }
public final OVar lookupField(String name) { for (AgentInterface ai : interfaces) { OVar a = ai.fields.get(name); if (a != null) return a; } return null; }
public Major autoPromote(Major other) { if (this == Unknown) return other; return this; }
@Override protected AgentInterface[] genInterfaces() { if (parentType != null) return parentType.genInterfaces(); return new AgentInterface[0]; }
public boolean contains(RALType rt) { return contents.contains(rt); }
@Override public Iterator<RALType> iterator() { return contents.iterator(); }
@Override public String toString() { StringBuilder res = new StringBuilder(); boolean first = true; for (RALType rt : contents) { if (!first) res.append('|'); first = false; res.append(rt); } return res.toString(); }
@Override protected AgentInterface[] genInterfaces() { HashSet<AgentInterface> all = new HashSet<>(); for (RALType rt : contents) { if (rt.interfaces == null) throw new RuntimeException("attempted to gen interfaces when interfaces null on " + rt); for (AgentInterface ai : rt.interfaces) all.add(ai); } HashSet<AgentInterface> filtered = new HashSet<>(); for (AgentInterface ai : all) { boolean ok = true; for (RALType rt : contents) { ok = false; for (AgentInterface ai2 : rt.interfaces) if (ai == ai2) { ok = true; break; } if (!ok) break; } if (ok) filtered.add(ai); } return filtered.toArray(new AgentInterface[0]); }
@Override public String toString() { return getFullDescription(); }
@Override protected AgentInterface[] genInterfaces() { return new AgentInterface[0]; }
public void addParent(Agent impl) { parents.add(impl); impl.influencesInterfacesOf.add(this); regenInterfaces(); }
@Override protected AgentInterface[] genInterfaces() { LinkedList<AgentInterface> total = new LinkedList<>(); total.add(inherent); for (Agent par : parents) for (AgentInterface ai : par.getInterfaces()) if (!total.contains(ai)) total.add(ai); return total.toArray(new AgentInterface[0]); }
public final void declareMS(String name, int id, boolean asScript, DefInfo di) { boolean asMessage = !asScript; AgentInterface.MST intent = asScript ? AgentInterface.MST.Script : AgentInterface.MST.Message; if (!typeSystem.messageHooks.contains(id)) { asMessage = true; asScript = true; intent = AgentInterface.MST.Both; } if (asMessage) { if (lookupMSID(name, false) != null) throw new RuntimeException("message " + typeName + "->" + name + " already declared"); if (lookupMSName(id, false) != null) throw new RuntimeException("message " + typeName + " " + id + " already declared"); } if (asScript) { if (lookupMSID(name, true) != null) throw new RuntimeException("script " + typeName + ":" + name + " already declared"); if (lookupMSName(id, true) != null) throw new RuntimeException("script " + typeName + " " + id + " already declared"); } AgentInterface.MsgScr ms = new AgentInterface.MsgScr(name, id, intent, di); if (asMessage) { inherent.messages.put(name, ms); inherent.messagesInv.put(id, name); } if (asScript) { inherent.scripts.put(name, ms); inherent.scriptsInv.put(id, name); } }
public void declareField(String fieldName, RALType fieldType, DefInfo idi, int ovSlot) { if (lookupField(fieldName) != null) throw new RuntimeException("Field " + fieldName + " already exists in " + this); inherent.fields.put(fieldName, new OVar(fieldName, ovSlot, fieldType, idi)); }
@Override public String toString() { return typeName; }
@Override public int compareTo(Attachment var1) { return name.compareTo(var1.name); }
@Override public String toString() { return "field " + type + " " + name + " (" + CAOSUtils.vaToString("ov", slot) + ")"; }
@Override public String toString() { if (intent == MST.Message) return "msg " + name + " (" + value + ")"; if (intent == MST.Script) return "scr " + name + " (" + value + ")"; return "m/s " + name + " (" + value + ")"; }
@Override public boolean equals(Object obj) { if (obj instanceof RALLambdaSignature) { return ((RALLambdaSignature) obj).rets.equals(rets) && ((RALLambdaSignature) obj).args.equals(args) && ((RALLambdaSignature) obj).argsInline.equals(argsInline); } return false; }
@Override public int hashCode() { return rets.hashCode() ^ args.hashCode() ^ argsInline.hashCode(); }
@Override public RALStatement resolveInner(ScopeContext csc) { return new Resolved(extent, resolveParts(parts, csc)); }
@Override public String toString() { return "inline (...);"; }
@Override protected void compileInner(CodeWriter writer, CompileContext scope) { try (CompileContext scope2 = scope.forkVAEH()) { scope.writer.writeCode(compileResolvedParts(parts2, scope2, false)); } }
public static Object[] resolveParts(Object[] parts, ScopeContext csc) { final Object[] parts2 = new Object[parts.length]; for (int i = 0; i < parts2.length; i++) { Object o = parts[i]; if (o instanceof String) { parts2[i] = o; } else if (o instanceof RALExprUR) { parts2[i] = ((RALExprUR) o).resolve(csc); } else { throw new RuntimeException("Inline sections take Strings and RALExprsURs."); } } return parts2; }
public static String compileResolvedParts(Object[] resolvedParts, CompileContextNW scope) { return compileResolvedParts(resolvedParts, scope, true); }
public static String compileResolvedParts(Object[] resolvedParts, CompileContext scope) { return compileResolvedParts(resolvedParts, scope, false); }
private static String compileResolvedParts( Object[] resolvedParts, CompileContextNW scope, boolean inlineOnly) { StringBuilder interiorWriter = new StringBuilder(); for (Object o : resolvedParts) { if (o instanceof String) { interiorWriter.append(o); } else if (o instanceof RALExprSlice) { RALExprSlice re = (RALExprSlice) o; if (!inlineOnly) { boolean[] inline = new boolean[re.length]; for (int i = 0; i < re.length; i++) inline[i] = re.getInlineCAOS(i, false, scope) != null; VarCacher vc = new VarCacher(re, inline, null); vc.writeCacheCode((CompileContext) scope); re = vc.finishedOutput; } for (int i = 0; i < re.length; i++) { String inlineRepr = re.getInlineCAOS(i, false, scope); if (inlineRepr == null) { return null; } if (i != 0) interiorWriter.append(" "); interiorWriter.append(inlineRepr); } } else { throw new RuntimeException("RALInlineStatement intern takes Strings and RALExprs."); } } return interiorWriter.toString(); }
@Override protected void compileInner(CodeWriter writer, CompileContext context) { try (CompileContext ccOuter = context.forkVAEHBreak(IBreakHandler.NOP)) { String endJumpLabel = ccOuter.allocLabel(ILabelHandle.BREAK); IBreakHandler trueHandler = context.typeSystem.codeGenFeatureLevel.requiresEnumBreakout ? EnumBreaker.INSTANCE : IBreakHandler.NOP; try (CompileContext cc = ccOuter.forkBreak(trueHandler)) { String continueLabel = cc.allocLabel(ILabelHandle.CONTINUE); loopStarter.compileInner(writer, cc); writer.indent++; loopBodyR.compileInner(writer, cc); if (cc.isLabelDefinedHereUsed(ILabelHandle.CONTINUE)) { writer.writeCode("goto " + continueLabel); writer.writeCode("subr " + continueLabel); } writer.writeCode(-1, "next"); } if (ccOuter.isLabelDefinedHereUsed(ILabelHandle.BREAK)) { writer.writeCode("goto " + endJumpLabel); writer.writeCode("subr " + endJumpLabel); } } }
@Override public String toString() { return enumToken + " " + targType; }
@Override public RALStatement resolveInner(ScopeContext scope) { RALExprSlice initRes = null; RALType[] finalTypes = new RALType[types.length]; System.arraycopy(types, 0, finalTypes, 0, types.length); if (init != null) { initRes = init.resolve(scope); if (initRes.length != names.length) throw new RuntimeException( "Expression return values don't match amount of defined variables"); for (int i = 0; i < names.length; i++) { RALType rt = initRes.readType(i); if (finalTypes[i] != null) { rt.assertImpCast(finalTypes[i]); } else { finalTypes[i] = rt; } } } else { for (int i = 0; i < names.length; i++) if (finalTypes[i] == null) throw new RuntimeException("Variable " + names[i] + " auto but no assignment statement"); } RALVarVA[] vars = new RALVarVA[names.length]; for (int i = 0; i < names.length; i++) { RALVarVA rvv = scope.newLocal(names[i], defInfo, finalTypes[i]); vars[i] = rvv; } return new Resolved(extent, names, fixedAlloc, vars, initRes); }
@Override protected void compileInner(CodeWriter writer, CompileContext scope) { for (int i = 0; i < vars.length; i++) { if (fixedAlloc[i] == -1) { scope.allocVA(vars[i].handle); } else { scope.allocVA(vars[i].handle, fixedAlloc[i]); } writer.writeComment( vars[i].getInlineCAOS(0, false, scope) + ": " + vars[i].type + " " + names[i]); } if (init != null) { try (CompileContext iScope = scope.forkVAEH()) { init.readCompile(RALExprSlice.concat(vars), iScope); } } }
@Override public String toString() { return "let (...);"; }
public final RALStatement resolve(ScopeContext scope) { scope.world.diags.pushFrame(extent); RALStatement res = null; try { scope.world.hcm.resolvePre(extent, scope); res = resolveInner(scope); scope.world.hcm.resolvePost(extent, scope); } catch (Exception ex) { scope.world.diags.error("statement resolve: ", ex); res = new RALInlineStatement.Resolved( extent, new String[] {"STOP * RAL STATEMENT RESOLVE ERROR"}); } scope.world.diags.popFrame(extent); return res; }
@Override protected void compileInner(CodeWriter writer, CompileContext context) { try (CompileContext ccs = context.forkVAEHBreak(IBreakHandler.NOP)) { String labelTop = ccs.allocLabel(ILabelHandle.CONTINUE); String labelEnd = ccs.allocLabel(ILabelHandle.BREAK); writer.writeCode("goto " + labelTop); writer.writeCode("subr " + labelTop, 1); rs.compile(writer, ccs); writer.writeCode(-1, "goto " + labelTop); writer.writeCode("subr " + labelEnd); } }
@Override public String toString() { return "loop { (...) }"; }
@Override protected void compileInner(CodeWriter writer, CompileContext scope) { writer.writeComment(exp + ": " + name); }
@Override public String toString() { return "alias (...);"; }
@Override public RALStatement resolveInner(ScopeContext scope) { if (isScopeBreaking) scope = new ScopeContext(scope); final LinkedList<RALStatement> content2 = new LinkedList<>(); for (RALStatementUR ur : content) content2.add(ur.resolve(scope)); return new Resolved(extent, content2, isScopeBreaking); }
@Override protected void compileInner(CodeWriter writer, CompileContext cc) { if (isScopeBreaking) { try (CompileContext innerScope = cc.forkVAEH()) { for (RALStatement rl : content2) rl.compile(writer, innerScope); } } else { for (RALStatement rl : content2) rl.compile(writer, cc); } }
@Override public String toString() { return "{...}"; }
@Override public RALStatement resolveInner(ScopeContext scope) { scope = new ScopeContext(scope); final RALExprSlice targetsR = targets == null ? null : targets.resolve(scope); final RALExprSlice sourceR = source.resolve(scope); return new Resolved(extent, targetsR, sourceR); }
@Override protected void compileInner(CodeWriter writer, CompileContext cc) { try (CompileContext c2 = cc.forkVAEH()) { if (targetsR == null) { sourceR.readCompile(new RALDiscard(c2.typeSystem, sourceR.length), c2); } else { sourceR.readCompile(targetsR, c2); } } }
@Override public String toString() { return targetsR + " = " + sourceR; }
@Override public String toString() { return "goto " + globalHandle + ";"; }
@Override protected void compileInner(CodeWriter writer, CompileContext context) { context.labelScope.compileJump(globalHandle, context); }
@Override protected void compileInner(CodeWriter writer, CompileContext context) { }
@Override public String toString() { return "if (DCE'd)"; }
@Override protected void compileInner(CodeWriter writer, CompileContext context) { try (CompileContext outerCtx = context.forkVAEH()) { String inl = conditionR.compileCond(writer, outerCtx, invert); writer.writeCode("doif " + inl, 1); try (CompileContext bsr = outerCtx.forkVAEH()) { mainBranchR.compile(writer, bsr); } if (elseBranchR != null) { writer.writeCode(-1, "else", 1); try (CompileContext bsr = outerCtx.forkVAEH()) { elseBranchR.compile(writer, bsr); } } writer.writeCode(-1, "endi"); } }
@Override public String toString() { return "if " + (invert ? "! " : "") + conditionR.toString() + " (...)"; }
public final void compile(CodeWriter writer, CompileContext context) { if (writer.queuedCommentForNextLine == null) writer.queuedCommentForNextLine = writer.debug.createQueuedComment(this); DebugSite newSite = null; if (writer.debug.shouldGenerateSites()) newSite = new DebugSite(context.currentDebugSite, extent.start.toUntranslated(), context); try (CompileContext c2 = context.forkDebugDiagExtent(newSite, extent)) { if (newSite != null) writer.queuedSiteForNextLine = c2.currentDebugSite; try { compileInner(writer, c2); } catch (Exception ex) { context.diags.error("stmt compile: ", ex); } } }
@Override protected RALStatement resolveInner(ScopeContext scope) { RALExprSlice resL = target.resolve(scope); RALExprSlice resR = source.resolve(scope); return new Resolved(extent, resL, resR, op, scope.world.types); }
@Override public String toString() { return target + " " + op + " " + source; }
@Override protected void compileInner(CodeWriter writer, CompileContext context) { try (CompileContext c2 = context.forkVAEH()) { RALVarVA lVA = null; String lInline = target.getInlineCAOS(0, true, c2); String rInline = source.getInlineCAOS(0, false, c2); if (lInline == null) { lVA = c2.allocVA(sourceType, "modAssignL"); target.readCompile(lVA, c2); lInline = lVA.getCode(c2); } if (rInline == null) { RALVarVA va = c2.allocVA(sourceType, "modAssignR"); source.readCompile(va, c2); rInline = va.getCode(c2); } op.stepCodegen(targetType, lInline, sourceType, rInline, c2); if (lVA != null) target.writeCompile(0, lVA.getCode(c2), targetNewType.majorType, c2); } }
@Override public String toString() { return modifier; }
@Override public void stepCodegen( RALType l, String lInline, RALType r, String rInline, CompileContext context) { context.writer.writeCode(modifier + " " + lInline + " " + rInline); }
@Override public RALType inputType(TypeSystem ts) { return ts.gNumber; }
@Override public RALType inputType(TypeSystem ts) { return ts.gInteger; }
@Override public RALType stepType(TypeSystem ts, RALType l, RALType r) { return ts.gInteger; }
public final RALConstant stepConst(TypeSystem ts, RALConstant l, RALConstant r) { if ((l instanceof RALConstant.Int) && (r instanceof RALConstant.Int)) { RALConstant.Int li = (RALConstant.Int) l; RALConstant.Int ri = (RALConstant.Int) r; return new RALConstant.Int(ts, stepConst(li.value, ri.value)); } return null; }
private static RALType workOutNumberType(TypeSystem ts, RALType l, RALType r) { boolean lInt = l.canImplicitlyCast(ts.gInteger); boolean lFloat = l.canImplicitlyCast(ts.gFloat); boolean rInt = r.canImplicitlyCast(ts.gInteger); boolean rFloat = r.canImplicitlyCast(ts.gFloat); if (lInt && rInt) return ts.gInteger; if (lFloat || rFloat) return ts.gFloat; return ts.gNumber; }
@Override public RALType stepType(TypeSystem ts, RALType l, RALType r) { return workOutNumberType(ts, l, r); }
public final RALConstant stepConst(TypeSystem ts, RALConstant l, RALConstant r) { if ((l instanceof RALConstant.Number) && (r instanceof RALConstant.Number)) { RALConstant.Number ln = (RALConstant.Number) l; RALConstant.Number rn = (RALConstant.Number) r; if ((l instanceof RALConstant.Int) && (r instanceof RALConstant.Int)) { RALConstant.Int li = (RALConstant.Int) l; RALConstant.Int ri = (RALConstant.Int) r; return new RALConstant.Int(ts, stepConstI(li.value, ri.value)); } return new RALConstant.Flo(ts, stepConstF(ln.toFloat(), rn.toFloat())); } return null; }
@Override int stepConst(int a, int b) { return a | b; }
@Override int stepConst(int a, int b) { return a & b; }
@Override float stepConstF(float a, float b) { return a - b; }
@Override int stepConstI(int a, int b) { return a - b; }
@Override float stepConstF(float a, float b) { return a / b; }
@Override int stepConstI(int a, int b) { return a / b; }
@Override float stepConstF(float a, float b) { return a * b; }
@Override int stepConstI(int a, int b) { return a * b; }
@Override public String toString() { return "+"; }
@Override public RALType inputType(TypeSystem ts) { return ts.gStringOrNumber; }
@Override public void stepCodegen( RALType l, String lInline, RALType r, String rInline, CompileContext context) { boolean lStr = l.canImplicitlyCast(context.typeSystem.gString); boolean rStr = r.canImplicitlyCast(context.typeSystem.gString); if ((!lStr) && (!rStr)) { context.writer.writeCode("addv " + lInline + " " + rInline); } else if ((!lStr) && (rStr)) { context.writer.writeCode("sets " + lInline + " vtos " + lInline); context.writer.writeCode("adds " + lInline + " " + rInline); } else if ((lStr) && (!rStr)) { context.writer.writeCode("adds " + lInline + " vtos " + rInline); } else if ((lStr) && (rStr)) { context.writer.writeCode("adds " + lInline + " " + rInline); } else { throw new RuntimeException("How'd you manage that? " + lStr + " " + rStr); } }
@Override public RALConstant stepConst(TypeSystem ts, RALConstant l, RALConstant r) { if (l instanceof RALConstant.Number) { if (r instanceof RALConstant.Number) { return stepConstAddNumbers(ts, (RALConstant.Number) l, (RALConstant.Number) r); } else if (r instanceof RALConstant.Str) { return new RALConstant.Str(ts, l.toString() + ((RALConstant.Str) r).valueChars); } } else if (l instanceof RALConstant.Str) { if (r instanceof RALConstant.Number) { return new RALConstant.Str(ts, ((RALConstant.Str) l).valueChars + r.toString()); } else if (r instanceof RALConstant.Str) { return new RALConstant.Str( ts, ((RALConstant.Str) l).valueChars + ((RALConstant.Str) r).valueChars); } } return null; }
private RALConstant stepConstAddNumbers( TypeSystem ts, RALConstant.Number l, RALConstant.Number r) { if ((l instanceof RALConstant.Int) && (r instanceof RALConstant.Int)) return new RALConstant.Int(ts, ((RALConstant.Int) l).value + ((RALConstant.Int) r).value); return new RALConstant.Flo(ts, l.toFloat() + r.toFloat()); }
@Override public RALType stepType(TypeSystem ts, RALType l, RALType r) { boolean lStr = l.canImplicitlyCast(ts.gString); boolean rStr = r.canImplicitlyCast(ts.gString); if (!lStr) l.assertImpCast(ts.gNumber); if (!rStr) r.assertImpCast(ts.gNumber); if (lStr || rStr) return ts.gString; return workOutNumberType(ts, l, r); }
public JSONObject toJSON(int frameCount) { JSONObject jo = new JSONObject(); if (parent != null && frameCount > 1) jo.put("parent", parent.toJSON(frameCount - 1)); jo.put("file", ((FileDocPath) location.file).file.getAbsolutePath()); jo.put("line", location.line); jo.put("character", location.character); for (int i = 0; i < vaNames.length; i++) { String df = CAOSUtils.vaToString(i); if (vaNames[i] != null) jo.put(df, vaNames[i]); } return jo; }
public String encode(int frameCount) { byte[] data = toJSON(frameCount).toString().getBytes(StandardCharsets.UTF_8); try { ByteArrayOutputStream baos = new ByteArrayOutputStream(); GZIPOutputStream gos = new GZIPOutputStream(baos); gos.write(data); gos.close(); data = baos.toByteArray(); } catch (Exception e2) { throw new RuntimeException(e2); } return Base64.getEncoder().encodeToString(data); }
public static DebugSite tryDecode(String string) { try { byte[] data = Base64.getDecoder().decode(string); try (GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(data))) { return new DebugSite( new JSONObject(new JSONTokener(new InputStreamReader(gis, StandardCharsets.UTF_8)))); } } catch (Exception ex) { return null; } }
@Override public boolean shouldGenerateSites() { return true; }
@Override public void saveSiteAndCreateMarker(CodeWriter caller, DebugSite ds) { int depth = ds.depth; while (depth > 0) { try { ByteString wanted = new ByteString(ds.encode(depth), CAOSUtils.CAOS_CHARSET); ByteString.Builder b = new ByteString.Builder(wanted.length() + 2); b.writeASCII("sets va99 "); CAOSUtils.stringIntoCAOSConstant(b, wanted, codeGenFeatureLevel); caller.writeCode(b); return; } catch (CAOSUtils.ConstantTooLargeForVMException vme) { } depth--; } caller.writeComment( "Unable to represent frame in acceptable constant string bounds for this VM."); caller.writeCode("sets va99 \"\""); }
@Override public void initializeRootCC(CompileContext compileContext) { compileContext.allocVA(99); }
@Override public String createQueuedComment(RALStatement rs) { if (detailed) { return "@ " + rs.extent + " " + rs; } else { return "@ " + rs.extent; } }
@Override public String createQueuedComment(RALStatement rs) { return null; }
@Override public boolean shouldGenerateSites() { return false; }
@Override public void saveSiteAndCreateMarker(CodeWriter caller, DebugSite ds) {}
@Override public void initializeRootCC(CompileContext compileContext) {}
public JSONObject toLSPDiagnostic() { JSONObject diagJ = new JSONObject(); diagJ.put("range", extent.toLSPRange()); diagJ.put("severity", 1); diagJ.put("message", text); return diagJ; }
private void sendError(PrintStream out, int code, Object id, String string) throws IOException { JSONObject rsp = new JSONObject(); rsp.put("jsonrpc", "2.0"); rsp.put("id", id); JSONObject err = new JSONObject(); rsp.put("error", err); err.put("code", code); err.put("message", string); sendObj(out, rsp); }
public void sendNotification(String method, JSONObject par) throws IOException { JSONObject rsp = new JSONObject(); rsp.put("jsonrpc", "2.0"); rsp.put("method", method); if (par != null) rsp.put("params", par); sendObj(out, rsp); }
private void sendObj(PrintStream out, JSONObject rsp) throws IOException { if (err != null) { err.print("OUT: "); rsp.write(err, 1, 0); err.println(); err.flush(); } byte[] data = rsp.toString().getBytes(StandardCharsets.UTF_8); out.print("Content-Length: " + data.length + "\r\n\r\n"); out.flush(); out.write(data); out.flush(); }
private File decodeFileURI(String uri) { if (uri.startsWith("file://")) try { return new File(URLDecoder.decode(uri.substring(7), lspURLEncoding)).getAbsoluteFile(); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } return null; }
private String encodeFileURI(File file) { String ovr = uriLSPClientCanon.get(file); if (ovr != null) return ovr; try { return "file://" + URLEncoder.encode(file.getAbsolutePath(), lspURLEncoding); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }
public void storeShadow(IDocPath path, String text) { if (text == null) { stored.remove(path); } else { stored.put(path, text); } }
@Override public Reader open() throws IOException { String override = stored.get(this); if (override != null) return new StringReader(override); return super.open(); }
@Override public boolean isFile() { if (stored.containsKey(this)) return true; return super.isFile(); }
@Override public String toString() { String base = super.toString(); return stored.containsKey(this) ? ("*" + base) : base; }
@Override public String toLSPURI() { return encodeFileURI(file); }
@Override public int hashCode() { return uri.hashCode(); }
@Override public boolean equals(Object var1) { if (var1 instanceof ExternalDP) return ((ExternalDP) var1).uri.equals(var1); return false; }
@Override public Reader open() throws IOException { String override = stored.get(this); if (override != null) return new StringReader(override); throw new FileNotFoundException("URI " + uri + " not available"); }
@Override public byte[] readAllBytes() throws IOException { String override = stored.get(this); if (override != null) return override.getBytes(StandardCharsets.UTF_8); throw new FileNotFoundException("URI " + uri + " not available"); }
@Override public boolean isFile() { return stored.containsKey(this); }
@Override public String toString() { return uri; }
@Override public String toLSPURI() { return uri; }
public void regenDiagnostics(String uri, LSPBaseProtocolLoop sendback) throws IOException { JSONObject diagsUpdate = new JSONObject(); diagsUpdate.put("uri", uri); JSONArray diagsContent = new JSONArray(); LSPDiag[] gd = getDiagnostics(docRepo.getDocPath(uri)); for (LSPDiag d : gd) diagsContent.put(d.toLSPDiagnostic()); diagsUpdate.put("diagnostics", diagsContent); sendback.sendNotification("textDocument/publishDiagnostics", diagsUpdate); }
@Override public void handleNotification(String method, JSONObject params, LSPBaseProtocolLoop sendback) throws IOException { if (method.equals("textDocument/didOpen")) { JSONObject actualParams = params.getJSONObject("textDocument"); String givenURI = actualParams.getString("uri"); docRepo.storeShadow(docRepo.getDocPath(givenURI), actualParams.getString("text")); regenDiagnostics(givenURI, sendback); } else if (method.equals("textDocument/didChange")) { JSONObject ident = params.getJSONObject("textDocument"); String givenURI = ident.getString("uri"); JSONArray changes = params.getJSONArray("contentChanges"); String anyFullContent = null; for (int i = 0; i < changes.length(); i++) { JSONObject change = changes.getJSONObject(i); if (!change.has("range")) anyFullContent = change.getString("text"); } if (anyFullContent != null) { docRepo.storeShadow(docRepo.getDocPath(givenURI), anyFullContent); regenDiagnostics(givenURI, sendback); } } else if (method.equals("textDocument/didClose")) { JSONObject ident = params.getJSONObject("textDocument"); String givenURI = ident.getString("uri"); IDocPath docPath = docRepo.getDocPath(givenURI); docRepo.storeShadow(docPath, null); docHCM.remove(docPath); } }
private static void doAttachment(String baseIndent, StringBuilder sb, Attachment a, Rule[] r) { if (matchesRules(a.defInfo, r)) { sb.append(baseIndent + "## `"); sb.append(a.toString()); sb.append("`\n\n"); showDocBody(sb, (DefInfo.At) a.defInfo); } }
private static void buildCallable(String baseIndent, StringBuilder sb, RALCallable rc, Rule[] r) { if (rc instanceof MacroDefSet) { HashMap<Integer, RALCallable.Global> rcx = ((MacroDefSet) rc).map; LinkedList<Integer> l = new LinkedList<>(rcx.keySet()); Collections.sort(l); for (Integer i : l) buildCallable(baseIndent, sb, rcx.get(i), r); } else if (rc instanceof Macro) { Macro mac = (Macro) rc; if (matchesRules(mac.defInfo, r)) { sb.append(baseIndent + "# `"); sb.append(mac.name); HCMHoverDataGenerators.showMacroArgs(sb, mac.args); if (mac.precompiledCode != null) { sb.append(": "); HCMHoverDataGenerators.showSlots(sb, mac.precompiledCode.slots()); } sb.append("`\n\n"); showDocBody(sb, mac.defInfo); } } }
private static void showDocBody(StringBuilder sb, DefInfo di) { if (di.docComment != null) { sb.append(di.docComment); sb.append("\n\n"); } sb.append("_Declared in:_ `"); sb.append(translateDefInfo(di)); sb.append("`\n\n"); }
private static String translateDefInfo(DefInfo di) { if (di instanceof DefInfo.Builtin) return "Built-in"; if (di instanceof DefInfo.At) return di.srcRange.file.shortName; return "Unknown DefInfo type: " + di; }
private static boolean matchesRules(DefInfo di, Rule[] r) { boolean matches = true; if (di instanceof DefInfo.Builtin) { for (Rule rule : r) if (rule.prefix.equals("BUILTIN")) matches = rule.add; } if (di instanceof DefInfo.At) { String spf = di.srcRange.file.shortName; for (Rule rule : r) { if (rule.prefix.equals("BUILTIN")) continue; if (spf.startsWith(rule.prefix)) matches = rule.add; } } return matches; }
public Classifier classifierByName(String name) { return names.get(name); }
public Iterable<String> allNamesIterable() { return names.keySet(); }
public boolean doNotInject() { return gameState == State.Tacked || gameState == State.RunningTack; }
private void updateGameState() { if (lastGameState != gameState) { lastGameState = gameState; stateChange.fire(gameState); } }
public void tackPlay(Function<RawDebugFrame, Boolean> sd) { stepDecider = sd; try { Injector.cpxRequest("execute\ndbg: tack tack", CAOSUtils.CAOS_CHARSET); gameState = State.RunningTack; } catch (Exception ex) { gameState = State.Offline; } updateGameState(); }
public void dbgPlay() { stepDecider = DebugStepDecider.SKIP_METADATA; try { Injector.cpxRequest("execute\ndbg: play", CAOSUtils.CAOS_CHARSET); gameState = State.Running; } catch (Exception ex) { gameState = State.Offline; } updateGameState(); }
@Override public void windowOpened(WindowEvent e) { trk.additionalRefreshTasks.add(refreshEv); }
@Override public void windowClosed(WindowEvent e) { trk.additionalRefreshTasks.remove(refreshEv); }
private void recordToHistoryIfNotDuplicate(String req) { if (!history.isEmpty()) if (history.getLast().equals(req)) return; history.add(req); historyIndex = history.size(); }
private void historyIntoField() { if (historyIndex < 0) return; if (historyIndex >= history.size()) return; textField.setText(history.get(historyIndex)); }
public void putText(String text) { StyledDocument sd = textPane.getStyledDocument(); try { sd.insertString(sd.getLength(), text, null); } catch (Exception ex) { } textPane.setCaretPosition(sd.getLength()); }
public void fakeInput(String req) { putText("> " + req + "\n"); if (req.equalsIgnoreCase("cls")) { textPane.setText(""); return; } try { putText(communicator.apply(req)); } catch (Exception ex) { ex.printStackTrace(); putText(ex.getMessage() + "\n"); } }
public static Mut immToMut(DebugStepDecider imm) { return (rdf) -> imm; }
@Override public Boolean apply(RawDebugFrame var1) { boolean res1 = currentCycle.apply(var1); if (res1) return true; sc2--; if (sc2 > 0) { currentCycle = interior.apply(var1); return true; } return false; }
public static DebugStepDecider stepOver(ProcessedDebugFrame processedFrame) { final String avoidLI = processedFrame.lineIdentifier; return (rdf) -> { if (SKIP_METADATA.apply(rdf)) return true; ProcessedDebugFrame[] frames = ProcessedDebugFrame.process(rdf); for (ProcessedDebugFrame av : frames) if (av.lineIdentifier.equals(avoidLI)) return true; return false; }; }
@Override public Boolean apply(RawDebugFrame var1) { if (SKIP_METADATA.apply(var1)) { hasReachedAtLeastOneMD = true; return true; } else if (hasReachedAtLeastOneMD) { return false; } else { return true; } }
public String get() { if (index >= contents.length) throw new RuntimeException(help); return contents[index++]; }
public void expectNoMore() { if (index != contents.length) throw new RuntimeException(help); }
public boolean hasMore() { return index < contents.length; }
public int remaining() { return contents.length - index; }
private static CodeViewPane.Contents findLineInCAOS(String caos, int ofs) { int plannedLine = 0; int chr = 0; if (ofs < caos.length()) { for (int i = 0; i < ofs; i++) { if (caos.charAt(i) == 10) { plannedLine++; chr = 0; } else { chr++; } } } return new CodeViewPane.Contents(caos, plannedLine, chr); }
private void doVV(final String arg) { new ValueMonitorDialog(state, "vv:" + arg, () -> arg); }
private Classifier classifierArg(StringArrayStream args, int decision) { if (args.remaining() >= decision) { int f = Integer.parseInt(args.get()); int g = Integer.parseInt(args.get()); int s = Integer.parseInt(args.get()); return new Classifier(f, g, s); } else { String name = args.get(); if (state.debugTaxonomy == null) throw new RuntimeException( "Hasn't compiled, so no debug taxonomy - use View CAOS or an inject button"); Classifier cls = state.debugTaxonomy.classifierByName(name); if (cls == null) throw new RuntimeException("Unable to find classifier for " + name); return cls; } }
private String bp(StringArrayStream args, boolean b) { Classifier cls = classifierArg(args, 4); int e = Integer.parseInt(args.get()); args.expectNoMore(); if (state.doNotInject()) return "Game potentially mid-processing, will not inject\n"; String magic = "dbg: tack ownr "; String fgse = cls.toCAOSString() + " " + e; try { String code = Injector.cpxRequest("execute\nouts sorc " + fgse + "\n", CAOSUtils.CAOS_CHARSET); if (!b) { if (code.startsWith(magic)) { code = code.substring(magic.length()); } else { return "No alteration necessary"; } } else { if (code.startsWith(magic)) { return "No alteration necessary"; } else { code = magic + code; } } return Injector.cpxRequest("scrp " + fgse + "\n" + code, CAOSUtils.CAOS_CHARSET) + "\n"; } catch (Exception ex) { ex.printStackTrace(); return "Error in injection: " + ex.getMessage() + "\n"; } }
@Override public int allocVA() { int va = currentVA++; if (va >= 100) throw new RuntimeException("Out of VAs"); return va; }
@Override public void allocVA(int i) { throw new RuntimeException("Cannot perform fixed VA allocation from linear allocator"); }
@Override public String toString() { return "break"; }
@Override public String toString() { return "continue"; }
@Override public void compile(CompileContext context) {}
public CompileContext forkVAEH() { return new CompileContext(this, true, true, null, null, null); }
@Override public CompileContext forkEH() { return new CompileContext(this, false, true, null, null, null); }
public CompileContext forkBreak(IBreakHandler escape) { assert escape != null; return new CompileContext(this, false, false, null, null, escape); }
public CompileContext forkVAEHBreak(IBreakHandler escape) { assert escape != null; return new CompileContext(this, true, true, null, null, escape); }
public CompileContext forkDebugDiagExtent(DebugSite dbg, SrcRange diagExtent) { return new CompileContext(this, false, false, dbg, diagExtent, null); }
@Override public void close() { if (diagsExtent != null) diags.popFrame(diagsExtent); if (ownsVAScope) vaScope.close(); }
@Override public CodeWriter internalCodeWriter() { return writer; }
@Override public CCTXLabelScope internalLabelScope() { return labelScope; }
@Override public CCTXVAScope internalVAScope() { return vaScope; }
@Override public void close() { if (subUsers != 0) throw new RuntimeException("Closing a CCTXVAScope with sub-users"); if (subUserTrackingParent != null) subUserTrackingParent.subUsers--; }
public void addLabel(ILabelHandle lbl, String name) { if (labels.containsKey(lbl)) throw new RuntimeException( "Cannot redefine label handle " + lbl + " in the same context (it makes usage tracking dodgy)"); labels.put(lbl, name); }
public boolean isDefinedHereUsed(ILabelHandle lbl) { return usedLabels.contains(lbl); }
public void compileJump(ILabelHandle break1, CompileContext context) { LinkedList<IBreakHandler> handlers = new LinkedList<>(); CCTXLabelScope here = this; while (true) { String hitHere = here.labels.get(break1); if (hitHere == null) { if (here.parent == null) throw new RuntimeException("Attempted to compile jump to non-existent " + break1); handlers.add(here.escapeAction); here = here.parent; } else { for (IBreakHandler ibh : handlers) ibh.compile(context); context.writer.writeCode("goto " + hitHere); here.usedLabels.add(break1); return; } } }
public Integer lookupVA(IVAHandle handle) { return vaScope.heldVAHandles.get(handle); }
default int allocVA(IVAHandle obj) { CCTXVAScope vac = internalVAScope(); int res = vac.alloc.allocVA(); vac.heldVAHandles.put(obj, res); return res; }
default void allocVA(int i) { CCTXVAScope vac = internalVAScope(); vac.alloc.allocVA(i); }
default void allocVA(IVAHandle obj, int i) { CCTXVAScope vac = internalVAScope(); vac.alloc.allocVA(i); vac.heldVAHandles.put(obj, i); }
@Override public String toString() { return "allocVA:" + t + ":" + site; }
default String allocLabel() { return "_RAL_" + internalCodeWriter().labelNumber++; }
default String allocLabel(ILabelHandle lbl) { String labelName = allocLabel(); internalLabelScope().addLabel(lbl, labelName); return labelName; }
default void allocLabel(ILabelHandle lbl, String lv) { internalLabelScope().addLabel(lbl, lv); }
default boolean isLabelDefinedHereUsed(ILabelHandle lbl) { return internalLabelScope().isDefinedHereUsed(lbl); }
private void writeIndent() { for (int i = 0; i < indent; i++) writer.append('\t'); }
private void writeNLC() { if (queuedCommentForNextLine != null) { String qc = queuedCommentForNextLine; queuedCommentForNextLine = null; writeComment(qc); } if (queuedSiteForNextLine != null) { DebugSite ds = queuedSiteForNextLine; queuedSiteForNextLine = null; debug.saveSiteAndCreateMarker(this, ds); } }
public void writeComment(String comment) { writeNLC(); writeIndent(); writer.append(" * "); for (char c : comment.toCharArray()) { writer.append(c); if (c == '\n') { writeIndent(); writer.append(" * "); } } writer.append('\n'); }
public void writeComment(ByteSequence comment) { writeComment(comment.toString(CAOSUtils.CAOS_CHARSET)); }
public void writeCode(int pre, String text, int post) { indent += pre; writeCode(text); indent += post; }
public void writeCode(int pre, String text) { writeCode(pre, text, 0); }
public void writeCode(String text, int post) { writeCode(0, text, post); }
public void writeCode(String text) { writeNLC(); writeIndent(); for (char c : text.toCharArray()) { writer.append(c); if (c == '\n') writeIndent(); } writer.append("\n"); }
public void writeCode(int pre, ByteSequence text, int post) { indent += pre; writeCode(text); indent += post; }
public void writeCode(int pre, ByteSequence text) { writeCode(pre, text, 0); }
public void writeCode(ByteSequence text, int post) { writeCode(0, text, post); }
public void writeCode(ByteSequence text) { writeCode(text.toString(CAOSUtils.CAOS_CHARSET)); }
@Override public byte[] readFromCryo(String moniker) { File f = getFileByFN(moniker); if (!f.exists()) return null; try (FileInputStream fos = new FileInputStream(f)) { byte[] bb = new byte[(int) f.length()]; new DataInputStream(fos).readFully(bb); return bb; } catch (Exception ex) { return null; } }
@Override public boolean writeToCryo(String moniker, byte[] data) { File f = getFileByFN(moniker); try (FileOutputStream fos = new FileOutputStream(f)) { fos.write(data); return true; } catch (Exception ex) { log(ex); f.delete(); return false; } }
@Override public boolean deleteFromCryo(String moniker) { return getFileByFN(moniker).delete(); }
private synchronized String performActualSubmit(String fn, byte[] write) { if (storage.readFromCryo(fn) != null) return "Already stored in cryo"; if (storage.getCryogenicsUsage() + write.length > config.cryo.cryoQuotaBytes.getValue()) return "Would overflow cryo quota"; if (!storage.writeToCryo(fn, write)) return "Failed to write to cryo"; return null; }
private LockedFN lockedFNByFNInSync(String optV, INatsueUserData receiver) { try { byte[] data = storage.readFromCryo(optV); LinkedList<PRAYBlock> pb = PRAYBlock.read( IOUtils.wrapLE(data), config.messages.maxDecompressedPRAYSize.getValue(), PacketReader.CHARSET); PRAYBlock root = ExportedCreatures.findCreatureRootBlock(pb); if (root == null) { log("can't get: " + optV + ", no root"); return null; } if (CryoFunctions.receiptCompatibilityCheck(pb, receiver) != null) return null; if (!ExportedCreatures.creatureConvertInPlace(pb, "warp")) { log("can't get: " + optV + ", convert failure"); return null; } CryoFunctions.cryoUpdateRootRetrieval(root, receiver.getUIN()); lockedFNs.add(optV); return new LockedFN(optV, pb); } catch (Exception e) { log(e); } return null; }
public void doDelete() { synchronized (CryoFrontend.this) { storage.deleteFromCryo(fn); } }
@Override public void close() { synchronized (CryoFrontend.this) { lockedFNs.remove(fn); } }
public synchronized boolean testFNExistsRightNow(String arg) { return storage.getFilesInCryo().contains(arg); }
@Override public boolean has2FAAuthed() { return has2FAAuthed; }
@Override public boolean try2FAAuth(int code) { if (twoFASecret != null) { if (TOTP.verify(twoFASecret, code)) { has2FAAuthed = true; return true; } } return false; }
@Override public ISessionClient acquireSessionClientForResearchCommands() { return client; }
public void dummyResponse(BaseCTOS packet) throws IOException { byte[] dummy = packet.makeDummy(); if (dummy != null) client.sendPacket(dummy); }
@Override public void logout() { hub.clientLogout(this); pingManager.logout(); }
@Override public boolean forceDisconnect(boolean sync) { client.forceDisconnect(sync); return true; }
@Override public synchronized void wwrNotify(boolean online, INatsueUserData userData) { try { client.sendPacket(PacketWriter.writeUserLine(online, userData.getBabelUserData().packed)); } catch (IOException e) { log(e); } }
@Override public void incomingMessage(PackedMessage message, Runnable reject, boolean compressIfAllowed) { incomingMessageByteArrayFastPath( message.toByteArray(config.messages.compressPRAYChunks.getValue() && compressIfAllowed), reject); }
@Override public boolean incomingMessageByteArrayFastPath(byte[] message, Runnable reject) { try { client.sendPacket(PacketWriter.writeMessage(message)); } catch (Exception ex) { log(ex); if (reject != null) reject.run(); return true; } if (reject == null) return true; final AtomicBoolean hasRejected = new AtomicBoolean(); byte[] pingPacket = pingManager.addPing( (status) -> { if (hasRejected.getAndSet(true)) return; if (status == 0) reject.run(); }); if (pingPacket == null) { if (!hasRejected.getAndSet(true)) reject.run(); return true; } try { client.sendPacket(pingPacket); } catch (Exception ex) { log(ex); if (!hasRejected.getAndSet(true)) reject.run(); } return true; }
@Override public boolean isNotReallyOnline() { return notReallyOnline; }
@Override public void markNotReallyOnline() { notReallyOnline = true; }
public byte[] addPing(IntConsumer response) { synchronized (this) { if (loggedOut) return null; short vsn = 0; for (int i = 0; i < 65536; i++) { if (nextVSN != 0) { if (!activePings.containsKey(nextVSN)) { vsn = nextVSN; break; } } nextVSN = (short) (nextVSN + 1); } if (vsn == 0) return null; activePings.put(vsn, response); if (client.logPings()) log("Sending: " + vsn); return PacketWriter.writeVirtualConnect(UINUtils.SERVER_UIN, vsn); } }
public boolean handleResponse(BaseCTOS packet) { if (packet instanceof CTOSClientCommand) { CTOSClientCommand cc = (CTOSClientCommand) packet; if (cc.targetUIN == UINUtils.SERVER_UIN) { if (cc.subCommand == 0x0E) { int serverVSN = (cc.param >> 16) & 0xFFFF; IntConsumer activePing; synchronized (this) { Short serverVSNS = (Short) (short) serverVSN; activePing = activePings.get(serverVSNS); if (activePing != null) activePings.remove(serverVSNS); } if (activePing != null) { if (client.logPings()) log("Confirmed: " + serverVSN); activePing.accept(1); } try { client.sendPacket(PacketWriter.writeVirtualCircuitClose(UINUtils.SERVER_UIN)); } catch (Exception ex) { log(ex); } return true; } } } return false; }
public void logout() { synchronized (this) { loggedOut = true; if (client.logPings()) if (activePings.size() > 0) log("Logout: " + activePings.size() + " outstanding pings"); for (IntConsumer ping : activePings.values()) ping.accept(0); activePings.clear(); } }
@Override public void handlePacket(BaseCTOS packet) throws IOException { if (packet instanceof CTOSHandshake) { handleHandshakePacket((CTOSHandshake) packet); } else { client.sendPacket( PacketWriter.writeHandshakeResponse(PacketWriter.HANDSHAKE_RESPONSE_UNKNOWN, 0L, 0L)); client.setSessionState(null); } }
@Override public MainSessionState receive( INatsueUserData.LongTermPrivileged userData, IHubClientAPI clientAPI) { byte[] secret = userData.calculate2FASecret(handshake.password); return new MainSessionState( config, client, handshake.clientVersion, secret, clientAPI, userData); }
@Override public void confirm(MainSessionState result) { client.setSessionState(result); try { long uin = result.userData.getUIN(); client.sendPacket( PacketWriter.writeHandshakeResponse( PacketWriter.HANDSHAKE_RESPONSE_OK, result.hub.getServerUIN(), uin)); client.sendPacket( PacketWriter.writeMessage( new PackedMessageWrit( uin, "natsue_version", 2468, HypercallFWModule.HVAPI_VERSION, SystemCommands.VERSION) .toByteArray(config.messages.compressPRAYChunks.getValue()))); } catch (Exception ex) { if (client.logFailedAuth()) log(ex); } }
@Override public void logout() { }
public static void ensureResourceInit() { try { URL res = PhotoFunctions.class.getResource("/invalid_photo.s16"); URLConnection uc = res.openConnection(); invalidPhoto = new byte[uc.getContentLength()]; new DataInputStream(uc.getInputStream()).readFully(invalidPhoto); } catch (Exception ex) { throw new RuntimeException(ex); } }
public static S16Image ensureValidPhoto(byte[] photo, ConfigPhotos cfg, ILogSource logger) { try { CS16FrameInfo[] frames = CS16IO.readCS16FrameInfo(photo, 1, 139); if (frames.length != 1) { if (cfg.logPhotoErrors.getValue()) logger.log("photo error: frame count wrong"); return null; } if (frames[0].width != 119) { if (cfg.logPhotoErrors.getValue()) logger.log("photo error: frame width not 119"); return null; } if (frames[0].height != 139) { if (cfg.logPhotoErrors.getValue()) logger.log("photo error: frame height not 139"); return null; } if (frames[0].format.compressed) { if (cfg.logPhotoErrors.getValue()) logger.log("photo error: compressed (it shouldn't be)"); return null; } if (frames[0].format.endian != ByteOrder.LITTLE_ENDIAN) { if (cfg.logPhotoErrors.getValue()) logger.log("photo error: wrong endianness"); return null; } return frames[0].decode(); } catch (Exception ex) { if (cfg.logPhotoErrors.getValue()) logger.log(ex); return null; } }
private boolean verifyID(String moniker, int index) { if (!Monikers.verifyMoniker(moniker)) return false; return index >= 0; }
private synchronized File monikerToDir(String moniker, boolean create) { File f = new File(baseDir, moniker); if (create) f.mkdirs(); return f; }
private int verifyEventIndexFile(File f) { try { if (!f.isFile()) return -1; String name = f.getName(); if (!name.endsWith(".png")) return -1; return Integer.parseInt(name.substring(0, name.length() - 4)); } catch (Exception ex) { } return -1; }
private File indexToImageFile(File base, int index) { return new File(base, index + ".png"); }
private File indexToMetaFile(File base, int index) { return new File(base, index + ".json"); }
@Override public synchronized boolean shouldPhotoExist(String moniker, int index) { if (!verifyID(moniker, index)) return false; File monikerDir = monikerToDir(moniker, false); if (!monikerDir.isDirectory()) return false; return indexToImageFile(monikerDir, index).exists(); }
@Override public synchronized void setPhoto( String moniker, int index, long senderUIN, byte[] png, int width, int height) { if (!verifyID(moniker, index)) return; JSONEncoder meta = new JSONEncoder(); meta.objectStart(); meta.writeKV("moniker", moniker); meta.writeKV("index", index); meta.writeKV("senderUIN", UINUtils.toString(senderUIN)); meta.writeKV("saveTime", UnixTime.get()); meta.writeKV("width", width); meta.writeKV("height", height); meta.objectEnd(); try { File monikerDir = monikerToDir(moniker, true); File imgFile = indexToImageFile(monikerDir, index); File metaFile = indexToMetaFile(monikerDir, index); try (FileOutputStream fos = new FileOutputStream(tempImageFile)) { fos.write(png); } try (FileOutputStream fos = new FileOutputStream(tempMetaFile)) { fos.write(meta.out.toString().getBytes(StandardCharsets.UTF_8)); } Files.move(tempMetaFile.toPath(), metaFile.toPath()); Files.move(tempImageFile.toPath(), imgFile.toPath()); } catch (Exception ex) { log(ex); } }
@Override public void visit(IConfigProvider icp) { String str = icp.configVisit(key, valueToString(), description); if (str != null) { try { setValueFromString(str); } catch (Exception ex) { ex.printStackTrace(); } } }
public Opt describe(String info) { description = info; return this; }
protected final void pokeObservers() { synchronized (observers) { for (Runnable c : observers) c.run(); } }
public final void addObserver(Runnable ob) { synchronized (observers) { observers.add(ob); } }
public final void rmObserver(Runnable ob) { synchronized (observers) { observers.remove(ob); } }
public OptGeneric<V> describe(String info) { super.describe(info); return this; }
public Int describe(String info) { super.describe(info); return this; }
@Override protected Integer valueFromString(String str) { return Integer.valueOf(str); }
@Override public String valueToString() { return getValue().toString(); }
public Bool describe(String info) { super.describe(info); return this; }
@Override protected Boolean valueFromString(String str) { return Boolean.valueOf(str); }
public Str describe(String info) { super.describe(info); return this; }
@Override protected String valueFromString(String str) { return str; }
@Override public String valueToString() { return getValue(); }
public Emu<T> describe(String info) { super.describe(info); return this; }
@SuppressWarnings("unchecked") @Override protected T valueFromString(String str) { return (T) Enum.valueOf((Class<T>) defValue.getClass(), str); }
@Override public String valueToString() { return getValue().name(); }
@Override public String configVisit(String name, String defaultVal, String description) { if (!descriptions.containsKey(name)) { descriptions.put(name, description); entryList.add(name); } String res = entries.get(name); if (res == null) { entries.put(name, defaultVal); needsSave = true; return defaultVal; } return res; }
@Override public void configFinished() throws IOException { if (needsSave) { FileOutputStream os = new FileOutputStream(file); OutputStreamWriter osw = new OutputStreamWriter(os, StandardCharsets.UTF_8); osw.write("# Natsue Configuration File - UTF-8\n"); osw.write("# '#' defines a comment until the end of the line.\n"); osw.write("# Any non-whitespace character that is not '#' or '\"' begins an ID.\n"); osw.write("# An ID is terminated by whitespace.\n"); osw.write("# '\"' begins a string.\n"); osw.write( "# '\"' within a string and '\\' itself may be escaped by prefixing it with '\\'.\n"); osw.write("# A string is terminated by an unescaped '\"'.\n"); osw.write("# Strings and IDs are effectively equivalent.\n"); osw.write( "# The file is made up of pairs of keys and values. Either can be strings or IDs.\n"); osw.write("# Booleans can be true or false, integers are written in decimal.\n"); osw.write("\n"); for (String s : entryList) { String des = descriptions.get(s); osw.write("# " + des.replaceAll("\n", "\n# ") + "\n"); writeVal(osw, s); osw.write(" "); writeVal(osw, entries.get(s)); osw.write("\n"); osw.write("\n"); } osw.write("\n"); osw.close(); } }
private void writeVal(Writer w, String s) throws IOException { char[] ch = s.toCharArray(); boolean idLike = ch.length > 0; if (idLike) { for (int i = 0; i < ch.length; i++) { char chr = ch[i]; idLike = ((chr > 32) && (chr != '"') && (chr != '#') && (chr != '\\')); if (!idLike) break; } } if (idLike) { w.write(s); } else { w.write('"'); for (int i = 0; i < ch.length; i++) { char chr = ch[i]; if ((chr == '\\') || (chr == '\"')) w.write('\\'); w.write(chr); } w.write('"'); } }
@Override default void log(ILogSource source, String text) { getLogParent().log(source, text); }
@Override default void log(ILogSource source, Throwable ex) { getLogParent().log(source, ex); }
@Override public void log(ILogSource source, String text) { while (source != null) { text = source + ": " + text; ILogProvider parent = source.getLogParent(); if (parent instanceof ILogSource) { source = (ILogSource) parent; } else { source = null; } } synchronized (this) { System.out.println(Instant.now().toString() + ": " + text); } }
@Override public void log(ILogSource source, Throwable ex) { StringWriter sw = new StringWriter(); ex.printStackTrace(new PrintWriter(sw)); log(source, sw.toString()); }
default ILogSource logExtend(String name) { return new NameLogSource(this, name); }
public String verifySanity() { if (!Monikers.verifyMoniker(moniker)) return "Moniker"; for (LifeEvent le : events) if (le.index < 0) return "Event index under 0"; return null; }
public static byte[] writeHandshakeResponse(int errorCode, long serverUIN, long clientUIN) { ByteBuffer packet = IOUtils.newBuffer(60); packet.put(BaseCTOS.BASE_FIELD_TYPE, (byte) 10); packet.put(1, (byte) errorCode); packet.putInt(BaseCTOS.BASE_FIELD_A, UINUtils.uid(serverUIN)); packet.putInt(BaseCTOS.BASE_FIELD_B, UINUtils.hid(serverUIN)); packet.putInt(BaseCTOS.BASE_FIELD_C, UINUtils.uid(clientUIN)); packet.putInt(BaseCTOS.BASE_FIELD_D, UINUtils.hid(clientUIN)); packet.putInt(44, 12); return packet.array(); }
public static byte[] writeMessage(byte[] message) { ByteBuffer packet = IOUtils.newBuffer(message.length + 32); packet.putInt(BaseCTOS.BASE_FIELD_TYPE, 9); packet.putInt(BaseCTOS.BASE_FIELD_FDLEN, message.length); packet.position(32); packet.put(message); return packet.array(); }
public static byte[] writeUserLine(boolean online, byte[] userData) { ByteBuffer packet = IOUtils.newBuffer(userData.length + 32); packet.putInt(BaseCTOS.BASE_FIELD_TYPE, online ? 0x0D : 0x0E); packet.putInt(BaseCTOS.BASE_FIELD_FDLEN, userData.length); packet.position(32); packet.put(userData); return packet.array(); }
public static byte[] writeVirtualConnect(long initiatorUIN, short vsn) { ByteBuffer packet = IOUtils.newBuffer(44); packet.putInt(BaseCTOS.BASE_FIELD_TYPE, 0x1E); packet.putInt(BaseCTOS.BASE_FIELD_C, UINUtils.uid(initiatorUIN)); packet.putInt(BaseCTOS.BASE_FIELD_D, UINUtils.hid(initiatorUIN)); packet.putInt(BaseCTOS.BASE_FIELD_E, vsn & 0xFFFF); return packet.array(); }
public static byte[] writeVirtualConnectResponse(short clientVSN, short serverVSN) { ByteBuffer packet = IOUtils.newBuffer(36); packet.putInt(BaseCTOS.BASE_FIELD_TYPE, 0x14); int vsns = ((clientVSN & 0xFFFF) << 16) | (serverVSN & 0xFFFF); packet.putInt(BaseCTOS.BASE_FIELD_E, vsns); packet.putInt(32, 0xE); return packet.array(); }
public static byte[] writeVirtualCircuitData( long senderUIN, short senderVSN, long receiverUIN, short receiverVSN, byte[] data) { ByteBuffer packet = IOUtils.newBuffer(44 + data.length); packet.putInt(BaseCTOS.BASE_FIELD_TYPE, 0x1F); packet.putInt(BaseCTOS.BASE_FIELD_C, UINUtils.uid(senderUIN)); packet.putInt(BaseCTOS.BASE_FIELD_D, UINUtils.hid(senderUIN)); packet.putInt(BaseCTOS.BASE_FIELD_FDLEN, data.length); int vsns = ((receiverVSN & 0xFFFF) << 16) | (senderVSN & 0xFFFF); packet.putInt(BaseCTOS.BASE_FIELD_E, vsns); packet.putInt(32, UINUtils.uid(receiverUIN)); packet.putInt(36, UINUtils.hid(receiverUIN)); packet.putInt(40, 2); byte[] res = packet.array(); System.arraycopy(data, 0, res, 44, data.length); return res; }
public static byte[] writeVirtualCircuitClose(long targetUIN) { ByteBuffer packet = IOUtils.newBuffer(32); packet.putInt(BaseCTOS.BASE_FIELD_TYPE, 0x20); packet.putInt(BaseCTOS.BASE_FIELD_C, UINUtils.uid(targetUIN)); packet.putInt(BaseCTOS.BASE_FIELD_D, UINUtils.hid(targetUIN)); return packet.array(); }
public static byte[] writeDummy() { return writeVirtualCircuitClose(0); }
public static byte[] encodeWrit(String channel, int messageId, Object param1, Object param2) { byte[] channelData = channel.getBytes(PacketReader.CHARSET); byte[] p1 = toByteArray(param1); byte[] p2 = toByteArray(param2); ByteBuffer bb = IOUtils.newBuffer(channelData.length + 8 + p1.length + p2.length); bb.putInt(channelData.length); bb.put(channelData); bb.putInt(messageId); bb.put(p1); bb.put(p2); return bb.array(); }
public static int determineWritSize(String channel, int messageId, Object param1, Object param2) { int len = 4 + channel.getBytes(PacketReader.CHARSET).length + 4; len += determineSize(param1); len += determineSize(param2); return len; }
public static Object readFrom(ByteBuffer bb) { int i = bb.getInt(); if (i == 0) { return (Integer) bb.getInt(); } else if (i == 1) { return (Float) bb.getFloat(); } else if (i == 2) { return PacketReader.getString(bb); } return null; }
public static byte[] toByteArray(Object val) { if (val == null) { byte[] data = new byte[4]; data[0] = (byte) 3; return data; } else if (val instanceof Integer) { ByteBuffer bb = IOUtils.newBuffer(8); bb.putInt(4, (Integer) val); return bb.array(); } else if (val instanceof Float) { ByteBuffer bb = IOUtils.newBuffer(8); bb.putInt(1); bb.putFloat((Float) val); return bb.array(); } else if (val instanceof String) { byte[] strDat = ((String) val).getBytes(PacketReader.CHARSET); ByteBuffer bb = IOUtils.newBuffer(strDat.length + 8); bb.putInt(2); bb.putInt(strDat.length); bb.put(strDat); return bb.array(); } else { throw new RuntimeException("WritVal can't encode " + val + "!"); } }
public static int determineSize(Object val) { if (val == null) { return 4; } else if (val instanceof Integer) { return 8; } else if (val instanceof Float) { return 8; } else if (val instanceof String) { return ((String) val).getBytes(PacketReader.CHARSET).length + 8; } else { throw new RuntimeException("WritVal can't encode " + val + "!"); } }
public static int readWithTimeout( Socket skt, int timeoutMs, byte[] data, int dataOfs, int dataLen) throws IOException { skt.setSoTimeout(timeoutMs); try { return skt.getInputStream().read(data, dataOfs, dataLen); } finally { skt.setSoTimeout(0); } }
public static byte[] readPacketHeader(Socket skt, int timeoutMs, int firstByte) throws IOException { byte[] data = new byte[PACKET_HEADER_SIZE]; int res; if (firstByte != -1) { data[0] = (byte) firstByte; res = readWithTimeout(skt, timeoutMs, data, 1, data.length - 1); } else { res = readWithTimeout(skt, timeoutMs, data, 0, data.length); } if (res <= 0) return null; if (firstByte != -1) res++; IOUtils.readFully(skt.getInputStream(), data, res, PACKET_HEADER_SIZE - res); return data; }
public static BaseCTOS readPacket( ConfigMessages cfg, byte[] initialData, InputStream packetSource) throws IOException { ByteBuffer initial = IOUtils.wrapLE(initialData); int type = initial.getInt(BaseCTOS.BASE_FIELD_TYPE); BaseCTOS packetBase = packetInstanceByType(type); packetBase.initializeAndReadRemainder(cfg, packetSource, initial); return packetBase; }
private static BaseCTOS packetInstanceByType(int type) { switch (type) { case 0x09: return new CTOSMessage(); case 0x0F: return new CTOSGetClientInfo(); case 0x10: return new CTOSWWRModify(true); case 0x11: return new CTOSWWRModify(false); case 0x12: return new CTOSUnknown(0, 0); case 0x13: return new CTOSGetConnectionDetail(); case 0x14: return new CTOSClientCommand(); case 0x18: return new CTOSUnknown(0, 48); case 0x1E: return new CTOSVirtualConnect(); case 0x1F: return new CTOSVirtualCircuit(); case 0x0221: return new CTOSFetchRandomUser(); case 0x0321: return new CTOSFeedHistory(); case 0x25: return new CTOSHandshake(); } return new CTOSUnknown(0, 0); }
public static void linger(Socket socket, int asClampedMs) { try { Thread.sleep(asClampedMs); } catch (Exception ex) { } }
public static int uid(long uin) { return (int) ((uin >> 32) & 0xFFFFFFFFL); }
public static int hid(long uin) { return (short) (uin & 0xFFFF); }
public static boolean isRegularUser(long uin) { return hid(uin) == HID_USER; }
public static long ofRegularUser(int uid) { return make(uid, HID_USER); }
public static int asDBUID(long uin) { return isRegularUser(uin) ? uid(uin) : 0; }
public static long make(int uid, int hid) { long uidl = uid & 0xFFFFFFFFL; long hidl = hid & 0x0000FFFFL; return (uidl << 32) | hidl; }
public static String toString(long targetUIN) { return uid(targetUIN) + "+" + hid(targetUIN); }
public static long valueOf(String str) { int plusIdx = str.indexOf('+'); if (plusIdx >= 0) { try { String a = str.substring(0, plusIdx); String b = str.substring(plusIdx + 1); return UINUtils.make(Integer.valueOf(a), Integer.valueOf(b)); } catch (Exception ex) { return -1; } } return -1; }
public void initializeAndReadRemainder( ConfigMessages pcfg, InputStream inputStream, ByteBuffer initial) throws IOException { ticketNumber = initial.getInt(BASE_FIELD_TICKET); }
public byte[] makeDummy() { int tdl = transactionDummyLength(); if (tdl != 0) { ByteBuffer res = IOUtils.newBuffer(tdl); res.putInt(BASE_FIELD_TICKET, ticketNumber); return res.array(); } return null; }
@Override public String toString() { return "CTOSFeedHistory[" + data.length + "]"; }
@Override public void initializeAndReadRemainder( ConfigMessages pcfg, InputStream inputStream, ByteBuffer initial) throws IOException { super.initializeAndReadRemainder(pcfg, inputStream, initial); int bytes = initial.getInt(BASE_FIELD_FDLEN); if (bytes < 0 || bytes > pcfg.maxFeedHistorySize.getValue()) throw new IOException("Invalid history size!"); data = IOUtils.getBytes(inputStream, bytes); }
@Override public int transactionDummyLength() { return 32; }
@Override public void initializeAndReadRemainder( ConfigMessages pcfg, InputStream inputStream, ByteBuffer initial) throws IOException { super.initializeAndReadRemainder(pcfg, inputStream, initial); ByteBuffer extra = IOUtils.getWrappedBytes(inputStream, 12); sourceVSN = (short) initial.getInt(BASE_FIELD_E); targetUIN = PacketReader.getUIN(extra, 0); }
@Override public String toString() { return "CTOSVirtualConnect{to: " + UINUtils.toString(targetUIN) + ", sourceVSN: " + sourceVSN + "}"; }
@Override public int transactionDummyLength() { return 0; }
@Override public void initializeAndReadRemainder( ConfigMessages pcfg, InputStream inputStream, ByteBuffer initial) throws IOException { super.initializeAndReadRemainder(pcfg, inputStream, initial); targetUIN = PacketReader.getUIN(initial, BASE_FIELD_C); }
@Override public String toString() { return "CTOSVirtualCircuit {" + sourceVSN + "->" + UINUtils.toString(targetUIN) + ":" + targetVSN + ", " + messageData.length + " bytes}"; }
@Override public void initializeAndReadRemainder( ConfigMessages pcfg, InputStream inputStream, ByteBuffer initial) throws IOException { super.initializeAndReadRemainder(pcfg, inputStream, initial); int vsns = initial.getInt(BASE_FIELD_E); sourceVSN = (short) (vsns & 0xFFFF); targetVSN = (short) ((vsns >> 16) & 0xFFFF); ByteBuffer extra = IOUtils.getWrappedBytes(inputStream, 12); targetUIN = PacketReader.getUIN(extra, 0); int wantedFurtherData = initial.getInt(BASE_FIELD_FDLEN); int maxNetWritPlus = pcfg.maxNetWritSize.getValue() + PackedMessage.HEADER_LEN; if (wantedFurtherData < 0 || wantedFurtherData > maxNetWritPlus) throw new IOException("Invalid further data!"); messageData = IOUtils.getBytes(inputStream, wantedFurtherData); }
@Override public void initializeAndReadRemainder( ConfigMessages pcfg, InputStream inputStream, ByteBuffer initial) throws IOException { super.initializeAndReadRemainder(pcfg, inputStream, initial); ByteBuffer extra = IOUtils.getWrappedBytes(inputStream, 4); param = initial.getInt(BASE_FIELD_E); subCommand = extra.getInt(0); }
@Override public String toString() { return "CTOSClientCommand{to: " + UINUtils.toString(targetUIN) + ", sc: " + subCommand + ", p: " + param + "}"; }
@Override public String toString() { return "CTOSHandshake[" + username + "]"; }
@Override public void initializeAndReadRemainder( ConfigMessages pcfg, InputStream inputStream, ByteBuffer initial) throws IOException { super.initializeAndReadRemainder(pcfg, inputStream, initial); ByteBuffer hdrExt = IOUtils.getWrappedBytes(inputStream, 20); int usernameLen = hdrExt.getInt(12); int passwordLen = hdrExt.getInt(16); int totalLen = usernameLen + passwordLen; if (totalLen < 0 || totalLen > pcfg.maxLoginInfoSize.getValue()) throw new IOException("Invalid message size!"); byte[] data = IOUtils.getBytes(inputStream, totalLen); username = new String(data, 0, usernameLen - 1, PacketReader.CHARSET); password = new String(data, usernameLen, passwordLen - 1, PacketReader.CHARSET); clientVersion = BabelClientVersion.Babel; if (hdrExt.getInt(8) >= 20240219) clientVersion = BabelClientVersion.Tower; }
@Override public String toString() { return "CTOSGetConnectionDetail{of: " + UINUtils.toString(targetUIN) + "}"; }
public byte[] makeOkResponse() { ByteBuffer bb = IOUtils.newBuffer(32); bb.putInt(BASE_FIELD_TICKET, ticketNumber); bb.putInt(BASE_FIELD_E, 1); return bb.array(); }
@Override public String toString() { return "CTOSWWRModify{of: " + UINUtils.toString(targetUIN) + ", add: " + add + "}"; }
@Override public String toString() { return "Unknown, type 0x" + Integer.toHexString(type); }
@Override public void initializeAndReadRemainder( ConfigMessages pcfg, InputStream inputStream, ByteBuffer initial) throws IOException { super.initializeAndReadRemainder(pcfg, inputStream, initial); type = initial.getInt(BASE_FIELD_TYPE); IOUtils.getBytes(inputStream, additionalLength); }
@Override public int transactionDummyLength() { return fixedTransactionDummyLength; }
@Override public String toString() { return "CTOSGetClientInfo{of: " + UINUtils.toString(targetUIN) + "}"; }
public byte[] makeResponse(byte[] shortUserData) { if (shortUserData == null) return makeDummy(); ByteBuffer bb = ByteBuffer.allocate(shortUserData.length + 32); bb.order(ByteOrder.LITTLE_ENDIAN); bb.putInt(BASE_FIELD_TICKET, ticketNumber); bb.putInt(BASE_FIELD_FDLEN, shortUserData.length); System.arraycopy(shortUserData, 0, bb.array(), 32, shortUserData.length); return bb.array(); }
@Override public String toString() { return "CTOSFetchRandomUser"; }
public byte[] makeResponse(long uin) { if (uin == 0) return makeDummy(); ByteBuffer bb = ByteBuffer.allocate(32); bb.order(ByteOrder.LITTLE_ENDIAN); bb.putInt(BASE_FIELD_TICKET, ticketNumber); bb.putInt(BASE_FIELD_C, UINUtils.uid(uin)); bb.putInt(BASE_FIELD_D, UINUtils.hid(uin)); bb.putInt(BASE_FIELD_E, 1); return bb.array(); }
@Override public String toString() { return "CTOSMessage{to: " + UINUtils.toString(targetUIN) + ", data:byte[" + messageData.length + "]}"; }
@Override public void initializeAndReadRemainder( ConfigMessages pcfg, InputStream inputStream, ByteBuffer initial) throws IOException { super.initializeAndReadRemainder(pcfg, inputStream, initial); int msgDataSize = initial.getInt(BASE_FIELD_FDLEN); if (msgDataSize < 0 || msgDataSize > pcfg.maxBabelBinaryMessageSize.getValue()) throw new IOException("Invalid message size!"); ByteBuffer data = IOUtils.getWrappedBytes(inputStream, 8); targetUIN = UINUtils.make(data.getInt(0), data.getInt(4)); messageData = IOUtils.getBytes(inputStream, msgDataSize); }
public int determineSize() { return WritVal.determineWritSize(channel, messageId, param1, param2); }
public static PackedMessage read(byte[] toDecode, ConfigMessages cfg) { ByteBuffer b = IOUtils.wrapLE(toDecode); long senderUIN = UINUtils.make(b.getInt(8), b.getInt(4) & 0xFFFF); int messageDataLen = b.getInt(12) - HEADER_C2E_LEN; if (messageDataLen > toDecode.length - HEADER_LEN) throw new IndexOutOfBoundsException("Not going to work"); int messageType = b.getInt(28); ByteBuffer messageDataSlice = IOUtils.wrapLE(toDecode, HEADER_LEN, messageDataLen); if (messageType == TYPE_PRAY) { return new PackedMessagePRAY( senderUIN, PRAYBlock.read( messageDataSlice, cfg.maxDecompressedPRAYSize.getValue(), PacketReader.CHARSET)); } else if (messageType == TYPE_WRIT) { if (messageDataLen > cfg.maxNetWritSize.getValue()) throw new RuntimeException("Too much data for a NET: WRIT!"); String channel = PacketReader.getString(messageDataSlice); int messageId = messageDataSlice.getInt(); Object p1 = WritVal.readFrom(messageDataSlice); Object p2 = WritVal.readFrom(messageDataSlice); return new PackedMessageWrit(senderUIN, channel, messageId, p1, p2); } else { byte[] messageData = new byte[messageDataLen]; messageDataSlice.get(messageData); return new PackedMessageUnknown(senderUIN, messageType, messageData); } }
public byte[] toByteArray(boolean compressIfAllowed) { byte[] messageData = getOrPackContents(compressIfAllowed); int len = messageData.length + HEADER_LEN; ByteBuffer bb = IOUtils.newBuffer(len); bb.putInt(len); bb.putInt(UINUtils.hid(senderUIN)); bb.putInt(UINUtils.uid(senderUIN)); bb.putInt(messageData.length + HEADER_C2E_LEN); bb.putInt(0); bb.putInt(1); bb.putInt(0x0C); bb.putInt(messageType); bb.putInt(0); bb.put(messageData); return bb.array(); }
public static PackedMessage addToContactList(long targetUIN, long contactUIN) { return new PackedMessageWrit( targetUIN, "add_to_contact_book", 2468, UINUtils.toString(contactUIN), null); }
public static PackedMessage systemMessage(long targetUIN, String text) { return new PackedMessageWrit(targetUIN, "system_message", 2469, text, null); }
public static PackedMessage chatRequest(long senderUIN, String nickname, String chatID) { PRAYTags res = new PRAYTags(PacketReader.CHARSET); res.strMap.put("Sender UserID", UINUtils.toString(senderUIN)); res.strMap.put("Date Sent", "19551101000000"); res.strMap.put("Request Type", "Request"); res.strMap.put("ChatID", chatID); res.strMap.put("Sender Nickname", nickname); return tagsMessage(senderUIN, "REQU", res); }
public static PackedMessage acceptChatRequest(long senderUIN, String nickname, String chatID) { PRAYTags res = new PRAYTags(PacketReader.CHARSET); res.strMap.put("Sender UserID", UINUtils.toString(senderUIN)); res.strMap.put("ChatID", chatID); res.strMap.put("Request Type", "Accept"); res.strMap.put("Sender Nickname", nickname); return tagsMessage(senderUIN, "REQU", res); }
public static PackedMessage chatMessage( long senderUIN, String senderNick, String chatID, String text) { PRAYTags res = new PRAYTags(PacketReader.CHARSET); res.strMap.put("Chat Message Type", "Message"); res.strMap.put("Sender UserID", UINUtils.toString(senderUIN)); res.strMap.put("ChatID", chatID); res.strMap.put("Sender Nickname", senderNick); res.strMap.put("Chat Message", text); return tagsMessage(senderUIN, "CHAT", res); }
public static PackedMessage chatLeave( long senderUIN, String senderNick, String chatID, long targetUIN, String targetNick) { PRAYTags res = new PRAYTags(PacketReader.CHARSET); res.strMap.put("ChatID", chatID); res.strMap.put("Sender Nickname", senderNick); res.strMap.put("Sender UserID", UINUtils.toString(senderUIN)); res.strMap.put("Chat Message Type", "Chatter go Bye Bye"); res.strMap.put("Exiting Chatter Nickname", targetNick); res.strMap.put("Exiting Chatter UserID", UINUtils.toString(targetUIN)); return tagsMessage(senderUIN, "CHAT", res); }
public static PackedMessage mail( long senderUIN, String senderNick, String dateSent, String subject, String message) { PRAYTags res = new PRAYTags(PacketReader.CHARSET); res.strMap.put("Sender UserID", UINUtils.toString(senderUIN)); res.strMap.put("Sender Nickname", senderNick); res.strMap.put("Date Sent", dateSent); res.strMap.put("Subject", subject); res.strMap.put("Message", message); return tagsMessage(senderUIN, "MESG", res); }
public static String generateBlockName(String type) { long randomRes = generator.nextLong(); return "natsue_" + randomRes + "_intgen_" + System.currentTimeMillis() + "_" + type; }
public static PackedMessage tagsMessage(long senderUIN, String type, PRAYTags tags) { PRAYBlock pb = new PRAYBlock(type, generateBlockName(type), tags.toByteArray(), PacketReader.CHARSET); return new PackedMessagePRAY(senderUIN, pb); }
@Test public void test() { for (int i = 0; i < 256; i++) { byte[] data = new byte[] {(byte) i}; String res = new String(data, CAOSUtils.CAOS_CHARSET); if (res.length() != 1) throw new RuntimeException( "CAOS charset maps " + i + " to " + res + " (" + res.length() + " chars)"); byte[] data2 = res.getBytes(CAOSUtils.CAOS_CHARSET); if (data2.length != 1) throw new RuntimeException( "CAOS charset non-transitively maps " + i + " (" + res + ") (wrong length)"); if (data2[0] != (byte) i) throw new RuntimeException( "CAOS charset non-transitively maps " + i + " (" + res + ") to " + (data2[0] & 0xFF)); } }
@Test public void test() { float[] cases = { (0), (1), (0.0000000000000000000000000000000000000000000014f), (0.0000000000000000000000000000000000000000000028f), (1f / 30000f), (1f / 3f), (1f / 0.00000003f), (100000000000000000.0f), (100000000000000000000000000000000000000.0f), (300000000000000000000000000000000000000.0f), (340000000000000000000000000000000000000.0f), (340282356779733000000000000000000000000.0f) }; for (int sign = 0; sign < 2; sign++) { if (sign == 1) { for (float f : cases) simpleCase(-f); } else { for (float f : cases) simpleCase(f); } } }
private void simpleCase(float v) { String cf = RALConstant.Flo.toCAOSFloat(v); System.out.println("TEST: " + v + " -> " + cf); float vRT = Float.valueOf(cf); if (vRT != v) { System.out.println(" FAILED: LoP, res = " + vRT); throw new RuntimeException("Loss of precision at " + v + " -> " + cf); } if (!cf.contains(".")) { System.out.println(" FAILED: no dot"); throw new RuntimeException("CAOS expects all floats to contain ."); } if (cf.contains("E")) { System.out.println(" FAILED: E"); throw new RuntimeException("CAOS does not understand scientific notation"); } System.out.println(" PASSED"); }
private static File findStandardLibrary() { String override = System.getenv("RAL_STDLIB_PATH"); if ((override != null) && (override.equals(""))) override = null; File ralStandardLibrary = new File("include"); if (override != null) { ralStandardLibrary = new File(override); } else { try { URL myURL = Main.class.getClassLoader().getResource("rals/Main.class"); String f = myURL.getFile(); int splitIdx = f.indexOf('!'); if (splitIdx != -1) f = f.substring(0, splitIdx); URL myURL2 = new URL(f); String decodedPath = URLDecoder.decode(myURL2.getPath(), "UTF-8"); File ralJarDir = new File(decodedPath).getParentFile(); ralStandardLibrary = new File(ralJarDir, "include"); if (!ralStandardLibrary.isDirectory()) ralStandardLibrary = new File(ralJarDir.getParentFile(), "include"); } catch (Exception ex) { } } return ralStandardLibrary; }
public static boolean inject( StringBuilder sb, IDocPath stdLibDP, File f, Function<CodeGenFeatureLevel, IDebugRecorder> di, Consumer<TypeSystem> exportTaxonomy, ScriptSection... sections) { try { IncludeParseContext ic = Parser.run(stdLibDP, f); LinkedList<String> queuedRequests = new LinkedList<>(); if (exportTaxonomy != null) exportTaxonomy.accept(ic.typeSystem); Scripts resolvedCode = ic.module.resolve(ic.diags, ic.hcm); for (ScriptSection s : sections) resolvedCode.compileSectionForInject( queuedRequests, di.apply(ic.typeSystem.codeGenFeatureLevel), s); String res = ic.diags.unwrapToString(); if (res != null) { sb.append("Compile failed:\n"); sb.append(res); return false; } for (String req : queuedRequests) { sb.append(Injector.cpxRequest(req, CAOSUtils.CAOS_CHARSET)); sb.append("\n"); } return true; } catch (Exception ex) { exceptionIntoSB(sb, ex); return false; } }
public static void exceptionIntoSB(StringBuilder sb, Exception ex) { sb.append("-- Error --\n"); StringWriter sw = new StringWriter(); ex.printStackTrace(new PrintWriter(sw)); sb.append(sw); }
private static void unwrapCalmly(DiagRecorder diags) { String res = diags.unwrapToString(); if (res != null) { System.out.println("Compile failed:"); System.out.print(res); System.exit(1); return; } }
public boolean isInDP(IDocPath docPath) { return extent.isInDP(docPath); }
public boolean isKeyword(String kw) { if (this instanceof Kw) if (((Kw) this).text.equals(kw)) return true; return false; }
@Override public String toString() { return "ID:" + text; }
@Override public String toString() { return "K:" + text; }
@Override public String toString() { return "S:" + text; }
@Override public String toString() { if (startIsClusterEnd && endIsClusterStart) { return "S|:"; } else if (startIsClusterEnd) { return "S}:"; } else if (endIsClusterStart) { return "S{:"; } return "SE:" + text; }
@Override public String toString() { return "I:" + value; }
@Override public String toString() { return "F:" + value; }
public SrcPos genLN() { Token nxt = next(); back(); if (nxt == null) return core.genLN(); return nxt.lineNumber; }
public DefInfo.At genDefInfo(Token tkn) { return new DefInfo.At(tkn, getLastToken()); }
public Token next() { if (tokenHistoryPtr < tokenHistory.length) { Token res = tokenHistory[tokenHistoryPtr++]; traceEvent(res); if (res != null) hcm.parserRequestedToken(res, true); return res; } Token tkn = null; while (true) { tkn = core.get(); if (tkn instanceof Token.Kw) { if (((Token.Kw) tkn).text.equals(Token.DEBUG_TRACE_ON)) { tracing = true; continue; } else if (((Token.Kw) tkn).text.equals(Token.DEBUG_TRACE_OFF)) { tracing = false; continue; } } break; } traceEvent(tkn); if (tkn != null) { hcm.readToken(tkn); hcm.parserRequestedToken(tkn, true); } for (int i = 0; i < tokenHistory.length - 1; i++) tokenHistory[i] = tokenHistory[i + 1]; tokenHistory[tokenHistory.length - 1] = tkn; return tkn; }
public void back() { traceEvent(tokenHistory[tokenHistoryPtr - 1]); if (tokenHistory[tokenHistoryPtr - 1] == null) throw new RuntimeException( "Attempted to go back before the start of the file / locked backwards travel cutoff!"); tokenHistoryPtr--; hcm.parserRequestedToken(tokenHistory[tokenHistoryPtr - 1], false); }
private void traceEvent(Token token) { if (tracing) { String msg = "LX:" + (token != null ? token : "EOF"); StackTraceElement[] ste = new RuntimeException().getStackTrace(); for (int i = 1; i < 5; i++) { if (i >= ste.length) break; msg += " " + ste[i].getMethodName() + ":" + ste[i].getLineNumber(); } diags.warning(msg); } }
public Token requireNext() { Token tkn = next(); if (tkn == null) throw new RuntimeException("Expected token, got EOF at " + genLN()); return tkn; }
public Token requireNextKw(String kw) { Token tkn = requireNext(); if (tkn.isKeyword(kw)) return tkn; throw new RuntimeException("Expected " + kw + ", got " + tkn); }
public boolean optNextKw(String string) { Token tkn = next(); if (tkn == null) return false; if (tkn.isKeyword(string)) return true; back(); return false; }
public String requireNextID() { return requireNextIDTkn().text; }
public Token.ID requireNextIDTkn() { Token tkn = requireNext(); if (tkn instanceof Token.ID) return (Token.ID) tkn; throw new RuntimeException("Expected ID, got " + tkn); }
public int requireNextInteger() { Token tkn = requireNext(); if (tkn instanceof Token.Int) return ((Token.Int) tkn).value; throw new RuntimeException("Expected integer, got " + tkn); }
public String diagContext() { StringBuilder sb = new StringBuilder(); boolean didWriteAtLeastOne = false; for (int i = 0; i < tokenHistoryPtr; i++) { if (tokenHistory[i] == null) continue; if (didWriteAtLeastOne) sb.append(" "); sb.append(tokenHistory[i]); didWriteAtLeastOne = true; } if (didWriteAtLeastOne) sb.append(" "); sb.append("<HERE>"); Token tkn = next(); back(); if (tkn != null) { sb.append(" "); sb.append(tkn); } else { sb.append(" <EOF>"); } return sb.toString(); }
public String describePosition() { if (srcRange == null) return "(unknown)"; return srcRange.start.toString(); }
public String describePosition() { return "BUILTIN"; }
private String consumeComment() { String s = lastComment; lastComment = null; return s; }
public SrcPos genLN() { return charHistory.genLN(file); }
private SrcRange completeExtent(SrcPos sp) { return new SrcRange(sp, charHistory.genLN(file)); }
private Token finishReadingString( SrcPos startOfToken, int c, boolean startIsClusterEnd, boolean isEmbedding) { StringBuilder sb = new StringBuilder(); boolean escaping = false; boolean endIsClusterStart = false; while (true) { int c2 = getNextByte(); if (c2 == -1) { diags.lexParseErr(startOfToken, "Unterminated string"); break; } if (escaping) { if (c2 == 'r') c2 = '\r'; if (c2 == 't') c2 = '\t'; if (c2 == 'n') c2 = '\n'; if (c2 == '0') c2 = 0; sb.append((char) c2); escaping = false; } else { if (c2 == c) { break; } else if (isEmbedding && (c2 == '{')) { levelOfStringEmbedding++; endIsClusterStart = true; break; } else if (c2 == '\\') { escaping = true; } else { sb.append((char) c2); } } } SrcRange sp = completeExtent(startOfToken); if (isEmbedding) { return new Token.StrEmb( sp, consumeComment(), sb.toString(), startIsClusterEnd, endIsClusterStart); } else { return new Token.Str(sp, consumeComment(), sb.toString()); } }
private void advanceHistory(int[] history, int val) { for (int i = 0; i < history.length - 1; i++) history[i] = history[i + 1]; history[history.length - 1] = val; }
public SrcPos genLN(SrcPosFile file) { if (charHistoryPtr < charHistory.length) return new SrcPos( file, gpHistory[charHistoryPtr], lnHistory[charHistoryPtr], lpHistory[charHistoryPtr]); return new SrcPos(file, globalPosition, lineNumber, linePosition); }
public static String vaToString(String pfx, int va) { String res = Integer.toString(va); if (res.length() == 1) return pfx + "0" + res; return pfx + res; }
public static String vaToString(int va) { return vaToString("va", va); }
public static void checkStringCAOSConstant(ByteSequence value, CodeGenFeatureLevel codeGen) { if (codeGen.lexerConstantStringLimit != -1) if (value.length() > codeGen.lexerConstantStringLimit) throw new ConstantTooLargeForVMException(); }
public static ByteString.Builder stringIntoCAOSConstant( ByteSequence value, CodeGenFeatureLevel codeGen) { ByteString.Builder res = new ByteString.Builder(value.length() + 2); stringIntoCAOSConstant(res, value, codeGen); return res; }
public static void stringIntoCAOSConstant( ByteString.Builder res, ByteSequence value, CodeGenFeatureLevel codeGen) { checkStringCAOSConstant(value, codeGen); byte[] valueBytes = value.getBytes(); res.write('"'); for (byte c : valueBytes) { if ((c == '\\') || (c == '\"')) { res.write('\\'); res.write(c); } else if (c == '\r') { res.write('\\'); res.write('r'); } else if (c == '\n') { res.write('\\'); res.write('n'); } else if (c == '\t') { res.write('\\'); res.write('t'); } else if (c == 0) { res.write('\\'); res.write('0'); } else { res.write(c); } } res.write('"'); }
public static String unescapeOUTX(String string) { StringBuilder sb = new StringBuilder(); if (!string.startsWith("\"")) throw new RuntimeException("unescapeOUTX: " + string); if (!string.endsWith("\"")) throw new RuntimeException("unescapeOUTX: " + string); string = string.substring(1, string.length() - 1); boolean isEscaping = false; for (char c : string.toCharArray()) { if (isEscaping) { char conv = c; if (c == 'n') { conv = '\n'; } else if (c == 'r') { conv = '\r'; } else if (c == '0') { conv = 0; } else if (c == 't') { conv = '\t'; } sb.append(conv); isEscaping = false; } else if (c == '\\') { isEscaping = true; } else { sb.append(c); } } return sb.toString(); }
public void compileInstall(OuterCompileContext ctx) { if (installScript != null) compile(ctx, installScript, 0); }
public void compileEvents(OuterCompileContext ctx) { LinkedList<ScriptIdentifier> allScriptIDs = new LinkedList<>(eventScripts.keySet()); Collections.sort(allScriptIDs); for (ScriptIdentifier k : allScriptIDs) { ctx.out.append(" * "); RALType.AgentClassifier type = typeSystem.byClassifier(k.classifier); ctx.out.append(type.typeName); String msgName = type.lookupMSName(k.script, true); if (msgName != null) { ctx.out.append(":"); ctx.out.append(msgName); } ctx.out.append(" "); ctx.out.append(k.script); ctx.out.append("\n"); ctx.out.append(k.toScrpLine()); ctx.out.append("\n"); compileEventContents(ctx, k); ctx.out.append("endm\n"); } }
public void compileSectionForInject( LinkedList<String> queuedRequests, IDebugRecorder dt, ScriptSection k) { RALStatement stmt; switch (k) { case Install: stmt = installScript; break; case Events: for (Map.Entry<ScriptIdentifier, RALStatement> eventScript : eventScripts.entrySet()) { ScriptIdentifier k2 = eventScript.getKey(); StringBuilder outText = new StringBuilder(); outText.append(k2.toScrpLine()); outText.append('\n'); compileEventContents(new OuterCompileContext(outText, dt), k2); queuedRequests.add(outText.toString()); } return; case Remove: stmt = removeScript; break; default: throw new RuntimeException("Unknown GlobalScriptKind " + k); } StringBuilder outText = new StringBuilder(); outText.append("execute\n"); if (stmt != null) compile(new OuterCompileContext(outText, dt), stmt, 0); queuedRequests.add(outText.toString()); }
public void compileEventContents(OuterCompileContext ctx, ScriptIdentifier k) { RALStatement v = eventScripts.get(k); compile(ctx, v, 1); }
public void compileRemove(OuterCompileContext ctx) { if (removeScript != null) compile(ctx, removeScript, 1); }
public void compile(OuterCompileContext ctx) { compileInstall(ctx); compileEvents(ctx); if (removeScript != null) ctx.out.append("rscr\n"); compileRemove(ctx); }
private void compile(OuterCompileContext ctx, RALStatement v, int ii) { CodeWriter cw = new CodeWriter(ctx.out, ctx.debug); cw.indent = ii; v.compile(cw, new CompileContext(typeSystem, this, diags, cw)); }
@Override public void precompile(UnresolvedWorld world) { if (precompiledCode != null) return; if (isBeingPrecompiled) throw new RuntimeException("Recursive macro compilation @ " + name + "#" + args.length); isBeingPrecompiled = true; TypeSystem ts = world.types; ScriptContext msContext = new ScriptContext(world, ts.gAgentNullable, ts.gAny, ts.gAny, ts.gAny); ScopeContext scContext = new ScopeContext(msContext); for (MacroArg arg : args) scContext.setLoc(arg.name, defInfo, new RALVarEH(arg, arg.type)); world.diags.pushFrame(defInfo.srcRange); try { world.hcm.resolvePre(defInfo.srcRange, scContext); precompiledCode = code.resolve(scContext); world.hcm.resolvePost(defInfo.srcRange, scContext); } catch (Exception ex) { world.diags.error("failed resolving: ", ex); precompiledCode = new RALErrorExpr("macro " + name + "#" + args.length + " failed to compile"); } world.diags.popFrame(defInfo.srcRange); }
public static void typeCheckMacroArgs(Object chk, RALExprSlice a, MacroArgNameless[] args) { if (a.length != args.length) throw new RuntimeException( chk + ": Amount of args passed (" + a.length + ") does not match callable expectations (" + args.length + ")"); for (int i = 0; i < args.length; i++) { RALSlot argSlot = a.slot(i); RALSlot.Perm wantedPerms = args[i].computeRequiredPerms(); argSlot.perms.require(chk, wantedPerms); if (wantedPerms.read) argSlot.type.assertImpCast(args[i].type); if (wantedPerms.write) args[i].type.assertImpCast(argSlot.type); } }
public static VarCacher varCacherFromMacroArgs(Object chk, RALExprSlice a, MacroArg[] args) { typeCheckMacroArgs(chk, a, args); boolean[] inline = new boolean[args.length]; String[] names = new String[args.length]; for (int i = 0; i < args.length; i++) { inline[i] = args[i].isInline != null; names[i] = args[i].name; } return new VarCacher(a, inline, names); }
@Override public RALExprSlice instance(final RALExprSlice a, ScopeContext sc) { if (a.length != args.length) throw new RuntimeException( "Macro " + name + " called with " + a.length + " args, not " + args.length); VarCacher vc = varCacherFromMacroArgs(this, a, args); precompile(sc.world); return new Resolved(name, defInfo.srcRange, vc, precompiledCode, args, sc.world.types); }
@Override protected RALExprSlice sliceInner(int tB, int tL) { return new Resolved(macroName, macroExt, vc, innards.slice(tB, tL), macroArgs, typeSystem); }
@Override protected RALExprSlice tryConcatWithInner(RALExprSlice b) { if (b instanceof Resolved) { if (((Resolved) b).vc == vc) { return new Resolved( macroName, macroExt, vc, RALExprSlice.concat(innards, ((Resolved) b).innards), macroArgs, typeSystem); } } return super.tryConcatWithInner(b); }
public void installMacroArgs(CompileContextNW c2) { for (int i = 0; i < macroArgs.length; i++) c2.heldExprHandles.put(macroArgs[i], vc.finishedOutput.slice(i, 1)); }
@Override protected RALSlot slotInner(int index) { return innards.slot(index); }
@Override public void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { try (DiagRecorder.Scope ds = context.diags.newScope(macroExt)) { try (CompileContext c2 = context.forkVAEH()) { vc.writeCacheCode(c2); installMacroArgs(c2); innards.writeCompile(index, input, inputExactType, c2); } } }
@Override public void readCompileInner(RALExprSlice out, CompileContext context) { try (DiagRecorder.Scope ds = context.diags.newScope(macroExt)) { try (CompileContext c2 = context.forkVAEH()) { vc.writeCacheCode(c2); installMacroArgs(c2); innards.readCompile(out, c2); } } }
@Override protected void readInplaceCompileInner(RALVarVA[] out, CompileContext context) { try (DiagRecorder.Scope ds = context.diags.newScope(macroExt)) { try (CompileContext c2 = context.forkVAEH()) { vc.writeCacheCode(c2); installMacroArgs(c2); innards.readInplaceCompile(out, c2); } } }
@Override public String compileCond(CodeWriter writer, CompileContext sharedContext, boolean invert) { try (CompileContext c2 = sharedContext.forkEH()) { vc.writeCacheCode(c2); installMacroArgs(c2); return innardsC.compileCond(writer, c2, invert); } }
@Override public String toString() { return "condition-of-macro " + macroName; }
@Override public String toString() { return "macro wrapper of " + macroName; }
public RALStatement resolveStmt(RALStatementUR v) { return v.resolve(new ScopeContext(this)); }
@Override public String toString() { if (isInline != null) { if (isInline == RALSlot.Perm.R) return type.getFullDescription() + " @"; if (isInline == RALSlot.Perm.RW) return type.getFullDescription() + " @="; return type.getFullDescription() + " @?"; } return type.getFullDescription(); }
public RALSlot.Perm computeRequiredPerms() { if (isInline != null) return isInline; return RALSlot.Perm.R; }
public boolean canBeCastTo(MacroArgNameless other) { if (!other.type.canImplicitlyCast(type)) return false; if (!type.canImplicitlyCast(other.type)) return false; if (isInline != other.isInline) return false; return true; }
@Override public String toString() { return "macro arg " + name; }
@Override public void precompile(UnresolvedWorld world) { for (RALCallable.Global rc : map.values()) rc.precompile(world); }
@Override public RALExprSlice instance(RALExprSlice args, ScopeContext sc) { RALCallable res = map.get(args.length); if (res == null) throw new RuntimeException(name + " doesn't have " + args.length + "-parameter variant"); return res.instance(args, sc); }
public void addMacro(int count, RALCallable.Global c) { if (map.containsKey(count)) throw new RuntimeException(name + " already has " + count + "-arg variant"); if ((lowestCount == -1) || (lowestCount > count)) lowestCount = count; map.put(count, c); }
public void regenerateTarg(SrcPos at, RALType type) { String doc = "targ is an agent reference that acts as an implicit parameter to many CAOS commands."; DefInfo dTrg = (at != null) ? new DefInfo.At(at, doc) : new DefInfo.Builtin(doc); setLoc("targ", dTrg, new RALVarTarg(type)); }
public LVar requireLocal(String string) { LVar lv = scopedVariables.get(string); if (lv == null) throw new RuntimeException("Expected local: " + string); return lv; }
public void addMacro(String name, int count, RALCallable.Global c) { if (!typeSystem.namedConstants.containsKey(name)) { MacroDefSet mds = macroDefs.computeIfAbsent(name, (n) -> new MacroDefSet(name)); typeSystem.declareConst( name, c.getDefInfo(), new RALConstant.Callable(typeSystem.gLambdaAny, mds)); } MacroDefSet res = macroDefs.get(name); if (res == null) throw new RuntimeException( name + " can't have a macro declared as a different type of value is already present."); res.addMacro(count, c); }
public void addInstall(RALStatementUR parseStatement) { if (installScript == null) installScript = new RALBlock(parseStatement.lineNumber, false); installScript.content.add(parseStatement); }
public void addRemove(RALStatementUR parseStatement) { if (removeScript == null) removeScript = new RALBlock(parseStatement.lineNumber, false); removeScript.content.add(parseStatement); }
public void writeCacheCode(CompileContext context) { for (Copy c : copies) { for (int i = 0; i < c.variables.length; i++) { RALVarVA va = c.variables[i]; int v = context.allocVA(va.handle); if (names != null) { int absI = c.sourceBase + i; if (names[absI] != null) context.writer.writeComment(CAOSUtils.vaToString(v) + ": " + names[absI]); } } c.srcSlice.readInplaceCompile(c.variables, context); } }
@Override public String toString() { return "vcache copy va " + absIndex + " from " + in; }
public void ensureFree(int amount) { while (freeList.size() < amount) { int va = parent.allocVA(); allList.add(va); freeList.add(va); } }
@Override public int allocVA() { if (freeList.size() > 0) return freeList.remove(); int va = parent.allocVA(); allList.add(va); return va; }
@Override public void allocVA(int i) { if (allList.contains(i)) { if (!freeList.contains(i)) throw new RuntimeException("VA " + i + " already in use"); } else { parent.allocVA(i); allList.add(i); } }
@Override public void releaseVA(int i) { freeList.add(i); }
public void close() { if (leak) return; for (Integer it : allList) parent.releaseVA(it); }
@Override public RALConstant resolveConst(TypeSystem ts, Set<String> scopedVariables) { RALExprUR[] details = content.decomposite(); byte[] target = new byte[details.length]; for (int i = 0; i < details.length; i++) { RALConstant rc = details[i].resolveConst(ts, scopedVariables); if (!(rc instanceof RALConstant.Int)) throw new RuntimeException("Byte " + i + " of byte string not a constant integer"); RALConstant.Int rci = (RALConstant.Int) rc; if (rci.value < 0 || rci.value > 255) throw new RuntimeException("Byte " + i + " of byte string outside of 0-255 range"); target[i] = (byte) rci.value; } return new RALConstant.Bytes(ts, target); }
@Override public RALExprSlice resolveInner(ScopeContext scope) { RALConstant res = resolveConst(scope.world.types, scope.scopedVariables.keySet()); if (res == null) throw new RuntimeException("Byte strings must eventually resolve to constants"); return res; }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { String outInline = out.getInlineCAOS(0, true, context); if (outInline != null) { inlineIO( context, (va) -> { RALVarString.writeSet( context.writer, outInline, va, slot.type.majorType.autoPromote(out.slot(0).type.majorType)); }); } else { RALSpecialInline si = baseExpr.getSpecialInline(0, context); if (si == RALSpecialInline.Ownr) { String vaInline = context.typeSystem.codeGenFeatureLevel.hasMVXX ? CAOSUtils.vaToString("mv", slot.slot) : ("avar ownr " + slot.slot); out.writeCompile(0, vaInline, slot.type.majorType, context); } else { fallbackIO( context, (va) -> { out.writeCompile(0, va, slot.type.majorType, context); }); } } }
@Override protected void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { inlineIO( context, (va) -> { RALVarString.writeSet( context.writer, va, input, inputExactType.autoPromote(slot.type.majorType)); }); }
private void inlineIO(CompileContext context, Consumer<String> doTheThing) { String fullInline = getInlineCAOSInner(0, true, context); if (fullInline != null) { doTheThing.accept(fullInline); return; } fallbackIO(context, doTheThing); }
private void fallbackIO(CompileContext context, Consumer<String> doTheThing) { try (CompileContext cc = context.forkVAEH()) { RALVarVA va = cc.allocVA(baseType, "RALFieldAccess computed agent"); baseExpr.readInplaceCompile(new RALVarVA[] {va}, cc); doTheThing.accept("avar " + va.getCode(cc) + " " + slot.slot); } }
@Override public String toString() { return baseExpr + "[" + baseType + "." + field + "]"; }
@Override public RALConstant resolveConst(TypeSystem ts, Set<String> scopedVariables) { return this; }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { out.writeCompile(0, toString(), type.majorType, context); }
@Override public Str cast(RALType rt) { return new Str(rt, valueBytes); }
@Override public int hashCode() { return valueChars.hashCode(); }
@Override public boolean equals(Object obj) { if (obj instanceof Str) return valueChars.equals(((Str) obj).valueChars); return false; }
@Override public String toString() { return CAOSUtils.stringIntoCAOSConstant(valueBytes, CodeGenFeatureLevel.customEngine) .toString(CAOSUtils.CAOS_CHARSET); }
@Override public float toFloat() { return value; }
@Override public Int cast(RALType rt) { return new Int(rt, value); }
@Override public boolean equals(Object obj) { if (obj instanceof Int) { return value == ((Int) obj).value; } else if (obj instanceof Flo) { return ((double) value) == ((Flo) obj).value; } return false; }
@Override public String toString() { return Integer.toString(value); }
@Override public Flo cast(RALType rt) { return new Flo(rt, value); }
@Override public int hashCode() { return Float.hashCode(value); }
@Override public boolean equals(Object obj) { if (obj instanceof Int) { return value == (double) ((Int) obj).value; } else if (obj instanceof Flo) { return value == ((Flo) obj).value; } return false; }
@Override public String toString() { return toCAOSFloat(value); }
@Override public Bytes cast(RALType rt) { return new Bytes(rt, value); }
@Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append("[ "); for (byte b : value) { sb.append(b & 0xFF); sb.append(" "); } sb.append("]"); return sb.toString(); }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { throw new RuntimeException("Lambdas and macros are not real values"); }
@Override public Callable cast(RALType rt) { return new Callable(rt, value); }
@Override public String toString() { return "(lambda)"; }
@Override public RALExprSlice instance(RALExprSlice argsV, ScopeContext sc) { String what = "(lambda " + where + ")"; VarCacher vc = Macro.varCacherFromMacroArgs(what, argsV, args); return new Macro.Resolved(what, where, vc, rStmtExpr, args, sc.world.types); }
@Override public RALExprSlice resolveInner(ScopeContext scope) { RALExprSlice slice = input.resolve(scope); RALType rt = slice.assert1ReadType(); if (rt.canImplicitlyCast(scope.script.world.types.gString)) return slice; if (rt.canImplicitlyCast(scope.script.world.types.gNumber)) return new RALInlineExpr.Resolved( new RALSlot(scope.world.types.gString, RALSlot.Perm.R), new Object[] {"vtos ", slice}); throw new RuntimeException("Cannot stringify " + rt); }
@Override public RALExprSlice resolveInner(ScopeContext scope) { ScopeContext sc = new ScopeContext(scope); final RALStatement rStmt = statement.resolve(sc); final RALExprSlice rExpr = expr.resolve(sc); return new Resolved(rStmt, rExpr); }
@Override protected RALExprSlice sliceInner(int base, int length) { return new Resolved(rStmt, rExpr.slice(base, length)); }
@Override protected RALExprSlice tryConcatWithInner(RALExprSlice b) { if (b instanceof Resolved) { if (((Resolved) b).rStmt == rStmt) { return new Resolved(rStmt, RALExprSlice.concat(rExpr, ((Resolved) b).rExpr)); } } return super.tryConcatWithInner(b); }
@Override protected RALSlot slotInner(int index) { return rExpr.slot(index); }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { try (CompileContext cc = context.forkVAEH()) { rStmt.compile(cc.writer, cc); rExpr.readCompile(out, cc); } }
@Override protected void readInplaceCompileInner(RALVarVA[] out, CompileContext context) { try (CompileContext cc = context.forkVAEH()) { rStmt.compile(cc.writer, cc); rExpr.readInplaceCompile(out, cc); } }
@Override protected void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { try (CompileContext cc = context.forkVAEH()) { rStmt.compile(cc.writer, cc); rExpr.writeCompile(index, input, inputExactType, cc); } }
@Override public String toString() { return type + "/" + perms; }
public Perm denyWrite() { if (!write) return this; if (this == W) return None; if (this == RW) return R; throw new RuntimeException("Bad deny write"); }
public Perm denyRead() { if (!read) return this; if (this == R) return None; if (this == RW) return W; throw new RuntimeException("Bad deny read"); }
public void require(Object chk, Perm required) { if (required.read && !read) throw new RuntimeException("Needed read perm on: " + chk); if (required.write && !write) throw new RuntimeException("Needed write perm on: " + chk); }
@Override public String toString() { return "VA[" + handle + "!" + type + "]"; }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { if (out.getSpecialInline(0, context) == RALSpecialInline.Discard) return; super.readCompileInner(out, context); }
@Override public String toString() { return "macro ret-arg " + ret.name; }
@Override public String toString() { return "resolved StmtExprInverted"; }
@Override protected void readCompileInner(RALExprSlice out, CompileContext context) { try (CompileContext cci = context.forkVAEH()) { for (int i = 0; i < out.length; i++) cci.heldExprHandles.put(handles[i], out.slice(i, 1)); innards.compile(context.writer, cci); } }
@Override public String toString() { return "EH[" + handle + "!" + type + "]"; }
public final RALSlot slot(int index) { checkSlot(index); return slotInner(index); }
public final RALSlot[] slots() { RALSlot[] slots = new RALSlot[length]; for (int i = 0; i < length; i++) slots[i] = slot(i); return slots; }
public final RALType readType(int index) { checkSlot(index); RALSlot rs = slotInner(index); if (!rs.perms.read) throw new RuntimeException("Slot " + index + " of " + this + " not readable"); return rs.type; }
public final RALType writeType(int index) { checkSlot(index); RALSlot rs = slotInner(index); if (!rs.perms.write) throw new RuntimeException("Slot " + index + " of " + this + " not writable"); return rs.type; }
public final void readCompile(RALExprSlice out, CompileContext context) { if (out.length != length) throw new RuntimeException( "Attempted to read " + this + " directly to " + out + " (different lengths!)"); getUnderlying(context).readCompileInner(out, context); }
public final void readInplaceCompile(RALVarVA[] out, CompileContext context) { if (out.length != length) throw new RuntimeException( "Attempted to read " + this + " directly to " + out + " (different lengths!)"); getUnderlying(context).readInplaceCompileInner(out, context); }
public final void writeCompile( int index, String input, RALType.Major inputExactType, CompileContext context) { checkSlot(index); getUnderlying(context).writeCompileInner(index, input, inputExactType, context); }
@Override public String toString() { return getClass().getName(); }
public final RALType assert1ReadType() { if (length != 1) throw new RuntimeException("Failed assert1ReadType: " + this); return readType(0); }
public final RALType assert1With(RALSlot.Perm required) { if (length != 1) throw new RuntimeException("Failed assert1ReadType: " + this); RALSlot rs = slotInner(0); rs.perms.require(this, required); return rs.type; }
public static RALExprSlice concat(RALExprSlice... slices) { RALExprSlice basis = EMPTY; for (RALExprSlice res : slices) basis = concat(basis, res); return basis; }
public static RALExprSlice concat(RALExprSlice a, RALExprSlice b) { RALExprSlice res = a.tryConcatWithInner(b); if (res != null) return res; if (b instanceof Concatenate) { RALExprSlice aba = a.tryConcatWithInner(((Concatenate) b).a); if (aba != null) { return concat(aba, ((Concatenate) b).b); } } if (a.length == 0) return b; if (b.length == 0) return a; return new Concatenate(a, b); }
public final RALExprSlice slice(int base, int newLen) { if (newLen == 0) return EMPTY; if (newLen < 0) throw new IndexOutOfBoundsException("Cannot slice " + this + " with a < 0 length " + length); if (base < 0) throw new IndexOutOfBoundsException("Attempted to slice at base " + base + " < 0 of " + this); if (base + newLen > length) throw new IndexOutOfBoundsException( "Attempted to slice " + base + "[" + newLen + "]" + " > " + length + " of " + this); if (newLen == length) return this; return sliceInner(base, newLen); }
protected RALExprSlice sliceInner(int base, int length) { return new QuasiSlice(this, base, length); }
protected RALExprSlice tryConcatWithInner(RALExprSlice b) { return null; }
private final void checkSlot(int index) { if (index < 0 || index >= length) throw new IndexOutOfBoundsException("Invalid slot " + index + " in " + this); }
protected RALSlot slotInner(int index) { throw new RuntimeException("Slot not supported on " + this); }
protected void readCompileInner(RALExprSlice out, CompileContext context) { throw new RuntimeException("Read not supported on " + this); }
protected void readInplaceCompileInner(RALVarVA[] out, CompileContext context) { readCompileInner(concat(out), context); }
protected void writeCompileInner( int index, String input, RALType.Major inputExactType, CompileContext context) { throw new RuntimeException("Write not supported on " + this); }
public final String describeGeneType(int geneTypeV) { String geneType = Integer.toHexString(geneTypeV); while (geneType.length() < 4) geneType = "0" + geneType; GenDataLayout gdl = getGeneLayout(geneTypeV); if (gdl != null) geneType += " (" + gdl.name + ")"; return geneType; }
public final String summarizeGene(VirtualCatalogue catalogue, byte[] genome, int start) { StringBuilder sb = new StringBuilder(); Gene g = new Gene(this); int len = GenUtils.nextChunk(genome, start + geneHeaderLength) - start; if (len < 0) len = 0; g.deserialize(genome, start, len); g.summarize(catalogue, sb); return sb.toString(); }
public boolean flagsWillExpress(int geneFlags, int sxs) { if ((geneFlags & (GeneFlags.C123_MALE | GeneFlags.C123_FEMALE)) != 0) { int relevantFlag = sxs == 0 ? GeneFlags.C123_MALE : GeneFlags.C123_FEMALE; if ((geneFlags & relevantFlag) == 0) return false; } return true; }
@Override public String summarizeGeneHeader(byte[] genome, int start) { int geneTypeV = getGeneType(genome, start); String geneType = describeGeneType(geneTypeV); int geneId = GenUtils.safeGet(genome, start + 6); int generation = GenUtils.safeGet(genome, start + 7); int switchOn = GenUtils.safeGet(genome, start + 8); int flags = GenUtils.safeGet(genome, start + 9); return geneType + " I" + (geneId & 0xFF) + " G" + (generation & 0xFF) + " A" + (switchOn & 0xFF) + " " + GeneFlags.summarizeGeneFlags((byte) flags); }
public boolean flagsWillExpress(int geneFlags, int sxs) { if ((geneFlags & GeneFlags.C_23_CARRY) != 0) return false; if ((geneFlags & (GeneFlags.C123_MALE | GeneFlags.C123_FEMALE)) != 0) { int relevantFlag = sxs == 0 ? GeneFlags.C123_MALE : GeneFlags.C123_FEMALE; if ((geneFlags & relevantFlag) == 0) return false; } return true; }
@Override public String summarizeGeneHeader(byte[] genome, int start) { int geneTypeV = getGeneType(genome, start); String geneType = describeGeneType(geneTypeV); int geneId = GenUtils.safeGet(genome, start + 6); int generation = GenUtils.safeGet(genome, start + 7); int switchOn = GenUtils.safeGet(genome, start + 8); int flags = GenUtils.safeGet(genome, start + 9); int mutability = GenUtils.safeGet(genome, start + 10); return geneType + " I" + (geneId & 0xFF) + " G" + (generation & 0xFF) + " A" + (switchOn & 0xFF) + " " + GeneFlags.summarizeGeneFlags((byte) flags) + " M" + (mutability & 0xFF); }
@Override public String summarizeGeneHeader(byte[] genome, int start) { int geneTypeV = getGeneType(genome, start); String geneType = describeGeneType(geneTypeV); int geneId = GenUtils.safeGet(genome, start + 6); int generation = GenUtils.safeGet(genome, start + 7); int switchOn = GenUtils.safeGet(genome, start + 8); int flags = GenUtils.safeGet(genome, start + 9); int mutability = GenUtils.safeGet(genome, start + 10); int variant = GenUtils.safeGet(genome, start + 11); return geneType + " I" + (geneId & 0xFF) + " G" + (generation & 0xFF) + " A" + (switchOn & 0xFF) + " " + GeneFlags.summarizeGeneFlags((byte) flags) + " M" + (mutability & 0xFF) + " V" + (variant & 0xFF); }
public Data newData() { if (geneClass == null) { return new Gene.DataUnknown(); } else { try { return geneClass.newInstance(); } catch (Exception ex) { throw new RuntimeException(ex); } } }
public static GenVersion identify(File file) throws IOException { return identify(Files.readAllBytes(file.toPath())); }
public static GenVersion identify(byte[] data) { if (matchWord(data, 0, 'd', 'n', 'a', '3')) return GenVersion.C3; if (matchWord(data, 0, 'd', 'n', 'a', '2')) return GenVersion.C2; if (matchWord(data, 0, 'g', 'e', 'n', 'e')) return GenVersion.C1; return null; }
public static GenPackage readGenome(File file) throws IOException { return readGenome(Files.readAllBytes(file.toPath())); }
public static GenPackage readGenome(byte[] data) { GenVersion gv = identify(data); if (gv == GenVersion.C1) { return new GenPackage(gv, data); } else if (gv == null) { throw new RuntimeException("Unknown genome version."); } else { byte[] outb = new byte[data.length - 4]; System.arraycopy(data, 4, outb, 0, outb.length); return new GenPackage(gv, outb); } }
public static int nextChunk(byte[] data, int start) { int effectiveLen = data.length - 4; while (start <= effectiveLen) { if (data[start] == 'g' && data[start + 1] == 'e' && data[start + 2] == 'n' && (data[start + 3] == 'e' || data[start + 3] == 'd')) return start; start++; } return data.length; }
public static int nextGene(byte[] data, int start) { int effectiveLen = data.length - 4; while (start <= effectiveLen) { if (data[start] == 'g' && data[start + 1] == 'e' && data[start + 2] == 'n') { if (data[start + 3] == 'e') return start; if (data[start + 3] == 'd') return data.length; } start++; } return data.length; }
public static boolean matchWord(byte[] data, int ptr, char a, char b, char c, char d) { if (ptr + 4 > data.length) return false; if (data[ptr++] != a) return false; if (data[ptr++] != b) return false; if (data[ptr++] != c) return false; return data[ptr] == d; }
public static int safeGet(byte[] data, int ptr) { if (ptr < 0 || ptr >= data.length) return 0; return data[ptr] & 0xFF; }
public static int safeGet(byte[] data, int ptr, int min, int max) { if (ptr < 0 || ptr >= data.length) return 0; int val = data[ptr] & 0xFF; if (val >= min && val < max) return val; val -= min; val %= max - min; val += min; return val; }
public static void summarizeChemRef(VirtualCatalogue catalogue, StringBuilder builder, int chem) { String name = catalogue.findChemName(chem); if (name != null) { builder.append(name); builder.append(" "); } builder.append("["); builder.append(chem); builder.append("]"); }
public static PRAYBlock findCreatureRootBlock(Iterable<PRAYBlock> inp) { for (PRAYBlock pb : inp) { String name = pb.getName(); String type = pb.getType(); if (!(type.equals("DSEX") || type.equals("warp"))) continue; if (name.endsWith("." + type)) { String head = ExportedCreatures.monikerFromRootBlock(pb); if (Monikers.verifyMoniker(head)) { return pb; } } } return null; }
public static boolean creatureConvertInPlace(Iterable<PRAYBlock> inp, String nType) { PRAYBlock creatureRoot = findCreatureRootBlock(inp); if (creatureRoot == null) return false; String oType = creatureRoot.getType(); creatureRoot.setType(nType); creatureRoot.setName(ExportedCreatures.monikerFromRootBlock(creatureRoot) + "." + nType); for (PRAYBlock blk : inp) blk.setName(blk.getName().replace("." + oType + ".", "." + nType + ".")); return true; }
public static String monikerFromRootBlock(PRAYBlock root) { String name = root.getName(); int splitIndex = name.lastIndexOf('.'); return name.substring(0, splitIndex); }
public PRAYBlock copy() { return new PRAYBlock(getType(), getName(), data.clone(), charset); }
public static LinkedList<PRAYBlock> copyList(Iterable<PRAYBlock> src) { LinkedList<PRAYBlock> blocks = new LinkedList<>(); for (PRAYBlock blk : src) blocks.add(blk.copy()); return blocks; }
public static LinkedList<PRAYBlock> read( ByteBuffer dataSlice, int maxDecompressedSize, Charset charset) { if (dataSlice.get() != (byte) 'P') throw new RuntimeException("Not a PRAY file!"); if (dataSlice.get() != (byte) 'R') throw new RuntimeException("Not a PRAY file!"); if (dataSlice.get() != (byte) 'A') throw new RuntimeException("Not a PRAY file!"); if (dataSlice.get() != (byte) 'Y') throw new RuntimeException("Not a PRAY file!"); LinkedList<PRAYBlock> blocks = new LinkedList<>(); int remaining = maxDecompressedSize; while (dataSlice.position() != dataSlice.limit()) { PRAYBlock pb = readOne(dataSlice, remaining, maxDecompressedSize, charset); blocks.add(pb); remaining -= pb.data.length; } return blocks; }
private static PRAYBlockPrepared prepareBlock(PRAYBlock pb, boolean compress) { byte[] dataMod = pb.data; if (compress) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); try { DeflaterOutputStream dos = new DeflaterOutputStream(baos); dos.write(pb.data); dos.close(); } catch (IOException ioe) { throw new RuntimeException(ioe); } dataMod = baos.toByteArray(); return new PRAYBlockPrepared(pb, pb.data.length, true, dataMod); } else { return new PRAYBlockPrepared(pb, pb.data.length, false, pb.data); } }
public static byte[] write(Iterable<PRAYBlock> blocks, boolean compressPRAYChunks) { int totalLen = 4; int blockCount = 0; for (Iterator<PRAYBlock> iterator = blocks.iterator(); iterator.hasNext(); iterator.next()) blockCount++; if (blockCount == 1) return writeFileWithOneBlock(blocks.iterator().next(), compressPRAYChunks); PRAYBlockPrepared[] preparedBlocks = new PRAYBlockPrepared[blockCount]; int blockIndex = 0; for (PRAYBlock pb : blocks) { PRAYBlockPrepared pbp = prepareBlock(pb, compressPRAYChunks); preparedBlocks[blockIndex++] = pbp; totalLen += pbp.calcSize(); } ByteBuffer total = IOUtils.newBuffer(totalLen); total.put((byte) 'P'); total.put((byte) 'R'); total.put((byte) 'A'); total.put((byte) 'Y'); for (PRAYBlockPrepared pb : preparedBlocks) pb.put(total); return total.array(); }
public static byte[] writeFileWithOneBlock(PRAYBlock pb, boolean compressPRAYChunks) { PRAYBlockPrepared pbp = prepareBlock(pb, compressPRAYChunks); int totalLen = 4 + pbp.calcSize(); ByteBuffer total = IOUtils.newBuffer(totalLen); total.put((byte) 'P'); total.put((byte) 'R'); total.put((byte) 'A'); total.put((byte) 'Y'); pbp.put(total); return total.array(); }
private void put(ByteBuffer total) { total.put(type); total.put(name); total.putInt(data.length); total.putInt(fullSize); total.putInt(compressed ? 1 : 0); total.put(data); }
public int calcSize() { return 16 + 128 + data.length; }
public void read(byte[] block) { ByteBuffer bb = IOUtils.wrapLE(block); int intValNo = bb.getInt(); for (int i = 0; i < intValNo; i++) { String key = IOUtils.getString(bb, charset); int val = bb.getInt(); intMap.put(key, val); } int strValNo = bb.getInt(); for (int i = 0; i < strValNo; i++) { String key = IOUtils.getString(bb, charset); strMap.put(key, IOUtils.getString(bb, charset)); } }
public byte[] toByteArray() { LinkedList<byte[]> intKeyByteArrays = new LinkedList<byte[]>(); LinkedList<Integer> intValues = new LinkedList<Integer>(); LinkedList<byte[]> stringByteArrays = new LinkedList<byte[]>(); int totalSize = 8; for (Entry<String, Integer> ent : intMap.entrySet()) { byte[] k = ent.getKey().getBytes(charset); intKeyByteArrays.add(k); intValues.add(ent.getValue()); totalSize += 8 + k.length; } for (Entry<String, String> ent : strMap.entrySet()) { byte[] k = ent.getKey().getBytes(charset); byte[] v = ent.getValue().getBytes(charset); stringByteArrays.add(k); stringByteArrays.add(v); totalSize += 8 + k.length + v.length; } ByteBuffer res = IOUtils.newBuffer(totalSize); Iterator<byte[]> iK; Iterator<Integer> iV; res.putInt(intValues.size()); iK = intKeyByteArrays.iterator(); iV = intValues.iterator(); while (iK.hasNext()) { byte[] key = iK.next(); int val = iV.next(); res.putInt(key.length); res.put(key); res.putInt(val); } res.putInt(stringByteArrays.size() / 2); iK = stringByteArrays.iterator(); while (iK.hasNext()) { byte[] key = iK.next(); res.putInt(key.length); res.put(key); } return res.array(); }
public static InflaterInputStream wrapInputStream(InputStream outer) throws IOException { for (byte b : MAGIC) if (outer.read() != b) throw new IOException("Did not match CreaturesArchive magic number."); return new InflaterInputStream(outer); }
public static OutputStream wrapOutputStream(OutputStream outer) throws IOException { outer.write(MAGIC); return new DeflaterOutputStream(outer); }
public static File selectDirectory(Component d) { JFileChooser fd = new JFileChooser(lastDir); fd.setFileHidingEnabled(false); fd.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY); int res = fd.showOpenDialog(d); lastDir = fd.getCurrentDirectory(); if (res == JFileChooser.APPROVE_OPTION) return fd.getSelectedFile(); return null; }
public static void showExceptionDialog( Frame parent, String introText, String title, Exception exception) { StringWriter sw = new StringWriter(); exception.printStackTrace(); exception.printStackTrace(new PrintWriter(sw)); JDialog dialog = new JDialog(parent); dialog.setModal(true); JTabbedPane tabs = new JTabbedPane(); dialog.add(tabs); JPanel mainError = new JPanel(); JTextArea jta1 = new JTextArea(introText + "\n" + exception.toString()); jta1.setEditable(false); mainError.add(jta1); mainError.add(new JButtonWR("Close", () -> dialog.setVisible(false))); tabs.addTab("Error", mainError); JTextArea jta = new JTextArea(sw.toString()); jta.setEditable(false); JScrollPane jsp = new JScrollPane(jta); jsp.setPreferredSize(new Dimension(640, 480)); tabs.addTab("Details", jsp); dialog.setLocationByPlatform(true); dialog.pack(); dialog.setVisible(true); }
public static boolean confirmInformationOperation(Component parent, String text, String title) { int res = JOptionPane.showOptionDialog( parent, text, title, JOptionPane.YES_NO_OPTION, JOptionPane.INFORMATION_MESSAGE, null, null, null); return res == JOptionPane.YES_OPTION; }
public static boolean confirmDangerousOperation(Component parent, String text, String title) { int res = JOptionPane.showOptionDialog( parent, text, title, JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE, null, null, null); return res == JOptionPane.YES_OPTION; }
public static void fileDialog(Frame parent, String title, int mode, Consumer<File> result) { FileDialog fd = new FileDialog(parent); try { fd.setDirectory(lastDir.getAbsolutePath()); } catch (Exception ex) { } fd.setTitle(title); fd.setMultipleMode(false); fd.setMode(mode); fd.setVisible(true); try { lastDir = new File(fd.getDirectory()); } catch (Exception ex) { } File[] files = fd.getFiles(); if (files.length == 1) { File f = files[0]; result.accept(f); } }
@Override public void windowClosing(WindowEvent e) { f.dispose(); }
public static void fixAWT() { System.setProperty("sun.awt.noerasebackground", "true"); System.setProperty("sun.awt.erasebackgroundonresize", "true"); }
public static GridBagConstraints gridBagFill(int x, int y, int w, int h, float wX, float wY) { GridBagConstraints gbc = new GridBagConstraints(); gbc.gridx = x; gbc.gridy = y; gbc.gridwidth = w; gbc.gridheight = h; gbc.weightx = wX; gbc.weighty = wY; gbc.fill = GridBagConstraints.BOTH; gbc.anchor = GridBagConstraints.CENTER; return gbc; }
private static File configRootPos() { String override = System.getenv("CDSP_CONFIG_ROOT"); if (override != null) return new File(override); File userHome = new File(System.getProperty("user.home", ".")); return new File(new File(new File(userHome, ".local"), "share"), "cdsp-common"); }
public static Object load(String name, String overrideVar) { try { File f = accountForOverrideVar(name, overrideVar); if (!f.exists()) return null; try (FileInputStream fis = new FileInputStream(f)) { return new JSONTokener(new InputStreamReader(fis, StandardCharsets.UTF_8)).nextValue(); } } catch (Exception ex) { ex.printStackTrace(); } return null; }
public static void save(String name, String overrideVar, Object val) { try { configRoot.mkdirs(); File f = accountForOverrideVar(name, overrideVar); StringWriter sw = new StringWriter(); if (val instanceof JSONObject) { ((JSONObject) val).write(sw, 4, 0); } else { sw.write(JSONWriter.valueToString(val)); } Files.write(f.toPath(), sw.toString().getBytes(StandardCharsets.UTF_8)); } catch (Exception ex) { ex.printStackTrace(); } }
private static File accountForOverrideVar(String name, String overrideVar) { if (overrideVar != null) { String override = System.getenv(overrideVar); if (override != null) return new File(override); } return new File(configRoot, name); }
public void add(Consumer<T> ctl) { listeners.add(ctl); }
public void remove(Consumer<Object> refreshEv) { listeners.remove(refreshEv); }
public void fire(T o) { for (Consumer<T> ct : listeners) ct.accept(o); }
@Override public final void paint(Graphics arg0) { int w = (getWidth() + (scale - 1)) / scale; int h = (getHeight() + (scale - 1)) / scale; if (w < 1) w = 1; if (h < 1) h = 1; BufferedImage bi = createContentsImage(w, h, true, true, true); arg0.drawImage(bi, 0, 0, bi.getWidth() * scale, bi.getHeight() * scale, null); }
public void repaintCleanly() { Graphics g = getGraphics(); if (g != null) paint(g); }
public final BufferedImage createPhoto() { int w = (getWidth() + (scale - 1)) / scale; int h = (getHeight() + (scale - 1)) / scale; if (w < 1) w = 1; if (h < 1) h = 1; return createContentsImage(w, h, false, true, false); }
public final BufferedImage createContentsImage( int w, int h, boolean background, boolean stage, boolean foreground) { BufferedImage bi = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB); Graphics big = bi.getGraphics(); int ofx = ((int) offsetX) + ((w - stageW) / 2); int ofy = ((int) offsetY) + ((h - stageH) / 2); if (background) paintStaticBackground(w, h, big); big.translate(ofx, ofy); if (stage) paintStage(w, h, big); big.translate(-ofx, -ofy); if (foreground) paintStaticForeground(w, h, big); return bi; }
public void paintStaticForeground(int w, int h, Graphics g) {}
@Override protected void processMouseMotionEvent(MouseEvent e) { super.processMouseMotionEvent(e); int x = e.getX(); int y = e.getY(); if (mb1Down) { offsetX += (x - lastX) / (float) scale; offsetY += (y - lastY) / (float) scale; repaintCleanly(); } lastX = x; lastY = y; }
public static GenPackage loadGenetics(File f, Frame frame) { try { return loadGeneticsCore(f); } catch (Exception ex) { CDSPCommonUI.showExceptionDialog(frame, "Could not load genetics.", "Error", ex); } return null; }
public static void loadGeneticsFileDialog(Frame frame, FileDialogThenLoad<GenPackage> handler) { loadGeneticsFileDialog(frame, "Genome/Exported Creature...", handler); }
public static void loadGeneticsFileDialog( Frame frame, String title, FileDialogThenLoad<GenPackage> handler) { CDSPCommonUI.fileDialog( frame, title, FileDialog.LOAD, (f) -> { GenPackage gPackage = loadGenetics(f, frame); if (gPackage == null) return; handler.accept(f, gPackage); }); }
private File[] ftar(LinkedList<File> files) { ArrayList<File> al = new ArrayList<>(files); return al.toArray(new File[0]); }
public void refreshDirs() { jlf.setListData(ftar(files)); }
@Override public void paintStaticBackground(int w, int h, Graphics g) { g.setColor(Color.black); g.fillRect(0, 0, w, h); }
@Override public void paintStage(int w, int h, Graphics g) { for (int i = 0; i < zOrder.length; i++) { int pi = zOrder[i]; BufferedImage bi = imageCache[pi].getImage(); if (bi != null) g.drawImage(bi, partLocations[pi].x, partLocations[pi].y, null); } }
@Override public void itemStateChanged(ItemEvent e) { if (e.getID() == ItemEvent.ITEM_STATE_CHANGED && e.getStateChange() == ItemEvent.SELECTED) target.run(); }
private void onUpdateFD() { setPoseString(poseString.getText()); onChange.run(); }
@Override public void removeUpdate(DocumentEvent e) { SwingUtilities.invokeLater( () -> { onUpdateFD(); }); }
@Override public void insertUpdate(DocumentEvent e) { SwingUtilities.invokeLater( () -> { onUpdateFD(); }); }
@Override public void changedUpdate(DocumentEvent e) { SwingUtilities.invokeLater( () -> { onUpdateFD(); }); }
private void comboboxesToTextField() { poseString.getDocument().removeDocumentListener(feedDoc); poseString.setText(getPoseString()); poseString.getDocument().addDocumentListener(feedDoc); }
public void intoPartFrames(int[] partFrames) { def.decodePoseString(partFrames, getPoseString()); for (int i = 0; i < poseChars.length; i++) if (states[i] != null) def.setState(partFrames, poseChars[i].associatedPartIndex, states[i].getSelectedIndex()); }
@Override public String findChemName(int chem) { return chemNames[chem & 0xFF]; }
public void reset() { charset = W1252Fixed.INSTANCE; for (LinkedList<File> llf : locations.values()) llf.clear(); for (int i = 0; i < chemNames.length; i++) chemNames[i] = null; }
public void fromGameDirectory(File dir) { for (Location loc : Location.values()) { File f = new File(dir, loc.nameTypical); if (f.exists()) locations.get(loc).add(f); } }
public void loadFromDefaultLocation() { load(AppConfig.load("gameinfo.json", "CDSP_GAMEINFO")); }
public JSONObject save() { JSONObject obj = new JSONObject(); obj.put("version", VERSION); obj.put("charset", charset.name()); JSONObject loc = new JSONObject(); for (Map.Entry<Location, LinkedList<File>> ent : locations.entrySet()) { JSONArray array = new JSONArray(); for (File f : ent.getValue()) array.put(f.toString()); loc.put(ent.getKey().nameInternal, array); } obj.put("locations", loc); JSONArray cn = new JSONArray(); for (int i = 0; i < 256; i++) cn.put((Object) chemNames[i]); obj.put("chemNames", cn); return obj; }
public void saveToDefaultLocation() { AppConfig.save("gameinfo.json", "CDSP_GAMEINFO", save()); }
@Override public boolean accept(File dir, String chkName) { return chkName.equalsIgnoreCase(name); }
@Override public File[] listFiles(Location location) { HashSet<String> includedCanonized = new HashSet<>(); LinkedList<File> list = new LinkedList<>(); for (File f : locations.get(location)) { File[] targets = f.listFiles(); if (targets == null) continue; for (File s : targets) { String sCanonized = s.getName().toLowerCase(); if (includedCanonized.add(sCanonized)) list.add(s); } } return list.toArray(new File[0]); }
public File newFile(Location location, String name) { return new File(locations.get(location).getFirst(), name); }
public boolean looksEmpty() { return locations.get(Location.GENETICS).size() == 0; }
public void loadCataloguesViaCPX() throws IOException { for (int i = 0; i < 256; i++) { String res = Injector.cpxRequest("execute\nouts read \"chemical_names\" " + i, charset); if (i == 90 && res.equals("90")) res = "Wounded"; chemNames[i] = res; } }
private void updateText() { text.setText( Integer.toString(scrollBar.getValue()) + "/" + Integer.toString(scrollBar.getMaximum() - 1)); }
@Override public void paintStage(int w, int h, Graphics g) { BufferedImage bi = tbic.getImage(); if (bi != null) g.drawImage(bi, 0, 0, null); }
@Override public void paintStaticForeground(int w, int h, Graphics g) {}
public static void main(String[] args) throws IOException { CDSPCommonUI.fixAWT(); new CS16Viewer().setVisible(true); }
private void refreshBI(JInfiniteCanvas canvas) { if (frI < 0 || frI >= fr.length) { tbic.setSource(null); } else { S16Image frame = fr[frI]; tbic.setSource(frame); canvas.stageW = frame.width; canvas.stageH = frame.height; } canvas.repaintCleanly(); }
public void doLoadGenetics() { File f = geneticsPicker.getFile(); if (f != null) { try { GenPackage genomeData = DoWhatIMeanLoader.loadGenetics(f, this); if (genomeData != null) { C3SkeletalAgingSimulation simulator = new C3SkeletalAgingSimulation(genomeData); for (int i = 0; i <= age.getSelectedIndex(); i++) simulator.executeAge(i, sxs.getSelectedIndex()); tint.setTint(simulator.myTint); jNorn.setTint(simulator.myTint); jpse.setSlots(simulator.myPartSlots); } } catch (Exception ex) { CDSPCommonUI.showExceptionDialog(this, "Could not simulate genetics.", "Error", ex); geneticsPicker.setFile(null); } } reloadSkeleton(this); }
public void doPhoto() { CDSPCommonUI.fileDialog( this, "Save PNG...", FileDialog.SAVE, file -> { try { BufferedImage bi = jNorn.createPhoto(); ImageIO.write(bi, "PNG", file); } catch (Exception ex) { CDSPCommonUI.showExceptionDialog(this, "Could not save image.", "Error", ex); } }); }
public void reloadSkeleton(Frame frame) { try { poseString.intoPartFrames(pose); C3PartSlots c3ps = jpse.getSlots(); SkeletonIndex[] genes = c3ps.asSkeletonIndexes(sxs.getSelectedIndex(), age.getSelectedIndex()); DirLookup cached = new CachedDirLookup(gameInfo); ls = new LoadedSkeleton(cached, genes, SkeletonDef.C3); jNorn.setParameters(ls, pose); } catch (Exception ex) { CDSPCommonUI.showExceptionDialog(frame, "Could not load skeleton.", "Error", ex); } }
public static void main(String[] args) throws IOException { S16Image testCard = new S16Image(256, 256); for (int i = 0; i < 65536; i++) testCard.pixels[i] = (short) i; byte[] data = CS16IO.encode(new S16Image[] {testCard}, CS16Format.S16_RGB565); Files.write(new File("../ral/samples/ral_tint_test_card.s16").toPath(), data); }
private String makeGenomeReport(GenPackage gPackage) { StringBuilder result = new StringBuilder(); result.append(gPackage.version.toString()); result.append("\n"); byte[] genomeData = gPackage.data; int offset = GenUtils.nextGene(genomeData, 0); while (offset < genomeData.length) { result.append(gPackage.version.summarizeGene(gameInfo, genomeData, offset)); result.append("\n"); offset = GenUtils.nextGene(genomeData, offset + 4); } return result.toString(); }
private void eggject(String sxs) { if (!convinceUserToDoSetup()) return; if (!convinceUserToInstallCPX()) return; DoWhatIMeanLoader.loadGeneticsFileDialog( this, (f, gPackage) -> { try { File target = gameInfo.newFile(Location.GENETICS, "dave.gen"); Files.write(target.toPath(), gPackage.toFileData()); Injector.cpxRequest("execute\nsetv va00 " + sxs + " " + EGG_REQUEST, gameInfo.charset); } catch (Exception ex) { CDSPCommonUI.showExceptionDialog(Main.this, "Could not inject egg.", "Error", ex); } }); }
private static boolean doConvert( File img, boolean blk, boolean forceOverwrite, CS16Format uncompressed, CS16Format compressed) throws IOException { Path path = img.toPath(); byte[] data = Files.readAllBytes(path); if (blk) { BLKInfo res = CS16IO.readBLKInfo(img); if (res.format == CS16Format.S16_RGB565 && !forceOverwrite) return false; ByteArrayOutputStream tmp = new ByteArrayOutputStream(); CS16IO.encodeBLK(tmp, res, uncompressed); Files.write(path, tmp.toByteArray()); } else { CS16Format originalFormat = CS16IO.determineFormat(data); CS16Format targetFormat = originalFormat.compressed ? compressed : uncompressed; if ((originalFormat == targetFormat) && !forceOverwrite) return false; S16Image[] res = CS16IO.decodeCS16(img); Files.write(path, CS16IO.encode(res, targetFormat)); } return true; }
public static void main(String[] args) throws IOException { CDSPCommonUI.fixAWT(); new Main(); }
public static BaseCTOS packetHex(String hex) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream(); while (hex.length() > 0) { baos.write(Integer.parseUnsignedInt(hex.substring(0, 2), 16)); hex = hex.substring(2); } ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); byte[] header = new byte[PacketReader.PACKET_HEADER_SIZE]; bais.read(header); Config defCfg = new Config(); return PacketReader.readPacket(defCfg.messages, header, bais); } catch (Exception ex) { throw new RuntimeException("During " + hex, ex); } }
@SuppressWarnings("unchecked") public static <T extends BaseCTOS> T checkedCastPacket(Class<T> cls, BaseCTOS bc) { if (cls.isInstance(bc)) return (T) bc; fail("Packet was expected to be " + cls + " not " + bc.getClass()); return null; }
@Test public void test() { CreatureHistoryBlob chb = parse( "210300000100000002000000a0a84e11010000000d000000cb00000000000000200000003030312d6461776e2d36776134722d617a3878372d636e7634762d756c67676b00010000001000000049b01700f4020500789246630500000000000000000000000200000041311c000000646f636b2d79797666652d76343232682d79626733352d72626c74630b0000003239303336373634382b311500000000000000010000003d000000446f6f6d656420746f20666f72657665722077616e646572207468652077617374656c616e6473206f662074686520696d706f737369626c652e2e2e0a00000000"); assertEquals(1, chb.events.length); assertEquals("dock-yyvfe-v422h-ybg35-rbltc", chb.events[0].worldID); assertEquals("", chb.name); assertEquals("Doomed to forever wander the wastelands of the impossible...\n", chb.userText); }
private CreatureHistoryBlob parse(String packet) { BaseCTOS data = TestUtils.packetHex(packet); CTOSFeedHistory cfh = TestUtils.checkedCastPacket(CTOSFeedHistory.class, data); return new CreatureHistoryBlob(IOUtils.wrapLE(cfh.data), 256); }
@Test public void test() { for (long i = 0; i != 0xF00000000L; i += 0x1000000) { for (int j = 0; j != 0xFFFF0000; j += 0x10000) { long trueTime = i + j; int reducedTime = (int) trueTime; assertEquals(trueTime, UnixTime.inferFrom32(reducedTime, i)); } } for (int i = 0; i != 0x80000000; i += 0x1000000) { for (int j = -0x800; j != 0x800; j += 0x100) { assertEquals(i, UnixTime.inferFrom32(i, i)); } } }
@Test public void test() throws InvalidTOTPKeyException { assertEquals( 872921, TOTP.hashToDigits( (byte) 0x1F, (byte) 0x86, (byte) 0x98, (byte) 0x69, (byte) 0x0E, (byte) 0x02, (byte) 0xCA, (byte) 0x16, (byte) 0x61, (byte) 0x85, (byte) 0x50, (byte) 0xEF, (byte) 0x7F, (byte) 0x19, (byte) 0xDA, (byte) 0x8E, (byte) 0x94, (byte) 0x5B, (byte) 0x55, (byte) 0x5A)); byte[] key = TOTP.decodeBase32("NTCRADLE"); assertEquals("NTCRADLE", new String(TOTP.encodeBase32(key))); assertEquals(329666, TOTP.calculate(key, 56945790)); }
@Test public void test() { assertEquals(true, Monikers.verifyMoniker("001-dawn-6wa4r-az8x7-cnv4v-ulggk")); assertEquals(true, Monikers.verifyMoniker("12345-dawn-6wa4r-az8x7-cnv4v-ulggk")); assertEquals(false, Monikers.verifyMoniker("../194141-b-c-d-e-f")); assertEquals(false, Monikers.verifyMonikerBase("..", 1)); }
public static String foldNickname(String username) { return username.toLowerCase(); }
public static boolean verifyNickname(ConfigAccounts nicknames, String username) { int len = username.length(); if (len < nicknames.nicknameMinLength.getValue() || len > nicknames.nicknameMaxLength.getValue()) return false; String allowedChars = nicknames.nicknameAllowedCharacters.getValue(); for (char c : username.toCharArray()) if (allowedChars.indexOf(c) == -1) return false; return true; }
public static boolean verify(int uid, String hash, String password, boolean allowDevPasswords) { if (hash.startsWith("G1:")) { return hash.equals(hashG1(uid, password)); } else if (hash.startsWith("DEV:") && allowDevPasswords) { return hash.equals("DEV:" + password); } return false; }
public static String hash(int uid, String password) { return hashG1(uid, password); }
public static String hashG1(int uid, String password) { byte[] data = ("PWHash_" + uid + "_" + password).getBytes(PacketReader.CHARSET); byte[] digest; try { MessageDigest md = MessageDigest.getInstance("SHA-256"); md.update(data); digest = md.digest(); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } return "G1:" + Base64.getEncoder().encodeToString(digest); }
public static byte[] make2FA(long twoFactorSeed, String password) { byte[] data = (twoFactorSeed + ":" + password).getBytes(PacketReader.CHARSET); byte[] digest; byte[] result = new byte[10]; try { MessageDigest md = MessageDigest.getInstance("SHA-256"); md.update(data); digest = md.digest(); System.arraycopy(digest, 0, result, 0, result.length); return result; } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } }
public static void main(String[] args) { System.out.println(hash(Integer.valueOf(args[0]), args[1])); }
private static String verifyLimitLen(int l, String name) { if (name.length() > l) name = name.substring(0, l); return name; }
private static String verifyHumanReadableLen(int l, String name, boolean newLines) { return verifyLimitLen(l, name); }
public static String stripMonikerLike(String name) { return verifyLimitLen(Monikers.MAX_MONIKER_LEN, name); }
public static String stripName(ConfigMessages config, String name) { return verifyHumanReadableLen(config.maxCreatureNameLen.getValue(), name, false); }
public static String stripUserText(ConfigMessages config, String userText) { return verifyHumanReadableLen(config.maxCreatureUserTextLen.getValue(), userText, true); }
@Override public String toString() { return "SSL certificate chain"; }
public void run() { doSocketAcceptLoop(sv, qm, serverHub, hhi, ilp, config); }
public static void doSocketAcceptLoop( ServerSocket sv, QuotaManager qm, ServerHub hub, IHTTPHandler hhi, ILogProvider ilp, Config config) { while (true) { Socket skt; try { skt = sv.accept(); } catch (IOException e) { e.printStackTrace(); continue; } if (!qm.socketStart(skt)) { try { try { skt.setSoLinger(true, 0); } catch (Exception ex) { } skt.close(); } catch (Exception ex) { } continue; } new SocketThread( skt, qm, (st) -> { return new LoginSessionState(config, st, hub); }, hhi, ilp, config) .start(); } }
public void run(Context args) { if (args.remaining()) { args.response.append("No parameters, please.\n"); return; } boolean first = true; for (INatsueUserData data : args.hub.listAllUsersOnlineYesIMeanAllOfThem()) { if (data.isUnlisted()) continue; if (!first) { args.response.append(ChatColours.CHAT); args.response.append(", "); } args.response.append(ChatColours.NICKNAME); args.response.append(data.getNickname()); first = false; } args.response.append("\n"); }
public void run(Context args) { args.hub.forceDisconnectUIN(args.senderUIN, false); }
public void run(Context args) { args.response.append("A philosophical question.\n"); args.response.append("To me? You are " + UINUtils.toString(args.senderUIN) + ".\n"); args.response.append("Others may say differently.\n"); }
@Override public void run(Context args) { if (args.remaining()) { args.response.append( "This command doesn't take any parameters - it will make a chat request.\n"); return; } boolean hasMe; synchronized (peopleInGroupChatLock) { hasMe = peopleInGroupChat.contains(args.senderUIN); } if (hasMe) { args.response.append("Already in global chat (reconnect?)\n"); } else { args.response.append("Please stand by.\n"); sendGlobalChatRequest(args.senderUIN, args.senderUIN); } }
private void addBotCommand(BaseBotCommand command) { botCommands.put(command.name, command); botCommandsHelp.add(command); }
@Override public boolean has2FAAuthed() { return false; }
@Override public boolean try2FAAuth(int code) { return false; }
@Override public ISessionClient acquireSessionClientForResearchCommands() { return null; }
@Override public boolean forceDisconnect(boolean sync) { return false; }
@Override public void wwrNotify(boolean online, INatsueUserData theirData) { if (online) { Long whoAreWeAdding; synchronized (userContactMapLock) { whoAreWeAdding = userContactMap.remove(theirData.getUIN()); } if (whoAreWeAdding == null) whoAreWeAdding = UIN; PackedMessage pm = StandardMessages.addToContactList(theirData.getUIN(), whoAreWeAdding); hub.sendMessage(theirData.getUIN(), pm, MsgSendType.Temp, theirData.getUIN()); } else { removeFromGlobalChat(theirData.getUIN(), null); } String status = online ? "is online." : "is offline."; sendToGlobalChatExcept( 0, "!System", ChatColours.NICKNAME + theirData.getNickname() + ChatColours.CHAT + " " + status + "\n"); }
private void handleSnailMessage(PackedMessage packed, String subject, String msg) { if ((subject != null) && (msg != null)) { if (subject.equalsIgnoreCase("SYSTEM MSG")) { IHubClientAsSeenByOtherClients user = hub.getConnectionByUIN(packed.senderUIN); if (user == null) return; if (user.isAdmin()) { for (INatsueUserData sud : hub.listAllUsersOnlineYesIMeanAllOfThem()) hub.sendMessage( sud.getUIN(), StandardMessages.systemMessage(sud.getUIN(), msg), MsgSendType.Temp, packed.senderUIN); } else { hub.rejectMessage(UIN, packed, "Have to be admin"); } } } }
private void sendGlobalChatRequest(long targetUIN, long causeUIN) { hub.sendMessage( targetUIN, StandardMessages.chatRequest(UIN, NICK_GLOBALCHAT, CHATID_GLOBAL), MsgSendType.Temp, causeUIN); }
private void addToGlobalChat(INatsueUserData nud) { long senderUIN = nud.getUIN(); synchronized (peopleInGroupChatLock) { peopleInGroupChat.add(senderUIN); } String leader = "<tint 255 255 255> - GLOBAL CHAT -\n"; if (nud.isMutedGlobalChat()) leader += MSG_MUTED; PackedMessage npm = StandardMessages.chatMessage(UIN, "", CHATID_GLOBAL, leader); hub.sendMessage(senderUIN, npm, MsgSendType.Temp, senderUIN); sendGlobalChatStatusUpdate(senderUIN, "joined"); }
private void removeFromGlobalChat(long targetUIN, String cause) { boolean hadToRemove = false; synchronized (peopleInGroupChatLock) { hadToRemove = peopleInGroupChat.remove(targetUIN); } if (hadToRemove && cause != null) { sendGlobalChatStatusUpdate(targetUIN, cause); } }
private void sendGlobalChatStatusUpdate(long targetUIN, String status) { String quickNick = "!404"; INatsueUserData nud = hub.getUserDataByUIN(targetUIN); if (nud != null) quickNick = nud.getNickname(); int count; synchronized (peopleInGroupChatLock) { count = peopleInGroupChat.size(); } sendToGlobalChatExcept( 0, "", ChatColours.NICKNAME + quickNick + ChatColours.CHAT + " " + status + ". (" + count + " people)\n"); }
private boolean sendToGlobalChatExcept(long senderUIN, String nickname, String text) { LinkedList<Long> targets; synchronized (peopleInGroupChatLock) { targets = new LinkedList<>(peopleInGroupChat); } if (senderUIN != 0) if (!targets.remove(senderUIN)) return false; for (Long target : targets) hub.sendMessage( target, StandardMessages.chatMessage(UIN, nickname, CHATID_GLOBAL, text), MsgSendType.Temp, senderUIN); return true; }
private void handleCommand(Context ctx) { if (!ctx.remaining()) { ctx.response.append("What command?\n"); } else { String cmd = ctx.nextArg(); BaseBotCommand cmdI = botCommands.get(cmd); if (cmdI == null) { ctx.response.append("Unknown command. Try 'help'\n"); } else if (cmdI.category.requiresAdmin && !ctx.sender.isAdmin()) { ctx.response.append("You're not allowed to do that!\n"); } else if (cmdI.category.requires2FA && !ctx.sender.has2FAAuthed()) { ctx.response.append( "This operation is dangerous - You need to authenticate using 2FA using `2fa CODE`," + " i.e. `2fa 123456`.\n"); } else { cmdI.run(ctx); } } }
private void sendChatMessage(long targetUIN, String chatID, String text) { hub.sendMessage( targetUIN, StandardMessages.chatMessage(UIN, getNickname(), chatID, text), MsgSendType.Temp, targetUIN); }
@Override public void run(Context args) { try (INatsueUserData.LongTermPrivileged ltp = args.hub.openUserDataByUINLT(args.senderUIN)) { if ((ltp != null) && ltp.updateFlags(targetAnd, targetXor)) { args.hub.considerRandomStatus(ltp); args.response.append(successMsg); } else { args.response.append("Failed.\n"); } } }
@Override public void run(Context args) { byte[] data = args.hub.runSystemCheck(true).getBytes(StandardCharsets.UTF_8); PRAYBlock pray = new PRAYBlock( "INVI", StandardMessages.generateBlockName("INVI") + ".txt", data, PacketReader.CHARSET); PackedMessage pm = new PackedMessagePRAY(args.senderUIN, pray); args.hub.sendMessage(args.senderUIN, pm, MsgSendType.SystemReport, args.senderUIN); args.response.append("Check your Warp In directory!"); }
@Override public void run(Context args) { args.response.append(args.hub.runSystemCheck(false)); }
private void consumeWhitespace() { while (index < text.length) { if (text[index] <= 32) { index++; } else { break; } } }
private void consumeText() { while (index < text.length) { if (text[index] > 32) { index++; } else { break; } } }
public boolean remaining() { consumeWhitespace(); return index < text.length; }
public String nextArg() { consumeWhitespace(); if (index == text.length) return null; int startIndex = index; consumeText(); return new String(text, startIndex, index - startIndex); }
public String toEnd() { consumeWhitespace(); return new String(text, index, text.length - index); }
public void appendNoSuchUser(String user) { response.append(ChatColours.CHAT); response.append("'"); response.append(ChatColours.NICKNAME); response.append(user); response.append(ChatColours.CHAT); response.append("' doesn't exist. Specify a nickname or UIN.\n"); }
public INatsueUserData.LongTermPrivileged commandLookupUserLongTerm(String ref) { long asUIN = UINUtils.valueOf(ref); if (asUIN != -1) return hub.openUserDataByUINLT(asUIN); return hub.openUserDataByNicknameLT(ref); }
public INatsueUserData commandLookupUser(String ref) { long asUIN = UINUtils.valueOf(ref); if (asUIN != -1) return hub.getUserDataByUIN(asUIN); return hub.getUserDataByNickname(ref); }
public void appendNewPassword(String newPW, LongTermPrivileged userData) { response.append("Reset password to: " + newPW + "\n"); byte[] newSecret = userData.calculate2FASecret(newPW); if (newSecret != null) { try { response.append("2FA secret: " + new String(TOTP.encodeBase32(newSecret)) + "\n"); } catch (TOTP.InvalidTOTPKeyException ex) { throw new RuntimeException(ex); } } }
@Override public void run(Context args) { if (args.remaining()) { args.response.append("Too many args.\n"); return; } ISessionClient escalator = args.sender.acquireSessionClientForResearchCommands(); try { long vcrUIN = UINUtils.VC_RESEARCH_UIN; escalator.sendPacket(PacketWriter.writeVirtualConnect(vcrUIN, (short) 1)); Thread.sleep(2000); byte[] data = new byte[12]; ByteBuffer bb = IOUtils.wrapLE(data); bb.putInt(0, 1); bb.putInt(4, UINUtils.uid(vcrUIN)); bb.putInt(8, UINUtils.hid(vcrUIN)); escalator.sendPacket( PacketWriter.writeVirtualCircuitData(vcrUIN, (short) 1, args.senderUIN, (short) 1, data)); } catch (Exception ex) { args.log.log(ex); } args.response.append("Done.\n"); }
private INatsueUserData.LongTermPrivileged inSyncIntroduceIntoDatabase( NatsueDBUserInfo userInfo) { if (userInfo == null) return null; HubActiveNatsueUserData ud = new HubActiveNatsueUserData(this, userInfo); ud.open("inSyncIntroduceIntoDatabase"); cacheByUIN.put(ud.babel.uin, ud); cacheByNick.put(ud.nicknameFolded, ud); return ud; }
@Override public synchronized INatsueUserData.LongTermPrivileged openUserDataByNicknameLT(String name) { name = NicknameVerifier.foldNickname(name); INatsueUserData.LongTermPrivileged ihc = cacheByNick.get(name); if (ihc != null) return ihc.open("openUserDataByNicknameLT"); if (!NicknameVerifier.verifyNickname(config, name)) return null; return inSyncIntroduceIntoDatabase(database.getUserByFoldedNickname(name)); }
private synchronized INatsueUserData.LongTermPrivileged openUserDataByNicknameFVLT(String name) { INatsueUserData.LongTermPrivileged ihc = cacheByNick.get(name); if (ihc != null) return ihc.open("openUserDataByNicknameFVLT"); return inSyncIntroduceIntoDatabase(database.getUserByFoldedNickname(name)); }
@Override public synchronized INatsueUserData.LongTermPrivileged openUserDataByUINLT(long uin) { INatsueUserData.LongTermPrivileged ihc = cacheByUIN.get(uin); if (ihc != null) return ihc.open("openUserDataByUINLT"); return inSyncIntroduceIntoDatabase(database.getUserByUIN(uin)); }
public synchronized void notifyZeroRefCount(HubActiveNatsueUserData hubActiveNatsueUserData) { cacheByUIN.remove(hubActiveNatsueUserData.babel.uin, hubActiveNatsueUserData); cacheByNick.remove(hubActiveNatsueUserData.nicknameFolded, hubActiveNatsueUserData); }
@Override public synchronized boolean hubLogin(Root root) { if (root instanceof Fixed) { Fixed fixed = (Fixed) root; if (cacheByUIN.putIfAbsent(fixed.babel.uin, fixed) == null) { cacheByNick.put(fixed.nicknameFolded, fixed); return true; } return false; } else if (root instanceof HubActiveNatsueUserData) { ((HubActiveNatsueUserData) root).open("hubLogin"); return true; } else { throw new RuntimeException("Unhandled root type"); } }
@Override public synchronized void hubLogout(Root root) { if (root instanceof Fixed) { Fixed fixed = (Fixed) root; cacheByUIN.remove(fixed.babel.uin, fixed); cacheByNick.remove(fixed.nicknameFolded, fixed); } else if (root instanceof HubActiveNatsueUserData) { ((HubActiveNatsueUserData) root).close(); } else { throw new RuntimeException("Unhandled root type"); } }
@Override public synchronized void runSystemCheck(StringBuilder sb, boolean detailed) { if (detailed) { sb.append("-- UserDataCache --\n"); } else { sb.append("UDC Content:\n"); } for (Map.Entry<Long, INatsueUserData.LongTermPrivileged> ent : cacheByUIN.entrySet()) { INatsueUserData.LongTermPrivileged v = ent.getValue(); sb.append(UINUtils.toString(ent.getKey()) + ": " + v.getNickname() + ", "); if (v instanceof Fixed) { sb.append("FIXED\n"); } else if (v instanceof HubActiveNatsueUserData) { sb.append(((HubActiveNatsueUserData) v).debugGetStatus() + "\n"); } } }
public LinkedList<IWWRListener> earlyClientLoginInSync(IHubClient cc) { Long uin = cc.getUIN(); if (connectedClients.containsKey(uin)) return null; if (!userDataCache.hubLogin(cc.getUserData())) return null; connectedClients.put(uin, cc); if (!cc.isNoRandom()) randomPool.add(uin); LinkedList<IWWRListener> wwrNotify = new LinkedList<IWWRListener>(wwrListeners); wwrListeners.add(cc); return wwrNotify; }
public void earlyClientLogoutInSync(IHubClient cc) { Long uin = cc.getUIN(); randomPool.remove(uin); connectedClients.remove(uin, cc); wwrListeners.remove(cc); userDataCache.hubLogout(cc.getUserData()); }
public void considerRandomStatusInSync(INatsueUserData.LongTerm user) { Long uin = user.getUIN(); if (user.isNoRandom()) { randomPool.remove(uin); } else { if (connectedClients.containsKey(uin)) randomPool.add(uin); } }
public String debugGetStatus() { String sv = activity; if (sv == null) sv = "not busy"; return refCount.get() + " refs, " + sv; }
@Override public String toString() { return "UserData[" + nicknameFolded + "]"; }
@Override public LongTermPrivileged open(String site) { int res = refCount.incrementAndGet(); if (logged) log("++ (" + res + ") @ " + site); return this; }
@Override public void close() { int res = refCount.decrementAndGet(); if (logged) log("-- (" + res + ")"); if (res < 0) { log("< 0 reference count in HubActiveNatsueUserData"); } else if (res == 0) { synchronized (this) { isDead = true; parent.notifyZeroRefCount(this); } } }
@Override public byte[] calculate2FASecret(String password) { if (!is2FAEnabled()) return null; return PWHash.make2FA(twoFactorSeed, password); }
@Override public boolean update2FA(long value) { synchronized (this) { if (isDead) return false; activity = "updating 2fa"; boolean tmp = parent.database.updateUserAuth(uid, pwHash, flags, value); if (tmp) twoFactorSeed = value; activity = null; return tmp; } }
@Override public boolean updateFlags(int and, int xor) { synchronized (this) { if (isDead) return false; activity = "updating flags"; int newFlags = (flags & and) ^ xor; if (parent.database.updateUserAuth(uid, pwHash, newFlags, twoFactorSeed)) { flags = newFlags; activity = null; return true; } activity = null; return false; } }
@Override public void storeGLST(String moniker, byte[] data) { if (!Monikers.verifyMoniker(moniker)) return; try { if (!compressed) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); InputStream ins = CArcContainer.wrapInputStream(new ByteArrayInputStream(data)); byte[] chk = new byte[4096]; while (true) { int len = ins.read(chk); if (len <= 0) break; baos.write(chk, 0, len); } doStoreBlob(moniker + ".bin", baos.toByteArray()); } else { doStoreBlob(moniker + ".cra", data); } } catch (Exception ex) { ex.printStackTrace(); } }
private synchronized void doStoreBlob(String string, byte[] data) throws IOException { try (FileOutputStream fos = new FileOutputStream(new File(rootDir, string))) { fos.write(data); } }
@Override public void storeGLST(String moniker, byte[] data) {}
public static void encodeUser(JSONEncoder je, INatsueUserData nud, IHubPrivilegedAPI hub) { je.objectStart(); je.writeKV("uin", nud.getUINString()); je.writeKV("exists", true); je.writeKV("online", hub.getConnectionByUIN(nud.getUIN()) != null); je.writeKV("nickname", nud.getNickname()); je.writeKV("nicknameFolded", nud.getNicknameFolded()); je.writeKV("flags", nud.getFlags()); je.objectEnd(); }
public static INatsueUserData encodeUserByUIN(JSONEncoder je, long make, IHubPrivilegedAPI hub) { return encodeUserByUIN(je, make, hub, null); }
public static INatsueUserData encodeUserByUIN( JSONEncoder je, long make, IHubPrivilegedAPI hub, INatsueUserData cache) { INatsueUserData nud = null; if (cache != null && cache.getUIN() == make) nud = cache; else nud = hub.getUserDataByUIN(make); if (nud != null) { encodeUser(je, nud, hub); } else { je.objectStart(); je.writeKV("uin", UINUtils.toString(make)); je.writeKV("exists", false); je.writeKV("online", false); je.objectEnd(); } return nud; }
public static INatsueUserData encodeUserByUID(JSONEncoder je, int uid, IHubPrivilegedAPI hub) { return encodeUserByUID(je, uid, hub, null); }
public static INatsueUserData encodeUserByUID( JSONEncoder je, int uid, IHubPrivilegedAPI hub, INatsueUserData cache) { return encodeUserByUIN(je, UINUtils.ofRegularUser(uid), hub, cache); }
public static void encodeCreatureInfoFail(JSONEncoder je, String moniker) { je.objectStart(); je.writeKV("moniker", moniker); je.objectEnd(); }
public static void encodeCreatureInfo( JSONEncoder je, NatsueDBCreatureInfo ci, IHubPrivilegedAPI hub) { je.objectStart(); je.write("sender"); je.objectSplit(); encodeUserByUID(je, ci.senderUID, hub); je.writeKV("moniker", ci.moniker); je.writeKV("name", ci.name); je.writeKV("userText", ci.userText); je.write("state"); je.objectSplit(); je.objectStart(); je.writeKV("sex", ci.state[CreatureHistoryBlob.STATE_SEX]); je.writeKV("genus", ci.state[CreatureHistoryBlob.STATE_GENUS]); je.writeKV("variant", ci.state[CreatureHistoryBlob.STATE_VARIANT]); je.writeKV("pointMutations", ci.state[CreatureHistoryBlob.STATE_POINT_MUTATIONS]); je.writeKV("crossoverPoints", ci.state[CreatureHistoryBlob.STATE_CROSSOVER_POINTS]); je.objectEnd(); je.objectEnd(); }
public static void encodeCreatureEvent( JSONEncoder je, NatsueDBCreatureEvent ev, IHubPrivilegedAPI hub) { je.objectStart(); je.write("sender"); je.objectSplit(); INatsueUserData cache = encodeUserByUID(je, ev.senderUID, hub); je.writeKV("moniker", ev.moniker); je.writeKV("eventIndex", ev.eventIndex); je.writeKV("eventType", ev.eventType); je.writeKV("worldTime", ev.worldTime); je.writeKV("ageTicks", ev.ageTicks); je.writeKV("unixTime", UnixTime.inferFrom32(ev.unixTime32, ev.sendUnixTime)); je.writeKV("lifeStage", ev.lifeStage); je.writeKV("param1", ev.param1); je.writeKV("param2", ev.param2); je.write("world"); je.objectSplit(); encodeWorldByDetails(je, ev.worldName, ev.worldID, UINUtils.valueOf(ev.userID), hub, cache); je.objectEnd(); }
public static void encodeWorldByDetails( JSONEncoder je, String worldName, String worldID, long uin, IHubPrivilegedAPI hub, INatsueUserData cache) { je.objectStart(); je.writeKV("id", worldID); je.writeKV("name", worldName); je.write("user"); je.objectSplit(); if (uin != -1) { encodeUserByUIN(je, uin, hub, cache); } else { je.write(null); } je.objectEnd(); }
public static INatsueUserData encodeWorld( JSONEncoder je, NatsueDBWorldInfo wi, IHubPrivilegedAPI pa, INatsueUserData cache) { je.objectStart(); je.writeKV("id", wi.worldID); je.writeKV("name", wi.worldName); je.write("user"); je.objectSplit(); INatsueUserData ch = encodeUserByUIN(je, UINUtils.ofRegularUser(wi.ownerUID), pa, cache); je.objectEnd(); return ch; }
private final void startValue() { if (comma) out.append(','); }
public void write(String text) { startValue(); if (text == null) { out.append("null"); } else { out.append('"'); for (char c : text.toCharArray()) { if (c == '"' || c == '\\') { out.append('\\'); out.append(c); } else if (c == '\b') { out.append("\\b"); } else if (c == '\f') { out.append("\\f"); } else if (c == '\n') { out.append("\\n"); } else if (c == '\r') { out.append("\\r"); } else if (c == '\t') { out.append("\\t"); } else if (c < 32 || c >= 127) { out.append("\\u"); String ih = Integer.toHexString((int) c); while (ih.length() < 4) ih = "0" + ih; out.append(ih); } else { out.append(c); } } out.append('"'); } comma = true; }
public void write(int number) { startValue(); out.append(number); comma = true; }
public void write(long number) { startValue(); out.append(number); comma = true; }
public void write(float number) { startValue(); out.append(number); comma = true; }
public void write(double number) { startValue(); out.append(number); comma = true; }
public void objectStart() { startValue(); out.append('{'); comma = false; }
public void objectSplit() { if (!comma) throw new RuntimeException("objectSplit only makes sense after a value has been written!"); out.append(':'); comma = false; }
public void objectEnd() { out.append('}'); comma = true; }
public void arrayStart() { startValue(); out.append('['); comma = false; }
public void arrayEnd() { out.append(']'); comma = true; }
public void write(boolean b) { startValue(); out.append(b ? "true" : "false"); comma = true; }
public static void htmlEncode(StringBuilder sw, String inp) { for (char ch : inp.toCharArray()) { boolean safe = false; if (ch < 128) if (safeASCII[ch]) safe = true; if (safe) { sw.append(ch); } else { sw.append("&#"); sw.append((int) ch); sw.append(';'); } } }
public static void qsToVars(HashMap<String, String> qv, String qs) { String[] qse = qs.split("\\&"); int paramNum = 0; for (String s : qse) { int idxEq = s.indexOf('='); if (idxEq != -1) { qv.put(urlDecode(s.substring(0, idxEq)), urlDecode(s.substring(idxEq + 1))); } else { qv.put("p" + paramNum, HTMLEncoder.urlDecode(s)); paramNum++; } } }
public static String urlDecode(String substring) { try { return URLDecoder.decode(substring, "UTF-8"); } catch (Exception ex) { throw new RuntimeException(ex); } }
public static String urlEncode(String nickname) { try { return URLEncoder.encode(nickname, "UTF-8"); } catch (Exception ex) { throw new RuntimeException(ex); } }
public static String hrefEncode(String nickname) { return urlEncode(nickname); }
void writeWorldReference(StringBuilder rsp, String worldID, String worldName) { rsp.append("<a href=\"world?" + HTMLEncoder.hrefEncode(worldID) + "\">"); HTMLEncoder.htmlEncode(rsp, worldName); rsp.append("</a>"); }
void writePager(StringBuilder rsp, int offset, int limit, boolean shouldHaveNext, String lBase) { int prevOfs = offset - limit; if (prevOfs >= 0) { rsp.append("<a href=\""); rsp.append(lBase); rsp.append("&offset="); rsp.append(prevOfs); rsp.append("\">prev</a>"); if (shouldHaveNext) rsp.append(" "); } if (shouldHaveNext) { rsp.append("<a href=\""); rsp.append(lBase); rsp.append("&offset="); rsp.append(offset + limit); rsp.append("\">next</a>"); } rsp.append("\n"); }
void failInvalidRequestFormat(Client r, boolean head) throws IOException { kisspopUI(r, head, "Invalid Request Format", "Some component of the request was wrong."); }
void kisspopUI(Client r, boolean head, String title, String text) throws IOException { kisspopUI(r, head, "200 OK", title, text); }
void kisspopUI(Client r, boolean head, String status, String title, String text) throws IOException { StringBuilder finale = new StringBuilder(); try (FileInputStream fis = new FileInputStream("kisspopui.html")) { InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8); while (true) { int ch = isr.read(); if (ch == -1) break; finale.append((char) ch); } } catch (Exception ex) { } String sts = finale.toString(); if (!sts.contains("$SHIT_GOES_HERE")) sts += "$PAGE_TITLE<hr/>$SHIT_GOES_HERE<hr/><i>Server Version:" + " $NATSUE_VERSION</i><hr/>kisspopui.html invalid or missing $SHIT_GOES_HERE"; sts = sts.replaceFirst( "\\$NATSUE_VERSION", "<a href=\"" + SystemCommands.VERSION_URL + "\">" + SystemCommands.VERSION + "</a>"); sts = sts.replaceAll("\\$PAGE_TITLE", title); sts = sts.replaceFirst("\\$SHIT_GOES_HERE", text); r.httpResponse(status, head, "text/html", sts); }
void writeCreatureReference( StringBuilder rsp, String src, HashMap<String, String> creatureNameCache) { String name = creatureNameCache.get(src); if (name == null) { NatsueDBCreatureInfo ci = database.getCreatureInfo(src); if ((ci != null) && (!ci.name.equals(""))) { int hasPfx = src.indexOf('-'); if (hasPfx == -1) { name = "?-" + ci.name; } else { name = src.substring(0, hasPfx + 1) + ci.name; } } else { name = src; } creatureNameCache.put(src, name); } rsp.append("<a href=\"creature?" + HTMLEncoder.hrefEncode(src) + "\">"); HTMLEncoder.htmlEncode(rsp, name); rsp.append("</a>"); }
void writeLifeStage(StringBuilder rsp, int lifeStage) { if (lifeStage == -1) { rsp.append("Egg"); } else if (lifeStage == 0) { rsp.append("Baby"); } else if (lifeStage == 1) { rsp.append("Child"); } else if (lifeStage == 2) { rsp.append("Adolescent"); } else if (lifeStage == 3) { rsp.append("Youth"); } else if (lifeStage == 4) { rsp.append("Adult"); } else if (lifeStage == 5) { rsp.append("Old"); } else if (lifeStage == 6) { rsp.append("Ancient"); } else if (lifeStage == 7) { rsp.append("Dead"); } else { rsp.append(lifeStage); } }
void writeTicks(StringBuilder rsp, int ageTicks) { int sec = ageTicks / 20; int min = sec / 60; sec %= 60; int hrs = min / 60; min %= 60; if (hrs > 0) { rsp.append(hrs); rsp.append("h"); } if (min > 0) { rsp.append(min); rsp.append("m"); } rsp.append(sec); rsp.append("s"); }
void userReference(StringBuilder rsp, long uin) { INatsueUserData nud = hub.getUserDataByUIN(uin); if (nud == null) { String ts = UINUtils.toString(uin); userReference(rsp, uin, ts, ts + "?"); } else { userReference(rsp, nud); } }
void userReference(StringBuilder rsp, INatsueUserData nud) { userReference(rsp, nud.getUIN(), nud.getNicknameFolded(), nud.getNickname()); }
void userReference(StringBuilder rsp, long uin, String nf, String nn) { rsp.append("<a href=\"user?" + HTMLEncoder.hrefEncode(nf) + "\">"); HTMLEncoder.htmlEncode(rsp, nn); rsp.append("</a>"); }
default void handleHTTP(String line, Client r) throws IOException { String[] parts = line.split(" "); if (parts.length < 2) { r.httpResponse("400 Bad Request", false, "< 2 request components"); return; } if (parts[0].equalsIgnoreCase("GET")) { handleHTTPGet(parts[1], false, r); } else if (parts[0].equalsIgnoreCase("HEAD")) { handleHTTPGet(parts[1], true, r); } else { r.httpResponse( "405 Method Not Allowed", false, "The method " + parts[0] + " was unrecognized."); return; } }
default void httpOk(boolean head, String contentType, String body) throws IOException { httpResponse("200 OK", head, contentType, body); }
default void httpOk(boolean head, String contentType, byte[] body) throws IOException { httpResponse("200 OK", head, contentType, body); }
default void httpResponse(String status, boolean head, String body) throws IOException { httpResponse(status, head, "text/plain", body.getBytes(StandardCharsets.UTF_8)); }
default void httpResponse(String status, boolean head, String contentType, String body) throws IOException { httpResponse(status, head, contentType, body.getBytes(StandardCharsets.UTF_8)); }
@Override public void handleHTTPGet(String url, boolean head, Client r) throws IOException { int qsIndex = url.indexOf('?'); HashMap<String, String> qv = new HashMap<>(); ; if (qsIndex != -1) { HTMLEncoder.qsToVars(qv, url.substring(qsIndex + 1)); url = url.substring(0, qsIndex); } boolean administrative = false; if (apiKey != null) { String otherKey = qv.get("apiKey"); if (otherKey != null) if (apiKey.equals(otherKey)) administrative = true; } boolean apiAllowed = administrative || apiPublic || r.isLocal(); if (pageSubhandler(url, qv, head, r)) { } else if (phoSubhandler(url, qv, head, r, administrative)) { } else if (apiAllowed && apiSubhandler(url, qv, head, r)) { } else { pages.kisspopUI(r, head, "404 Not Found", "No such file...", ""); } }
private boolean phoSubhandler( String url, HashMap<String, String> qv, boolean head, Client r, boolean administrative) throws IOException { if (url.equals("/creaturePhoto.png")) { if (!(photosPublic || administrative)) return false; String moniker = qv.get("moniker"); if (moniker == null) { r.httpResponse("404 Not Found", head, "requires moniker=..."); return true; } String index = qv.get("index"); if (index == null) { r.httpResponse("404 Not Found", head, "requires index=..."); return true; } byte[] data = photoStorage.getPhotoPNG(moniker, Integer.parseInt(index)); if (data == null) { r.httpResponse("404 Not Found", head, "no such photo"); return true; } r.httpResponse("200 OK", head, "image/png", data); return true; } return false; }
public static byte[][] fileIntoPEMBodies(File f) throws IOException { List<String> lines = Files.readAllLines(f.toPath()); StringBuilder dataBuilder = new StringBuilder(); LinkedList<byte[]> potential = new LinkedList<>(); for (String s : lines) { if (s.startsWith("-")) { String res = dataBuilder.toString(); if (!res.equals("")) potential.add(Base64.getDecoder().decode(res)); dataBuilder.setLength(0); } else { dataBuilder.append(s.trim()); } } return potential.toArray(new byte[0][]); }
public static byte[] fileIntoPEMBody(File f) throws IOException { byte[][] bodies = fileIntoPEMBodies(f); if (bodies.length != 1) throw new IOException( "PEM file " + f + " has an inappropriate count of PEM bodies (" + bodies.length + ") for target use-case, are you sure you didn't get fullchain and privkey" + " confused?"); return bodies[0]; }
public static Key loadPrivKey(File f, String algorithm) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException { byte[] privKey = fileIntoPEMBody(f); PKCS8EncodedKeySpec key = new PKCS8EncodedKeySpec(privKey); if (algorithm.equals("")) { String[] algorithmsToTry = {"RSA", "DiffieHellman", "DSA", "EC", "RSASSA-PSS"}; for (String alg : algorithmsToTry) { try { KeyFactory res = KeyFactory.getInstance(alg); return res.generatePrivate(key); } catch (Exception ex) { } } throw new NoSuchAlgorithmException( "Unable to guess algorithm. Specify manually via sslPrivKeyAlgorithm"); } KeyFactory res = KeyFactory.getInstance(algorithm); return res.generatePrivate(key); }
public static Certificate[] loadCertChain(File f) throws IOException, CertificateException { byte[][] bodies = fileIntoPEMBodies(f); CertificateFactory cf = CertificateFactory.getInstance("X.509"); Certificate[] certs = new Certificate[bodies.length]; for (int i = 0; i < bodies.length; i++) certs[i] = cf.generateCertificate(new ByteArrayInputStream(bodies[i])); return certs; }
@Override public void sendPacket(byte[] packet) throws IOException { synchronized (sendPacketLock) { socketOutput.write(packet); } }
@Override public boolean logFailedAuth() { return config.logFailedAuthentication.getValue(); }
@Override public boolean logPings() { return config.logPings.getValue(); }
@Override public void forceDisconnect(boolean sync) { try { socket.close(); } catch (Exception ex) { } if (sync) { if (Thread.currentThread() == this) { log( new Throwable( "NOT AN EXCEPTION, BUT DEFINITELY AN ERROR: SYNCHRONOUS CONNECTION SHOOTDOWN" + " TARGETTING CURRENT THREAD") .fillInStackTrace()); } else { try { join(); } catch (InterruptedException e) { throw new RuntimeException(e); } } } }
private void handleHTTPConnection(int firstByte) throws IOException { if (!config.httpRequestsEnabled.getValue()) return; byte[] request = HTTPRequest.readRequestHeader( socket, this, this, firstByte, config.httpRequestMaxLength.getValue(), config.httpRequestTime.getValue()); if (request != null) { String requestStr = new String(request, 0, request.length, StandardCharsets.UTF_8); int idx1 = requestStr.indexOf('\r'); String requestLine = requestStr.substring(0, idx1); try { initialHandler.handleHTTP(requestLine, this); } catch (Exception ex) { log(ex); StringWriter sb = new StringWriter(); PrintWriter pb = new PrintWriter(sb); ex.printStackTrace(pb); pb.flush(); httpResponse("500 Internal Server Error", false, sb.toString()); } } }
@Override public void httpResponse(String status, boolean head, String contentType, byte[] body) throws IOException { StringBuilder sb = new StringBuilder(); sb.append("HTTP/1.1 "); sb.append(status); sb.append("\r\nContent-Type: "); sb.append(contentType); sb.append("\r\nContent-Length: "); sb.append(body.length); sb.append("\r\nConnection: close\r\n\r\n"); socketOutput.write(sb.toString().getBytes(StandardCharsets.UTF_8)); if (!head) { socketOutput.write(body); } socketOutput.flush(); PacketReader.linger(socket, config.httpRequestFakeLingerTime.getAsClampedMs()); }
@Override public boolean isLocal() { return socket.getInetAddress().isLoopbackAddress(); }
@Override public void run() { while (true) { try { Thread.sleep(60000); } catch (InterruptedException e) { break; } minuteUpdate(); } }
private synchronized void minuteUpdate() { HashSet<InetAddress> remove = new HashSet<>(); for (Map.Entry<InetAddress, IPDetail> ina : informationAbout.entrySet()) { IPDetail ipd = ina.getValue(); ipd.connectionsLastMinute = ipd.connectionsThisMinute; ipd.connectionsThisMinute = 0; if (ipd.currentConnections == 0) if (ipd.connectionsLastMinute == 0) remove.add(ina.getKey()); } for (InetAddress ia : remove) informationAbout.remove(ia); }
public synchronized boolean socketStart(Socket skt) { InetAddress inetAddress = skt.getInetAddress(); if (config.quotaIgnoresLoopback.getValue() && inetAddress.isLoopbackAddress()) return true; IPDetail ipd = informationAbout.get(inetAddress); if (ipd == null) informationAbout.put(skt.getInetAddress(), ipd = new IPDetail()); if (ipd.connectionsThisMinute + ipd.connectionsLastMinute >= config.maxConnectionsInTwoMinutes.getValue()) return false; if (ipd.currentConnections >= config.maxConnectionsConcurrent.getValue()) return false; ipd.connectionsThisMinute++; ipd.currentConnections++; return true; }
public synchronized void socketEnd(Socket skt) { IPDetail ipd = informationAbout.get(skt.getInetAddress()); if (ipd != null) ipd.currentConnections--; }
public synchronized void runSystemCheck(StringBuilder sb, boolean detailed) { if (detailed) { sb.append("-- QuotaManager --\n"); for (Map.Entry<InetAddress, IPDetail> ipd : informationAbout.entrySet()) { sb.append(ipd.getKey().toString() + "\n"); sb.append(" currentConnections: " + ipd.getValue().currentConnections); sb.append(" connectionsThisMinute: " + ipd.getValue().connectionsThisMinute); sb.append(" connectionsLastMinute: " + ipd.getValue().connectionsLastMinute + "\n"); } } else { sb.append("QuotaManager:\n"); for (Map.Entry<InetAddress, IPDetail> ipd : informationAbout.entrySet()) { sb.append(ipd.getKey().toString()); sb.append("\n C"); sb.append(ipd.getValue().currentConnections); sb.append(" T"); sb.append(ipd.getValue().connectionsThisMinute); sb.append(" L"); sb.append(ipd.getValue().connectionsLastMinute); sb.append('\n'); } } }
@Override default INatsueUserData.LongTermPrivileged openUserDataByNicknameLT(String name) { return getUserDataCachePrivileged().openUserDataByNicknameLT(name); }
@Override default INatsueUserData.LongTermPrivileged openUserDataByUINLT(long uin) { return getUserDataCachePrivileged().openUserDataByUINLT(uin); }
@Override default INatsueUserData.LongTermPrivileged usernameAndPasswordLookup( String username, String password, boolean allowedToRegister) { return getUserDataCachePrivileged() .usernameAndPasswordLookup(username, password, allowedToRegister); }
default boolean unsetFlags(int flags) { return updateFlags(~flags, 0); }
@Override public LongTermPrivileged open(String site) { return this; }
@Override public byte[] calculate2FASecret(String password) { return null; }
@Override public boolean update2FA(long value) { return false; }
@Override public boolean updateFlags(int and, int xor) { return false; }
default boolean isAdmin() { return (getFlags() & FLAG_ADMINISTRATOR) != 0; }
default boolean isFrozen() { return (getFlags() & FLAG_FROZEN) != 0; }
default boolean isReceivingNBNorns() { return (getFlags() & FLAG_RECEIVE_NB_NORNS) != 0; }
default boolean isNoRandom() { return (getFlags() & FLAG_NO_RANDOM) != 0; }
default boolean isReceivingGeats() { return (getFlags() & FLAG_RECEIVE_GEATS) != 0; }
default boolean isMutedGlobalChat() { return (getFlags() & FLAG_MUTED_GLOBAL_CHAT) != 0; }
default boolean isUnlisted() { return (getFlags() & FLAG_UNLISTED) != 0; }
default boolean is2FAEnabled() { return (getFlags() & FLAG_2FA_ENABLED) != 0; }
public static String showFlags(int ofValue) { StringBuilder sb = new StringBuilder(); int p2 = 1; boolean first = true; for (int iteration = 0; iteration < 32; iteration++) { if ((ofValue & p2) != 0) { if (!first) sb.append(' '); first = false; Flag f = getFlagByPower(p2); if (f == null) { sb.append(Integer.toString(p2)); } else { sb.append(f.name().toUpperCase()); } } p2 <<= 1; } return sb.toString(); }
public BabelShortUserData convertToBabel() { return new BabelShortUserData("", "", nickname, UINUtils.ofRegularUser(uid)); }
@Override public void close() throws Exception { conn.close(); }
@Override public boolean logExpectedDBErrors() { return config.logExpectedDBErrors.getValue(); }
@Override public String fromResultSet(ResultSet rs) throws SQLException { return rs.getString(1); }
@Override public NatsueDBUserInfo fromResultSet(ResultSet rs) throws SQLException { return new NatsueDBUserInfo( rs.getInt(1), rs.getString(2), rs.getString(3), rs.getString(4), rs.getInt(5), rs.getLong(6), rs.getLong(7)); }
@Override public void toStatement(NatsueDBUserInfo userInfo, PreparedStatement s) throws SQLException { s.setInt(1, userInfo.uid); s.setString(2, userInfo.nickname); s.setString(3, userInfo.nicknameFolded); s.setString(4, userInfo.passwordHash); s.setInt(5, userInfo.flags); s.setLong(6, userInfo.creationUnixTime); s.setLong(7, userInfo.twoFactorSeed); }
@Override public NatsueDBCreatureEvent fromResultSet(ResultSet rs) throws SQLException { return new NatsueDBCreatureEvent( rs.getInt(1), rs.getString(2), rs.getInt(3), rs.getInt(4), rs.getInt(5), rs.getInt(6), rs.getInt(7), rs.getInt(8), rs.getString(9), rs.getString(10), rs.getString(11), rs.getString(12), rs.getString(13), rs.getLong(14)); }
default V fromResultSet(ResultSet rs) throws SQLException { throw new RuntimeException("NYI"); }
default void toStatement(V value, PreparedStatement s) throws SQLException { throw new RuntimeException("NYI"); }
public final V executeOuter(ILDBTxnHost base) { try (ILDBTxnHost.AcquiredConnection aConn = base.acquireConnection()) { return executeInner(aConn.getInstance()); } catch (Exception ex) { if (base.logExpectedDBErrors() || !failureExpected) base.getLogSource().log(ex); } return failureResult; }
@Override public LinkedList<V> fromResultSet(ResultSet rs) throws SQLException { LinkedList<V> res = new LinkedList<>(); res.add(base.fromResultSet(rs)); while (rs.next()) res.add(base.fromResultSet(rs)); return res; }
@Override protected void parameterize(PreparedStatement ps) throws SQLException { ps.setInt(1, uid); }
@Override protected void parameterize(PreparedStatement ps) throws SQLException { ps.setString(1, nicknameFolded); }
@Override protected byte[] executeInner(Connection conn) throws SQLException { try (PreparedStatement stmt = conn.prepareStatement("SELECT id, uid, data FROM natsue_spool WHERE uid=?")) { stmt.setInt(1, uid); try (ResultSet rs = stmt.executeQuery()) { if (rs.next()) { long id = rs.getLong(1); byte[] message = rs.getBytes(3); try (PreparedStatement stmt2 = conn.prepareStatement("DELETE FROM natsue_spool WHERE id=? and uid=?")) { stmt2.setLong(1, id); stmt2.setInt(2, uid); stmt2.executeUpdate(); return message; } } } } return null; }
@Override protected Boolean executeInner(Connection conn) throws SQLException { try (PreparedStatement stmt = conn.prepareStatement( "INSERT INTO natsue_spool(id, uid, data, cause_uid, send_unix_time) VALUES (?, ?, ?, ?," + " ?)")) { stmt.setLong(1, Snowflake.generateSnowflake()); stmt.setInt(2, uid); stmt.setBytes(3, data); stmt.setInt(4, causeUID); stmt.setLong(5, UnixTime.get()); stmt.executeUpdate(); return Boolean.TRUE; } }
@Override protected Boolean executeInner(Connection conn) throws SQLException { try (PreparedStatement stmt = conn.prepareStatement( "INSERT INTO natsue_history_creatures(" + "moniker, first_uid, ch0, ch1, ch2, ch3, ch4, name, user_text, send_unix_time" + ") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) { stmt.setString(1, moniker); stmt.setInt(2, firstUID); stmt.setInt(3, ch0); stmt.setInt(4, ch1); stmt.setInt(5, ch2); stmt.setInt(6, ch3); stmt.setInt(7, ch4); stmt.setString(8, name); stmt.setString(9, userText); stmt.setLong(10, UnixTime.get()); stmt.executeUpdate(); return Boolean.TRUE; } }
@Override protected void parameterize(PreparedStatement ps) throws SQLException { ps.setString(1, moniker); }
@Override protected Boolean executeInner(Connection conn) throws SQLException { try (PreparedStatement stmt = conn.prepareStatement( "INSERT INTO natsue_history_events(sender_uid, moniker, event_index, event_type," + " world_time, age_ticks, unix_time, life_stage, param1, param2, world_name," + " world_id, user_id, send_unix_time) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?," + " ?, ?)")) { stmt.setInt(1, senderUID); stmt.setString(2, moniker); stmt.setInt(3, eventIndex); stmt.setInt(4, eventType); stmt.setInt(5, worldTime); stmt.setInt(6, ageTicks); stmt.setInt(7, unixTime); stmt.setInt(8, lifeStage); stmt.setString(9, param1); stmt.setString(10, param2); stmt.setString(11, worldName); stmt.setString(12, worldID); stmt.setString(13, userID); stmt.setLong(14, UnixTime.get()); stmt.executeUpdate(); return Boolean.TRUE; } }
@Override protected void parameterize(PreparedStatement ps) throws SQLException { ps.setString(1, worldID); ps.setInt(2, limit); ps.setInt(3, offset); }
@Override protected void parameterize(PreparedStatement ps) throws SQLException { ps.setInt(1, uid); ps.setString(2, UINUtils.toString(UINUtils.ofRegularUser(uid))); ps.setInt(3, limit); ps.setInt(4, offset); }
@Override public NatsueDBWorldInfo fromResultSet(ResultSet rs) throws SQLException { return new NatsueDBWorldInfo( rs.getInt(2), rs.getString(1), rs.getString(3)); }
@Override protected void parameterize(PreparedStatement ps) throws SQLException { ps.setString(1, id); }
@Override public NatsueDBWorldInfo fromResultSet(ResultSet rs) throws SQLException { return new NatsueDBWorldInfo( rs.getInt(1), rs.getString(2), rs.getString(3)); }
@Override protected Boolean executeInner(Connection conn) throws SQLException { try (PreparedStatement stmt = conn.prepareStatement( "INSERT INTO natsue_users(" + UserInfoRSC.SELECTION + ") VALUES (" + UserInfoRSC.VALUES + ")")) { UserInfoRSC.INSTANCE.toStatement(userInfo, stmt); stmt.executeUpdate(); return Boolean.TRUE; } }
@Override protected Boolean executeInner(Connection conn) throws SQLException { try (PreparedStatement stmt = conn.prepareStatement( "UPDATE natsue_users SET psha256=?, flags=?, two_factor_seed=? WHERE uid=?")) { stmt.setString(1, passwordHash); stmt.setInt(2, flags); stmt.setLong(3, twoFactorSeed); stmt.setInt(4, uid); stmt.executeUpdate(); return Boolean.TRUE; } }
@Override public NatsueDBCreatureInfo fromResultSet(ResultSet rs) throws SQLException { return new NatsueDBCreatureInfo( rs.getString(1), rs.getInt(2), rs.getInt(3), rs.getInt(4), rs.getInt(5), rs.getInt(6), rs.getInt(7), rs.getString(8), rs.getString(9)); }
@Override public boolean spoolMessage(int uid, int causeUID, byte[] pm) { synchronized (this) { txns.storeOnSpool.uid = uid; txns.storeOnSpool.causeUID = causeUID; txns.storeOnSpool.data = pm; return txns.storeOnSpool.executeOuter(txnHost); } }
@Override public byte[] popFirstSpooledMessage(int uid) { synchronized (this) { txns.popFromSpool.uid = uid; return txns.popFromSpool.executeOuter(txnHost); } }
@Override public boolean ensureCreature( String moniker, int firstUID, int ch0, int ch1, int ch2, int ch3, int ch4, String name, String userText) { synchronized (this) { txns.addCreature.moniker = moniker; txns.addCreature.firstUID = firstUID; txns.addCreature.ch0 = ch0; txns.addCreature.ch1 = ch1; txns.addCreature.ch2 = ch2; txns.addCreature.ch3 = ch3; txns.addCreature.ch4 = ch4; txns.addCreature.name = name; txns.addCreature.userText = userText; return txns.addCreature.executeOuter(txnHost); } }
@Override public boolean updateCreatureText(int senderUID, String moniker, String name, String userText) { synchronized (this) { txns.updateCreatureText.senderUID = senderUID; txns.updateCreatureText.moniker = moniker; txns.updateCreatureText.name = name; txns.updateCreatureText.userText = userText; return txns.updateCreatureText.executeOuter(txnHost); } }
@Override public boolean ensureCreatureEvent( int senderUID, String moniker, int index, int type, int worldTime, int ageTicks, int unixTime, int lifeStage, String param1, String param2, String worldName, String worldID, String userID) { synchronized (this) { txns.addCreatureEvent.senderUID = senderUID; txns.addCreatureEvent.moniker = moniker; txns.addCreatureEvent.eventIndex = index; txns.addCreatureEvent.eventType = type; txns.addCreatureEvent.worldTime = worldTime; txns.addCreatureEvent.ageTicks = ageTicks; txns.addCreatureEvent.unixTime = unixTime; txns.addCreatureEvent.lifeStage = lifeStage; txns.addCreatureEvent.param1 = param1; txns.addCreatureEvent.param2 = param2; txns.addCreatureEvent.worldName = worldName; txns.addCreatureEvent.worldID = worldID; txns.addCreatureEvent.userID = userID; return txns.addCreatureEvent.executeOuter(txnHost); } }
@Override public boolean tryCreateUser(NatsueDBUserInfo userInfo) { synchronized (this) { txns.createUser.userInfo = userInfo; return txns.createUser.executeOuter(txnHost); } }
@Override public boolean updateUserAuth(int uid, String hash, int flags, long twoFA) { synchronized (this) { txns.updateUserAuth.uid = uid; txns.updateUserAuth.passwordHash = hash; txns.updateUserAuth.flags = flags; txns.updateUserAuth.twoFactorSeed = twoFA; return txns.updateUserAuth.executeOuter(txnHost); } }
@Override protected V executeInner(Connection conn) throws SQLException { try (PreparedStatement ps = conn.prepareStatement(sql)) { parameterize(ps); try (ResultSet rs = ps.executeQuery()) { if (!rs.next()) return failureResult; return resultSetConverter.fromResultSet(rs); } } }
@Override public void wwrNotify(boolean online, INatsueUserData userData) {}
private void hypercallError(long uin, String err) { err = "NATSUE HYPERCALL INTERFACE:\n" + err; hub.sendMessage(uin, StandardMessages.systemMessage(uin, err), MsgSendType.Temp, uin); }
@Override public boolean handleMessage( INatsueUserData sourceUser, INatsueUserData destUser, PackedMessage message) { if (message instanceof PackedMessagePRAY) { PackedMessagePRAY pray = (PackedMessagePRAY) message; if (CryoFunctions.expectedToContainACreature(pray.messageBlocks)) { String err = ExportedCreatures.checkWellFormedCreature(pray.messageBlocks); if (err != null) { hub.rejectMessage(destUser.getUIN(), message, err); return true; } err = CryoFunctions.receiptCompatibilityCheck(pray.messageBlocks, destUser); if (err != null) { hub.rejectMessage(destUser.getUIN(), message, err); return true; } } } return false; }
@Override public boolean handleMessage( INatsueUserData sourceUser, INatsueUserData destUser, PackedMessage message) { if (sourceUser.getUIN() == destUser.getUIN()) return false; if (message instanceof PackedMessageWrit) { PackedMessageWrit w = (PackedMessageWrit) message; if (level == NetWritLevel.blocked) { hub.rejectMessage(destUser, message, "NET: WRIT not allowed period"); return true; } if (w.channel.equals("system_message") || w.channel.equals("add_to_contact_book")) { hub.rejectMessage(destUser, message, "NET: WRIT on restricted channel"); return true; } if (level == NetWritLevel.vanillaSafe) { if (w.messageId < 1000) { hub.rejectMessage(destUser, message, "NET: WRIT with restricted message ID"); return true; } } else if (level == NetWritLevel.restrictive) { if (w.messageId != 2468) { hub.rejectMessage(destUser, message, "NET: WRIT with restricted message ID"); return true; } } } return false; }
@Override public boolean handleMessage( INatsueUserData sourceUser, INatsueUserData destUser, PackedMessage message) { if (message instanceof PackedMessagePRAY) { PackedMessagePRAY pray = (PackedMessagePRAY) message; for (PRAYBlock block : pray.messageBlocks) { String type = block.getType(); if (type.equals("MESG")) { hub.sendMessage(destUser, message, MsgSendType.Perm, sourceUser); return true; } else if (type.equals("warp")) { hub.sendMessage(destUser, message, MsgSendType.PermReturnIfOffline, sourceUser); return true; } } } return false; }
@Override public boolean handleMessage( INatsueUserData sourceUser, INatsueUserData destUser, PackedMessage message) { if (message instanceof PackedMessagePRAY) { PackedMessagePRAY pray = (PackedMessagePRAY) message; for (PRAYBlock block : pray.messageBlocks) { String type = block.getType(); if (obviouslyDangerousBlocks.contains(type)) { hub.rejectMessage(destUser, message, "Blatantly dangerous PRAY block type: " + type); return true; } if (restrictCustomBlocks && !knownBlocks.contains(type)) { hub.rejectMessage(destUser, message, "Custom PRAY block type: " + type); return true; } } } return false; }
@Override public boolean handleMessage( INatsueUserData sourceUser, INatsueUserData destUser, PackedMessage message) { hub.rejectMessage(destUser, message, "Rejecting everything"); return true; }
@Override public boolean handleMessage( INatsueUserData sourceUser, INatsueUserData destUser, PackedMessage message) { if (message instanceof PackedMessagePRAY) { PackedMessagePRAY pray = (PackedMessagePRAY) message; for (PRAYBlock block : pray.messageBlocks) { String type = block.getType(); if (type.equals("MESG")) { sanitizeMESG(sourceUser, block); } else if (type.equals("REQU")) { PRAYTags pt = new PRAYTags(PacketReader.CHARSET); pt.read(block.data); String chatID = pt.strMap.getOrDefault("ChatID", "?"); String reqType = pt.strMap.getOrDefault("Request Type", "?"); if (chatID.equals(SystemUserHubClient.CHATID_GLOBAL) && !reqType.equals("Accept")) { PackedMessage pm = StandardMessages.systemMessage( message.senderUIN, "You can't invite people to Global Chat."); hub.sendMessage(message.senderUIN, pm, MsgSendType.Temp, message.senderUIN); return true; } } } } return false; }
public void sanitizeMESG(INatsueUserData sourceUser, PRAYBlock mesgBlock) { PRAYTags pt = new PRAYTags(PacketReader.CHARSET); pt.read(mesgBlock.data); pt.strMap.put("Sender UserID", sourceUser.getUINString()); pt.strMap.put("Sender Nickname", sourceUser.getNickname()); mesgBlock.data = pt.toByteArray(); }
@Override public void rejectMessage(long destinationUIN, PackedMessage message, String reason) { if (message instanceof PackedMessagePRAY) { LinkedList<PRAYBlock> blocks = ((PackedMessagePRAY) message).messageBlocks; for (PRAYBlock blk : blocks) { String lastType = blk.getType(); if (lastType.equals("warp")) { rejectWarpedCreature(destinationUIN, message, reason, blk); return; } else if (lastType.equals("MESG")) { rejectMail(destinationUIN, message, reason, blk); return; } } } }
private void rejectWarpedCreature( long destinationUIN, PackedMessage message, String reason, PRAYBlock last) { PRAYTags pt = new PRAYTags(PacketReader.CHARSET); pt.read(last.data); pt.strMap.put("Last Network User", UINUtils.toString(destinationUIN)); pt.intMap.put("Pray Extra foe", 0); pt.intMap.put("Pray Extra reject", 4); last.data = pt.toByteArray(); sendInversion(destinationUIN, message); }
private void rejectMail( long destinationUIN, PackedMessage message, String reason, PRAYBlock last) { PRAYTags pt = new PRAYTags(PacketReader.CHARSET); pt.read(last.data); pt.strMap.put("Subject", "ERR: " + pt.strMap.get("Subject")); pt.strMap.put("Sender UserID", UINUtils.toString(onBehalfOf.getUIN())); pt.strMap.put("Sender Nickname", onBehalfOf.getNickname()); pt.strMap.put( "Message", "Unsendable to " + UINUtils.toString(destinationUIN) + " (" + reason + "), contents:\n" + pt.strMap.get("Message")); last.data = pt.toByteArray(); sendAsSystem(message); }
private void sendInversion(long destinationUIN, PackedMessage message) { long tmp = message.senderUIN; message.senderUIN = destinationUIN; hub.sendMessage(tmp, message, MsgSendType.PermReject, message.senderUIN); }
private void sendAsSystem(PackedMessage message) { long tmp = message.senderUIN; message.senderUIN = onBehalfOf.getUIN(); hub.sendMessage(tmp, message, MsgSendType.PermReject, message.senderUIN); }
public default void rejectMessage( INatsueUserData destUser, PackedMessage message, String reason) { rejectMessage(destUser.getUIN(), message, reason); }
default boolean incomingMessageByteArrayFastPath(byte[] message, Runnable reject) { return false; }
default void sendMessage( INatsueUserData destUser, PackedMessage message, MsgSendType type, INatsueUserData causeUser) { sendMessage(destUser.getUIN(), message, type, causeUser.getUIN()); }
public static boolean expectedToContainACreature(Iterable<PRAYBlock> inp) { for (PRAYBlock pb : inp) { String t = pb.getType(); if (t.equals("warp") || t.equals("DSEX")) return true; if (t.equals("GENE") || t.equals("PHOT") || t.equals("CREA") || t.equals("GLST")) return true; } return false; }
public static void cryoUpdateRootStorage(PRAYBlock inp, long fromUIN) { PRAYTags pt = new PRAYTags(PacketReader.CHARSET); pt.read(inp.data); pt.strMap.put("Pray Extra natsueCryoSubmitter", UINUtils.toString(fromUIN)); pt.intMap.put("Pray Extra natsueCryoSubmitTime", (int) UnixTime.get()); pt.intMap.put("Pray Extra natsueCryoSubmitTimeH", (int) (UnixTime.get() >> 32)); inp.data = pt.toByteArray(); }
public static void cryoUpdateRootRetrieval(PRAYBlock inp, long fromUIN) { PRAYTags pt = new PRAYTags(PacketReader.CHARSET); pt.read(inp.data); pt.strMap.remove("Pray Extra natsueCryoSubmitter"); pt.intMap.remove("Pray Extra natsueCryoSubmitTime"); pt.intMap.remove("Pray Extra natsueCryoSubmitTimeH"); inp.data = pt.toByteArray(); }
public static String receiptCompatibilityCheck( LinkedList<PRAYBlock> messageBlocks, INatsueUserData destUser) { PRAYBlock block = ExportedCreatures.findCreatureRootBlock(messageBlocks); PRAYTags pt = new PRAYTags(PacketReader.CHARSET); pt.read(block.data); int reC = pt.intMap.get("Gender"); int reG = pt.intMap.get("Genus"); boolean isNB = reC != 1 && reC != 2; boolean isGeat = reG == 4; if (isGeat && !destUser.isReceivingGeats()) { return "Geat that target couldn't receive"; } else if (isNB && !destUser.isReceivingNBNorns()) { return "NB norn that target couldn't receive"; } return null; }
public void setVmd(MmdVmdMotion_BasicClass i_vmd_model) throws MmdException { super.setVmd(i_vmd_model); }
private static FloatBuffer makeFloatBuffer(int i_size) { ByteBuffer bb = ByteBuffer.allocateDirect(i_size * 4); bb.order(ByteOrder.nativeOrder()); FloatBuffer fb = bb.asFloatBuffer(); return fb; }
public int compare(PmdIK o1, PmdIK o2) { return (int) (o1.getSortVal() - o2.getSortVal()); }
private static InputStream getStream(ResourceLocation loc) throws IOException { return new BufferedInputStream(Minecraft.getInstance().getResourceManager().open(loc)); }
public static void notImplement() throws MmdException { throw new MmdException("Not Implement!"); }
public int compare(BoneKeyFrame o1, BoneKeyFrame o2) { return (int) (o1.fFrameNo - o2.fFrameNo); }
public int compare(FaceKeyFrame o1, FaceKeyFrame o2) { return (int) (o1.fFrameNo - o2.fFrameNo); }
public MotionData[] refMotionDataArray() { return this._motion_data_array; }
public FaceData[] refFaceDataArray() { return this._face_data_array; }
public void lookMeEnable(boolean i_enable) { this._lookme_enabled = i_enable; }
private void updateNeckBone() { if (this.m_pNeckBone == null) { return; } this.m_pNeckBone.lookAt(this._looktarget); PmdBone[] bone_array = this._ref_pmd_model.getBoneArray(); int i; for (i = 0; i < bone_array.length; i++) { if (this.m_pNeckBone == bone_array[i]) { break; } } for (; i < bone_array.length; i++) { bone_array[i].updateMatrix(); } return; }
private void updateFace(float i_frame) throws MmdException { final MmdVector3[] position_array = this._ref_pmd_model.getPositionArray(); PmdFace[] ppFace = this.m_ppFaceList; FaceData[] pFaceDataList = _ref_vmd_motion.refFaceDataArray(); for (int i = 0; i < pFaceDataList.length; i++) { final float fFaceRate = getFaceRate(pFaceDataList[i], i_frame); if (ppFace[i] == null) { continue; } if (fFaceRate == 1.0f) { ppFace[i].setFace(position_array); } else if (0.001f < fFaceRate) { ppFace[i].blendFace(position_array, fFaceRate); } } return; }
public ResourceLocation getTextureStream(String i_name) throws MmdException { try { return new ResourceLocation(i_name); } catch (Exception e) { throw new MmdException(e); } }
public void recalcOffset() { if (this._parent_bone != null) { m_vec3Offset.Vector3Sub(this._pmd_bone_position, this._parent_bone._pmd_bone_position); } return; }
public void reset() { m_vec3Position.x = m_vec3Position.y = m_vec3Position.z = 0.0f; m_vec4Rotate.x = m_vec4Rotate.y = m_vec4Rotate.z = 0.0f; m_vec4Rotate.w = 1.0f; this.m_matLocal.identity(); this.m_matLocal.m30 = _pmd_bone_position.x; this.m_matLocal.m31 = _pmd_bone_position.y; this.m_matLocal.m32 = _pmd_bone_position.z; }
public void updateSkinningMat(MmdMatrix o_matrix) { o_matrix.mul(this.m_matInvTransform, this.m_matLocal); return; }
public void setFace(MmdVector3[] pvec3Vertices) throws MmdException { if (this._face_vertex == null) { throw new MmdException(); } final PMD_FACE_VTX[] vertex_array = this._face_vertex; for (int i = vertex_array.length - 1; i >= 0; i--) { final PMD_FACE_VTX vertex = vertex_array[i]; pvec3Vertices[vertex.ulIndex].setValue(vertex.vec3Pos); } return; }
public void blendFace(MmdVector3[] pvec3Vertices, float fRate) throws MmdException { if (this._face_vertex == null) { throw new MmdException(); } PMD_FACE_VTX[] vertex_array = this._face_vertex; for (int i = vertex_array.length - 1; i >= 0; i--) { final PMD_FACE_VTX vertex = vertex_array[i]; MmdVector3 vec = pvec3Vertices[vertex.ulIndex]; vec.Vector3Lerp(vec, vertex.vec3Pos, fRate); } return; }
public static void read(MmdColor4 i_dest, DataReader i_reader) throws MmdException { i_dest.r = i_reader.readFloat(); i_dest.g = i_reader.readFloat(); i_dest.b = i_reader.readFloat(); i_dest.a = i_reader.readFloat(); return; }
public static void read(MmdColor3 i_dest, DataReader i_reader) throws MmdException { i_dest.r = i_reader.readFloat(); i_dest.g = i_reader.readFloat(); i_dest.b = i_reader.readFloat(); return; }
public static void read(MmdTexUV i_dest, DataReader i_reader) throws MmdException { i_dest.u = i_reader.readFloat(); i_dest.v = i_reader.readFloat(); return; }
public static void read(MmdVector3 i_dest, DataReader i_reader) throws MmdException { i_dest.x = i_reader.readFloat(); i_dest.y = i_reader.readFloat(); i_dest.z = i_reader.readFloat(); return; }
public static void read(MmdVector4 i_dest, DataReader i_reader) throws MmdException { i_dest.x = i_reader.readFloat(); i_dest.y = i_reader.readFloat(); i_dest.z = i_reader.readFloat(); i_dest.w = i_reader.readFloat(); return; }
public short readShort() { return this._buf.getShort(); }
public float readFloat() { return this._buf.getFloat(); }
public double readDouble() { return this._buf.getDouble(); }
public String readAscii(int i_length) throws MmdException { try { String ret = ""; int len = 0; byte[] tmp = new byte[i_length]; int i; for (i = 0; i < i_length; i++) { byte b = this._buf.get(); if (b == 0x00) { i++; break; } tmp[i] = b; len++; } ret = new String(tmp, 0, len, "Shift_JIS"); for (; i < i_length; i++) { this._buf.get(); } return ret; } catch (Exception e) { throw new MmdException(); } }
public void read(DataReader i_reader) throws MmdException { this.szName = i_reader.readAscii(20); this.nParentNo = i_reader.readShort(); this.nChildNo = i_reader.readShort(); this.cbKind = i_reader.readByte(); this.unIKTarget = i_reader.readShort(); StructReader.read(this.vec3Position, i_reader); return; }
public void read(DataReader i_reader) throws MmdException { StructReader.read(this.vec3Pos, i_reader); StructReader.read(this.vec3Normal, i_reader); StructReader.read(this.uvTex, i_reader); this.unBoneNo[0] = i_reader.readUnsignedShort(); this.unBoneNo[1] = i_reader.readUnsignedShort(); this.cbWeight = i_reader.read(); this.cbEdge = i_reader.read(); return; }
public void read(DataReader i_reader) throws MmdException { StructReader.read(this.col4Diffuse, i_reader); this.fShininess = i_reader.readFloat(); StructReader.read(this.col3Specular, i_reader); StructReader.read(this.col3Ambient, i_reader); this.unknown = i_reader.readUnsignedShort(); this.ulNumIndices = i_reader.readInt(); this.szTextureFileName = i_reader.readAscii(20); return; }
public void read(DataReader i_reader) throws MmdException { this.szMagic = i_reader.readAscii(3); this.fVersion = i_reader.readFloat(); this.szName = i_reader.readAscii(20); this.szComment = i_reader.readAscii(256); return; }
public void read(DataReader i_reader) throws MmdException { this.ulIndex = i_reader.readInt(); StructReader.read(this.vec3Pos, i_reader); return; }
public static PMD_FACE_VTX[] createArray(int i_length) { PMD_FACE_VTX[] ret = new PMD_FACE_VTX[i_length]; for (int i = 0; i < i_length; i++) { ret[i] = new PMD_FACE_VTX(); } return ret; }
public void read(DataReader i_reader) throws MmdException { this.szHeader = i_reader.readAscii(30); this.szModelName = i_reader.readAscii(20); return; }
public void read(DataReader i_reader) throws MmdException { int i; this.szBoneName = i_reader.readAscii(15); this.ulFrameNo = i_reader.readInt(); StructReader.read(this.vec3Position, i_reader); StructReader.read(this.vec4Rotate, i_reader); for (i = 0; i < 16; i++) { this.cInterpolation1[i] = i_reader.readByte(); } for (i = 0; i < 16; i++) { this.cInterpolation2[i] = i_reader.readByte(); } for (i = 0; i < 16; i++) { this.cInterpolation3[i] = i_reader.readByte(); } for (i = 0; i < 16; i++) { this.cInterpolation4[i] = i_reader.readByte(); } return; }
public void read(DataReader i_reader) throws MmdException { this.szFaceName = i_reader.readAscii(15); this.ulFrameNo = i_reader.readInt(); this.fFactor = i_reader.readFloat(); return; }
public static FaceKeyFrame[] createArray(int i_length) { FaceKeyFrame[] ret = new FaceKeyFrame[i_length]; for (int i = 0; i < i_length; i++) { ret[i] = new FaceKeyFrame(); } return ret; }
public static BoneKeyFrame[] createArray(int i_length) { BoneKeyFrame[] ret = new BoneKeyFrame[i_length]; for (int i = 0; i < i_length; i++) { ret[i] = new BoneKeyFrame(); } return ret; }
public static MmdMatrix[] createArray(int i_number) { MmdMatrix[] ret = new MmdMatrix[i_number]; for (int i = 0; i < i_number; i++) { ret[i] = new MmdMatrix(); } return ret; }
public final void identity() { this.m00 = this.m11 = this.m22 = this.m33 = 1; this.m01 = this.m02 = this.m03 = this.m10 = this.m12 = this.m13 = this.m20 = this.m21 = this.m23 = this.m30 = this.m31 = this.m32 = 0; return; }
public void MatrixLerp(MmdMatrix sm1, MmdMatrix sm2, float fLerpValue) { double fT = 1.0 - fLerpValue; this.m00 = sm1.m00 * fLerpValue + sm2.m00 * fT; this.m01 = sm1.m01 * fLerpValue + sm2.m01 * fT; this.m02 = sm1.m02 * fLerpValue + sm2.m02 * fT; this.m03 = sm1.m03 * fLerpValue + sm2.m03 * fT; this.m10 = sm1.m10 * fLerpValue + sm2.m10 * fT; this.m11 = sm1.m11 * fLerpValue + sm2.m11 * fT; this.m12 = sm1.m12 * fLerpValue + sm2.m12 * fT; this.m13 = sm1.m13 * fLerpValue + sm2.m13 * fT; this.m20 = sm1.m20 * fLerpValue + sm2.m20 * fT; this.m21 = sm1.m21 * fLerpValue + sm2.m21 * fT; this.m22 = sm1.m22 * fLerpValue + sm2.m22 * fT; this.m23 = sm1.m23 * fLerpValue + sm2.m23 * fT; this.m30 = sm1.m30 * fLerpValue + sm2.m30 * fT; this.m31 = sm1.m31 * fLerpValue + sm2.m31 * fT; this.m32 = sm1.m32 * fLerpValue + sm2.m32 * fT; this.m33 = sm1.m33 * fLerpValue + sm2.m33 * fT; return; }
public void QuaternionToMatrix(MmdVector4 pvec4Quat) { double x2 = pvec4Quat.x * pvec4Quat.x * 2.0f; double y2 = pvec4Quat.y * pvec4Quat.y * 2.0f; double z2 = pvec4Quat.z * pvec4Quat.z * 2.0f; double xy = pvec4Quat.x * pvec4Quat.y * 2.0f; double yz = pvec4Quat.y * pvec4Quat.z * 2.0f; double zx = pvec4Quat.z * pvec4Quat.x * 2.0f; double xw = pvec4Quat.x * pvec4Quat.w * 2.0f; double yw = pvec4Quat.y * pvec4Quat.w * 2.0f; double zw = pvec4Quat.z * pvec4Quat.w * 2.0f; this.m00 = 1.0f - y2 - z2; this.m01 = xy + zw; this.m02 = zx - yw; this.m10 = xy - zw; this.m11 = 1.0f - z2 - x2; this.m12 = yz + xw; this.m20 = zx + yw; this.m21 = yz - xw; this.m22 = 1.0f - x2 - y2; this.m03 = this.m13 = this.m23 = this.m30 = this.m31 = this.m32 = 0.0f; this.m33 = 1.0f; return; }
public void QuaternionSlerp(MmdVector4 pvec4Src1, MmdVector4 pvec4Src2, double fLerpValue) { double qr = pvec4Src1.x * pvec4Src2.x + pvec4Src1.y * pvec4Src2.y + pvec4Src1.z * pvec4Src2.z + pvec4Src1.w * pvec4Src2.w; double t0 = 1.0f - fLerpValue; if (qr < 0) { this.x = pvec4Src1.x * t0 - pvec4Src2.x * fLerpValue; this.y = pvec4Src1.y * t0 - pvec4Src2.y * fLerpValue; this.z = pvec4Src1.z * t0 - pvec4Src2.z * fLerpValue; this.w = pvec4Src1.w * t0 - pvec4Src2.w * fLerpValue; } else { this.x = pvec4Src1.x * t0 + pvec4Src2.x * fLerpValue; this.y = pvec4Src1.y * t0 + pvec4Src2.y * fLerpValue; this.z = pvec4Src1.z * t0 + pvec4Src2.z * fLerpValue; this.w = pvec4Src1.w * t0 + pvec4Src2.w * fLerpValue; } QuaternionNormalize(this); return; }
public void QuaternionNormalize(MmdVector4 pvec4Src) { final double fSqr = 1.0 / Math.sqrt( (pvec4Src.x * pvec4Src.x + pvec4Src.y * pvec4Src.y + pvec4Src.z * pvec4Src.z + pvec4Src.w * pvec4Src.w)); this.x = (pvec4Src.x * fSqr); this.y = (pvec4Src.y * fSqr); this.z = (pvec4Src.z * fSqr); this.w = (pvec4Src.w * fSqr); }
public void QuaternionCreateAxis(MmdVector3 pvec3Axis, double fRotAngle) { if (Math.abs(fRotAngle) < 0.0001f) { this.x = this.y = this.z = 0.0f; this.w = 1.0f; } else { fRotAngle *= 0.5f; double fTemp = Math.sin(fRotAngle); this.x = pvec3Axis.x * fTemp; this.y = pvec3Axis.y * fTemp; this.z = pvec3Axis.z * fTemp; this.w = Math.cos(fRotAngle); } return; }
public void QuaternionMultiply(MmdVector4 pvec4Src1, MmdVector4 pvec4Src2) { double px, py, pz, pw; double qx, qy, qz, qw; px = pvec4Src1.x; py = pvec4Src1.y; pz = pvec4Src1.z; pw = pvec4Src1.w; qx = pvec4Src2.x; qy = pvec4Src2.y; qz = pvec4Src2.z; qw = pvec4Src2.w; this.x = pw * qx + px * qw + py * qz - pz * qy; this.y = pw * qy - px * qz + py * qw + pz * qx; this.z = pw * qz + px * qy - py * qx + pz * qw; this.w = pw * qw - px * qx - py * qy - pz * qz; }
public void QuaternionCreateEuler(MmdVector3 pvec3EulerAngle) { final double xRadian = pvec3EulerAngle.x * 0.5; final double yRadian = pvec3EulerAngle.y * 0.5; final double zRadian = pvec3EulerAngle.z * 0.5; final double sinX = Math.sin(xRadian); final double cosX = Math.cos(xRadian); final double sinY = Math.sin(yRadian); final double cosY = Math.cos(yRadian); final double sinZ = Math.sin(zRadian); final double cosZ = Math.cos(zRadian); this.x = sinX * cosY * cosZ - cosX * sinY * sinZ; this.y = cosX * sinY * cosZ + sinX * cosY * sinZ; this.z = cosX * cosY * sinZ - sinX * sinY * cosZ; this.w = cosX * cosY * cosZ + sinX * sinY * sinZ; }
public static MmdTexUV[] createArray(int i_length) { MmdTexUV[] ret = new MmdTexUV[i_length]; for (int i = 0; i < i_length; i++) { ret[i] = new MmdTexUV(); } return ret; }
public static MmdVector3[] createArray(int i_length) { MmdVector3[] ret = new MmdVector3[i_length]; for (int i = 0; i < i_length; i++) { ret[i] = new MmdVector3(); } return ret; }
public void Vector3Add(MmdVector3 pvec3Add1, MmdVector3 pvec3Add2) { this.x = pvec3Add1.x + pvec3Add2.x; this.y = pvec3Add1.y + pvec3Add2.y; this.z = pvec3Add1.z + pvec3Add2.z; return; }
public void Vector3Sub(MmdVector3 pvec3Sub1, MmdVector3 pvec3Sub2) { this.x = pvec3Sub1.x - pvec3Sub2.x; this.y = pvec3Sub1.y - pvec3Sub2.y; this.z = pvec3Sub1.z - pvec3Sub2.z; return; }
public void Vector3MulAdd(MmdVector3 pvec3Add1, MmdVector3 pvec3Add2, float fRate) { this.x = pvec3Add1.x + pvec3Add2.x * fRate; this.y = pvec3Add1.y + pvec3Add2.y * fRate; this.z = pvec3Add1.z + pvec3Add2.z * fRate; }
public void Vector3Normalize(MmdVector3 pvec3Src) { double fSqr = (1.0f / Math.sqrt( pvec3Src.x * pvec3Src.x + pvec3Src.y * pvec3Src.y + pvec3Src.z * pvec3Src.z)); this.x = (float) (pvec3Src.x * fSqr); this.y = (float) (pvec3Src.y * fSqr); this.z = (float) (pvec3Src.z * fSqr); return; }
public double Vector3DotProduct(MmdVector3 pvec3Src2) { return (this.x * pvec3Src2.x + this.y * pvec3Src2.y + this.z * pvec3Src2.z); }
public void Vector3CrossProduct(MmdVector3 pvec3Src1, MmdVector3 pvec3Src2) { final float vx1 = pvec3Src1.x; final float vy1 = pvec3Src1.y; final float vz1 = pvec3Src1.z; final float vx2 = pvec3Src2.x; final float vy2 = pvec3Src2.y; final float vz2 = pvec3Src2.z; this.x = vy1 * vz2 - vz1 * vy2; this.y = vz1 * vx2 - vx1 * vz2; this.z = vx1 * vy2 - vy1 * vx2; }
public void Vector3Lerp(MmdVector3 pvec3Src1, MmdVector3 pvec3Src2, float fLerpValue) { float t0 = 1.0f - fLerpValue; this.x = pvec3Src1.x * t0 + pvec3Src2.x * fLerpValue; this.y = pvec3Src1.y * t0 + pvec3Src2.y * fLerpValue; this.z = pvec3Src1.z * t0 + pvec3Src2.z * fLerpValue; return; }
public void Vector3Transform(MmdVector3 pVec3In, MmdMatrix matTransform) { final double vx = pVec3In.x; final double vy = pVec3In.y; final double vz = pVec3In.z; this.x = (float) (vx * matTransform.m00 + vy * matTransform.m10 + vz * matTransform.m20 + matTransform.m30); this.y = (float) (vx * matTransform.m01 + vy * matTransform.m11 + vz * matTransform.m21 + matTransform.m31); this.z = (float) (vx * matTransform.m02 + vy * matTransform.m12 + vz * matTransform.m22 + matTransform.m32); return; }
public void Vector3Transform(MmdMatrix i_posmat, MmdMatrix matTransform) { final double vx = i_posmat.m30; final double vy = i_posmat.m31; final double vz = i_posmat.m32; this.x = (float) (vx * matTransform.m00 + vy * matTransform.m10 + vz * matTransform.m20 + matTransform.m30); this.y = (float) (vx * matTransform.m01 + vy * matTransform.m11 + vz * matTransform.m21 + matTransform.m31); this.z = (float) (vx * matTransform.m02 + vy * matTransform.m12 + vz * matTransform.m22 + matTransform.m32); return; }
public void Vector3Rotate(MmdVector3 pVec3In, MmdMatrix matRotate) { final double vx = pVec3In.x; final double vy = pVec3In.y; final double vz = pVec3In.z; this.x = (float) (vx * matRotate.m00 + vy * matRotate.m10 + vz * matRotate.m20); this.y = (float) (vx * matRotate.m01 + vy * matRotate.m11 + vz * matRotate.m21); this.z = (float) (vx * matRotate.m02 + vy * matRotate.m12 + vz * matRotate.m22); return; }
public static ResourceLocation prefix(String path) { return new ResourceLocation(SlashBlade.MODID, path); }
private void setup(final FMLCommonSetupEvent event) { MinecraftForge.EVENT_BUS.addListener(KnockBackHandler::onLivingKnockBack); FallHandler.getInstance().register(); LockOnManager.getInstance().register(); Guard.getInstance().register(); MinecraftForge.EVENT_BUS.register(new CapabilityAttachHandler()); MinecraftForge.EVENT_BUS.register(new StunManager()); RefineHandler.getInstance().register(); KillCounter.getInstance().register(); RankPointHandler.getInstance().register(); AllowFlightOverrwrite.getInstance().register(); BlockPickCanceller.getInstance().register(); BladeMotionEventBroadcaster.getInstance().register(); MinecraftForge.EVENT_BUS.addListener(TargetSelector::onInputChange); SummonedSwordArts.getInstance().register(); SlayerStyleArts.getInstance().register(); Untouchable.getInstance().register(); EnemyStep.getInstance().register(); KickJump.getInstance().register(); SuperSlashArts.getInstance().register(); ComboCommands.initDefaultStandByCommands(); }
@Override public boolean onEntityItemUpdate(ItemStack stack, ItemEntity entity) { if (entity instanceof BladeItemEntity) return false; CompoundTag tag = entity.serializeNBT(); tag.putInt("Health", 50); entity.deserializeNBT(tag); if (entity.isCurrentlyGlowing()) { entity.setDeltaMovement( entity.getDeltaMovement().multiply(0.8, 0.0, 0.8).add(0.0D, +0.04D, 0.0D)); } else if (entity.isOnFire()) { entity.setDeltaMovement( entity.getDeltaMovement().multiply(0.8, 0.5, 0.8).add(0.0D, +0.04D, 0.0D)); } return false; }
@Override public boolean isFoil(ItemStack stack) { return true; }
private static String classToString(Class<? extends Entity> entityClass) { return CaseFormat.UPPER_CAMEL .to(CaseFormat.LOWER_UNDERSCORE, entityClass.getSimpleName()) .replace("entity_", ""); }
@SubscribeEvent public static void onRegisterRenderers(final EntityRenderersEvent.RegisterRenderers event) { event.registerEntityRenderer(RegistryEvents.SummonedSword, SummonedSwordRenderer::new); event.registerEntityRenderer(RegistryEvents.StormSwords, SummonedSwordRenderer::new); event.registerEntityRenderer(RegistryEvents.SpiralSwords, SummonedSwordRenderer::new); event.registerEntityRenderer(RegistryEvents.BlisteringSwords, SummonedSwordRenderer::new); event.registerEntityRenderer(RegistryEvents.HeavyRainSwords, SummonedSwordRenderer::new); event.registerEntityRenderer(RegistryEvents.JudgementCut, JudgementCutRenderer::new); event.registerEntityRenderer(RegistryEvents.BladeItem, BladeItemEntityRenderer::new); event.registerEntityRenderer(RegistryEvents.BladeStand, BladeStandEntityRenderer::new); event.registerEntityRenderer(RegistryEvents.SlashEffect, SlashEffectRenderer::new); event.registerEntityRenderer(RegistryEvents.Drive, DriveRenderer::new); }
@SubscribeEvent public static void onRegisterCapability(final RegisterCapabilitiesEvent event) { CapabilitySlashBlade.register(event); CapabilityMobEffect.register(event); CapabilityInputState.register(event); CapabilityConcentrationRank.register(event); }
private static ResourceLocation registerCustomStat(String name) { ResourceLocation resourcelocation = new ResourceLocation(MODID, name); Registry.register(BuiltInRegistries.CUSTOM_STAT, name, resourcelocation); Stats.CUSTOM.get(resourcelocation, StatFormatter.DEFAULT); return resourcelocation; }
public static HolderLookup.RegistryLookup<SlashBladeDefinition> getSlashBladeDefinitionRegistry( HolderLookup.Provider access) { return access.lookupOrThrow(SlashBladeDefinition.REGISTRY_KEY); }
private static void fillBlades( CreativeModeTab.ItemDisplayParameters features, CreativeModeTab.Output output) { SlashBlade.getSlashBladeDefinitionRegistry(features.holders()) .listElements() .sorted(SlashBladeDefinition.COMPARATOR) .forEach( entry -> { output.accept(entry.value().getBlade()); }); }
private static void fillSASpheres(CreativeModeTab.Output output) { SlashArtsRegistry.REGISTRY .get() .forEach( slashArts -> { ResourceLocation key = SlashArtsRegistry.REGISTRY.get().getKey(slashArts); if (slashArts.equals(SlashArtsRegistry.NONE.get()) || key == null) return; ItemStack sphere = new ItemStack(SBItems.proudsoul_sphere); CompoundTag tag = new CompoundTag(); tag.putString("SpecialAttackType", key.toString()); sphere.setTag(tag); output.accept(sphere); }); }
public void register() { MinecraftForge.EVENT_BUS.register(this); }
@SubscribeEvent public static void onMobSpawn(MobSpawnEvent.FinalizeSpawn event) { LivingEntity entity = event.getEntity(); boolean isZombie = isZombie(entity); if (!isZombie) return; if (!entity.getItemBySlot(EquipmentSlot.MAINHAND).isEmpty()) return; RandomSource random = event.getLevel().getRandom(); float difficultyMultiplier = event.getDifficulty().getSpecialMultiplier(); Registry<SlashBladeDefinition> bladeRegistry = SlashBlade.getSlashBladeDefinitionRegistry(event.getEntity().level()); if (!bladeRegistry.containsKey(SlashBladeBuiltInRegistry.SABIGATANA.location())) return; float rngResult = random.nextFloat(); if (rngResult < SlashBladeConfig.BROKEN_SABIGATANA_SPAWN_CHANCE.get() * difficultyMultiplier) { if (rngResult < SlashBladeConfig.SABIGATANA_SPAWN_CHANCE.get() * difficultyMultiplier) { entity.setItemSlot( EquipmentSlot.MAINHAND, bladeRegistry.get(SlashBladeBuiltInRegistry.SABIGATANA.location()).getBlade()); } else { entity.setItemSlot( EquipmentSlot.MAINHAND, bladeRegistry.get(SlashBladeBuiltInRegistry.SABIGATANA_BROKEN.location()).getBlade()); } } }
private static boolean isZombie(LivingEntity entity) { return entity instanceof Zombie && !(entity instanceof Drowned) && !(entity instanceof ZombifiedPiglin); }
public static boolean checkFlag(int data, int flags) { return (data & flags) == flags; }
@SubscribeEvent public void onFMLServerAboutToStartEvent(ServerAboutToStartEvent event) { event.getServer().setFlightAllowed(true); }
public static void setFactor( LivingEntity target, double horizontalFactor, double verticalFactor, double addFallDistance) { NBTHelper.putVector3d( target.getPersistentData(), NBT_KEY, new Vec3(horizontalFactor, verticalFactor, addFallDistance)); }
@SubscribeEvent public static void onLivingKnockBack(LivingKnockBackEvent event) { LivingEntity target = event.getEntity(); CompoundTag nbt = target.getPersistentData(); if (!nbt.contains(NBT_KEY)) return; Vec3 factor = NBTHelper.getVector3d(nbt, NBT_KEY); nbt.remove(NBT_KEY); if (target.fallDistance < 0) target.fallDistance = 0; target.fallDistance += factor.z; if ((target.getRandom().nextDouble() < target.getAttribute(Attributes.KNOCKBACK_RESISTANCE).getValue())) return; target.hasImpulse = true; Vec3 motion = target.getDeltaMovement(); if (factor.x == 0) { event.setCanceled(true); motion = motion.multiply(0, 1, 0); } else event.setStrength((float) (event.getStrength() * factor.x)); if (0 < factor.y) { target.setOnGround(false); event.getEntity().setDeltaMovement(motion.x, Math.max(motion.y, factor.y), motion.z); } else if (factor.y < 0) { event.getEntity().setDeltaMovement(motion.x, Math.min(motion.y, factor.y), motion.z); } }
@SubscribeEvent(priority = EventPriority.LOWEST) public void onLivingDeathEvent(LivingDeathEvent event) { Entity trueSource = event.getSource().getEntity(); if (!(trueSource instanceof LivingEntity)) return; ItemStack stack = ((LivingEntity) trueSource).getMainHandItem(); if (stack.isEmpty()) return; if (!(stack.getItem() instanceof ItemSlashBlade)) return; stack .getCapability(ItemSlashBlade.BLADESTATE) .ifPresent( state -> { state.setKillCount(state.getKillCount() + 1); }); }
@SubscribeEvent(priority = EventPriority.LOWEST) public void onXPDropping(LivingExperienceDropEvent event) { Player player = event.getAttackingPlayer(); if (player == null) return; ItemStack stack = player.getMainHandItem(); if (stack.isEmpty()) return; if (!(stack.getItem() instanceof ItemSlashBlade)) return; IConcentrationRank.ConcentrationRanks rankBonus = player .getCapability(ConcentrationRankCapabilityProvider.RANK_POINT) .map(rp -> rp.getRank(player.getCommandSenderWorld().getGameTime())) .orElse(IConcentrationRank.ConcentrationRanks.NONE); int souls = (int) Math.floor(event.getDroppedExperience() * (1.0F + (rankBonus.level * 0.1F))); stack .getCapability(ItemSlashBlade.BLADESTATE) .ifPresent( state -> { state.setProudSoulCount( state.getProudSoulCount() + Math.min(SlashBladeConfig.MAX_PROUD_SOUL_GOT.get(), souls)); }); }
@SubscribeEvent public static void onDatapackRegister(DataPackRegistryEvent.NewRegistry event) { event.dataPackRegistry( SlashBladeDefinition.REGISTRY_KEY, SlashBladeDefinition.CODEC, SlashBladeDefinition.CODEC); event.dataPackRegistry( EntityDropEntry.REGISTRY_KEY, EntityDropEntry.CODEC, EntityDropEntry.CODEC); }
@SubscribeEvent public static void registerSerializers(RegisterEvent event) { event.register( ForgeRegistries.Keys.RECIPE_SERIALIZERS, helper -> CraftingHelper.register( SlashBlade.prefix("blade"), SlashBladeIngredient.Serializer.INSTANCE)); }
@SubscribeEvent public void onAnvilRepairEvent(AnvilRepairEvent event) { if (!(event.getEntity() instanceof ServerPlayer)) return; ItemStack material = event.getRight(); ItemStack base = event.getLeft(); ItemStack output = event.getOutput(); if (base.isEmpty()) return; if (!(base.getItem() instanceof ItemSlashBlade)) return; if (material.isEmpty()) return; boolean isRepairable = base.getItem().isValidRepairItem(base, material); if (!isRepairable) return; int before = base.getCapability(ItemSlashBlade.BLADESTATE).map(s -> s.getRefine()).orElse(0); int after = output.getCapability(ItemSlashBlade.BLADESTATE).map(s -> s.getRefine()).orElse(0); if (before < after) AdvancementHelper.grantCriterion((ServerPlayer) event.getEntity(), REFINE); }
@SubscribeEvent public void onFall(LivingFallEvent event) { resetState(event.getEntity()); }
@SubscribeEvent public void onFlyableFall(PlayerFlyableFallEvent event) { resetState(event.getEntity()); }
public static void resetState(LivingEntity user) { user.getMainHandItem() .getCapability(ItemSlashBlade.BLADESTATE) .ifPresent( (state) -> { state.setFallDecreaseRate(0); ComboState combo = ComboStateRegistry.REGISTRY.get().getValue(state.getComboSeq()) != null ? ComboStateRegistry.REGISTRY.get().getValue(state.getComboSeq()) : ComboStateRegistry.NONE.get(); if (combo.isAerial()) { state.setComboSeq(combo.getNextOfTimeout(user)); } }); }
public static void spawnLandingParticle(LivingEntity user, float fallFactor) { if (!user.level().isClientSide()) { int x = Mth.floor(user.getX()); int y = Mth.floor(user.getY() - (double) 0.5F); int z = Mth.floor(user.getZ()); BlockPos pos = new BlockPos(x, y, z); BlockState state = user.level().getBlockState(pos); float f = (float) Mth.ceil(fallFactor); if (!state.isAir()) { double d0 = Math.min((double) (0.2F + f / 15.0F), 2.5D); int i = (int) (150.0D * d0); if (!state.addLandingEffects((ServerLevel) user.level(), pos, state, user, i)) ((ServerLevel) user.level()) .sendParticles( new BlockParticleOption(ParticleTypes.BLOCK, state), user.getX(), user.getY(), user.getZ(), i, 0.0D, 0.0D, 0.0D, (double) 0.15F); } } }
public static void spawnLandingParticle( Entity user, Vec3 targetPos, Vec3 normal, float fallFactor) { if (!user.level().isClientSide()) { Vec3 blockPos = targetPos.add(normal.normalize().scale(0.5f)); int x = Mth.floor(blockPos.x()); int y = Mth.floor(blockPos.y()); int z = Mth.floor(blockPos.z()); BlockPos pos = new BlockPos(x, y, z); BlockState state = user.level().getBlockState(pos); float f = (float) Mth.ceil(fallFactor); if (!state.isAir()) { double d0 = Math.min((double) (0.2F + f / 15.0F), 2.5D); int i = (int) (150.0D * d0); ((ServerLevel) user.level()) .sendParticles( new BlockParticleOption(ParticleTypes.BLOCK, state), targetPos.x(), targetPos.y(), targetPos.z(), i, 0.0D, 0.0D, 0.0D, (double) 0.15F); } } }
public static void fallDecrease(LivingEntity user) { if (!user.isNoGravity() && !user.onGround()) { user.fallDistance = 1; float currentRatio = user.getMainHandItem() .getCapability(ItemSlashBlade.BLADESTATE) .map( (state) -> { float decRatio = state.getFallDecreaseRate(); float newDecRatio = decRatio + 0.05f; newDecRatio = Math.min(1.0f, newDecRatio); state.setFallDecreaseRate(newDecRatio); return decRatio; }) .orElseGet(() -> 1.0f); double gravityReductionFactor = 0.85f; int level = EnchantmentHelper.getEnchantmentLevel(Enchantments.FALL_PROTECTION, user); if (0 < level) { gravityReductionFactor = Math.min(0.93, gravityReductionFactor + 0.2 * level); AdvancementHelper.grantedIf(Enchantments.FALL_PROTECTION, user); } AttributeInstance gravity = user.getAttribute(ForgeMod.ENTITY_GRAVITY.get()); double g = gravity.getValue() * gravityReductionFactor; Vec3 motion = user.getDeltaMovement(); if (motion.y < 0) user.setDeltaMovement(motion.x, (motion.y + g) * currentRatio, motion.z); } }
public static void fallResist(LivingEntity user) { if (!user.isNoGravity() && !user.onGround()) { user.fallDistance = 1; Vec3 motion = user.getDeltaMovement(); AttributeInstance gravity = user.getAttribute(ForgeMod.ENTITY_GRAVITY.get()); double g = gravity.getValue(); if (motion.y < 0) user.setDeltaMovement(motion.x, (motion.y + g + 0.002f), motion.z); } }
@SubscribeEvent public void AttachCapabilities_Entity(AttachCapabilitiesEvent<Entity> event) { if (!(event.getObject() instanceof LivingEntity)) return; event.addCapability(INPUTSTATE_KEY, new InputStateCapabilityProvider()); event.addCapability(MOBEFFECT_KEY, new MobEffectCapabilityProvider()); event.addCapability(RANK_KEY, new ConcentrationRankCapabilityProvider()); }
public void onTick(LivingEntity entity) { queue.tick(entity, entity.level().getGameTime()); }
public void schedule(String key, long time, TimerCallback<LivingEntity> callback) { queue.schedule(key, time, callback); }
@SubscribeEvent public static void onLivingOnFire(LivingAttackEvent event) { LivingEntity victim = event.getEntity(); DamageSource source = event.getSource(); ItemStack stack = victim.getMainHandItem(); if (stack.getEnchantmentLevel(Enchantments.FIRE_PROTECTION) <= 0) return; if (!source.is(DamageTypeTags.IS_FIRE)) return; event.setCanceled(true); }
public static InputCommandEvent onInputChange( ServerPlayer player, IInputState state, EnumSet<InputCommand> old, EnumSet<InputCommand> current) { InputCommandEvent event = new InputCommandEvent(player, state, old, current); MinecraftForge.EVENT_BUS.post(event); return event; }
@SubscribeEvent(priority = EventPriority.LOWEST) public void onLivingDeathEvent(LivingHurtEvent event) { LivingEntity victim = event.getEntity(); if (victim != null) victim .getCapability(CapabilityConcentrationRank.RANK_POINT) .ifPresent(cr -> cr.addRankPoint(victim, -cr.getUnitCapacity())); Entity trueSource = event.getSource().getEntity(); if (!(trueSource instanceof LivingEntity)) return; trueSource .getCapability(CapabilityConcentrationRank.RANK_POINT) .ifPresent(cr -> cr.addRankPoint(event.getSource())); }
@SubscribeEvent public static void eventKoseki(SlashBladeEvent.BladeStandAttackEvent event) { var slashBladeDefinitionRegistry = SlashBlade.getSlashBladeDefinitionRegistry(event.getBladeStand().level()); if (!slashBladeDefinitionRegistry.containsKey(SlashBladeBuiltInRegistry.KOSEKI.location())) return; if (!(event.getDamageSource().getEntity() instanceof WitherBoss)) return; if (!event.getDamageSource().is(DamageTypeTags.IS_EXPLOSION)) return; var in = SlashBladeIngredient.of(RequestDefinition.Builder.newInstance().build()); if (!in.test(event.getBlade())) return; event .getBladeStand() .setItem(slashBladeDefinitionRegistry.get(SlashBladeBuiltInRegistry.KOSEKI).getBlade()); event.setCanceled(true); }
public void register() { MinecraftForge.EVENT_BUS.register(this); UsePoseOverrider = true; }
@SubscribeEvent public void onRenderPlayerEventPre(RenderLivingEvent.Pre<?, ?> event) { ItemStack stack = event.getEntity().getMainHandItem(); if (stack.isEmpty()) return; if (!(stack.getItem() instanceof ItemSlashBlade)) return; float rot = event.getEntity().getPersistentData().getFloat(TAG_ROT); float rotPrev = event.getEntity().getPersistentData().getFloat(TAG_ROT_PREV); PoseStack matrixStackIn = event.getPoseStack(); LivingEntity entityLiving = event.getEntity(); float partialTicks = event.getPartialTick(); float f = Mth.rotLerp(partialTicks, entityLiving.yBodyRotO, entityLiving.yBodyRot); matrixStackIn.mulPose(Axis.YP.rotationDegrees(180.0F - f)); anotherPoseRotP(matrixStackIn, entityLiving, partialTicks); matrixStackIn.mulPose(Axis.YP.rotationDegrees(Mth.rotLerp(partialTicks, rot, rotPrev))); anotherPoseRotN(matrixStackIn, entityLiving, partialTicks); matrixStackIn.mulPose(Axis.YN.rotationDegrees(180.0F - f)); }
public static void resetRot(Entity target) { CompoundTag tag = target.getPersistentData(); tag.putFloat(TAG_ROT_PREV, 0); tag.putFloat(TAG_ROT, 0); }
public static void invertRot(PoseStack matrixStack, Entity entity, float partialTicks) { float rot = entity.getPersistentData().getFloat(TAG_ROT); float rotPrev = entity.getPersistentData().getFloat(TAG_ROT_PREV); matrixStack.mulPose(Axis.YP.rotationDegrees(Mth.rotLerp(partialTicks, rot, rotPrev))); }
public static RenderOverrideEvent onRenderOverride( ItemStack stack, WavefrontObject model, String target, ResourceLocation texture, PoseStack matrixStack, MultiBufferSource buffer) { RenderOverrideEvent event = new RenderOverrideEvent(stack, model, target, texture, matrixStack, buffer); MinecraftForge.EVENT_BUS.post(event); return event; }
@SubscribeEvent public void onRenderPlayerEventPre(RenderPlayerEvent.Pre event) { ItemStack stack = event.getEntity().getMainHandItem(); if (stack.isEmpty()) return; if (!(stack.getItem() instanceof ItemSlashBlade)) return; if (!event.getRenderer().getModel().crouching) return; final Minecraft instance = Minecraft.getInstance(); if (instance.options.getCameraType() == CameraType.FIRST_PERSON && instance.player == event.getEntity()) return; event.getRenderer().getModel().crouching = false; Vec3 offset = event .getRenderer() .getRenderOffset((AbstractClientPlayer) event.getEntity(), event.getPartialTick()) .scale(-1); event.getPoseStack().translate(offset.x, offset.y, offset.z); }
@Override public boolean matches(Container inv, Level worldIn) { return false; }
@Override public ItemStack assemble(Container p_44001_, RegistryAccess p_267165_) { return result.copy(); }
@Override public boolean canCraftInDimensions(int width, int height) { return false; }
@Override public void addItemToSlot( Iterator<Ingredient> ingredients, int slotIn, int maxAmount, int y, int x) { Ingredient ingredient = ingredients.next(); if (!ingredient.isEmpty()) { if (slotIn < currentView.slots.size()) { Vec3i slot = currentView.slots.get(slotIn); gr.addIngredient(ingredient, slot.getX(), slot.getY()); } } }
static void clearGhostRecipe() { target = null; gr.clear(); currentRecipe = null; currentView = null; }
void drawBackGround( GuiGraphics gg, int xCorner, int yCorner, int zOffset, int xSize, int ySize, int yClip) { int bPadding = 5; gg.blit( currentView.background, xCorner, yCorner, zOffset, 0, 0, xSize, yClip - bPadding, 256, 256); gg.blit( currentView.background, xCorner, yCorner + yClip - bPadding, zOffset, 0, ySize - bPadding, xSize, bPadding, 256, 256); }
void drawGhostRecipe(GuiGraphics gg, int xCorner, int yCorner, int zOffset, float partialTicks) { try { gg.pose().pushPose(); int padding = 5; gg.renderFakeItem(gr.getRecipe().getToastSymbol(), xCorner + padding, yCorner + padding); boolean wideOutputSlot = currentView.isWideOutputSlot; gr.render(gg, MCINSTANCE, xCorner, yCorner, wideOutputSlot, partialTicks); } finally { gg.pose().popPose(); } }
void drawTooltip( GuiGraphics gg, int xCorner, int yCorner, int zOffset, int mouseX, int mouseY, Screen gui) { ItemStack itemStack = null; int slotSize = 16; for (int i = 0; i < gr.size(); ++i) { GhostRecipe.GhostIngredient ghostIngredient = gr.get(i); int j = ghostIngredient.getX() + xCorner; int k = ghostIngredient.getY() + yCorner; if (mouseX >= j && mouseY >= k && mouseX < j + slotSize && mouseY < k + slotSize) { itemStack = ghostIngredient.getItem(); } } if (itemStack != null) { if (itemStack != null && MCINSTANCE.screen != null) { gg.renderTooltip(MCINSTANCE.font, itemStack, mouseX, mouseY); } } }
@OnlyIn(Dist.CLIENT) @SubscribeEvent public void onDrawScreenPost(ScreenEvent.Render.Post event) { if (!(event.getScreen() instanceof AdvancementsScreen)) return; if (AdvancementsRecipeRenderer.currentRecipe == null) return; if (AdvancementsRecipeRenderer.currentView == null) return; AdvancementsScreen gui = (AdvancementsScreen) event.getScreen(); try { event.getGuiGraphics().pose().pushPose(); PoseStack matrixStack = event.getGuiGraphics().pose(); int zOffset = 425; int zStep = 75; matrixStack.translate(0, 0, zOffset); int xSize = 176; int ySize = 166; int yClip = 85; int xCorner = (gui.width - xSize) / 2; int yCorner = (gui.height - yClip) / 2; drawBackGround(event.getGuiGraphics(), xCorner, yCorner, zOffset, xSize, ySize, yClip); drawGhostRecipe(event.getGuiGraphics(), xCorner, yCorner, zOffset, event.getPartialTick()); matrixStack.translate(0, 0, zStep); drawTooltip( event.getGuiGraphics(), xCorner, yCorner, zOffset, event.getMouseX(), event.getMouseY(), gui); } finally { event.getGuiGraphics().pose().popPose(); } }
@OnlyIn(Dist.CLIENT) @SubscribeEvent public void onInitGuiPost(ScreenEvent.Init.Post event) { if (!(event.getScreen() instanceof AdvancementsScreen)) return; AdvancementsScreen gui = (AdvancementsScreen) event.getScreen(); ((List<GuiEventListener>) gui.children()).add(new AdvancementsExGuiEventListener(gui)); }
@Override public boolean mouseClicked(double mouseX, double mouseY, int button) { if (button == 1) { clearGhostRecipe(); return false; } int offsetX = (screen.width - 252) / 2; int offsetY = (screen.height - 140) / 2; ItemStack found = null; AdvancementTab selectedTab = screen.selectedTab; if (selectedTab == null) return false; int mouseXX = (int) (mouseX - offsetX - 9); int mouseYY = (int) (mouseY - offsetY - 18); double scrollX = selectedTab.scrollX; double scrollY = selectedTab.scrollY; Map<Advancement, AdvancementWidget> guis = selectedTab.widgets; int i = Mth.floor(scrollX); int j = Mth.floor(scrollY); if (mouseXX > 0 && mouseXX < 234 && mouseYY > 0 && mouseYY < 113) { for (AdvancementWidget advancemententrygui : guis.values()) { if (advancemententrygui.isMouseOver(i, j, mouseXX, mouseYY)) { DisplayInfo info = advancemententrygui.display; found = info.getIcon(); break; } } } setGhostRecipe(found); return false; }
@Override public boolean isFocused() { return focus; }
public boolean isRequestSlashBladeKill() { return requestSlashBladeKill; }
public boolean isDropFixedPoint() { return dropFixedPoint; }
public static void register() { int id = 0; INSTANCE.registerMessage( id++, MoveCommandMessage.class, MoveCommandMessage::encode, MoveCommandMessage::decode, MoveCommandMessage::handle); INSTANCE.registerMessage( id++, ActiveStateSyncMessage.class, ActiveStateSyncMessage::encode, ActiveStateSyncMessage::decode, ActiveStateSyncMessage::handle); INSTANCE.registerMessage( id++, RankSyncMessage.class, RankSyncMessage::encode, RankSyncMessage::decode, RankSyncMessage::handle); INSTANCE.registerMessage( id++, MotionBroadcastMessage.class, MotionBroadcastMessage::encode, MotionBroadcastMessage::decode, MotionBroadcastMessage::handle); }
public static MoveCommandMessage decode(FriendlyByteBuf buf) { MoveCommandMessage msg = new MoveCommandMessage(); msg.command = buf.readInt(); return msg; }
public static void encode(MoveCommandMessage msg, FriendlyByteBuf buf) { buf.writeInt(msg.command); }
public static MotionBroadcastMessage decode(FriendlyByteBuf buf) { MotionBroadcastMessage msg = new MotionBroadcastMessage(); msg.playerId = buf.readUUID(); msg.combo = buf.readUtf(); return msg; }
public static void encode(MotionBroadcastMessage msg, FriendlyByteBuf buf) { buf.writeUUID(msg.playerId); buf.writeUtf(msg.combo); }
public static ActiveStateSyncMessage decode(FriendlyByteBuf buf) { ActiveStateSyncMessage msg = new ActiveStateSyncMessage(); msg.id = buf.readInt(); msg.activeTag = buf.readNbt(); return msg; }
public static void encode(ActiveStateSyncMessage msg, FriendlyByteBuf buf) { buf.writeInt(msg.id); buf.writeNbt(msg.activeTag); }
public static RankSyncMessage decode(FriendlyByteBuf buf) { RankSyncMessage msg = new RankSyncMessage(); msg.rawPoint = buf.readLong(); return msg; }
public static void encode(RankSyncMessage msg, FriendlyByteBuf buf) { buf.writeLong(msg.rawPoint); }
private static Map<String, String> initNamemap() { Map<String, String> map = Maps.newHashMap(); map.put("leftArm", "left arm"); map.put("rightArm", "right arm"); map.put("leftLeg", "left leg"); map.put("rightLeg", "right leg"); return map; }
@Override public void tick() { if (this.isRunning) { this.currentTick++; double endTicks = span; this.loop = false; if (this.loop && endTicks < this.currentTick) { this.currentTick = 0; } if (endTicks <= currentTick) { this.stop(); } } }
public void play() { this.currentTick = 0; this.isRunning = true; }
@Override public boolean isActive() { return this.isRunning; }
Vector3d QuaternionToEulerZYX(Quaterniond qt) { Vector3d tmp = new Vector3d(); double a_x_x = Math.pow(qt.w, 2) + Math.pow(qt.x, 2) - Math.pow(qt.y, 2) - Math.pow(qt.z, 2); double a_x_y = 2 * (qt.x * qt.y + qt.w * qt.z); double a_x_z = 2 * (qt.x * qt.z - qt.w * qt.y); double a_y_z = 2 * (qt.y * qt.z + qt.w * qt.x); double a_z_z = Math.pow(qt.w, 2) - Math.pow(qt.x, 2) - Math.pow(qt.y, 2) + Math.pow(qt.z, 2); tmp.z = Math.atan2(a_x_y, a_x_x); tmp.y = Math.asin(-a_x_z); tmp.x = Math.atan2(a_y_z, a_z_z); return tmp; }
@Override public void setupAnim(float tickDelta) { if (!motionPlayer.isPresent()) return; MmdMotionPlayerGL2 mmp = motionPlayer.orElse(null); double eofTime = 0; MmdVmdMotionMc motion = BladeMotionManager.getInstance().getMotion(loc); try { mmp.setVmd(motion); eofTime = TimeValueHelper.getMSecFromFrames(motion.getMaxFrame()); } catch (Exception e) { e.printStackTrace(); } double time = TimeValueHelper.getMSecFromTicks((float) (currentTick + (double) tickDelta)); time = Math.min(eofTime, time); time = TimeValueHelper.getMSecFromFrames((float) start) + time; try { mmp.updateMotion((float) time); } catch (MmdException e) { e.printStackTrace(); } }
@SubscribeEvent public void onBladeAnimationStart(BladeMotionEvent event) { if (!(event.getEntity() instanceof AbstractClientPlayer)) return; AbstractClientPlayer player = (AbstractClientPlayer) event.getEntity(); AnimationStack animationStack = PlayerAnimationAccess.getPlayerAnimLayer(player); VmdAnimation animation = this.getAnimation().get(event.getCombo()); if (animation != null) { animationStack.removeLayer(0); animation.play(); animationStack.addAnimLayer(0, animation.getClone()); } }
@Override public void registerItemSubtypes(ISubtypeRegistration registration) { registration.registerSubtypeInterpreter( SBItems.slashblade, (stack, context) -> stack.getOrCreateTagElement("bladeState").getString("translationKey")); }
@Override protected void defineSynchedData() { super.defineSynchedData(); this.entityData.define(IT_FIRED, false); }
public void doFire() { this.getEntityData().set(IT_FIRED, true); }
public boolean itFired() { return this.getEntityData().get(IT_FIRED); }
public static EntityStormSwords createInstance(PlayMessages.SpawnEntity packet, Level worldIn) { return new EntityStormSwords(SlashBlade.RegistryEvents.StormSwords, worldIn); }
@Override public void rideTick() { if (itFired()) { faceEntityStandby(); Entity target = getVehicle(); this.stopRiding(); this.tickCount = 0; Vec3 dir = this.getViewVector(1.0f); if (target != null) { dir = target.position().subtract(this.position()).multiply(1, 0, 1).normalize(); } ((EntityStormSwords) this).shoot(dir.x, dir.y, dir.z, 3.0f, 1.0f); return; } this.setDeltaMovement(Vec3.ZERO); if (canUpdate()) this.baseTick(); faceEntityStandby(); if (20 <= this.tickCount) doFire(); if (!level().isClientSide()) hitCheck(); }
@Override protected void onHitEntity(EntityHitResult p_213868_1_) { Entity targetEntity = p_213868_1_.getEntity(); if (targetEntity instanceof LivingEntity) { KnockBacks.toss.action.accept((LivingEntity) targetEntity); StunManager.setStun((LivingEntity) targetEntity); } super.onHitEntity(p_213868_1_); }
@Override protected void onHitBlock(BlockHitResult blockraytraceresult) { burst(); }
public static EntityHeavyRainSwords createInstance( PlayMessages.SpawnEntity packet, Level worldIn) { return new EntityHeavyRainSwords(SlashBlade.RegistryEvents.HeavyRainSwords, worldIn); }
@Override public void rideTick() { if (itFired() && fireTime <= tickCount) { faceEntityStandby(); this.stopRiding(); Vec3 dir = new Vec3(0, -1, 0); this.shoot(dir.x, dir.y, dir.z, 4.0f, 2.0f); this.tickCount = 0; return; } this.setDeltaMovement(Vec3.ZERO); if (canUpdate()) this.baseTick(); faceEntityStandby(); if (!itFired()) { int basedelay = 10; fireTime = tickCount + basedelay + getDelay(); doFire(); } }
private void faceEntityStandby() { setPos(this.position()); setRot(this.getYRot(), -90); }
@Override protected void onHitEntity(EntityHitResult p_213868_1_) { Entity targetEntity = p_213868_1_.getEntity(); if (targetEntity instanceof LivingEntity) { KnockBacks.cancel.action.accept((LivingEntity) targetEntity); StunManager.setStun((LivingEntity) targetEntity); } super.onHitEntity(p_213868_1_); }
protected void tryDespawn() { ++this.ticksInGround; if (ON_GROUND_LIFE_TIME <= this.ticksInGround) { this.burst(); } }
public static EntitySlashEffect createInstance(PlayMessages.SpawnEntity packet, Level worldIn) { return new EntitySlashEffect(SlashBlade.RegistryEvents.SlashEffect, worldIn); }
@Override protected void defineSynchedData() { super.defineSynchedData(); this.entityData.define(COLOR, 0x3333FF); this.entityData.define(FLAGS, 0); this.entityData.define(RANK, 0.0f); this.entityData.define(ROTATION_OFFSET, 0.0f); this.entityData.define(ROTATION_ROLL, 0.0f); this.entityData.define(BASESIZE, 1.0f); }
@Override protected void addAdditionalSaveData(CompoundTag compound) { super.addAdditionalSaveData(compound); NBTHelper.getNBTCoupler(compound) .put("RotationOffset", this.getRotationOffset()) .put("RotationRoll", this.getRotationRoll()) .put("BaseSize", this.getBaseSize()) .put("Color", this.getColor()) .put("Rank", this.getRank()) .put("damage", this.damage) .put("crit", this.getIsCritical()) .put("clip", this.isNoClip()) .put("Lifetime", this.getLifetime()) .put("Knockback", this.getKnockBack().ordinal()); }
@Override protected void readAdditionalSaveData(CompoundTag compound) { super.readAdditionalSaveData(compound); NBTHelper.getNBTCoupler(compound) .get("RotationOffset", this::setRotationOffset) .get("RotationRoll", this::setRotationRoll) .get("BaseSize", this::setBaseSize) .get("Color", this::setColor) .get("Rank", this::setRank) .get("damage", ((Double v) -> this.damage = v), this.damage) .get("crit", this::setIsCritical) .get("clip", this::setNoClip) .get("Lifetime", this::setLifetime) .get("Knockback", this::setKnockBackOrdinal); }
@Override public void shoot(double x, double y, double z, float velocity, float inaccuracy) { if (!this.isWave()) this.setDeltaMovement(0, 0, 0); }
@Override @OnlyIn(Dist.CLIENT) public boolean shouldRenderAtSqrDistance(double distance) { double d0 = this.getBoundingBox().getSize() * 10.0D; if (Double.isNaN(d0)) { d0 = 1.0D; } d0 = d0 * 64.0D * getViewScale(); return distance < d0 * d0; }
@Override @OnlyIn(Dist.CLIENT) public void lerpTo( double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport) { this.setPos(x, y, z); this.setRot(yaw, pitch); }
@Override @OnlyIn(Dist.CLIENT) public void lerpMotion(double x, double y, double z) { this.setDeltaMovement(0, 0, 0); }
private void removeFlags(FlagsState value) { this.flags.remove(value); refreshFlags(); }
private void refreshFlags() { if (this.level().isClientSide()) { int newValue = this.entityData.get(FLAGS).intValue(); if (intFlags != newValue) { intFlags = newValue; flags = EnumSetConverter.convertToEnumSet(FlagsState.class, intFlags); } } else { int newValue = EnumSetConverter.convertToInt(this.flags); if (this.intFlags != newValue) { this.entityData.set(FLAGS, newValue); this.intFlags = newValue; } } }
public boolean isNoClip() { if (!this.level().isClientSide()) { return this.noPhysics; } else { refreshFlags(); return flags.contains(FlagsState.NoClip); } }
protected void tryDespawn() { if (!this.level().isClientSide()) { if (getLifetime() < this.tickCount) this.remove(RemovalReason.DISCARDED); } }
@Override protected void defineSynchedData() { super.defineSynchedData(); this.getEntityData().define(DATA_MODEL, DefaultResources.resourceDefaultModel.toString()); this.getEntityData().define(DATA_TEXTURE, DefaultResources.resourceDefaultTexture.toString()); }
public void init() { this.setInvulnerable(true); CompoundTag compoundnbt = this.saveWithoutId(new CompoundTag()); compoundnbt.remove("Dimension"); compoundnbt.putShort("Health", (short) 100); compoundnbt.putShort("Age", Short.MIN_VALUE); this.load(compoundnbt); }
public static BladeItemEntity createInstanceFromPacket( PlayMessages.SpawnEntity packet, Level worldIn) { return new BladeItemEntity(SlashBlade.RegistryEvents.BladeItem, worldIn); }
@Override public boolean isOnFire() { return super.isOnFire(); }
@Override public void addAdditionalSaveData(CompoundTag compound) { super.addAdditionalSaveData(compound); String standTypeStr; if (this.currentType != null) { standTypeStr = ForgeRegistries.ITEMS.getKey(this.currentType).toString(); } else { standTypeStr = ""; } compound.putString("StandType", standTypeStr); compound.putByte("Pose", (byte) this.getPose().ordinal()); }
@Override public void readAdditionalSaveData(CompoundTag compound) { super.readAdditionalSaveData(compound); this.currentType = ForgeRegistries.ITEMS.getValue(new ResourceLocation(compound.getString("StandType"))); this.setPose(Pose.values()[compound.getByte("Pose") % Pose.values().length]); }
@Override public void writeSpawnData(FriendlyByteBuf buffer) { CompoundTag tag = new CompoundTag(); this.addAdditionalSaveData(tag); buffer.writeNbt(tag); }
@Override public void readSpawnData(FriendlyByteBuf additionalData) { CompoundTag tag = additionalData.readNbt(); this.readAdditionalSaveData(tag); }
public static BladeStandEntity createInstanceFromPos( Level worldIn, BlockPos placePos, Direction dir, Item type) { BladeStandEntity e = new BladeStandEntity(SlashBlade.RegistryEvents.BladeStand, worldIn); e.pos = placePos; e.setDirection(dir); e.currentType = type; return e; }
public static BladeStandEntity createInstance(PlayMessages.SpawnEntity spawnEntity, Level world) { return new BladeStandEntity(SlashBlade.RegistryEvents.BladeStand, world); }
@Nullable @Override public ItemEntity spawnAtLocation(ItemLike iip) { if (iip == Items.ITEM_FRAME) { if (this.currentType == null || this.currentType == Items.AIR) return null; iip = this.currentType; } return super.spawnAtLocation(iip); }
@Override public boolean hurt(DamageSource damageSource, float cat) { ItemStack blade = this.getItem(); if (blade.isEmpty()) return super.hurt(damageSource, cat); if (!blade.getCapability(ItemSlashBlade.BLADESTATE).isPresent()) return super.hurt(damageSource, cat); ISlashBladeState state = blade.getCapability(ItemSlashBlade.BLADESTATE).orElseThrow(NullPointerException::new); if (MinecraftForge.EVENT_BUS.post( new SlashBladeEvent.BladeStandAttackEvent(blade, state, this, damageSource))) return true; return super.hurt(damageSource, cat); }
public static EntityDrive createInstance(PlayMessages.SpawnEntity packet, Level worldIn) { return new EntityDrive(SlashBlade.RegistryEvents.Drive, worldIn); }
@Override protected void defineSynchedData() { super.defineSynchedData(); this.entityData.define(COLOR, 0x3333FF); this.entityData.define(FLAGS, 0); this.entityData.define(RANK, 0.0f); this.entityData.define(LIFETIME, 10.0f); this.entityData.define(ROTATION_OFFSET, 0.0f); this.entityData.define(ROTATION_ROLL, 0.0f); this.entityData.define(BASESIZE, 1.0f); this.entityData.define(SPEED, 0.5f); }
@Override public void addAdditionalSaveData(CompoundTag compound) { super.addAdditionalSaveData(compound); NBTHelper.getNBTCoupler(compound) .put("RotationOffset", this.getRotationOffset()) .put("RotationRoll", this.getRotationRoll()) .put("BaseSize", this.getBaseSize()) .put("Speed", this.getSpeed()) .put("Color", this.getColor()) .put("Rank", this.getRank()) .put("damage", this.damage) .put("crit", this.getIsCritical()) .put("clip", this.isNoClip()) .put("Lifetime", this.getLifetime()) .put("Knockback", this.getKnockBack().ordinal()); }
@Override public void readAdditionalSaveData(CompoundTag compound) { super.readAdditionalSaveData(compound); NBTHelper.getNBTCoupler(compound) .get("RotationOffset", this::setRotationOffset) .get("RotationRoll", this::setRotationRoll) .get("BaseSize", this::setBaseSize) .get("Speed", this::setSpeed) .get("Color", this::setColor) .get("Rank", this::setRank) .get("damage", ((Double v) -> this.damage = v), this.damage) .get("crit", this::setIsCritical) .get("clip", this::setNoClip) .get("Lifetime", this::setLifetime) .get("Knockback", this::setKnockBackOrdinal); }
protected void removeFlags(FlagsState value) { this.flags.remove(value); refreshFlags(); }
@Override protected void onHitBlock(BlockHitResult blockraytraceresult) { this.setRemoved(RemovalReason.DISCARDED); }
public static EntitySpiralSwords createInstance(PlayMessages.SpawnEntity packet, Level worldIn) { return new EntitySpiralSwords(SlashBlade.RegistryEvents.SpiralSwords, worldIn); }
@Override public void rideTick() { if (itFired()) { faceEntityStandby(); Entity target = getVehicle(); this.stopRiding(); this.tickCount = 0; Vec3 dir = this.getViewVector(1.0f); if (target != null) { dir = this.position().subtract(target.position()).multiply(1, 0, 1).normalize(); } ((EntitySpiralSwords) this).shoot(dir.x, dir.y, dir.z, 3.0f, 1.0f); return; } this.setDeltaMovement(Vec3.ZERO); if (canUpdate()) this.baseTick(); faceEntityStandby(); if (200 < this.tickCount) burst(); if (!level().isClientSide()) hitCheck(); }
@Override protected void onHitEntity(EntityHitResult p_213868_1_) { Entity targetEntity = p_213868_1_.getEntity(); if (targetEntity instanceof LivingEntity) { KnockBacks.cancel.action.accept((LivingEntity) targetEntity); } super.onHitEntity(p_213868_1_); }
@Override protected void defineSynchedData() { this.entityData.define(OWNERID, -1); }
public boolean canUse() { boolean onStun = this.entity .getCapability(CapabilityMobEffect.MOB_EFFECT) .filter((state) -> state.isStun(this.entity.level().getGameTime())) .isPresent(); return onStun; }
public void stop() { this.entity .getCapability(CapabilityMobEffect.MOB_EFFECT) .ifPresent( (state) -> { state.clearStunTimeOut(); }); }
public boolean isInsideGuardableRange(DamageSource source, LivingEntity victim) { Vec3 sPos = source.getSourcePosition(); if (sPos != null) { Vec3 viewVec = victim.getViewVector(1.0F); Vec3 attackVec = sPos.vectorTo(victim.position()).normalize(); attackVec = new Vec3(attackVec.x, 0.0D, attackVec.z); if (attackVec.dot(viewVec) < 0.0D) { return true; } } return false; }
private boolean checkUntouchable(LivingEntity entity) { Optional<Boolean> isUntouchable = entity .getCapability(CapabilityMobEffect.MOB_EFFECT) .map(ef -> ef.isUntouchable(entity.getCommandSenderWorld().getGameTime())); return isUntouchable.orElseGet(() -> false); }
private void doWitchTime(Entity entity) { if (entity == null) return; if (!(entity instanceof LivingEntity)) return; StunManager.setStun((LivingEntity) entity); }
@SubscribeEvent public void onLivingTicks(LivingEvent.LivingTickEvent event) { LivingEntity entity = event.getEntity(); if (entity.level().isClientSide()) return; entity .getCapability(CapabilityMobEffect.MOB_EFFECT) .ifPresent( ef -> { if (ef.hasUntouchableWorked()) { ef.setUntouchableWorked(false); List<MobEffect> filterd = entity.getActiveEffectsMap().keySet().stream() .filter(p -> !(ef.getEffectSet().contains(p) || p.isBeneficial())) .toList(); filterd.forEach(p -> entity.removeEffect(p)); float storedHealth = ef.getStoredHealth(); if (ef.getStoredHealth() < storedHealth) entity.setHealth(ef.getStoredHealth()); } }); }
@SubscribeEvent public void onPlayerJump(LivingEvent.LivingJumpEvent event) { if (!event.getEntity().getMainHandItem().getCapability(ItemSlashBlade.BLADESTATE).isPresent()) return; Untouchable.setUntouchable(event.getEntity(), JUMP_TICKS); }
@SubscribeEvent(priority = EventPriority.HIGHEST) public void onEntityJoinWorldEvent(EntityJoinLevelEvent event) { if (!(event.getEntity() instanceof PathfinderMob)) return; PathfinderMob entity = (PathfinderMob) event.getEntity(); entity.goalSelector.addGoal(-1, new StunGoal(entity)); }
@SubscribeEvent public void onEntityLivingUpdate(LivingEvent.LivingTickEvent event) { LivingEntity target = event.getEntity(); if (!(target instanceof PathfinderMob)) return; if (target.level() == null) return; boolean onStun = target .getCapability(CapabilityMobEffect.MOB_EFFECT) .filter((state) -> state.isStun(target.level().getGameTime())) .isPresent(); if (onStun) { Vec3 motion = target.getDeltaMovement(); if (5 < target.fallDistance) target.setDeltaMovement(motion.x, motion.y - 2.0f, motion.z); else if (motion.y < 0) target.setDeltaMovement(motion.x, motion.y * 0.25f, motion.z); } }
public static void removeStun(LivingEntity target) { if (target.level() == null) return; if (!(target instanceof LivingEntity)) return; target .getCapability(CapabilityMobEffect.MOB_EFFECT) .ifPresent( (state) -> { state.clearStunTimeOut(); }); }
private static void doTeleport(Entity entityIn, LivingEntity target) { entityIn.getPersistentData().putInt("sb.airtrick.counter", 3); entityIn.getPersistentData().putInt("sb.airtrick.target", target.getId()); if (entityIn instanceof ServerPlayer) { AdvancementHelper.grantCriterion((ServerPlayer) entityIn, ADVANCEMENT_AIR_TRICK); Vec3 motion = target.getPosition(1.0f).subtract(entityIn.getPosition(1.0f)).scale(0.5f); ((ServerPlayer) entityIn) .connection.send(new ClientboundSetEntityMotionPacket(entityIn.getId(), motion)); } }
public static boolean isMatch(Entity arrow, Entity attacker) { if (arrow == null) return false; if (!(arrow instanceof Projectile)) return false; return true; }
public static void doReflect(Entity arrow, Entity attacker) { if (!isMatch(arrow, attacker)) return; arrow.hurtMarked = true; if (attacker != null) { Vec3 dir = attacker.getLookAngle(); do { if (attacker instanceof LivingEntity) break; ItemStack stack = ((LivingEntity) attacker).getMainHandItem(); if (stack.isEmpty()) break; if (!(stack.getItem() instanceof ItemSlashBlade)) break; Entity target = stack .getCapability(ItemSlashBlade.BLADESTATE) .map(s -> s.getTargetEntity(attacker.level())) .orElse(null); if (target != null) { dir = arrow.position().subtract(target.getEyePosition(1.0f)).normalize(); } else { dir = arrow .position() .subtract(attacker.getLookAngle().scale(10).add(attacker.getEyePosition(1.0f))) .normalize(); } } while (false); arrow.setDeltaMovement(dir); ((Projectile) arrow).shoot(dir.x, dir.y, dir.z, 1.1f, 0.5f); arrow.setNoGravity(true); if (arrow instanceof AbstractArrow) ((AbstractArrow) arrow).setCritArrow(true); } }
@Override public void handle(LivingEntity rawEntity, TimerQueue<LivingEntity> queue, long now) { if (!(rawEntity instanceof ServerPlayer)) return; ServerPlayer entity = (ServerPlayer) rawEntity; InputCommand targetCommnad = InputCommand.SPRINT; boolean inputSucceed = entity .getCapability(CapabilityInputState.INPUT_STATE) .filter( input -> input.getCommands().contains(targetCommnad) && (!InputCommand.anyMatch(input.getCommands(), InputCommand.move) || !input.getCommands().contains(InputCommand.SNEAK)) && input.getLastPressTime(targetCommnad) == pressTime) .isPresent(); if (!inputSucceed) return; releaseSSA(entity); }
@Override public float unclampedCall( ItemStack p_174564_, @Nullable ClientLevel p_174565_, @Nullable LivingEntity p_174566_, int p_174567_) { BladeModel.user = p_174566_; return 0; }
@SubscribeEvent public static void registerKeyMapping(RegisterKeyMappingsEvent event) { event.register(SlashBladeKeyMappings.KEY_SPECIAL_MOVE); event.register(SlashBladeKeyMappings.KEY_SUMMON_BLADE); }
@SubscribeEvent public static void Baked(final ModelEvent.ModifyBakingResult event) { bakeBlade(SBItems.slashblade, event); bakeBlade(SBItems.slashblade_white, event); bakeBlade(SBItems.slashblade_wood, event); bakeBlade(SBItems.slashblade_silverbamboo, event); bakeBlade(SBItems.slashblade_bamboo, event); }
public static void bakeBlade(Item blade, final ModelEvent.ModifyBakingResult event) { ModelResourceLocation loc = new ModelResourceLocation(ForgeRegistries.ITEMS.getKey(blade), "inventory"); BladeModel model = new BladeModel(event.getModels().get(loc), event.getModelBakery()); event.getModels().put(loc, model); }
@SubscribeEvent public static void addLayers(EntityRenderersEvent.AddLayers event) { addPlayerLayer(event, "default"); addPlayerLayer(event, "slim"); addEntityLayer(event, EntityType.ZOMBIE); addEntityLayer(event, EntityType.HUSK); addEntityLayer(event, EntityType.ZOMBIE_VILLAGER); addEntityLayer(event, EntityType.WITHER_SKELETON); addEntityLayer(event, EntityType.SKELETON); addEntityLayer(event, EntityType.STRAY); addEntityLayer(event, EntityType.PIGLIN); addEntityLayer(event, EntityType.PIGLIN_BRUTE); addEntityLayer(event, EntityType.ZOMBIFIED_PIGLIN); }
@SuppressWarnings({"unchecked"}) private static void addPlayerLayer(EntityRenderersEvent.AddLayers evt, String skin) { EntityRenderer<? extends Player> renderer = evt.getSkin(skin); if (renderer instanceof LivingEntityRenderer livingRenderer) { livingRenderer.addLayer(new LayerMainBlade<>(livingRenderer)); } }
@SuppressWarnings({"unchecked", "rawtypes"}) private static void addEntityLayer(EntityRenderersEvent.AddLayers evt, EntityType type) { EntityRenderer<?> renderer = evt.getRenderer(type); if (renderer instanceof LivingEntityRenderer livingRenderer) { livingRenderer.addLayer(new LayerMainBlade<>(livingRenderer)); } }
@Override public void renderByItem( ItemStack itemStackIn, ItemDisplayContext type, PoseStack matrixStack, MultiBufferSource bufferIn, int combinedLightIn, int combinedOverlayIn) { if (!(itemStackIn.getItem() instanceof ItemSlashBlade)) return; renderBlade(itemStackIn, type, matrixStack, bufferIn, combinedLightIn, combinedOverlayIn); }
boolean checkRenderNaked() { ItemStack mainHand = BladeModel.user.getMainHandItem(); if (!(mainHand.getItem() instanceof ItemSlashBlade)) return true; return false; }
private void renderIcon( ItemStack stack, PoseStack matrixStack, MultiBufferSource bufferIn, int lightIn, float scale) { renderIcon(stack, matrixStack, bufferIn, lightIn, scale, false); }
public float modifiedSpeed(float baseSpeed, LivingEntity entity) { float modif = 6.0f; if (MobEffectUtil.hasDigSpeed(entity)) { modif = 6 - (1 + MobEffectUtil.getDigSpeedAmplification(entity)); } else if (entity.hasEffect(MobEffects.DIG_SLOWDOWN)) { modif = 6 + (1 + entity.getEffect(MobEffects.DIG_SLOWDOWN).getAmplifier()) * 2; } modif /= 6.0f; return baseSpeed / modif; }
public void renderHotbarItem( PoseStack matrixStack, MultiBufferSource bufferIn, int lightIn, T entity) { if (entity instanceof Player player) { if (player.getInventory().selected == 0) return; ItemStack blade = player.getInventory().getItem(0); if (blade.isEmpty()) return; renderStandbyBlade(matrixStack, bufferIn, lightIn, blade); } }
@Override public boolean shouldSpreadItems() { return false; }
@Override public boolean shouldBob() { return false; }
@Override public void render( T entity, float entityYaw, float partialTicks, PoseStack matrixStack, MultiBufferSource bufferIn, int packedLightIn) { try (MSAutoCloser msac = MSAutoCloser.pushMatrix(matrixStack)) { float lifetime = entity.getLifetime(); double deathTime = lifetime; double baseAlpha = (Math.min(deathTime, Math.max(0, (lifetime - (entity.tickCount)))) / deathTime); baseAlpha = Math.max(0, -Math.pow(baseAlpha - 1, 4.0) + 0.75); matrixStack.mulPose( Axis.YP.rotationDegrees( Mth.rotLerp(partialTicks, entity.yRotO, entity.getYRot()) - 90.0F)); matrixStack.mulPose( Axis.ZP.rotationDegrees(Mth.rotLerp(partialTicks, entity.xRotO, entity.getXRot()))); matrixStack.mulPose(Axis.XP.rotationDegrees(entity.getRotationRoll())); float scale = 0.015f; matrixStack.scale(scale, scale, scale); matrixStack.mulPose(Axis.YP.rotationDegrees(90.0F)); int color = entity.getColor() & 0xFFFFFF; int alpha = ((0xFF & (int) (0xFF * baseAlpha)) << 24); WavefrontObject model = BladeModelManager.getInstance().getModel(MODEL); BladeRenderState.setCol(color | alpha); BladeRenderState.renderOverridedLuminous( ItemStack.EMPTY, model, "base", TEXTURE, matrixStack, bufferIn, packedLightIn); } }
@Override public void render( BladeStandEntity entity, float entityYaw, float partialTicks, PoseStack matrixStackIn, MultiBufferSource bufferIn, int packedLightIn) { doRender(entity, entityYaw, partialTicks, matrixStackIn, bufferIn, packedLightIn); }
private void renderItem( BladeStandEntity entity, ItemStack itemstack, PoseStack matrixStackIn, MultiBufferSource bufferIn, int packedLightIn) { if (!itemstack.isEmpty()) { BakedModel ibakedmodel = this.itemRenderer.getModel(itemstack, entity.level(), (LivingEntity) null, 0); this.itemRenderer.render( itemstack, ItemDisplayContext.FIXED, false, matrixStackIn, bufferIn, packedLightIn, OverlayTexture.NO_OVERLAY, ibakedmodel); } }
public void render(PoseStack matrixStack, MultiBufferSource bufferIn, int combinedLightIn) { if (layer == null) return; Minecraft mc = Minecraft.getInstance(); boolean flag = mc.getCameraEntity() instanceof LivingEntity && ((LivingEntity) mc.getCameraEntity()).isSleeping(); if (!(mc.options.getCameraType() == CameraType.FIRST_PERSON && !flag && !mc.options.hideGui && !mc.gameMode.isAlwaysFlying())) { return; } LocalPlayer player = mc.player; ItemStack stack = player.getItemInHand(InteractionHand.MAIN_HAND); if (stack.isEmpty()) return; if (!(stack.getItem() instanceof ItemSlashBlade)) return; try (MSAutoCloser msac = MSAutoCloser.pushMatrix(matrixStack)) { PoseStack.Pose me = matrixStack.last(); me.pose().identity(); me.normal().identity(); matrixStack.translate(0.0f, 0.0f, -0.5f); matrixStack.mulPose(Axis.ZP.rotationDegrees(180.0f)); matrixStack.scale(1.2F, 1.0F, 1.0F); matrixStack.mulPose(Axis.XP.rotationDegrees(-mc.player.getXRot())); float partialTicks = mc.getFrameTime(); layer.render(matrixStack, bufferIn, combinedLightIn, mc.player, 0, 0, partialTicks, 0, 0, 0); } }
@Override public MmdVmdMotionMc load(ResourceLocation key) throws Exception { try { return new MmdVmdMotionMc(key); } catch (Exception e) { e.printStackTrace(); return defaultMotion; } }
@SubscribeEvent public void reload(TextureStitchEvent.Post event) { cache.invalidateAll(); try { defaultMotion = new MmdVmdMotionMc(ExMotionLocation); } catch (IOException e) { e.printStackTrace(); } catch (MmdException e) { e.printStackTrace(); } }
@Override public WavefrontObject load(ResourceLocation key) throws Exception { try { return new WavefrontObject(key); } catch (Exception e) { return defaultModel; } }
@SubscribeEvent public void reload(TextureStitchEvent.Post event) { cache.invalidateAll(); defaultModel = new WavefrontObject(DefaultResources.resourceDefaultModel); }
@SuppressWarnings("deprecation") @Override public List<BakedQuad> getQuads( @org.jetbrains.annotations.Nullable BlockState p_235039_, @org.jetbrains.annotations.Nullable Direction p_235040_, RandomSource p_235041_) { return original.getQuads(p_235039_, p_235040_, p_235041_); }
@Override public boolean useAmbientOcclusion() { return original.useAmbientOcclusion(); }
@Override public boolean isGui3d() { return original.isGui3d(); }
@Override public boolean usesBlockLight() { return false; }
@Override public boolean isCustomRenderer() { return true; }
@OnlyIn(Dist.CLIENT) public void render(VertexConsumer tessellator) { if (faces.size() > 0) { for (Face face : faces) { face.addFaceForRender(tessellator); } } }
@OnlyIn(Dist.CLIENT) public void tessellateAll(VertexConsumer tessellator) { for (GroupObject groupObject : groupObjects) { groupObject.render(tessellator); } }
@OnlyIn(Dist.CLIENT) public void tessellateOnly(VertexConsumer tessellator, String... groupNames) { for (GroupObject groupObject : groupObjects) { for (String groupName : groupNames) { if (groupName.equalsIgnoreCase(groupObject.name)) { groupObject.render(tessellator); } } } }
@OnlyIn(Dist.CLIENT) public void tessellatePart(VertexConsumer tessellator, String partName) { for (GroupObject groupObject : groupObjects) { if (partName.equalsIgnoreCase(groupObject.name)) { groupObject.render(tessellator); } } }
@OnlyIn(Dist.CLIENT) public void tessellateAllExcept(VertexConsumer tessellator, String... excludedGroupNames) { boolean exclude; for (GroupObject groupObject : groupObjects) { exclude = false; for (String excludedGroupName : excludedGroupNames) { if (excludedGroupName.equalsIgnoreCase(groupObject.name)) { exclude = true; } } if (!exclude) { groupObject.render(tessellator); } } }
private Vertex parseVertex(String line, int lineCount) throws ModelFormatException { Vertex vertex = null; if (isValidVertexLine(line)) { line = line.substring(line.indexOf(" ") + 1); String[] tokens = line.split(" "); try { if (tokens.length == 2) { return new Vertex(Float.parseFloat(tokens[0]), Float.parseFloat(tokens[1])); } else if (tokens.length == 3) { return new Vertex( Float.parseFloat(tokens[0]), Float.parseFloat(tokens[1]), Float.parseFloat(tokens[2])); } } catch (NumberFormatException e) { throw new ModelFormatException( String.format("Number formatting error at line %d", lineCount), e); } } else { throw new ModelFormatException( "Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + fileName + "' - Incorrect format"); } return vertex; }
private Vertex parseVertexNormal(String line, int lineCount) throws ModelFormatException { Vertex vertexNormal = null; if (isValidVertexNormalLine(line)) { line = line.substring(line.indexOf(" ") + 1); String[] tokens = line.split(" "); try { if (tokens.length == 3) return new Vertex( Float.parseFloat(tokens[0]), Float.parseFloat(tokens[1]), Float.parseFloat(tokens[2])); } catch (NumberFormatException e) { throw new ModelFormatException( String.format("Number formatting error at line %d", lineCount), e); } } else { throw new ModelFormatException( "Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + fileName + "' - Incorrect format"); } return vertexNormal; }
private TextureCoordinate parseTextureCoordinate(String line, int lineCount) throws ModelFormatException { TextureCoordinate textureCoordinate = null; if (isValidTextureCoordinateLine(line)) { line = line.substring(line.indexOf(" ") + 1); String[] tokens = line.split(" "); try { if (tokens.length == 2) return new TextureCoordinate( Float.parseFloat(tokens[0]), 1 - Float.parseFloat(tokens[1])); else if (tokens.length == 3) return new TextureCoordinate( Float.parseFloat(tokens[0]), 1 - Float.parseFloat(tokens[1]), Float.parseFloat(tokens[2])); } catch (NumberFormatException e) { throw new ModelFormatException( String.format("Number formatting error at line %d", lineCount), e); } } else { throw new ModelFormatException( "Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + fileName + "' - Incorrect format"); } return textureCoordinate; }
private GroupObject parseGroupObject(String line, int lineCount) throws ModelFormatException { GroupObject group = null; if (isValidGroupObjectLine(line)) { String trimmedLine = line.substring(line.indexOf(" ") + 1); if (trimmedLine.length() > 0) { group = new GroupObject(trimmedLine); } } else { throw new ModelFormatException( "Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + fileName + "' - Incorrect format"); } return group; }
private static boolean isValidVertexLine(String line) { if (vertexMatcher != null) { vertexMatcher.reset(); } vertexMatcher = vertexPattern.matcher(line); return vertexMatcher.matches(); }
private static boolean isValidVertexNormalLine(String line) { if (vertexNormalMatcher != null) { vertexNormalMatcher.reset(); } vertexNormalMatcher = vertexNormalPattern.matcher(line); return vertexNormalMatcher.matches(); }
private static boolean isValidTextureCoordinateLine(String line) { if (textureCoordinateMatcher != null) { textureCoordinateMatcher.reset(); } textureCoordinateMatcher = textureCoordinatePattern.matcher(line); return textureCoordinateMatcher.matches(); }
private static boolean isValidFace_V_VT_VN_Line(String line) { if (face_V_VT_VN_Matcher != null) { face_V_VT_VN_Matcher.reset(); } face_V_VT_VN_Matcher = face_V_VT_VN_Pattern.matcher(line); return face_V_VT_VN_Matcher.matches(); }
private static boolean isValidFace_V_VT_Line(String line) { if (face_V_VT_Matcher != null) { face_V_VT_Matcher.reset(); } face_V_VT_Matcher = face_V_VT_Pattern.matcher(line); return face_V_VT_Matcher.matches(); }
private static boolean isValidFace_V_VN_Line(String line) { if (face_V_VN_Matcher != null) { face_V_VN_Matcher.reset(); } face_V_VN_Matcher = face_V_VN_Pattern.matcher(line); return face_V_VN_Matcher.matches(); }
private static boolean isValidFace_V_Line(String line) { if (face_V_Matcher != null) { face_V_Matcher.reset(); } face_V_Matcher = face_V_Pattern.matcher(line); return face_V_Matcher.matches(); }
private static boolean isValidFaceLine(String line) { return isValidFace_V_VT_VN_Line(line) || isValidFace_V_VT_Line(line) || isValidFace_V_VN_Line(line) || isValidFace_V_Line(line); }
private static boolean isValidGroupObjectLine(String line) { if (groupObjectMatcher != null) { groupObjectMatcher.reset(); } groupObjectMatcher = groupObjectPattern.matcher(line); return groupObjectMatcher.matches(); }
public static void resetLightMap() { lightmap = 15; }
public static void resetAlphaOverride() { Face.alphaOverride = alphaNoOverride; }
public static void resetUvOperator() { Face.uvOperator = uvDefaultOperator; }
public static void resetCol() { Face.col = Color.white; }
@OnlyIn(Dist.CLIENT) public void addFaceForRender(VertexConsumer tessellator) { addFaceForRender(tessellator, 0.0005F); }
@OnlyIn(Dist.CLIENT) public void addFaceForRender(VertexConsumer tessellator, float textureOffset) { if (faceNormal == null) { faceNormal = this.calculateFaceNormal(); } float averageU = 0F; float averageV = 0F; if ((textureCoordinates != null) && (textureCoordinates.length > 0)) { for (int i = 0; i < textureCoordinates.length; ++i) { averageU += textureCoordinates[i].u * uvOperator.x() + uvOperator.z(); averageV += textureCoordinates[i].v * uvOperator.y() + uvOperator.w(); } averageU = averageU / textureCoordinates.length; averageV = averageV / textureCoordinates.length; } VertexConsumer wr = tessellator; Matrix4f transform; if (matrix != null) { PoseStack.Pose me = matrix.last(); transform = me.pose(); } else { transform = defaultTransform.get(); } for (int i = 0; i < vertices.length; ++i) { putVertex(wr, i, transform, textureOffset, averageU, averageV); } }
public Vertex calculateFaceNormal() { Vec3 v1 = new Vec3( vertices[1].x - vertices[0].x, vertices[1].y - vertices[0].y, vertices[1].z - vertices[0].z); Vec3 v2 = new Vec3( vertices[2].x - vertices[0].x, vertices[2].y - vertices[0].y, vertices[2].z - vertices[0].z); Vec3 normalVector = null; normalVector = v1.cross(v2).normalize(); return new Vertex((float) normalVector.x, (float) normalVector.y, (float) normalVector.z); }
@SubscribeEvent @OnlyIn(Dist.CLIENT) public void renderTick(RenderGuiOverlayEvent.Post event) { Minecraft mc = Minecraft.getInstance(); if (mc.player == null) return; if (!Minecraft.renderNames()) return; if (mc.screen != null) { if (!(mc.screen instanceof ChatScreen)) return; } LocalPlayer player = mc.player; long time = System.currentTimeMillis(); renderRankHud(event.getPartialTick(), player, time); }
public static void drawTexturedQuad( PoseStack poseStack, int x, int y, int u, int v, int width, int height, float zLevel) { float var7 = 0.00390625F; float var8 = 0.00390625F; RenderSystem.setShader(GameRenderer::getPositionTexShader); Tesselator tessellator = Tesselator.getInstance(); BufferBuilder wr = tessellator.getBuilder(); wr.begin(VertexFormat.Mode.QUADS, DefaultVertexFormat.POSITION_TEX); Matrix4f m = poseStack.last().pose(); wr.vertex(m, x + 0, y + height, zLevel).uv((u + 0.0f) * var7, (v + height) * var8).endVertex(); wr.vertex(m, x + width, y + height, zLevel) .uv((u + width) * var7, (v + height) * var8) .endVertex(); wr.vertex(m, x + width, y + 0, zLevel).uv((u + width) * var7, (v + 0) * var8).endVertex(); wr.vertex(m, x + 0, y + 0, zLevel).uv((u + 0) * var7, (v + 0) * var8).endVertex(); BufferUploader.drawWithShader(wr.end()); }
public static void resetCol() { col = defaultColor; }
public static void renderOverrided( ItemStack stack, WavefrontObject model, String target, ResourceLocation texture, PoseStack matrixStackIn, MultiBufferSource bufferIn, int packedLightIn) { renderOverrided( stack, model, target, texture, matrixStackIn, bufferIn, packedLightIn, BladeRenderState::getSlashBladeBlend, true); }
public static void renderOverridedColorWrite( ItemStack stack, WavefrontObject model, String target, ResourceLocation texture, PoseStack matrixStackIn, MultiBufferSource bufferIn, int packedLightIn) { renderOverrided( stack, model, target, texture, matrixStackIn, bufferIn, packedLightIn, BladeRenderState::getSlashBladeBlendColorWrite, true); }
public static void renderChargeEffect( ItemStack stack, float f, WavefrontObject model, String target, ResourceLocation texture, PoseStack matrixStackIn, MultiBufferSource bufferIn, int packedLightIn) { renderOverrided( stack, model, target, texture, matrixStackIn, bufferIn, packedLightIn, (loc) -> BladeRenderState.getChargeEffect(loc, f * 0.1F % 1.0F, f * 0.01F % 1.0F), false); }
public static void renderOverridedLuminous( ItemStack stack, WavefrontObject model, String target, ResourceLocation texture, PoseStack matrixStackIn, MultiBufferSource bufferIn, int packedLightIn) { renderOverrided( stack, model, target, texture, matrixStackIn, bufferIn, packedLightIn, BladeRenderState::getSlashBladeBlendLuminous, false); }
public static void renderOverridedLuminousDepthWrite( ItemStack stack, WavefrontObject model, String target, ResourceLocation texture, PoseStack matrixStackIn, MultiBufferSource bufferIn, int packedLightIn) { renderOverrided( stack, model, target, texture, matrixStackIn, bufferIn, packedLightIn, BladeRenderState::getSlashBladeBlendLuminousDepthWrite, false); }
public static void renderOverridedReverseLuminous( ItemStack stack, WavefrontObject model, String target, ResourceLocation texture, PoseStack matrixStackIn, MultiBufferSource bufferIn, int packedLightIn) { renderOverrided( stack, model, target, texture, matrixStackIn, bufferIn, packedLightIn, BladeRenderState::getSlashBladeBlendReverseLuminous, false); }
public static void renderOverrided( ItemStack stack, WavefrontObject model, String target, ResourceLocation texture, PoseStack matrixStackIn, MultiBufferSource bufferIn, int packedLightIn, Function<ResourceLocation, RenderType> getRenderType, boolean enableEffect) { RenderOverrideEvent event = RenderOverrideEvent.onRenderOverride( stack, model, target, texture, matrixStackIn, bufferIn); if (event.isCanceled()) return; ResourceLocation loc = event.getTexture(); RenderType rt = getRenderType.apply(loc); VertexConsumer vb = bufferIn.getBuffer(rt); Face.setCol(col); Face.setLightMap(packedLightIn); Face.setMatrix(matrixStackIn); event.getModel().tessellateOnly(vb, event.getTarget()); if (stack.hasFoil() && enableEffect) { vb = bufferIn.getBuffer( target.startsWith("item_") ? BladeRenderState.SLASHBLADE_ITEM_GLINT : BladeRenderState.SLASHBLADE_GLINT); event.getModel().tessellateOnly(vb, event.getTarget()); } Face.resetMatrix(); Face.resetLightMap(); Face.resetCol(); Face.resetAlphaOverride(); Face.resetUvOperator(); resetCol(); }
public static MSAutoCloser pushMatrix(PoseStack ms) { return new MSAutoCloser(ms); }
@Override public void close() { this.ms.popPose(); }
public static void grantCriterion(LivingEntity entity, ResourceLocation resourcelocation) { if (entity instanceof ServerPlayer) grantCriterion((ServerPlayer) entity, resourcelocation); }
public static void grantedIf(Enchantment enchantment, LivingEntity owner) { int level = EnchantmentHelper.getEnchantmentLevel(enchantment, owner); if (0 < level) { grantCriterion(owner, EXEFFECT_ENCHANTMENT.withSuffix("root")); grantCriterion( owner, EXEFFECT_ENCHANTMENT.withSuffix( ForgeRegistries.ENCHANTMENTS.getKey(enchantment).getPath())); } }
@Nullable public static EntityHitResult rayTrace( Level worldIn, Entity entityIn, Vec3 start, Vec3 end, AABB boundingBox, Predicate<Entity> selector) { return rayTrace(worldIn, entityIn, start, end, boundingBox, selector, Double.MAX_VALUE); }
public static boolean anyMatch(EnumSet<InputCommand> a, EnumSet<InputCommand> b) { return a.stream().anyMatch(cc -> b.contains(cc)); }
public static Vec3i f2i(Vec3 src) { return new Vec3i(Mth.floor(src.x), Mth.floor(src.y), Mth.floor(src.z)); }
public static Vec3i f2i(double x, double y, double z) { return new Vec3i(Mth.floor(x), Mth.floor(y), Mth.floor(z)); }
public static Matrix4f matrix4fFromArray(float[] in) { return new Matrix4f( in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], in[10], in[11], in[12], in[13], in[14], in[15]); }
public static void putVector3d(CompoundTag tag, String key, Vec3 value) { tag.put(key, newDoubleNBTList(value.x, value.y, value.z)); }
public static ListTag newDoubleNBTList(Vec3 value) { return newDoubleNBTList(value.x, value.y, value.z); }
public static ListTag newDoubleNBTList(double... numbers) { ListTag listnbt = new ListTag(); for (double dValue : numbers) { listnbt.add(DoubleTag.valueOf(dValue)); } return listnbt; }
public <T> NBTCoupler put(String key, T... value) { writeNBT(instance, key, value); return this; }
public <T> NBTCoupler get(String key, Consumer<T> dest, T... values) { return this.get(key, dest, false, values); }
public <T> NBTCoupler get(String key, Consumer<T> dest, boolean isNullable, T... values) { readNBT(this.instance, key, dest, isNullable, values); return this; }
public NBTCoupler remove(String key) { if (this.instance.hasUUID(key)) { this.instance.remove(key + "Most"); this.instance.remove(key + "Least"); } else this.instance.remove(key); return this; }
public NBTCoupler doRawCompound(String key, Consumer<CompoundTag> action) { if (this.instance.contains(key, 10)) action.accept(this.instance.getCompound(key)); return this; }
public static <T> void readNBT(CompoundTag src, String key, Consumer<T> dest, T... values) { readNBT(src, key, dest, false, values); }
public static <T> void readNBT( CompoundTag src, String key, Consumer<T> dest, boolean isNullable, T... defaultValue) { if (isNullable) dest.accept(((Optional<T>) castValue(key, src, defaultValue)).orElse(null)); else ((Optional<T>) castValue(key, src, defaultValue)).ifPresent(dest); }
public static int increase(ServerPlayer player, ResourceLocation loc, int amount) { Stat<?> stat = Stats.CUSTOM.get(loc); ServerStatsCounter stats = player.getStats(); int oldValue = stats.getValue(stat); int newValue = (int) Math.min((long) oldValue + (long) amount, MAX_VALUE); if (oldValue == newValue) { newValue--; } stats.setValue(player, stat, newValue); return newValue; }
public static void areaAttack(LivingEntity playerIn, Consumer<LivingEntity> beforeHit) { areaAttack(playerIn, beforeHit, 1.0f, true, true, false); }
public static EntitySlashEffect doSlash(LivingEntity playerIn, float roll) { return doSlash(playerIn, roll, false); }
public static EntitySlashEffect doSlash(LivingEntity playerIn, float roll, boolean mute) { return doSlash(playerIn, roll, mute, false); }
public static EntitySlashEffect doSlash( LivingEntity playerIn, float roll, boolean mute, boolean critical) { return doSlash(playerIn, roll, mute, critical, 1.0); }
public static EntitySlashEffect doSlash( LivingEntity playerIn, float roll, boolean mute, boolean critical, double damage) { return doSlash(playerIn, roll, Vec3.ZERO, mute, critical, damage); }
public static EntitySlashEffect doSlash( LivingEntity playerIn, float roll, Vec3 centerOffset, boolean mute, boolean critical, double damage) { return doSlash(playerIn, roll, centerOffset, mute, critical, damage, KnockBacks.cancel); }
public static EntitySlashEffect doSlash( LivingEntity playerIn, float roll, Vec3 centerOffset, boolean mute, boolean critical, double damage, KnockBacks knockback) { int colorCode = playerIn .getMainHandItem() .getCapability(ItemSlashBlade.BLADESTATE) .map(state -> state.getColorCode()) .orElseGet(() -> 0xFFFFFF); return doSlash(playerIn, roll, colorCode, centerOffset, mute, critical, damage, knockback); }
public static List<Entity> areaAttack( LivingEntity playerIn, Consumer<LivingEntity> beforeHit, float ratio, boolean forceHit, boolean resetHit, boolean mute) { return areaAttack(playerIn, beforeHit, ratio, forceHit, resetHit, mute, null); }
public static <E extends Entity & IShootable> List<Entity> areaAttack( E owner, Consumer<LivingEntity> beforeHit, double reach, boolean forceHit, boolean resetHit) { return areaAttack(owner, beforeHit, reach, forceHit, resetHit, null); }
public static void doManagedAttack( Consumer<Entity> attack, Entity target, boolean forceHit, boolean resetHit) { if (forceHit) target.invulnerableTime = 0; attack.accept(target); if (resetHit) target.invulnerableTime = 0; }
public static void doAttackWith( DamageSource src, float amount, Entity target, boolean forceHit, boolean resetHit) { if (target instanceof EntityAbstractSummonedSword) return; doManagedAttack( (t) -> { t.hurt(src, amount); }, target, forceHit, resetHit); }
public static void playQuickSheathSoundAction(LivingEntity entity) { if (entity.level().isClientSide()) return; entity .level() .playSound( (Player) null, entity.getX(), entity.getY(), entity.getZ(), SoundEvents.CHAIN_HIT, SoundSource.PLAYERS, 1.0F, 1.0F); }
public static Vec3 genRushOffset(LivingEntity entityIn) { return new Vec3( entityIn.getRandom().nextFloat() - 0.5f, entityIn.getRandom().nextFloat() - 0.5f, 0) .scale(2.0); }
public static <T extends Enum<T>> int convertToInt(EnumSet<T> enumSet) { return enumSet.stream().mapToInt(e -> 1 << e.ordinal()).sum(); }
public static <T extends Enum<T>> EnumSet<T> convertToEnumSet(Class<T> tclass, int ivalues) { T[] values = tclass.getEnumConstants(); EnumSet<T> set = EnumSet.noneOf(tclass); IntStream.range(0, Math.min(values.length, 32)) .filter(i -> (ivalues & (1 << i)) != 0) .forEach(i -> set.add(values[i])); return set; }
public static <T extends Enum<?>> T fromOrdinal(T[] values, int ordinal, T def) { return Arrays.stream(values).skip(ordinal).findFirst().orElse(def); }
public static double BrokendReach() { return 1.25; }
public static double BladeReach() { return 2.5; }
@Override public boolean canApplyAtEnchantingTable(ItemStack stack, Enchantment enchantment) { if (exEnchantment.contains(enchantment)) return true; return super.canApplyAtEnchantingTable(stack, enchantment); }
@Override public boolean onLeftClickEntity(ItemStack itemstack, Player playerIn, Entity entity) { Optional<ISlashBladeState> stateHolder = itemstack.getCapability(BLADESTATE).filter((state) -> !state.onClick()); stateHolder.ifPresent( (state) -> { playerIn .getCapability(INPUT_STATE) .ifPresent((s) -> s.getCommands().add(InputCommand.L_CLICK)); state.progressCombo(playerIn); playerIn .getCapability(INPUT_STATE) .ifPresent((s) -> s.getCommands().remove(InputCommand.L_CLICK)); }); return stateHolder.isPresent(); }
@Override public boolean hurtEnemy(ItemStack stack, LivingEntity target, LivingEntity attacker) { stack .getCapability(BLADESTATE) .ifPresent( (state) -> { ResourceLocation loc = state.resolvCurrentComboState(attacker); ComboState cs = ComboStateRegistry.REGISTRY.get().getValue(loc) != null ? ComboStateRegistry.REGISTRY.get().getValue(loc) : ComboStateRegistry.NONE.get(); if (MinecraftForge.EVENT_BUS.post( new SlashBladeEvent.HitEvent(stack, state, target, attacker))) return; cs.hitEffect(target, attacker); stack.hurtAndBreak(1, attacker, ItemSlashBlade.getOnBroken(stack)); }); return true; }
@Override public void readShareTag(ItemStack stack, @Nullable CompoundTag nbt) { if (nbt != null) { if (nbt.contains("bladeState")) stack .getCapability(BLADESTATE) .ifPresent(state -> state.deserializeNBT(nbt.getCompound("bladeState"))); } super.readShareTag(stack, nbt); }
@Override public boolean isBarVisible(ItemStack stack) { return false; }
private String stackDefaultDescriptionId(ItemStack stack) { String key = stack.getOrCreateTagElement("bladeState").getString("translationKey"); return !key.isBlank() ? key : super.getDescriptionId(stack); }
public boolean isDestructable(ItemStack stack) { return false; }
@Override public boolean isValidRepairItem(ItemStack toRepair, ItemStack repair) { if (Ingredient.of(ItemTags.STONE_TOOL_MATERIALS).test(repair)) { return true; } if (repair.is(SlashBladeItemTags.PROUD_SOULS)) return true; return super.isValidRepairItem(toRepair, repair); }
@OnlyIn(Dist.CLIENT) public void appendSlashArt( ItemStack stack, List<Component> tooltip, @NotNull ISlashBladeState s) { var swordType = SwordType.from(stack); if (swordType.contains(SwordType.BEWITCHED) && !swordType.contains(SwordType.SEALED)) { tooltip.add( Component.translatable("slashblade.tooltip.slash_art", s.getSlashArts().getDescription()) .withStyle(ChatFormatting.GRAY)); } }
@OnlyIn(Dist.CLIENT) public void appendRefineCount(List<Component> tooltip, @NotNull ItemStack stack) { int refine = stack.getOrCreateTagElement("bladeState").getInt("RepairCounter"); if (refine > 0) { tooltip.add( Component.translatable("slashblade.tooltip.refine", refine) .withStyle((ChatFormatting) refineColor.get(refine))); } }
@OnlyIn(Dist.CLIENT) public void appendProudSoulCount(List<Component> tooltip, @NotNull ItemStack stack) { int proudsoul = stack.getOrCreateTagElement("bladeState").getInt("proudSoul"); if (proudsoul > 0) { MutableComponent countComponent = Component.translatable("slashblade.tooltip.proud_soul", proudsoul) .withStyle(ChatFormatting.GRAY); if (proudsoul > 1000) countComponent = countComponent.withStyle(ChatFormatting.DARK_PURPLE); tooltip.add(countComponent); } }
@OnlyIn(Dist.CLIENT) public void appendKillCount(List<Component> tooltip, @NotNull ItemStack stack) { int killCount = stack.getOrCreateTagElement("bladeState").getInt("killCount"); if (killCount > 0) { MutableComponent killCountComponent = Component.translatable("slashblade.tooltip.killcount", killCount) .withStyle(ChatFormatting.GRAY); if (killCount > 1000) killCountComponent = killCountComponent.withStyle(ChatFormatting.DARK_PURPLE); tooltip.add(killCountComponent); } }
@OnlyIn(Dist.CLIENT) public void appendSpecialEffects(List<Component> tooltip, @NotNull ISlashBladeState s) { if (s.getSpecialEffects().isEmpty()) return; Minecraft mcinstance = Minecraft.getInstance(); Player player = mcinstance.player; s.getSpecialEffects() .forEach( se -> { tooltip.add( Component.translatable( "slashblade.tooltip.special_effect", SpecialEffect.getDescription(se), Component.literal(String.valueOf(SpecialEffect.getRequestLevel(se))) .withStyle( SpecialEffect.isEffective(se, player.experienceLevel) ? ChatFormatting.RED : ChatFormatting.DARK_GRAY)) .withStyle(ChatFormatting.GRAY)); }); }
@OnlyIn(Dist.CLIENT) public void appendSwordType( ItemStack stack, @Nullable Level worldIn, List<Component> tooltip, TooltipFlag flagIn) { var swordType = SwordType.from(stack); if (swordType.contains(SwordType.BEWITCHED)) { tooltip.add( Component.translatable("slashblade.sword_type.bewitched") .withStyle(ChatFormatting.DARK_PURPLE)); } else if (swordType.contains(SwordType.ENCHANTED)) { tooltip.add( Component.translatable("slashblade.sword_type.enchanted") .withStyle(ChatFormatting.DARK_AQUA)); } else { tooltip.add( Component.translatable("slashblade.sword_type.noname") .withStyle(ChatFormatting.DARK_GRAY)); } }
@Override public ICapabilityProvider initCapabilities(ItemStack stack, CompoundTag nbt) { if (!stack.isEmpty() && stack.getItem() instanceof ItemSlashBlade) return new NamedBladeStateCapabilityProvider(stack); return null; }
@Override public boolean onEntitySwing(ItemStack stack, LivingEntity entity) { return !stack .getCapability(BLADESTATE) .filter(s -> s.getLastActionTime() == entity.level().getGameTime()) .isPresent(); }
@Override public boolean hasCustomEntity(ItemStack stack) { return true; }
@Nullable @Override public Entity createEntity(Level world, Entity location, ItemStack itemstack) { BladeItemEntity e = new BladeItemEntity(SlashBlade.RegistryEvents.BladeItem, world); e.restoreFrom(location); e.init(); return e; }
@Override public InteractionResult useOn(UseOnContext context) { BlockPos blockpos = context.getClickedPos(); Direction direction = context.getClickedFace(); BlockPos blockpos1 = blockpos.relative(direction); Player playerentity = context.getPlayer(); ItemStack itemstack = context.getItemInHand(); if (playerentity != null && !this.mayPlace(playerentity, direction, itemstack, blockpos1)) { return InteractionResult.FAIL; } else { Level world = context.getLevel(); HangingEntity hangingentity = BladeStandEntity.createInstanceFromPos(world, blockpos1, direction, this); CompoundTag compoundnbt = itemstack.getTag(); if (compoundnbt != null) { EntityType.updateCustomEntityTag(world, playerentity, hangingentity, compoundnbt); } if (hangingentity.survives()) { if (!world.isClientSide) { hangingentity.playPlacementSound(); world.addFreshEntity(hangingentity); } itemstack.shrink(1); return InteractionResult.sidedSuccess(world.isClientSide); } else { return InteractionResult.CONSUME; } } }
protected boolean mayPlace(Player player, Direction dir, ItemStack stack, BlockPos pos) { if (isWallType) return !dir.getAxis().isVertical() && !player.level().isOutsideBuildHeight(pos) && player.mayUseItemAt(pos, dir, stack); else return (dir == Direction.UP) && !player.level().isOutsideBuildHeight(pos) && player.mayUseItemAt(pos, dir, stack); }
public boolean isDestructable() { return isDestructable; }
@Override public boolean isDestructable(ItemStack stack) { return this.isDestructable; }
@Override public @Nullable ICapabilityProvider initCapabilities( ItemStack stack, @Nullable CompoundTag nbt) { if (!stack.isEmpty() && stack.getItem() instanceof ItemSlashBladeDetune) return new SimpleBladeStateCapabilityProvider( stack, model, texture, baseAttack, this.getTier().getUses()); return null; }
@Override public void appendSwordType( ItemStack stack, Level worldIn, List<Component> tooltip, TooltipFlag flagIn) {}
public boolean isRemovable() { return isRemovable; }
public static boolean isEffective(SpecialEffect se, int level) { return se.requestLevel < level; }
public static boolean isEffective(ResourceLocation id, int level) { return SpecialEffectsRegistry.REGISTRY.get().getValue(id).getRequestLevel() < level; }
public String toString() { return SpecialEffectsRegistry.REGISTRY.get().getKey(this).toString(); }
@Override public int compare(Reference<SlashBladeDefinition> left, Reference<SlashBladeDefinition> right) { ResourceLocation leftKey = left.key().location(); ResourceLocation rightKey = right.key().location(); boolean checkSame = leftKey.getNamespace().equalsIgnoreCase(rightKey.getNamespace()); if (!checkSame) { if (leftKey.getNamespace().equalsIgnoreCase(SlashBlade.MODID)) return -1; if (rightKey.getNamespace().equalsIgnoreCase(SlashBlade.MODID)) return 1; } String leftName = leftKey.toString(); String rightName = rightKey.toString(); return leftName.compareToIgnoreCase(rightName); }
public static Builder newInstance() { return new Builder(); }
public Builder rootComboState(ResourceLocation comboRoot) { this.comboRoot = comboRoot; return this; }
public Builder slashArtsType(ResourceLocation specialAttackType) { this.specialAttackType = specialAttackType; return this; }
public Builder baseAttackModifier(float baseAttackModifier) { this.baseAttackModifier = baseAttackModifier; return this; }
public Builder maxDamage(int maxDamage) { this.maxDamage = maxDamage; return this; }
public Builder defaultSwordType(List<SwordType> defaultType) { this.defaultType = defaultType; return this; }
public Builder addSpecialEffect(ResourceLocation se) { this.specialEffects.add(se); return this; }
public PropertiesDefinition build() { return new PropertiesDefinition( comboRoot, specialAttackType, baseAttackModifier, maxDamage, defaultType, specialEffects); }
public boolean isSummonedSwordColorInverse() { return SummonedSwordColorInverse; }
public Builder textureName(ResourceLocation TextureName) { this.TextureName = TextureName; return this; }
public Builder modelName(ResourceLocation ModelName) { this.ModelName = ModelName; return this; }
public Builder effectColor(int SummonedSwordColor) { this.SummonedSwordColor = SummonedSwordColor; return this; }
public Builder effectColorInverse(boolean SummonedSwordColorInverse) { this.SummonedSwordColorInverse = SummonedSwordColorInverse; return this; }
public Builder standbyRenderType(CarryType standbyRenderType) { this.StandbyRenderType = standbyRenderType; return this; }
public RenderDefinition build() { return new RenderDefinition( TextureName, ModelName, SummonedSwordColor, SummonedSwordColorInverse, StandbyRenderType); }
public static ResourceLocation initStandByCommand(LivingEntity a) { return initStandByCommand(a, DEAFULT_STANDBY); }
public static ResourceLocation initStandByCommand( LivingEntity a, Map<EnumSet<InputCommand>, ResourceLocation> map) { EnumSet<InputCommand> commands = a.getCapability(CapabilityInputState.INPUT_STATE) .map((state) -> state.getCommands(a)) .orElseGet(() -> EnumSet.noneOf(InputCommand.class)); return map.entrySet().stream() .filter((entry) -> commands.containsAll(entry.getKey())) .min( Comparator.comparingInt( (entry) -> ComboStateRegistry.REGISTRY.get().getValue(entry.getValue()).getPriority())) .map((entry) -> entry.getValue()) .orElseGet(ComboStateRegistry.NONE::getId); }
public static void initDefaultStandByCommands() { DEAFULT_STANDBY.put( EnumSet.of( InputCommand.ON_GROUND, InputCommand.SNEAK, InputCommand.FORWARD, InputCommand.R_CLICK), ComboStateRegistry.RAPID_SLASH.getId()); DEAFULT_STANDBY.put( EnumSet.of(InputCommand.ON_GROUND, InputCommand.L_CLICK), ComboStateRegistry.COMBO_A1.getId()); DEAFULT_STANDBY.put( EnumSet.of( InputCommand.ON_GROUND, InputCommand.BACK, InputCommand.SNEAK, InputCommand.R_CLICK), ComboStateRegistry.UPPERSLASH.getId()); DEAFULT_STANDBY.put( EnumSet.of(InputCommand.ON_GROUND, InputCommand.R_CLICK), ComboStateRegistry.COMBO_A1.getId()); DEAFULT_STANDBY.put( EnumSet.of( InputCommand.ON_AIR, InputCommand.SNEAK, InputCommand.BACK, InputCommand.R_CLICK), ComboStateRegistry.AERIAL_CLEAVE.getId()); DEAFULT_STANDBY.put(EnumSet.of(InputCommand.ON_AIR), ComboStateRegistry.AERIAL_RAVE_A1.getId()); }
public void holdAction(LivingEntity user) { holdAction.accept(user); }
public void tickAction(LivingEntity user) { tickAction.accept(user); }
public void hitEffect(LivingEntity target, LivingEntity attacker) { hitEffect.accept(target, attacker); }
public void clickAction(LivingEntity user) { clickAction.accept(user); }
public SlashArts.ArtsType releaseAction(LivingEntity user, int elapsed) { return this.releaseAction.apply(user, elapsed); }
@Nonnull public ComboState checkTimeOut(LivingEntity living, float msec) { return this.getTimeoutMS() < msec ? ComboStateRegistry.REGISTRY.get().getValue(this.nextOfTimeout.apply(living)) : this; }
public static SlashArts.ArtsType releaseActionQuickCharge(LivingEntity user, Integer elapsed) { int level = EnchantmentHelper.getEnchantmentLevel(Enchantments.SOUL_SPEED, user); if (elapsed <= 3 + level) { AdvancementHelper.grantedIf(Enchantments.SOUL_SPEED, user); AdvancementHelper.grantCriterion(user, AdvancementHelper.ADVANCEMENT_QUICK_CHARGE); return SlashArts.ArtsType.Jackpot; } else return SlashArts.ArtsType.Fail; }
public static TimeoutNext buildFromFrame( int timeoutFrame, Function<LivingEntity, ResourceLocation> next) { return new TimeoutNext((int) TimeValueHelper.getTicksFromFrames(timeoutFrame), next); }
@Override public ResourceLocation apply(LivingEntity livingEntity) { long elapsed = ComboState.getElapsed(livingEntity); if (timeout <= elapsed) { return next.apply(livingEntity); } else { return livingEntity .getMainHandItem() .getCapability(ItemSlashBlade.BLADESTATE) .map((state) -> state.getComboSeq()) .orElse(SlashBlade.prefix("none")); } }
public TimeLineTickActionBuilder put(int ticks, Consumer<LivingEntity> action) { timeLine.put(ticks, action); return this; }
public TimeLineTickAction build() { return new TimeLineTickAction(timeLine); }
@Override public void accept(LivingEntity livingEntity) { long elapsed = getElapsed(livingEntity); if (offset < 0) { offset = elapsed; } elapsed -= offset; Consumer<LivingEntity> action = timeLine.getOrDefault((int) elapsed, this::defaultConsumer); action.accept(livingEntity); }
public ComboState build() { return new ComboState(this); }
public Builder startAndEnd(int start, int end) { this.start = start; this.end = end; return this; }
public Builder priority(int priority) { this.priority = priority; return this; }
public Builder speed(float speed) { this.speed = speed; return this; }
public Builder loop() { this.loop = true; return this; }
public Builder aerial() { this.aerial = true; return this; }
public Builder timeout(int timeout) { this.timeout = timeout; return this; }
public Builder motionLoc(ResourceLocation motionLoc) { this.motionLoc = motionLoc; return this; }
public Builder next(Function<LivingEntity, ResourceLocation> next) { this.next = next; return this; }
public Builder nextOfTimeout(Function<LivingEntity, ResourceLocation> nextOfTimeout) { this.nextOfTimeout = nextOfTimeout; return this; }
public Builder addHoldAction(Consumer<LivingEntity> holdAction) { this.holdAction = this.holdAction.andThen(holdAction); return this; }
public Builder addTickAction(Consumer<LivingEntity> tickAction) { this.tickAction = this.tickAction.andThen(tickAction); return this; }
public Builder addHitEffect(BiConsumer<LivingEntity, LivingEntity> hitEffect) { this.hitEffect = this.hitEffect.andThen(hitEffect); return this; }
public Builder clickAction(Consumer<LivingEntity> clickAction) { this.clickAction = clickAction; return this; }
public Builder releaseAction(BiFunction<LivingEntity, Integer, SlashArts.ArtsType> clickAction) { this.releaseAction = clickAction; return this; }
public static void doSlash( LivingEntity playerIn, float roll, int lifetime, Vec3 centerOffset, boolean critical, double damage, float minSpeed, float maxSpeed, int count) { doSlash( playerIn, roll, lifetime, centerOffset, critical, damage, KnockBacks.cancel, minSpeed, maxSpeed, count); }
public static void doSlash( LivingEntity playerIn, float roll, int lifetime, Vec3 centerOffset, boolean critical, double damage, KnockBacks knockback, float minSpeed, float maxSpeed, int count) { int colorCode = playerIn .getMainHandItem() .getCapability(ItemSlashBlade.BLADESTATE) .map(state -> state.getColorCode()) .orElse(0xFF3333FF); doSlash( playerIn, roll, lifetime, colorCode, centerOffset, critical, damage, knockback, minSpeed, maxSpeed, count); }
public ResourceLocation doArts(ArtsType type, LivingEntity user) { switch (type) { case Jackpot: return getComboStateJust(user); case Success: return getComboState(user); case Super: return getComboStateSuper().apply(user); default: break; } return ComboStateRegistry.NONE.getId(); }
public String toString() { return SlashArtsRegistry.REGISTRY.get().getKey(this).toString(); }
public static EntityDrive doSlash( LivingEntity playerIn, float roll, int lifetime, Vec3 centerOffset, boolean critical, double damage, float speed) { return doSlash( playerIn, roll, lifetime, centerOffset, critical, damage, KnockBacks.cancel, speed); }
public static EntityDrive doSlash( LivingEntity playerIn, float roll, int lifetime, Vec3 centerOffset, boolean critical, double damage, KnockBacks knockback, float speed) { int colorCode = playerIn .getMainHandItem() .getCapability(ItemSlashBlade.BLADESTATE) .map(state -> state.getColorCode()) .orElse(0xFF3333FF); return doSlash( playerIn, roll, lifetime, colorCode, centerOffset, critical, damage, knockback, speed); }
public static EntityJudgementCut doJudgementCutJust(LivingEntity user) { EntityJudgementCut sa = doJudgementCut(user); sa.setIsCritical(true); return sa; }
public static void doJudgementCutSuper(LivingEntity owner) { doJudgementCutSuper(owner, null); }
public static void doJudgementCutSuper(LivingEntity owner, List<Entity> exclude) { Level level = owner.level(); ItemStack stack = owner.getMainHandItem(); List<Entity> founds = TargetSelector.getTargettableEntitiesWithinAABB( level, owner, owner.getBoundingBox().inflate(48.0D), TargetSelector.getResolvedReach(owner) + 32D); if (exclude != null) founds.removeAll(exclude); for (Entity entity : founds) { if (entity instanceof LivingEntity) { ((LivingEntity) entity) .addEffect(new MobEffectInstance(MobEffects.MOVEMENT_SLOWDOWN, 40, 10)); EntityJudgementCut judgementCut = new EntityJudgementCut(SlashBlade.RegistryEvents.JudgementCut, level); judgementCut.setPos(entity.getX(), entity.getY(), entity.getZ()); judgementCut.setOwner(owner); stack .getCapability(ItemSlashBlade.BLADESTATE) .ifPresent(state -> judgementCut.setColor(state.getColorCode())); owner .getCapability(ConcentrationRankCapabilityProvider.RANK_POINT) .ifPresent(rank -> judgementCut.setRank(rank.getRankLevel(level.getGameTime()))); level.addFreshEntity(judgementCut); } } level.playSound( owner, owner.blockPosition(), SoundEvents.ENDERMAN_TELEPORT, SoundSource.PLAYERS, 1.0F, 1.0F); }
@SuppressWarnings("deprecation") @Inject( at = @At("HEAD"), method = "getCollisionShape(Lnet/minecraft/world/level/BlockGetter;Lnet/minecraft/core/BlockPos;Lnet/minecraft/world/phys/shapes/CollisionContext;)Lnet/minecraft/world/phys/shapes/VoxelShape;", cancellable = true, remap = true) public void getCollisionShape( BlockGetter p_60743_, BlockPos p_60744_, CollisionContext p_60745_, CallbackInfoReturnable<VoxelShape> callback) { if (!(asState().is(BlockTags.LEAVES))) return; if (p_60745_.isDescending()) return; if (!(p_60745_ instanceof EntityCollisionContext)) return; if (!(((EntityCollisionContext) p_60745_).getEntity() instanceof Player)) return; ItemStack itemStack = ((Player) ((EntityCollisionContext) p_60745_).getEntity()).getMainHandItem(); if (!(itemStack.getItem() instanceof ItemSlashBlade)) return; callback.setReturnValue( Blocks.SCAFFOLDING.getCollisionShape( Blocks.SCAFFOLDING.defaultBlockState(), p_60743_, p_60744_, p_60745_)); callback.cancel(); }
@SuppressWarnings("deprecation") @Inject( at = @At("HEAD"), method = "getVisualShape(Lnet/minecraft/world/level/BlockGetter;Lnet/minecraft/core/BlockPos;Lnet/minecraft/world/phys/shapes/CollisionContext;)Lnet/minecraft/world/phys/shapes/VoxelShape;", cancellable = true, remap = true) public void getVisualShape( BlockGetter p_60743_, BlockPos p_60744_, CollisionContext p_60745_, CallbackInfoReturnable<VoxelShape> callback) { if (!(asState().is(BlockTags.LEAVES))) return; callback.setReturnValue( Blocks.SCAFFOLDING.getVisualShape( Blocks.SCAFFOLDING.defaultBlockState(), p_60743_, p_60744_, p_60745_)); callback.cancel(); }
@Shadow protected BlockState asState() { throw new IllegalStateException("Mixin failed to shadow asState()"); }
private void rodaiRecipe( ResourceLocation rodai, ItemLike sword, Consumer<FinishedRecipe> consumer) { SlashBladeShapedRecipeBuilder.shaped(rodai) .pattern(" P") .pattern(" B ") .pattern("WS ") .define( 'B', SlashBladeIngredient.of( SBItems.slashblade_silverbamboo, RequestDefinition.Builder.newInstance() .killCount(100) .addSwordType(SwordType.BROKEN) .build())) .define('W', Ingredient.of(sword)) .define('S', Ingredient.of(Tags.Items.STRING)) .define('P', Ingredient.of(SBItems.proudsoul_crystal)) .unlockedBy( getHasName(SBItems.slashblade_silverbamboo), has(SBItems.slashblade_silverbamboo)) .save(consumer); }
private void rodaiAdvRecipe( ResourceLocation rodai, ItemLike sword, Consumer<FinishedRecipe> consumer) { SlashBladeShapedRecipeBuilder.shaped(rodai) .pattern(" P") .pattern(" B ") .pattern("WS ") .define( 'B', SlashBladeIngredient.of( SBItems.slashblade_silverbamboo, RequestDefinition.Builder.newInstance() .killCount(100) .addSwordType(SwordType.BROKEN) .build())) .define('W', Ingredient.of(sword)) .define('S', Ingredient.of(Tags.Items.STRING)) .define('P', Ingredient.of(SBItems.proudsoul_trapezohedron)) .unlockedBy( getHasName(SBItems.slashblade_silverbamboo), has(SBItems.slashblade_silverbamboo)) .save(consumer); }
@Override protected void addTags(Provider lookupProvider) { this.tag(EntityTypeTags.ATTACKABLE_BLACKLIST) .add(EntityType.VILLAGER) .addOptional(new ResourceLocation("touhou_little_maid", "maid")); }
private static ResourceKey<SlashBladeDefinition> register(String id) { ResourceKey<SlashBladeDefinition> loc = ResourceKey.create(SlashBladeDefinition.REGISTRY_KEY, SlashBlade.prefix(id)); return loc; }
public static void registerAll(BootstapContext<EntityDropEntry> bootstrap) { bootstrap.register( ENDER_DRAGON_YAMATO, new EntityDropEntry( new ResourceLocation("minecraft", "ender_dragon"), SlashBlade.prefix("yamato_broken"), 1.0F, false, true, new Vec3(0F, 60F, 0F))); bootstrap.register( WITHER_SANGE, new EntityDropEntry( new ResourceLocation("minecraft", "wither"), SlashBlade.prefix("sange"), 0.3F, true)); bootstrap.register( MINOTAUR_YASHA, new EntityDropEntry( new ResourceLocation("twilightforest", "minotaur"), SlashBlade.prefix("yasha"), 0.05F, true)); bootstrap.register( MINOSHROOM_YASHA_TRUE, new EntityDropEntry( new ResourceLocation("twilightforest", "minoshroom"), SlashBlade.prefix("yasha_true"), 0.2F, true)); bootstrap.register( NAGA_AGITO, new EntityDropEntry( new ResourceLocation("twilightforest", "naga"), SlashBlade.prefix("agito_rust"), 0.3F, false)); bootstrap.register( HYDRA_OROTIAGITO, new EntityDropEntry( new ResourceLocation("twilightforest", "hydra"), SlashBlade.prefix("orotiagito_rust"), 0.3F, false)); }
private static ResourceKey<EntityDropEntry> register(String id) { ResourceKey<EntityDropEntry> loc = ResourceKey.create(EntityDropEntry.REGISTRY_KEY, SlashBlade.prefix(id)); return loc; }
@Override public boolean isDefaultBewitched() { return false; }
@Override public boolean onClick() { return _onClick; }
@Override public boolean isBroken() { return isBroken; }
@Override public boolean isSealed() { return isSealed; }
@Override public boolean isDefaultBewitched() { return isDefaultBewitched; }
@Override public boolean isEffectColorInverse() { return effectColorInverse; }
@Override public boolean hasChangedActiveState() { return this.isChangedActiveState; }
@Override public boolean addSpecialEffect(ResourceLocation se) { if (SpecialEffectsRegistry.REGISTRY.get().containsKey(se)) { return this.specialEffects.add(se); } return false; }
@Override public boolean removeSpecialEffect(ResourceLocation se) { return this.specialEffects.remove(se); }
@Override public boolean hasSpecialEffect(ResourceLocation se) { if (SpecialEffectsRegistry.REGISTRY.get().containsKey(se)) { return this.specialEffects.contains(se); } this.specialEffects.remove(se); return true; }
@Override public CompoundTag serializeNBT() { return this.state.orElseGet(() -> new SlashBladeState(blade)).serializeNBT(); }
@Override public void deserializeNBT(CompoundTag inTag) { state.ifPresent(instance -> instance.deserializeNBT(inTag)); }
default boolean isCharged(LivingEntity user) { if (!(SwordType.from(user.getMainHandItem()).contains(SwordType.ENCHANTED))) return false; if (this.isBroken() || this.isSealed()) return false; int elapsed = user.getTicksUsingItem(); return getFullChargeTicks(user) < elapsed; }
default ResourceLocation progressCombo(LivingEntity user, boolean isVirtual) { ResourceLocation currentloc = resolvCurrentComboState(user); ComboState current = ComboStateRegistry.REGISTRY.get().getValue(currentloc); if (current == null) return ComboStateRegistry.NONE.getId(); ResourceLocation next = current.getNext(user); if (!next.equals(ComboStateRegistry.NONE.getId()) && next.equals(currentloc)) return ComboStateRegistry.NONE.getId(); ResourceLocation rootNext = ComboStateRegistry.REGISTRY.get().getValue(getComboRoot()).getNext(user); ComboState nextCS = ComboStateRegistry.REGISTRY.get().getValue(next); ComboState rootNextCS = ComboStateRegistry.REGISTRY.get().getValue(rootNext); ResourceLocation resolved = nextCS.getPriority() <= rootNextCS.getPriority() ? next : rootNext; if (!isVirtual) { this.updateComboSeq(user, resolved); } return resolved; }
default ResourceLocation progressCombo(LivingEntity user) { return progressCombo(user, false); }
default void updateComboSeq(LivingEntity entity, ResourceLocation loc) { MinecraftForge.EVENT_BUS.post(new BladeMotionEvent(entity, loc)); this.setComboSeq(loc); this.setLastActionTime(entity.level().getGameTime()); ComboState cs = ComboStateRegistry.REGISTRY.get().getValue(loc); cs.clickAction(entity); }
default ResourceLocation resolvCurrentComboState(LivingEntity user) { if (!(user.getMainHandItem().getItem() instanceof ItemSlashBlade)) return ComboStateRegistry.NONE.getId(); return resolvCurrentComboStateTicks(user).getValue(); }
default void sendChanges(Entity entityIn) { if (!entityIn.level().isClientSide() && this.hasChangedActiveState()) { ActiveStateSyncMessage msg = new ActiveStateSyncMessage(); msg.activeTag = this.getActiveState(); msg.id = entityIn.getId(); NetworkManager.INSTANCE.send( PacketDistributor.TRACKING_ENTITY_AND_SELF.with(() -> entityIn), msg); this.setHasChangedActiveState(false); } }
public static void register(RegisterCapabilitiesEvent event) { event.register(ISlashBladeState.class); }
@Override public CompoundTag serializeNBT() { CompoundTag baseTag = new CompoundTag(); state.ifPresent( instance -> NBTHelper.getNBTCoupler(baseTag).put("StunTimeout", instance.getStunTimeOut())); return baseTag; }
@Override public void deserializeNBT(CompoundTag nbt) { state.ifPresent( instance -> NBTHelper.getNBTCoupler(nbt).get("StunTimeout", instance::setStunTimeOut)); }
default void clearStunTimeOut() { setStunTimeOut(-1); }
default boolean isStun(long now) { return isStun(now, false); }
default void clearUntouchableTimeOut(boolean isVirtual) { if (!isVirtual) setUntouchableTimeOut(Optional.empty()); }
default boolean isUntouchable(long now) { return isUntouchable(now, false); }
default void storeEffects(Collection<MobEffect> effects) { this.getEffectSet().clear(); this.getEffectSet().addAll(effects); }
default boolean checkCanAvoid(long now) { if (getAvoidCount() < AVOID_MAX) return true; return !getAvoidCooldown().filter(ct -> now < ct).isPresent(); }
public static void register(RegisterCapabilitiesEvent event) { event.register(IMobEffectState.class); }
@Override public boolean hasUntouchableWorked() { return this.hasWorked; }
@Override public void storeHealth(float health) { this.storedHealth = health; }
public static void register(RegisterCapabilitiesEvent event) { event.register(IInputState.class); }
@Override public CompoundTag serializeNBT() { CompoundTag baseTag = new CompoundTag(); state.ifPresent( instance -> { baseTag.putInt(KEY, EnumSetConverter.convertToInt(instance.getCommands())); }); return baseTag; }
@Override public void deserializeNBT(CompoundTag baseTag) { state.ifPresent( instance -> { instance .getCommands() .addAll(EnumSetConverter.convertToEnumSet(InputCommand.class, baseTag.getInt(KEY))); }); }
@Override public CompoundTag serializeNBT() { CompoundTag baseTag = new CompoundTag(); state.ifPresent( instance -> { NBTHelper.getNBTCoupler(baseTag) .put("rawPoint", instance.getRawRankPoint()) .put("lastupdate", instance.getLastUpdate()); }); return baseTag; }
@Override public void deserializeNBT(CompoundTag baseTag) { state.ifPresent( instance -> NBTHelper.getNBTCoupler((CompoundTag) baseTag) .get("rawPoint", instance::setRawRankPoint) .get("lastupdate", instance::setLastUpdte)); ; }
public static void register(RegisterCapabilitiesEvent event) { event.register(IConcentrationRank.class); }
default long reductionLimitter(long reduction) { long limit = getRawRankPoint() % getUnitCapacity(); return Math.min(reduction, limit); }
default void addRankPoint(LivingEntity user, long point) { long time = user.level().getGameTime(); ConcentrationRanks oldRank = getRank(time); this.setRawRankPoint(Math.min(Math.max(0, point + getRankPoint(time)), getMaxCapacity())); this.setLastUpdte(time); if (oldRank.level < getRank(time).level) this.setLastRankRise(time); if (user instanceof ServerPlayer && !user.level().isClientSide()) { if (((ServerPlayer) user).connection == null) return; RankSyncMessage msg = new RankSyncMessage(); msg.rawPoint = this.getRawRankPoint(); NetworkManager.INSTANCE.send(PacketDistributor.PLAYER.with(() -> (ServerPlayer) user), msg); } }
default void addRankPoint(DamageSource src) { if (!(src.getEntity() instanceof LivingEntity)) return; LivingEntity user = (LivingEntity) src.getEntity(); ItemStack stack = user.getMainHandItem(); Optional<ResourceLocation> combo = stack.getCapability(ItemSlashBlade.BLADESTATE).map(s -> s.resolvCurrentComboState(user)); float modifier = combo.map(c -> getRankPointModifier(c)).orElse(getRankPointModifier(src)); addRankPoint(user, (long) (modifier * getUnitCapacity())); }
public static RequestDefinition fromJSON(JsonObject json) { return CODEC .parse(JsonOps.INSTANCE, json) .resultOrPartial( msg -> { SlashBlade.LOGGER.error("Failed to parse : {}", msg); }) .orElseGet(Builder.newInstance()::build); }
public JsonElement toJson() { return CODEC .encodeStart(JsonOps.INSTANCE, this) .resultOrPartial( msg -> { SlashBlade.LOGGER.error("Failed to encode : {}", msg); }) .orElseThrow(); }
public void toNetwork(FriendlyByteBuf buffer) { buffer.writeResourceLocation(this.getName()); buffer.writeInt(this.getProudSoulCount()); buffer.writeInt(this.getKillCount()); buffer.writeInt(this.getRefineCount()); buffer.writeCollection( this.getEnchantments(), (buf, request) -> { buf.writeResourceLocation(request.getEnchantmentID()); buf.writeByte(request.getEnchantmentLevel()); }); buffer.writeCollection( this.getDefaultType(), (buf, request) -> { buf.writeUtf(request.name().toLowerCase()); }); }
public static RequestDefinition fromNetwork(FriendlyByteBuf buffer) { ResourceLocation name = buffer.readResourceLocation(); int proud = buffer.readInt(); int kill = buffer.readInt(); int refine = buffer.readInt(); var enchantments = buffer.readList( (buf) -> { return new EnchantmentDefinition(buf.readResourceLocation(), buf.readByte()); }); var types = buffer.readList((buf) -> SwordType.valueOf(buf.readUtf().toUpperCase())); return new RequestDefinition(name, proud, kill, refine, enchantments, types); }
public void initItemStack(ItemStack blade) { var state = blade.getCapability(ItemSlashBlade.BLADESTATE).orElse(new SlashBladeState(blade)); if (!this.name.equals(SlashBlade.prefix("none"))) state.setTranslationKey(getTranslationKey()); state.setProudSoulCount(getProudSoulCount()); state.setKillCount(getKillCount()); state.setRefine(getRefineCount()); this.getEnchantments() .forEach( enchantment -> blade.enchant( ForgeRegistries.ENCHANTMENTS.getValue(enchantment.getEnchantmentID()), enchantment.getEnchantmentLevel())); this.defaultType.forEach( type -> { switch (type) { case BEWITCHED -> state.setDefaultBewitched(true); case BROKEN -> { blade.setDamageValue(blade.getMaxDamage() - 1); state.setBroken(true); } case SEALED -> state.setSealed(true); default -> {} } }); blade.getOrCreateTag().put("bladeState", state.serializeNBT()); }
public Builder name(ResourceLocation name) { this.name = name; return this; }
public Builder proudSoul(int proudCount) { this.proudCount = proudCount; return this; }
public Builder killCount(int killCount) { this.killCount = killCount; return this; }
public Builder refineCount(int refineCount) { this.refineCount = refineCount; return this; }
public Builder addEnchantment(EnchantmentDefinition... enchantments) { for (var enchantment : enchantments) this.enchantments.add(enchantment); return this; }
public Builder addSwordType(SwordType... types) { for (var type : types) this.defaultType.add(type); return this; }
public RequestDefinition build() { return new RequestDefinition( name, proudCount, killCount, refineCount, enchantments, defaultType); }
@Override @NotNull public U fromJson(@NotNull ResourceLocation id, @NotNull JsonObject json) { if (!json.has("result")) { JsonObject object = new JsonObject(); object.addProperty("item", "slashblade:slashblade"); json.add("result", object); } T recipe = compose().fromJson(id, json); if (json.has("blade")) { ResourceLocation output = new ResourceLocation(GsonHelper.getAsString(json, "blade")); return converter().apply(recipe, output); } return converter() .apply( recipe, new ResourceLocation(GsonHelper.getAsString(json.getAsJsonObject("result"), "item"))); }
@Override @NotNull public U fromNetwork(@NotNull ResourceLocation id, @NotNull FriendlyByteBuf buf) { T recipe = compose().fromNetwork(id, buf); if (buf.readBoolean()) return converter().apply(recipe, buf.readResourceLocation()); return converter().apply(recipe, null); }
@Override public void toNetwork(@NotNull FriendlyByteBuf buf, @NotNull U recipe) { compose().toNetwork(buf, recipe); if (recipe instanceof SlashBladeShapedRecipe bladeRecipe) { boolean hasName = bladeRecipe.getOutputBlade() != null; buf.writeBoolean(hasName); if (hasName) buf.writeResourceLocation(bladeRecipe.getOutputBlade()); } else buf.writeBoolean(false); }
private void updateEnchantment(ItemStack result, ItemStack ingredient) { var newItemEnchants = result.getAllEnchantments(); var oldItemEnchants = ingredient.getAllEnchantments(); for (Enchantment enchantIndex : oldItemEnchants.keySet()) { Enchantment enchantment = enchantIndex; int destLevel = newItemEnchants.containsKey(enchantIndex) ? newItemEnchants.get(enchantIndex) : 0; int srcLevel = oldItemEnchants.get(enchantIndex); srcLevel = Math.max(srcLevel, destLevel); srcLevel = Math.min(srcLevel, enchantment.getMaxLevel()); boolean canApplyFlag = enchantment.canApplyAtEnchantingTable(result); if (canApplyFlag) { for (Enchantment curEnchantIndex : newItemEnchants.keySet()) { if (curEnchantIndex != enchantIndex && !enchantment.isCompatibleWith(curEnchantIndex) ) { canApplyFlag = false; break; } } if (canApplyFlag) newItemEnchants.put(enchantIndex, Integer.valueOf(srcLevel)); } } EnchantmentHelper.setEnchantments(newItemEnchants, result); }
public static SlashBladeShapedRecipeBuilder shaped(ResourceLocation blade) { return shaped(SBItems.slashblade, 1).blade(blade); }
public static SlashBladeShapedRecipeBuilder shaped(ItemLike result) { return shaped(result, 1); }
public static SlashBladeShapedRecipeBuilder shaped(ItemLike result, int count) { return new SlashBladeShapedRecipeBuilder(result, count); }
public SlashBladeShapedRecipeBuilder define(Character key, TagKey<Item> tag) { return this.define(key, Ingredient.of(tag)); }
public SlashBladeShapedRecipeBuilder define(Character key, ItemLike tag) { return this.define(key, Ingredient.of(tag)); }
public SlashBladeShapedRecipeBuilder blade(ResourceLocation blade) { this.blade = blade; return this; }
public SlashBladeShapedRecipeBuilder define(Character key, Ingredient ingredient) { if (this.key.containsKey(key)) { throw new IllegalArgumentException("Symbol '" + key + "' is already defined!"); } else if (key == ' ') { throw new IllegalArgumentException( "Symbol ' ' (whitespace) is reserved and cannot be defined"); } else { this.key.put(key, ingredient); return this; } }
public SlashBladeShapedRecipeBuilder pattern(String pattern) { if (!this.rows.isEmpty() && pattern.length() != this.rows.get(0).length()) { throw new IllegalArgumentException("Pattern must be the same width on every line!"); } else { this.rows.add(pattern); return this; } }
public SlashBladeShapedRecipeBuilder unlockedBy(String key, CriterionTriggerInstance trigger) { this.advancement.addCriterion(key, trigger); return this; }
public SlashBladeShapedRecipeBuilder group(@Nullable String group) { this.group = group; return this; }
public SlashBladeShapedRecipeBuilder showNotification(boolean show) { this.showNotification = show; return this; }
@Override public void save(Consumer<FinishedRecipe> consumer) { this.save( consumer, this.blade != null ? this.blade : ForgeRegistries.ITEMS.getKey(this.getResult())); }
public void save(Consumer<FinishedRecipe> consumer, ResourceLocation id) { this.ensureValid(id); this.advancement .parent(ROOT_RECIPE_ADVANCEMENT) .addCriterion("has_the_recipe", RecipeUnlockedTrigger.unlocked(id)) .rewards(AdvancementRewards.Builder.recipe(id)) .requirements(RequirementsStrategy.OR); consumer.accept( new SlashBladeShapedRecipeBuilder.Result( id, this.result, this.count, this.blade, this.group == null ? "" : this.group, this.rows, this.key, this.advancement, id.withPrefix("recipes/" + this.category.getFolderName() + "/"), this.showNotification)); }
public void serializeRecipeData(JsonObject json) { super.serializeRecipeData(json); if (!this.group.isEmpty()) { json.addProperty("group", this.group); } JsonArray jsonarray = new JsonArray(); for (String s : this.pattern) { jsonarray.add(s); } json.add("pattern", jsonarray); JsonObject jsonobject = new JsonObject(); for (Map.Entry<Character, Ingredient> entry : this.key.entrySet()) { jsonobject.add(String.valueOf(entry.getKey()), entry.getValue().toJson()); } json.add("key", jsonobject); JsonObject jsonobject1 = new JsonObject(); jsonobject1.addProperty("item", ForgeRegistries.ITEMS.getKey(this.result).toString()); if (this.count > 1) { jsonobject1.addProperty("count", this.count); } json.add("result", jsonobject1); if (this.bladeId != null) json.addProperty("blade", this.bladeId.toString()); json.addProperty("show_notification", this.showNotification); }
@Nullable public JsonObject serializeAdvancement() { return this.advancement.serializeToJson(); }
public ProudsoulShapelessRecipe fromJson(ResourceLocation p_44290_, JsonObject p_44291_) { String s = GsonHelper.getAsString(p_44291_, "group", ""); @SuppressWarnings("deprecation") CraftingBookCategory craftingbookcategory = CraftingBookCategory.CODEC.byName( GsonHelper.getAsString(p_44291_, "category", (String) null), CraftingBookCategory.MISC); NonNullList<Ingredient> nonnulllist = itemsFromJson(GsonHelper.getAsJsonArray(p_44291_, "ingredients")); if (nonnulllist.isEmpty()) { throw new JsonParseException("No ingredients for shapeless recipe"); } else if (nonnulllist.size() > 3 * 3) { throw new JsonParseException( "Too many ingredients for shapeless recipe. The maximum is " + (3 * 3)); } else { ItemStack itemstack = ShapedRecipe.itemStackFromJson(GsonHelper.getAsJsonObject(p_44291_, "result")); return new ProudsoulShapelessRecipe( p_44290_, s, craftingbookcategory, itemstack, nonnulllist); } }
private static NonNullList<Ingredient> itemsFromJson(JsonArray p_44276_) { NonNullList<Ingredient> nonnulllist = NonNullList.create(); for (int i = 0; i < p_44276_.size(); ++i) { Ingredient ingredient = Ingredient.fromJson(p_44276_.get(i), false); nonnulllist.add(ingredient); } return nonnulllist; }
public ProudsoulShapelessRecipe fromNetwork(ResourceLocation p_44293_, FriendlyByteBuf p_44294_) { String s = p_44294_.readUtf(); CraftingBookCategory craftingbookcategory = p_44294_.readEnum(CraftingBookCategory.class); int i = p_44294_.readVarInt(); NonNullList<Ingredient> nonnulllist = NonNullList.withSize(i, Ingredient.EMPTY); for (int j = 0; j < nonnulllist.size(); ++j) { nonnulllist.set(j, Ingredient.fromNetwork(p_44294_)); } ItemStack itemstack = p_44294_.readItem(); return new ProudsoulShapelessRecipe(p_44293_, s, craftingbookcategory, itemstack, nonnulllist); }
public static SlashBladeIngredient of(ItemLike item, RequestDefinition request) { return new SlashBladeIngredient(Set.of(item.asItem()), request); }
public static SlashBladeIngredient of(RequestDefinition request) { return new SlashBladeIngredient(Set.of(SBItems.slashblade), request); }
@Override public boolean test(ItemStack input) { if (input == null) return false; return items.contains(input.getItem()) && this.request.test(input); }
@Override public boolean isSimple() { return false; }
@Override public JsonElement toJson() { JsonObject json = new JsonObject(); json.addProperty("type", CraftingHelper.getID(Serializer.INSTANCE).toString()); if (items.size() == 1) { json.addProperty("item", ForgeRegistries.ITEMS.getKey(items.iterator().next()).toString()); } else { JsonArray items = new JsonArray(); this.items.stream() .map(ForgeRegistries.ITEMS::getKey) .sorted() .forEach(name -> items.add(name.toString())); json.add("items", items); } json.add("request", this.request.toJson()); return json; }
@Override public SlashBladeIngredient parse(FriendlyByteBuf buffer) { Set<Item> items = Stream.generate(() -> buffer.readRegistryIdUnsafe(ForgeRegistries.ITEMS)) .limit(buffer.readVarInt()) .collect(Collectors.toSet()); RequestDefinition request = RequestDefinition.fromNetwork(buffer); return new SlashBladeIngredient(items, request); }
@Override public SlashBladeIngredient parse(JsonObject json) { Set<Item> items; if (json.has("item")) items = Set.of(CraftingHelper.getItem(GsonHelper.getAsString(json, "item"), true)); else if (json.has("items")) { ImmutableSet.Builder<Item> builder = ImmutableSet.builder(); JsonArray itemArray = GsonHelper.getAsJsonArray(json, "items"); for (int i = 0; i < itemArray.size(); i++) { builder.add( CraftingHelper.getItem( GsonHelper.convertToString(itemArray.get(i), "items[" + i + ']'), true)); } items = builder.build(); } else throw new JsonSyntaxException("Must set either 'item' or 'items'"); var request = RequestDefinition.fromJSON(json.getAsJsonObject("request")); return new SlashBladeIngredient(items, request); }
@Override public void write(FriendlyByteBuf buffer, SlashBladeIngredient ingredient) { buffer.writeVarInt(ingredient.items.size()); for (Item item : ingredient.items) buffer.writeRegistryIdUnsafe(ForgeRegistries.ITEMS, item); ingredient.request.toNetwork(buffer); }
@Override public boolean isCharged() { return isCharged; }
@Override public boolean isDestructable() { return isDestructable; }
@Override public Dimension render(Graphics2D graphics) { panelComponent.getChildren().clear(); panelComponent.setPreferredSize(new Dimension(175, 0)); panelComponent .getChildren() .add(TitleComponent.builder().text("Scurrius Spine Redeemer").build()); LineComponent spinesRedeemed = buildLine("Spines Redeemed: ", String.valueOf(plugin.spinesRedeemed)); LineComponent timeout = buildLine("Started: ", String.valueOf(plugin.started)); LineComponent skill = buildLine("Skill: ", plugin.config.spineSkill().name()); panelComponent.getChildren().add(timeout); panelComponent.getChildren().add(spinesRedeemed); panelComponent.getChildren().add(skill); return panelComponent.render(graphics); }
private LineComponent buildLine(String left, String right) { return LineComponent.builder() .left(left) .right(right) .leftColor(Color.WHITE) .rightColor(Color.YELLOW) .build(); }
private void renderTile( Graphics2D graphics, LocalPoint dest, Color color, double borderWidth, Color fillColor) { if (dest != null) { Polygon poly = Perspective.getCanvasTilePoly(this.client, dest); if (poly != null) { OverlayUtil.renderPolygon( graphics, poly, color, fillColor, new BasicStroke((float) borderWidth)); } } }
@Override protected void startUp() throws Exception { keyManager.registerKeyListener(toggle); overlayManager.add(overlay); timeout = 0; }
@Override protected void shutDown() throws Exception { keyManager.unregisterKeyListener(toggle); overlayManager.remove(overlay); timeout = 0; started = false; aldo = null; spine = null; lamp = null; manhole = null; }
public void handleBanking() { if (!Bank.isOpen()) return; if (Bank.search().withId(ItemID.SCURRIUS_SPINE).empty()) { EthanApiPlugin.sendClientMessage("No spines left in bank"); started = false; return; } Bank.search() .withId(ItemID.SCURRIUS_SPINE) .first() .ifPresent( spine -> { BankInteraction.useItem(spine, "Withdraw-All"); }); }
public void walkTowardsAldo() { MousePackets.queueClickPacket(); MovementPackets.queueMovement(HISTORIAN_ALDO_TILE); timeout = 2; }
public void walkTowardsLadder() { MousePackets.queueClickPacket(); MovementPackets.queueMovement(LADDER_TILE); timeout = 2; }
public void walkTowardsManhole() { MousePackets.queueClickPacket(); MovementPackets.queueMovement(SEWER_MANHOLE_TILE); timeout = 2; }
public void walkTowardsBank() { MousePackets.queueClickPacket(); MovementPackets.queueMovement(VARROCK_EAST_BANK_TILE); timeout = 2; }
public boolean openBank() { if (Bank.isOpen()) return true; Optional<NPC> banker = NPCs.search().withAction("Bank").withinWorldArea(VARROCK_EAST_BANK_AREA).nearestToPlayer(); if (banker.isPresent()) { NPCInteraction.interact(banker.get(), "Bank"); timeout = 2; return true; } return false; }
public boolean inVarrockSewer() { return playerUtil.inRegion(12954, 13210); }
private boolean runIsOff() { return EthanApiPlugin.getClient().getVarpValue(173) == 0; }
@ConfigItem(keyName = "Toggle", name = "Toggle", description = "", position = 0) default Keybind toggle() { return Keybind.NOT_SET; }
@ConfigItem(keyName = "spineSkill", name = "Spine Skill", description = "", position = 1) default SpineSkill spineSkill() { return SpineSkill.ATTACK; }
@ConfigItem( keyName = "stopAtSpinesRedeemed", name = "Stop at # redeemed", description = "0 to redeem all spines", position = 2) default int stopAtSpinesRedeemed() { return 0; }
@Override public void actionPerformed(ActionEvent e) { decryptAccounts(); }
@Override public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException { String currentText = fb.getDocument().getText(0, fb.getDocument().getLength()); String newText = currentText.substring(0, offset) + text + currentText.substring(offset + length); if (newText.matches("\\d{0,4}")) { super.replace(fb, offset, length, text, attrs); } }
@Override public void insertString(FilterBypass fb, int offset, String string, AttributeSet attr) throws BadLocationException { String currentText = fb.getDocument().getText(0, fb.getDocument().getLength()); String newText = currentText.substring(0, offset) + string + currentText.substring(offset); if (newText.matches("\\d{0,4}")) { super.insertString(fb, offset, string, attr); } }
@Override public void remove(FilterBypass fb, int offset, int length) throws BadLocationException { String currentText = fb.getDocument().getText(0, fb.getDocument().getLength()); String newText = currentText.substring(0, offset) + currentText.substring(offset + length); if (newText.matches("\\d{0,4}")) { super.remove(fb, offset, length); } }
private void setupPasswordField(JPasswordField passwordField, String placeholder) { setupPasswordField(passwordField, placeholder, false); }
void redrawProfiles() { try { profilesPanel.removeAll(); String profileData = getProfileData(); addAccounts(profileData); revalidate(); repaint(); } catch (Exception e) { log.error( "Unexpected error: {}", e .getMessage()); } }
private void addAccount(String data) { try { BetterProfilePanel profile = new BetterProfilePanel(client, data, betterProfilesConfig, this); profilesPanel.add(profile); revalidate(); repaint(); } catch (Exception e) { log.warn("Error processing profile data: {}", e.getMessage()); } }
private void addAccounts(String data) { data = data.trim(); if (!data.contains(":")) { return; } Arrays.stream(data.split("\\n")).forEach(this::addAccount); }
private boolean addProfile(String data) throws InvalidKeySpecException, NoSuchAlgorithmException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException { log.debug("Adding profile data: {}", data); String currentData = getProfileData(); log.debug("Current profile data: {}", currentData); String updatedData = currentData.isEmpty() ? data : currentData + "\n" + data; log.debug("Updated profile data: {}", updatedData); return setProfileData(updatedData); }
private byte[] base64Decode(String data) { return Base64.getDecoder().decode(data); }
private String base64Encode(byte[] data) { return Base64.getEncoder().encodeToString(data); }
private static byte[] encryptText(String text, SecretKey aesKey) throws NoSuchAlgorithmException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException { if (text == null || text.isEmpty()) { log.debug("Encrypting empty text."); return new byte[0]; } Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); SecretKeySpec newKey = new SecretKeySpec(aesKey.getEncoded(), "AES"); cipher.init(Cipher.ENCRYPT_MODE, newKey); return cipher.doFinal(text.getBytes()); }
private static String decryptText(byte[] enc, SecretKey aesKey) throws NoSuchAlgorithmException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException { if (enc == null || enc.length == 0) { log.debug("Decrypting empty data."); return ""; } Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); SecretKeySpec newKey = new SecretKeySpec(aesKey.getEncoded(), "AES"); cipher.init(Cipher.DECRYPT_MODE, newKey); return new String(cipher.doFinal(enc)); }
private static void showErrorMessage(String title, String text) { }
private static String htmlLabel(String text) { return "<html><body><span style = 'color:white'>" + text + "</span></body></html>"; }
@Override public void mousePressed(MouseEvent e) { panel.getParent().remove(panel); try { parent.removeProfile(data); } catch (InvalidKeySpecException | NoSuchAlgorithmException | IllegalBlockSizeException | InvalidKeyException | BadPaddingException | NoSuchPaddingException ex) { log.error(e.toString()); } }
@Override public void mouseEntered(MouseEvent e) { delete.setIcon(DELETE_HOVER_ICON); }
@Override public void mouseExited(MouseEvent e) { delete.setIcon(DELETE_ICON); }
@ConfigItem( keyName = "profilesData", name = "Delete Me If Broken/Forgot Information", description = "") default String profilesData() { return ""; }
@ConfigItem(keyName = "salt", name = "", description = "", hidden = true) default String salt() { return ""; }
@ConfigItem( keyName = "rememberPassword", name = "Remember Password", description = "Remembers passwords for accounts", position = 0) default boolean rememberPassword() { return true; }
@ConfigItem( keyName = "displayEmailAddress", name = "Display email field", description = "Displays the email address field", position = 1) default boolean displayEmailAddress() { return false; }
@ConfigItem( keyName = "streamerMode", name = "Hide email addresses", description = "Hides your account emails", position = 2, hidden = true) default boolean streamerMode() { return false; }
@Override protected void startUp() { panel = injector.getInstance(BetterProfilesPanel.class); panel.init(); if (icon == null) { icon = ImageUtil.loadImageResource(getClass(), "profiles_icon.png"); } if (icon != null) { navButton = NavigationButton.builder() .tooltip("Profiles") .icon(icon) .priority(8) .panel(panel) .build(); clientToolbar.addNavigation(navButton); } else { log.error("Failed to load profiles_icon.png"); } }
@Override protected void shutDown() { clientToolbar.removeNavigation(navButton); }
@Subscribe private void onGameStateChanged(GameStateChanged event) {}
@ConfigItem(keyName = "copyGear", name = "Copy Gear", description = "", position = -5) default boolean copyGear() { return false; }
@ConfigItem( keyName = "specToggle", name = "Spec", description = "Toggle to click spec", position = -4) default Keybind specToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "tripleEatToggle", name = "Triple Eat", description = "Toggle to triple eat", position = -1, section = foodSection) default Keybind tripleEatToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "foodName", name = "Food name", description = "Hard food name to eat in triple eat", position = 0, section = foodSection) default String foodName() { return "Blighted anglerfish"; }
@ConfigItem( keyName = "blightedKaram", name = "Blighted Karambwans", description = "If you're using blighted karams over normal", position = 1, section = foodSection) default boolean blightedKaram() { return false; }
@ConfigItem( keyName = "autoEat", name = "Auto Triple Eat", description = "Auto triple eats when below the threshold", position = 2, section = foodSection) default boolean autoEat() { return false; }
@Range(min = 1, max = 99) @ConfigItem( keyName = "eatThreshold", name = "Eat Threshold", description = "Threshold of HP you should auto eat at", position = 3, section = foodSection) default int eatThreshold() { return 50; }
@ConfigItem( keyName = "oneToggle", name = "One Toggle", description = "", position = 1, section = gearSection) default Keybind oneToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "oneGear", name = "One Gear", description = "", position = 2, section = gearSection) default String oneGear() { return ""; }
@ConfigItem( keyName = "twoToggle", name = "Two Toggle", description = "", position = 3, section = gearSection) default Keybind twoToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "twoGear", name = "Two Gear", description = "", position = 4, section = gearSection) default String twoGear() { return ""; }
@ConfigItem( keyName = "threeToggle", name = "Three Toggle", description = "", position = 5, section = gearSection) default Keybind threeToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "threeGear", name = "Three Gear", description = "", position = 6, section = gearSection) default String threeGear() { return ""; }
@ConfigItem( keyName = "fourToggle", name = "Four Toggle", description = "", position = 7, section = gearSection) default Keybind fourToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "fourGear", name = "Four Gear", description = "", position = 8, section = gearSection) default String fourGear() { return ""; }
@ConfigItem( keyName = "fiveToggle", name = "Five Toggle", description = "", position = 9, section = gearSection) default Keybind fiveToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "fiveGear", name = "Five Gear", description = "", position = 10, section = gearSection) default String fiveGear() { return ""; }
@ConfigItem( keyName = "sixToggle", name = "Six Toggle", description = "", position = 11, section = gearSection) default Keybind sixToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "sixGear", name = "Six Gear", description = "", position = 12, section = gearSection) default String sixGear() { return ""; }
@ConfigItem( keyName = "eightToggle", name = "Prayers One Toggle", description = "", position = 16, section = prayerSection) default Keybind onePrayerToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "onePrayerFirst", name = "Prayers One", description = "", position = 17, section = prayerSection) default String onePrayer() { return ""; }
@ConfigItem( keyName = "nineToggle", name = "Prayers Two Toggle", description = "", position = 18, section = prayerSection) default Keybind twoPrayerToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "twoPrayer", name = "Prayers Two", description = "", position = 19, section = prayerSection) default String twoPrayer() { return ""; }
@ConfigItem( keyName = "threePrayerToggle", name = "Prayers Three Toggle", description = "", position = 20, section = prayerSection) default Keybind threePrayerToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "threePrayer", name = "Prayers Three", description = "", position = 21, section = prayerSection) default String threePrayer() { return ""; }
@ConfigItem( keyName = "spellOneToggle", name = "Spell One Toggle", description = "", position = 0, section = spellSection) default Keybind spellOneToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "spellOne", name = "Spell One", description = "", position = 1, section = spellSection) default String spellOne() { return "Ice barrage"; }
@ConfigItem( keyName = "spellTwoToggle", name = "Spell Two Toggle", description = "", position = 2, section = spellSection) default Keybind spellTwoToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "spellTwo", name = "Spell Two", description = "", position = 3, section = spellSection) default String spellTwo() { return "Tele block"; }
@ConfigItem( keyName = "spellThreeToggle", name = "Spell Three Toggle", description = "", position = 4, section = spellSection) default Keybind spellThreeToggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "spellThree", name = "Spell Three", description = "", position = 5, section = spellSection) default String spellThree() { return "Tele block"; }
@ConfigItem( keyName = "veng", name = "Vengeance", description = "", position = 6, section = spellSection) default Keybind veng() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "targetOverlay", name = "Highlight target", description = "Highlight focused target", position = -1, section = overlaySection) default boolean targetOverlay() { return true; }
@ConfigItem( keyName = "autoFocusTarget", name = "Auto Focus target", description = "Automatically focuses target player", position = 0, section = overlaySection) default boolean autoFocusTarget() { return false; }
@Range(min = 1, max = 8) @ConfigItem( keyName = "overlayWidth", name = "Highlight width", description = "Width of target highlight", position = 1, section = overlaySection) default int overlayWidth() { return 2; }
@ConfigItem( keyName = "overlayColor", name = "Highlight color", description = "Color of target highlight", position = 2, section = overlaySection) default Color overlayColor() { return Color.RED; }
@ConfigItem( keyName = "showOverlay", name = "Show target panel", description = "Enables an on screen panel showing target's expected value", position = 3, section = overlaySection) default boolean showOverlay() { return false; }
public static ItemQuery search() { return new ItemQuery( tradeInventoryItems.stream().filter(Objects::nonNull).collect(Collectors.toList())); }
@Override public boolean isHidden() { return false; }
@Override public boolean isSelfHidden() { return false; }
@Override public boolean contains(Point point) { return false; }
@Override public Widget createChild(int index, int type) { return null; }
@Override public Widget createChild(int type) { return null; }
@Override public boolean hasListener() { return false; }
@Override public boolean isIf3() { return false; }
@Override public boolean isFilled() { return false; }
public void interact(boolean ctrlDown) { MousePackets.queueClickPacket(); TileItemPackets.queueTileItemAction(this, ctrlDown); }
public static TileItemQuery search() { return new TileItemQuery(tileItems); }
public static boolean full() { return getEmptySlots() == 0; }
public static PlayerQuery search() { return new PlayerQuery(players); }
public static boolean isOpen() { return client.getWidget(WidgetInfo.BANK_ITEM_CONTAINER) != null && !client.getWidget(WidgetInfo.BANK_ITEM_CONTAINER).isHidden(); }
public static TileObjectQuery search() { return new TileObjectQuery(tileObjects); }
public static NPCQuery search() { return new NPCQuery(npcList); }
public static ItemQuery search() { return new ItemQuery( geInventoryItems.stream().filter(Objects::nonNull).collect(Collectors.toList())); }
public void interact(String... actions) { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(EthanApiPlugin.getClient().getWidget(packedId), actions); }
public EquipmentItemQuery filter(Predicate<? super Widget> predicate) { items = items.stream().filter(predicate).collect(Collectors.toList()); return this; }
public EquipmentItemQuery withAction(String action) { items = items.stream() .filter(item -> Arrays.asList(item.getActions()).contains(action)) .collect(Collectors.toList()); return this; }
public EquipmentItemQuery withId(int id) { items = items.stream().filter(item -> item.getEquipmentItemId() == id).collect(Collectors.toList()); return this; }
public EquipmentItemQuery withName(String name) { items = items.stream().filter(item -> item.getName().equals(name)).collect(Collectors.toList()); return this; }
public EquipmentItemQuery nameContains(String name) { items = items.stream().filter(item -> item.getName().contains(name)).collect(Collectors.toList()); return this; }
public EquipmentItemQuery nameContainsNoCase(String name) { items = items.stream() .filter(item -> item.getName().toLowerCase().contains(name.toLowerCase())) .collect(Collectors.toList()); return this; }
public EquipmentItemQuery idInList(List<Integer> ids) { items = items.stream() .filter(item -> ids.contains(item.getEquipmentItemId())) .collect(Collectors.toList()); return this; }
public EquipmentItemQuery indexIs(int index) { items = items.stream().filter(item -> item.getIndex() == index).collect(Collectors.toList()); return this; }
public EquipmentItemQuery matchesWildCardNoCase(String input) { items = items.stream() .filter( item -> WildcardMatcher.matches( input.toLowerCase(), Text.removeTags(item.getName().toLowerCase()))) .collect(Collectors.toList()); return this; }
public boolean empty() { return items.size() == 0; }
public EquipmentItemQuery filterUnique() { items = items.stream() .collect( Collectors.collectingAndThen( Collectors.toCollection( () -> new TreeSet<>(Comparator.comparingInt(Widget::getItemId))), ArrayList::new)); return this; }
public List<EquipmentItemWidget> result() { return items; }
public Optional<EquipmentItemWidget> first() { Widget returnWidget = null; if (items.size() == 0) { return Optional.ofNullable(null); } return Optional.ofNullable(items.get(0)); }
public TileItemQuery withId(int id) { tileItems = this.tileItems.stream() .filter(tileItem -> tileItem.tileItem.getId() == id) .collect(Collectors.toList()); return this; }
@SneakyThrows public TileItemQuery withName(String name) { tileItems = tileItems.stream() .filter( tileItem -> { try { return EthanApiPlugin.itemDefs .get(tileItem.tileItem.getId()) .getName() .equals(name); } catch (ExecutionException e) { throw new RuntimeException(e); } }) .collect(Collectors.toList()); return this; }
public TileItemQuery nameContains(String name) { tileItems = tileItems.stream() .filter( tileItem -> { try { return EthanApiPlugin.itemDefs .get(tileItem.tileItem.getId()) .getName() .contains(name); } catch (ExecutionException e) { throw new RuntimeException(e); } }) .collect(Collectors.toList()); return this; }
public TileItemQuery filter(Predicate<? super ETileItem> predicate) { tileItems = tileItems.stream().filter(predicate).collect(Collectors.toList()); return this; }
public TileItemQuery onlyNoted() { tileItems = tileItems.stream().filter(this::isNoted).collect(Collectors.toList()); return this; }
public TileItemQuery onlyUnnoted() { tileItems = tileItems.stream().filter(item -> !isNoted(item)).collect(Collectors.toList()); return this; }
public TileItemQuery matchesWildCardNoCase(String input) { tileItems = tileItems.stream() .filter( item -> { try { return WildcardMatcher.matches( input.toLowerCase(), Text.removeTags( EthanApiPlugin.itemDefs .get(item.tileItem.getId()) .getName() .toLowerCase())); } catch (ExecutionException e) { throw new RuntimeException(e); } }) .collect(Collectors.toList()); return this; }
public TileItemQuery eachItemAboveXValue(int value) { tileItems = tileItems.stream() .filter(item -> itemManager.getItemPrice(item.getTileItem().getId()) > value) .collect(Collectors.toList()); return this; }
public TileItemQuery stackAboveXValue(int value) { tileItems = tileItems.stream() .filter( item -> item.getTileItem().getQuantity() * itemManager.getItemPrice(item.getTileItem().getId()) > value) .collect(Collectors.toList()); return this; }
public TileItemQuery doesNotMatchWildCardNoCase(String input) { tileItems = tileItems.stream() .filter( item -> { try { return !WildcardMatcher.matches( input.toLowerCase(), Text.removeTags( EthanApiPlugin.itemDefs .get(item.tileItem.getId()) .getName() .toLowerCase())); } catch (ExecutionException e) { throw new RuntimeException(e); } }) .collect(Collectors.toList()); return this; }
public TileItemQuery itemsMatchingWildcardsNoCase(String... input) { List<ETileItem> tileItemsTemp = new ArrayList<>(); for (String s : input) { tileItemsTemp.addAll( tileItems.stream() .filter( item -> { try { return WildcardMatcher.matches( s.toLowerCase(), Text.removeTags( EthanApiPlugin.itemDefs .get(item.tileItem.getId()) .getName() .toLowerCase())); } catch (ExecutionException e) { throw new RuntimeException(e); } }) .collect(Collectors.toList())); } tileItems = tileItemsTemp; return this; }
public TileItemQuery itemsExcludingMatchingWildcardsNoCase(String... input) { List<ETileItem> tileItemsTemp = new ArrayList<>(); for (String s : input) { tileItemsTemp.addAll( tileItems.stream() .filter( item -> { try { return WildcardMatcher.matches( s.toLowerCase(), Text.removeTags( EthanApiPlugin.itemDefs .get(item.tileItem.getId()) .getName() .toLowerCase())); } catch (ExecutionException e) { throw new RuntimeException(e); } }) .collect(Collectors.toList())); } tileItems.removeAll(tileItemsTemp); return this; }
public boolean empty() { return tileItems.size() == 0; }
public List<ETileItem> result() { return tileItems; }
public Optional<ETileItem> first() { if (tileItems.size() == 0) { return Optional.empty(); } return Optional.ofNullable(tileItems.get(0)); }
public TileItemQuery withinDistance(int distance) { tileItems = tileItems.stream() .filter( tileItem -> tileItem.getLocation().distanceTo(client.getLocalPlayer().getWorldLocation()) <= distance) .collect(Collectors.toList()); return this; }
public TileItemQuery withinDistanceToPoint(int distance, WorldPoint point) { tileItems = tileItems.stream() .filter(tileItem -> tileItem.getLocation().distanceTo(point) <= distance) .collect(Collectors.toList()); return this; }
public TileItemQuery alchValueAbove(int value) { tileItems = tileItems.stream() .filter( tileItem -> itemManager.getItemComposition(tileItem.getTileItem().getId()).getHaPrice() > value) .collect(Collectors.toList()); return this; }
public Optional<ETileItem> nearestToPlayer() { return nearestToPoint(client.getLocalPlayer().getWorldLocation()); }
public Optional<ETileItem> nearestToPoint(WorldPoint point) { if (tileItems.size() == 0) { return Optional.empty(); } return tileItems.stream() .min(Comparator.comparingInt(tileItem -> tileItem.location.distanceTo(point))); }
@SneakyThrows public boolean isNoted(ETileItem item) { ItemComposition itemComposition = EthanApiPlugin.itemDefs.get(item.tileItem.getId()); return itemComposition.getNote() != -1; }
public Optional<ETileItem> nearestByPath() { return tileItems.stream() .min( Comparator.comparingInt( o -> { var path = GlobalCollisionMap.findPath(o.location); if (path == null) { return Integer.MAX_VALUE; } return path.size(); })); }
public NPCQuery filter(Predicate<? super NPC> predicate) { npcs = npcs.stream().filter(predicate).collect(Collectors.toList()); return this; }
public NPCQuery atLocation(WorldPoint wp) { npcs = npcs.stream().filter(npc -> npc.getWorldLocation().equals(wp)).collect(Collectors.toList()); return this; }
public NPCQuery withAction(String action) { npcs = npcs.stream() .filter( npc -> { NPCComposition npcComposition = getNPCComposition(npc); if (npcComposition == null) return false; String[] actions = getNPCComposition(npc).getActions(); return Arrays.stream(actions) .filter(Objects::nonNull) .anyMatch(a -> a.equalsIgnoreCase(action)); }) .collect(Collectors.toList()); return this; }
public NPCQuery withId(int id) { npcs = npcs.stream().filter(npc -> npc.getId() == id).collect(Collectors.toList()); return this; }
public NPCQuery withName(String name) { npcs = npcs.stream() .filter(npcs -> npcs.getName() != null && npcs.getName().equals(name)) .collect(Collectors.toList()); return this; }
public NPCQuery nameContains(String name) { npcs = npcs.stream() .filter(npcs -> npcs.getName() != null && npcs.getName().contains(name)) .collect(Collectors.toList()); return this; }
public NPCQuery interactingWithLocal() { List<NPC> filteredNPCs = new ArrayList<>(); for (NPC npc : npcs) { if (!npc.isInteracting()) continue; if (npc.getInteracting() == client.getLocalPlayer()) filteredNPCs.add(npc); } npcs = filteredNPCs; return this; }
public NPCQuery interactingWith(Actor actor) { List<NPC> filteredNPCs = new ArrayList<>(); for (NPC npc : npcs) { if (!npc.isInteracting()) continue; if (npc.getInteracting() == actor) filteredNPCs.add(npc); } npcs = filteredNPCs; return this; }
public NPCQuery idInList(List<Integer> ids) { npcs = npcs.stream().filter(npcs -> ids.contains(npcs.getId())).collect(Collectors.toList()); return this; }
public NPCQuery withinWorldArea(WorldArea area) { npcs = npcs.stream() .filter(npcs -> area.contains(npcs.getWorldLocation())) .collect(Collectors.toList()); return this; }
public NPCQuery withinBounds(WorldPoint min, WorldPoint max) { int x1 = min.getX(); int x2 = max.getX(); int y1 = min.getY(); int y2 = max.getY(); npcs = npcs.stream() .filter( npc -> { int x3 = npc.getWorldLocation().getX(); int y3 = npc.getWorldLocation().getY(); if (x3 > Math.max(x1, x2) || x3 < Math.min(x1, x2)) { return false; } return y3 <= Math.max(y1, y2) && y3 >= Math.min(y1, y2); }) .collect(Collectors.toList()); return this; }
public NPCQuery indexIs(int index) { npcs = npcs.stream().filter(npcs -> npcs.getIndex() == index).collect(Collectors.toList()); return this; }
public NPCQuery filterUnique() { npcs = npcs.stream() .collect( Collectors.collectingAndThen( Collectors.toCollection( () -> new TreeSet<>(Comparator.comparingInt(NPC::getId))), ArrayList::new)); return this; }
public NPCQuery walkable() { npcs = npcs.stream() .filter(npc -> EthanApiPlugin.canPathToTile(npc.getWorldLocation()).isReachable()) .collect(Collectors.toList()); return this; }
public NPCQuery interacting() { npcs = npcs.stream().filter(Actor::isInteracting).collect(Collectors.toList()); return this; }
public NPCQuery notInteracting() { npcs = npcs.stream().filter(npc -> !npc.isInteracting()).collect(Collectors.toList()); return this; }
public NPCQuery noOneInteractingWith() { npcs = npcs.stream() .filter(npc -> Players.search().interactingWith(npc).isEmpty()) .collect(Collectors.toList()); return this; }
public NPCQuery meleeable() { List<WorldPoint> meleeTiles = new ArrayList<>(); meleeTiles.add(client.getLocalPlayer().getWorldLocation().dx(1)); meleeTiles.add(client.getLocalPlayer().getWorldLocation().dx(-1)); meleeTiles.add(client.getLocalPlayer().getWorldLocation().dy(1)); meleeTiles.add(client.getLocalPlayer().getWorldLocation().dy(-1)); npcs = npcs.stream() .filter( npc -> !Collections.disjoint(meleeTiles, npc.getWorldArea().toWorldPointList()) && npc.getWorldArea().distanceTo(client.getLocalPlayer().getWorldLocation()) == 1) .collect(Collectors.toList()); return this; }
public NPCQuery alive() { npcs = npcs.stream() .filter(npc -> !npc.isDead() && npc.getHealthRatio() != 0) .collect(Collectors.toList()); return this; }
public Optional<NPC> nearestToPlayer() { if (npcs.size() == 0) { return Optional.ofNullable(null); } return npcs.stream() .min( Comparator.comparingInt( npc -> npc.getWorldLocation().distanceTo(client.getLocalPlayer().getWorldLocation()))); }
public Optional<NPC> nearestToPoint(WorldPoint point) { if (npcs.size() == 0) { return Optional.ofNullable(null); } return npcs.stream() .min(Comparator.comparingInt(npc -> npc.getWorldLocation().distanceTo(point))); }
public Optional<NPC> first() { if (npcs.size() == 0) { return Optional.ofNullable(null); } return Optional.ofNullable(npcs.get(0)); }
public Optional<NPC> nearestByPath() { return npcs.stream() .min( Comparator.comparingInt( o -> { var path = GlobalCollisionMap.findPath(o.getWorldLocation()); if (path == null) { return Integer.MAX_VALUE; } return path.size(); })); }
public WidgetQuery filter(Predicate<? super Widget> predicate) { widgets = widgets.stream().filter(predicate).collect(Collectors.toList()); return this; }
public WidgetQuery withAction(String action) { widgets = widgets.stream() .filter( widget -> widget.getActions() != null && Arrays.asList(widget.getActions()).contains(action)) .collect(java.util.stream.Collectors.toList()); return this; }
public boolean empty() { return widgets.isEmpty(); }
public WidgetQuery hiddenState(boolean hidden) { widgets = widgets.stream() .filter(widget -> widget.isHidden() == hidden) .collect(java.util.stream.Collectors.toList()); return this; }
public WidgetQuery withId(int id) { widgets = widgets.stream() .filter(widget -> widget.getId() == id) .collect(java.util.stream.Collectors.toList()); return this; }
public WidgetQuery withItemId(int itemId) { widgets = widgets.stream() .filter(widget -> widget.getItemId() == itemId) .collect(java.util.stream.Collectors.toList()); return this; }
public Optional<Widget> first() { return widgets.stream().findFirst(); }
public WidgetQuery nonPlaceHolder() { return quantityGreaterThan(0); }
public WidgetQuery itemIdInList(List<Integer> ids) { widgets = widgets.stream() .filter(item -> ids.contains(item.getItemId())) .collect(Collectors.toList()); return this; }
public WidgetQuery quantityGreaterThan(int quanity) { widgets = widgets.stream() .filter(item -> item.getItemQuantity() > quanity) .collect(Collectors.toList()); return this; }
public WidgetQuery nameContains(String name) { widgets = widgets.stream() .filter(item -> item.getName() != null && item.getName().contains(name)) .collect(Collectors.toList()); return this; }
public WidgetQuery withName(String name) { widgets = widgets.stream() .filter(item -> item.getName() != null && item.getName().equals(name)) .collect(Collectors.toList()); return this; }
public WidgetQuery withText(String text) { widgets = widgets.stream() .filter(item -> item.getText() != null && item.getText().equals(text)) .collect(Collectors.toList()); return this; }
public WidgetQuery withTextContains(String text) { widgets = widgets.stream() .filter(item -> item.getText() != null && item.getText().contains(text)) .collect(Collectors.toList()); return this; }
public WidgetQuery withParentId(int parentId) { widgets = widgets.stream() .filter(item -> item.getParentId() == parentId) .collect(Collectors.toList()); return this; }
public WidgetQuery nameMatchesWildCardNoCase(String input) { widgets = widgets.stream() .filter( item -> item.getName() != null && WildcardMatcher.matches( input.toLowerCase(), Text.removeTags(item.getName().toLowerCase()))) .collect(Collectors.toList()); return this; }
public ItemQuery filter(Predicate<? super Widget> predicate) { items = items.stream().filter(predicate).collect(Collectors.toList()); return this; }
public ItemQuery withAction(String action) { items = items.stream() .filter(item -> Arrays.asList(item.getActions()).contains(action)) .collect(Collectors.toList()); return this; }
public ItemQuery tradeAble() { items = items.stream() .filter(item -> itemManager.getItemComposition(item.getItemId()).isTradeable()) .collect(Collectors.toList()); return this; }
public ItemQuery differenceInValueLessThan(int difference) { items = items.stream() .filter( item -> Math.abs( itemManager.getItemComposition(item.getItemId()).getHaPrice() - itemManager.getItemPriceWithSource(item.getItemId(), true)) < difference) .collect(Collectors.toList()); return this; }
public ItemQuery priceOver(int price) { items = items.stream() .filter(item -> itemManager.getItemComposition(item.getItemId()).getHaPrice() >= price) .collect(Collectors.toList()); return this; }
public ItemQuery withSet(Set<Integer> ids) { items = items.stream().filter(item -> ids.contains(item.getItemId())).collect(Collectors.toList()); return this; }
public ItemQuery withId(int id) { items = items.stream().filter(item -> item.getItemId() == id).collect(Collectors.toList()); return this; }
public ItemQuery withName(String name) { items = items.stream() .filter(item -> Text.removeTags(item.getName()).equals(Text.removeTags(name))) .collect(Collectors.toList()); return this; }
public ItemQuery quantityGreaterThan(int quanity) { items = items.stream() .filter(item -> item.getItemQuantity() > quanity) .collect(Collectors.toList()); return this; }
public ItemQuery nameContains(String name) { items = items.stream().filter(item -> item.getName().contains(name)).collect(Collectors.toList()); return this; }
public ItemQuery nonPlaceHolder() { return quantityGreaterThan(0); }
public ItemQuery idInList(List<Integer> ids) { items = items.stream().filter(item -> ids.contains(item.getItemId())).collect(Collectors.toList()); return this; }
public ItemQuery nameInList(List<String> names) { items = items.stream() .filter( item -> names.stream() .map(String::toLowerCase) .anyMatch(name -> Text.removeTags(item.getName()).equalsIgnoreCase(name))) .collect(Collectors.toList()); return this; }
public ItemQuery indexIs(int index) { items = items.stream().filter(item -> item.getIndex() == index).collect(Collectors.toList()); return this; }
public ItemQuery matchesWildCardNoCase(String input) { items = items.stream() .filter( item -> WildcardMatcher.matches( input.toLowerCase(), Text.removeTags(item.getName().toLowerCase()))) .collect(Collectors.toList()); return this; }
public ItemQuery onlyNoted() { items = items.stream().filter(this::isNoted).collect(Collectors.toList()); return this; }
public ItemQuery onlyStackable() { items = items.stream().filter(this::isStackable).collect(Collectors.toList()); return this; }
public ItemQuery onlyUnnoted() { items = items.stream().filter(item -> !isNoted(item)).collect(Collectors.toList()); return this; }
public ItemQuery filterUnique() { items = items.stream() .collect( Collectors.collectingAndThen( Collectors.toCollection( () -> new TreeSet<>(Comparator.comparingInt(Widget::getItemId))), ArrayList::new)); return this; }
public Optional<Widget> first() { Widget returnWidget = null; if (items.size() == 0) { return Optional.ofNullable(null); } return Optional.ofNullable(items.get(0)); }
@SneakyThrows public boolean isNoted(Widget item) { ItemComposition itemComposition = EthanApiPlugin.itemDefs.get(item.getItemId()); return itemComposition.getNote() != -1; }
@SneakyThrows public boolean isStackable(Widget item) { ItemComposition itemComposition = EthanApiPlugin.itemDefs.get(item.getItemId()); return itemComposition.isStackable(); }
public PlayerQuery withName(String name) { List<Player> filteredPlayers = new ArrayList<>(); for (Player player : players) { if (player.getName().equals(name)) filteredPlayers.add(player); } players = filteredPlayers; return this; }
public PlayerQuery withinWorldArea(WorldArea area) { players = players.stream() .filter(player -> area.contains(player.getWorldLocation())) .collect(Collectors.toList()); return this; }
public PlayerQuery filter(Predicate<? super Player> predicate) { players = players.stream().filter(predicate).collect(Collectors.toList()); return this; }
public PlayerQuery interactingWithLocal() { List<Player> filteredPlayers = new ArrayList<>(); for (Player player : players) { if (!player.isInteracting()) continue; if (player.getInteracting() == client.getLocalPlayer()) filteredPlayers.add(player); } players = filteredPlayers; return this; }
public PlayerQuery interactingWith(Actor actor) { List<Player> filteredPlayers = new ArrayList<>(); for (Player player : players) { if (!player.isInteracting()) continue; if (player.getInteracting() == actor) filteredPlayers.add(player); } players = filteredPlayers; return this; }
public PlayerQuery nameContains(String name) { List<Player> filteredPlayers = new ArrayList<>(); for (Player player : players) { if (player.getName().contains(name)) filteredPlayers.add(player); } players = filteredPlayers; return this; }
public PlayerQuery notLocalPlayer() { players.remove(client.getLocalPlayer()); return this; }
public PlayerQuery withinLevel(int low, int high) { List<Player> filteredPlayers = new ArrayList<>(); for (Player player : players) { if (player.getCombatLevel() >= low && player.getCombatLevel() <= high) filteredPlayers.add(player); } players = filteredPlayers; return this; }
public boolean isEmpty() { return players.isEmpty(); }
public Optional<Player> first() { if (players.isEmpty()) return Optional.empty(); return Optional.ofNullable(players.get(0)); }
public Optional<Player> nearestByPath() { return players.stream() .min( Comparator.comparingInt( o -> { var path = GlobalCollisionMap.findPath(o.getWorldLocation()); if (path == null) { return Integer.MAX_VALUE; } return path.size(); })); }
public TileObjectQuery withName(String name) { tileObjects = tileObjects.stream() .filter( tileObject -> { ObjectComposition objectComposition = getObjectComposition(tileObject); if (objectComposition == null) return false; return objectComposition.getName().equals(name); }) .collect(Collectors.toList()); return this; }
public TileObjectQuery withId(int id) { tileObjects = tileObjects.stream() .filter(tileObject -> tileObject.getId() == id) .collect(Collectors.toList()); return this; }
public TileObjectQuery withAction(String action) { tileObjects = tileObjects.stream() .filter( tileObject -> { ObjectComposition objectComposition = getObjectComposition(tileObject); if (objectComposition == null) return false; String[] actions = getObjectComposition(tileObject).getActions(); return Arrays.stream(actions) .filter(Objects::nonNull) .anyMatch(a -> a.equalsIgnoreCase(action)); }) .collect(Collectors.toList()); return this; }
public TileObjectQuery atLocation(WorldPoint location) { tileObjects = tileObjects.stream() .filter(tileObject -> tileObject.getWorldLocation().equals(location)) .collect(Collectors.toList()); return this; }
public TileObjectQuery withinDistance(int distance) { tileObjects = tileObjects.stream() .filter( tileObject -> tileObject .getWorldLocation() .distanceTo(client.getLocalPlayer().getWorldLocation()) <= distance) .collect(Collectors.toList()); return this; }
public TileObjectQuery withinBounds(WorldPoint min, WorldPoint max) { int x1 = min.getX(); int x2 = max.getX(); int y1 = min.getY(); int y2 = max.getY(); tileObjects = tileObjects.stream() .filter( tileObject -> { int x3 = tileObject.getWorldLocation().getX(); int y3 = tileObject.getWorldLocation().getY(); if (x3 > Math.max(x1, x2) || x3 < Math.min(x1, x2)) { return false; } return y3 <= Math.max(y1, y2) && y3 >= Math.min(y1, y2); }) .collect(Collectors.toList()); return this; }
public TileObjectQuery atLocation(int x, int y, int plane) { WorldPoint p = new WorldPoint(x, y, plane); tileObjects = tileObjects.stream() .filter(tileObject -> tileObject.getWorldLocation().equals(p)) .collect(Collectors.toList()); return this; }
public TileObjectQuery filter(Predicate<? super TileObject> predicate) { tileObjects = tileObjects.stream().filter(predicate).collect(Collectors.toList()); return this; }
public TileObjectQuery nameContains(String name) { tileObjects = tileObjects.stream() .filter( tileObject -> { ObjectComposition comp = getObjectComposition(tileObject); if (comp == null) return false; return comp.getName().contains(name); }) .collect(Collectors.toList()); return this; }
public TileObjectQuery idInList(List<Integer> ids) { tileObjects = tileObjects.stream() .filter(tileObject -> ids.contains(tileObject.getId())) .collect(Collectors.toList()); return this; }
public boolean empty() { return tileObjects.size() == 0; }
public List<TileObject> result() { return tileObjects; }
public Optional<TileObject> first() { return tileObjects.stream().findFirst(); }
public Optional<TileObject> nearestToPlayer() { return tileObjects.stream() .min( Comparator.comparingInt( o -> client.getLocalPlayer().getWorldLocation().distanceTo(o.getWorldLocation()))); }
public Optional<TileObject> nearestByPath() { return tileObjects.stream() .min( Comparator.comparingInt( o -> { List<WorldPoint> adjacentTiles = WorldAreaUtility.objectInteractableTiles(o); return adjacentTiles.stream() .distinct() .mapToInt( worldPoint -> { List<WorldPoint> path = GlobalCollisionMap.findPath(worldPoint); if (path == null) { return Integer.MAX_VALUE; } return path.size(); }) .min() .orElse(Integer.MAX_VALUE); })); }
public Optional<TileObject> nearestToPoint(WorldPoint point) { return tileObjects.stream() .min(Comparator.comparingInt(o -> point.distanceTo(o.getWorldLocation()))); }
static byte[] load() { try { InputStream is = GlobalCollisionMap.class.getResourceAsStream("map"); return new GZIPInputStream(is).readAllBytes(); } catch (Exception e) { e.printStackTrace(); } return null; }
public static RoaringBitmap init() { RoaringBitmap bitmap = new RoaringBitmap(); try { bitmap.deserialize(ByteBuffer.wrap(load())); bitmap.runOptimize(); } catch (IOException e) { throw new RuntimeException(e); } return bitmap; }
public static boolean east(WorldPoint wp) { return bitmap.contains(packed(wp) | (1 << 30)); }
public static boolean north(WorldPoint wp) { return bitmap.contains(packed(wp)); }
public static boolean south(WorldPoint wp) { return north(wp.dy(-1)); }
public static boolean west(WorldPoint wp) { return east(wp.dx(-1)); }
public static int packed(int x, int y, int plane) { return (x & 16383) | ((y & 16383) << 14) | (plane << 28); }
public static WorldPoint unpack(int packed) { return new WorldPoint(packed & 16383, (packed >> 14) & 16383, packed >> 28); }
public static int packed(WorldPoint wp) { return (wp.getX() & 16383) | ((wp.getY() & 16383) << 14) | (wp.getPlane() << 28); }
public static List<WorldPoint> findPath(WorldPoint p) { long start = System.currentTimeMillis(); WorldPoint starting = EthanApiPlugin.getClient().getLocalPlayer().getWorldLocation(); HashSet<WorldPoint> visited = new HashSet<>(); ArrayDeque<Node> queue = new ArrayDeque<Node>(); queue.add(new Node(starting)); while (!queue.isEmpty()) { Node current = queue.poll(); WorldPoint currentData = current.getData(); if (currentData.equals(p)) { List<WorldPoint> ret = new ArrayList<>(); while (current != null) { ret.add(current.getData()); current = current.getPrevious(); } Collections.reverse(ret); ret.remove(0); System.out.println("Path took " + (System.currentTimeMillis() - start) + "ms"); return ret; } if (west(currentData) && visited.add(currentData.dx(-1))) { queue.add(new Node(currentData.dx(-1), current)); } if (east(currentData) && visited.add(currentData.dx(1))) { queue.add(new Node(currentData.dx(1), current)); } if (south(currentData) && visited.add(currentData.dy(-1))) { queue.add(new Node(currentData.dy(-1), current)); } if (north(currentData) && visited.add(currentData.dy(1))) { queue.add(new Node(currentData.dy(1), current)); } } return null; }
public static boolean arePointsAdjacent(WorldPoint reference, WorldPoint target) { int x1 = reference.getX(); int x2 = target.getX(); int y1 = reference.getY(); int y2 = target.getY(); if (x1 != x2 && y1 != y2) { return false; } if (x1 == x2 && Math.abs(y1 - y2) == 1) { return true; } return y1 == y2 && Math.abs(x1 - x2) == 1; }
public static void queueMovement(int worldPointX, int worldPointY, boolean ctrlDown) { int ctrl = ctrlDown ? 2 : 0; PacketReflection.sendPacket(PacketDef.getMoveGameClick(), worldPointX, worldPointY, ctrl, 5); }
public static void queueMovement(WorldPoint location) { queueMovement(location.getX(), location.getY(), false); }
@SneakyThrows public static void queueNPCAction(int actionFieldNo, int npcIndex, boolean ctrlDown) { int ctrl = ctrlDown ? 1 : 0; switch (actionFieldNo) { case 1: PacketReflection.sendPacket(PacketDef.getOpNpc1(), npcIndex, ctrl); break; case 2: PacketReflection.sendPacket(PacketDef.getOpNpc2(), npcIndex, ctrl); break; case 3: PacketReflection.sendPacket(PacketDef.getOpNpc3(), npcIndex, ctrl); break; case 4: PacketReflection.sendPacket(PacketDef.getOpNpc4(), npcIndex, ctrl); break; case 5: PacketReflection.sendPacket(PacketDef.getOpNpc5(), npcIndex, ctrl); break; } }
public static void queueWidgetOnNPC( int npcIndex, int sourceItemId, int sourceSlot, int sourceWidgetId, boolean ctrlDown) { int ctrl = ctrlDown ? 1 : 0; PacketReflection.sendPacket( PacketDef.getOpNpcT(), npcIndex, sourceItemId, sourceSlot, sourceWidgetId, ctrl); }
public static void queueWidgetOnNPC(NPC npc, Widget widget) { queueWidgetOnNPC(npc.getIndex(), widget.getItemId(), widget.getIndex(), widget.getId(), false); }
public static BigInteger modInverse(BigInteger val, int bits) { try { BigInteger shift = BigInteger.ONE.shiftLeft(bits); return val.modInverse(shift); } catch (ArithmeticException e) { return val; } }
public static long modInverse(long val) { return modInverse(BigInteger.valueOf(val), 64).longValue(); }
@SneakyThrows public static void queueClickPacket(int x, int y) { long mouseHandlerMS = System.currentTimeMillis(); setMouseHandlerLastMillis(mouseHandlerMS); long clientMS = getClientLastMillis(); long deltaMs = mouseHandlerMS - clientMS; setClientLastMillis(mouseHandlerMS); if (deltaMs < 0) { deltaMs = 0L; } if (deltaMs > 32767) { deltaMs = 32767L; } int mouseInfo = ((int) deltaMs << 1); PacketReflection.sendPacket(PacketDef.getEventMouseClick(), mouseInfo, x, y); if (checkIdleLogout()) { randomDelay = randomDelay(); Executors.newSingleThreadExecutor().submit(MousePackets::pressKey); } }
public static void queueClickPacket() { queueClickPacket(0, 0); }
private static long randomDelay() { return (long) clamp(Math.round(random.nextGaussian() * 8000)); }
private static double clamp(double val) { return Math.max(1, Math.min(13000, val)); }
private static void pressKey() { KeyEvent keyPress = new KeyEvent( client.getCanvas(), KeyEvent.KEY_PRESSED, System.currentTimeMillis(), BUTTON1_DOWN_MASK, KeyEvent.VK_BACK_SPACE); client.getCanvas().dispatchEvent(keyPress); KeyEvent keyRelease = new KeyEvent( client.getCanvas(), KeyEvent.KEY_RELEASED, System.currentTimeMillis(), 0, KeyEvent.VK_BACK_SPACE); client.getCanvas().dispatchEvent(keyRelease); KeyEvent keyTyped = new KeyEvent( client.getCanvas(), KeyEvent.KEY_TYPED, System.currentTimeMillis(), 0, KeyEvent.VK_UNDEFINED); client.getCanvas().dispatchEvent(keyTyped); }
@SneakyThrows public static void queuePlayerAction(int actionFieldNo, int playerIndex, boolean ctrlDown) { int ctrl = ctrlDown ? 1 : 0; switch (actionFieldNo) { case 1: PacketReflection.sendPacket(PacketDef.getOpPlayer1(), playerIndex, ctrl); break; case 2: PacketReflection.sendPacket(PacketDef.getOpPlayer2(), playerIndex, ctrl); break; case 3: PacketReflection.sendPacket(PacketDef.getOpPlayer3(), playerIndex, ctrl); break; case 4: PacketReflection.sendPacket(PacketDef.getOpPlayer4(), playerIndex, ctrl); break; case 5: PacketReflection.sendPacket(PacketDef.getOpPlayer5(), playerIndex, ctrl); break; case 6: PacketReflection.sendPacket(PacketDef.getOpPlayer6(), playerIndex, ctrl); break; case 7: PacketReflection.sendPacket(PacketDef.getOpPlayer7(), playerIndex, ctrl); break; case 8: PacketReflection.sendPacket(PacketDef.getOpPlayer8(), playerIndex, ctrl); break; } }
@SneakyThrows public static void queuePlayerAction(Player player, String... actionlist) { List<String> actions = Arrays.stream(PacketReflection.getClient().getPlayerOptions()).collect(Collectors.toList()); for (int i = 0; i < actions.size(); i++) { if (actions.get(i) == null) continue; actions.set(i, actions.get(i).toLowerCase()); } int num = -1; for (String action : actions) { for (String action2 : actionlist) { if (action != null && action.equalsIgnoreCase(action2)) { num = actions.indexOf(action.toLowerCase()) + 1; } } } if (num < 1 || num > 10) { return; } queuePlayerAction(num, player.getId(), false); }
public static void queueWidgetOnPlayer( int playerIndex, int sourceItemId, int sourceSlot, int sourceWidgetId, boolean ctrlDown) { int ctrl = ctrlDown ? 1 : 0; PacketReflection.sendPacket( PacketDef.getOpPlayerT(), playerIndex, sourceItemId, sourceSlot, sourceWidgetId, ctrl); }
public static void queueWidgetOnPlayer(Player player, Widget widget) { queueWidgetOnPlayer( player.getId(), widget.getItemId(), widget.getIndex(), widget.getId(), false); }
public static void writeValue(String writeDescription, int value, Object bufferInstance) { int writeTypeMagnitude = writeDescription.contains("v") ? 0 : Integer.parseInt(writeDescription.substring(1).trim()); byte[] arr = getArray(bufferInstance); int index = nextIndex(getOffset(bufferInstance)); setOffset(bufferInstance, index); index = index * Integer.parseInt(ObfuscatedNames.indexMultiplier) - 1; switch (writeDescription.charAt(0)) { case 's': setArray(bufferInstance, writeSub(writeTypeMagnitude, value, arr, index)); break; case 'a': setArray(bufferInstance, writeAdd(writeTypeMagnitude, value, arr, index)); break; case 'r': setArray(bufferInstance, writeRightShifted(writeTypeMagnitude, value, arr, index)); break; case 'v': setArray(bufferInstance, writeVar(value, arr, index)); break; } }
static byte[] writeSub(int subValue, int value, byte[] arr, int index) { arr[index] = (byte) (subValue - value); return arr; }
static byte[] writeAdd(int addValue, int value, byte[] arr, int index) { arr[index] = (byte) (addValue + value); return arr; }
static byte[] writeRightShifted(int shiftAmount, int value, byte[] arr, int index) { arr[index] = (byte) (value >> shiftAmount); return arr; }
static byte[] writeVar(int value, byte[] arr, int index) { arr[index] = (byte) (value); return arr; }
public static int nextIndex(int offset) { offset += (int) Long.parseLong(ObfuscatedNames.offsetMultiplier); return offset; }
@SneakyThrows public static void queueObjectAction( int actionFieldNo, int objectId, int worldPointX, int worldPointY, boolean ctrlDown) { int ctrl = ctrlDown ? 1 : 0; switch (actionFieldNo) { case 1: PacketReflection.sendPacket( PacketDef.getOpLoc1(), objectId, worldPointX, worldPointY, ctrl); break; case 2: PacketReflection.sendPacket( PacketDef.getOpLoc2(), objectId, worldPointX, worldPointY, ctrl); break; case 3: PacketReflection.sendPacket( PacketDef.getOpLoc3(), objectId, worldPointX, worldPointY, ctrl); break; case 4: PacketReflection.sendPacket( PacketDef.getOpLoc4(), objectId, worldPointX, worldPointY, ctrl); break; case 5: PacketReflection.sendPacket( PacketDef.getOpLoc5(), objectId, worldPointX, worldPointY, ctrl); break; } }
public static void queueWidgetOnTileObject( int objectId, int worldPointX, int worldPointY, int sourceSlot, int sourceItemId, int sourceWidgetId, boolean ctrlDown) { int ctrl = ctrlDown ? 1 : 0; PacketReflection.sendPacket( PacketDef.getOpLocT(), objectId, worldPointX, worldPointY, sourceSlot, sourceItemId, sourceWidgetId, ctrl); }
public static void queueWidgetOnTileObject(Widget widget, TileObject object) { Point p; if (object instanceof GameObject) { GameObject gameObject = (GameObject) object; p = gameObject.getSceneMinLocation(); } else { p = new Point(object.getLocalLocation().getSceneX(), object.getLocalLocation().getSceneY()); } LocalPoint lp = new LocalPoint(p.getX(), p.getY()); WorldPoint wp = WorldPoint.fromScene(PacketReflection.getClient(), lp.getX(), lp.getY(), object.getPlane()); queueWidgetOnTileObject( object.getId(), wp.getX(), wp.getY(), widget.getIndex(), widget.getItemId(), widget.getId(), false); }
@SneakyThrows public static void queueTileItemAction( int actionFieldNo, int objectId, int worldPointX, int worldPointY, boolean ctrlDown) { int ctrl = ctrlDown ? 1 : 0; switch (actionFieldNo) { case 1: PacketReflection.sendPacket( PacketDef.getOpObj1(), objectId, worldPointX, worldPointY, ctrl); break; case 2: PacketReflection.sendPacket( PacketDef.getOpObj2(), objectId, worldPointX, worldPointY, ctrl); break; case 3: PacketReflection.sendPacket( PacketDef.getOpObj3(), objectId, worldPointX, worldPointY, ctrl); break; case 4: PacketReflection.sendPacket( PacketDef.getOpObj4(), objectId, worldPointX, worldPointY, ctrl); break; case 5: PacketReflection.sendPacket( PacketDef.getOpObj5(), objectId, worldPointX, worldPointY, ctrl); break; } }
public static void queueWidgetOnTileItem( int objectId, int worldPointX, int worldPointY, int sourceSlot, int sourceItemId, int sourceWidgetId, boolean ctrlDown) { int ctrl = ctrlDown ? 1 : 0; PacketReflection.sendPacket( PacketDef.getOpObjT(), objectId, worldPointX, worldPointY, sourceSlot, sourceItemId, sourceWidgetId, ctrl); }
public static void queueTileItemAction(ETileItem item, boolean ctrlDown) { queueTileItemAction( 3, item.getTileItem().getId(), item.getLocation().getX(), item.getLocation().getY(), ctrlDown); }
public static void queueWidgetOnTileItem(ETileItem item, Widget w, boolean ctrlDown) { queueWidgetOnTileItem( item.getTileItem().getId(), item.getLocation().getX(), item.getLocation().getY(), w.getIndex(), w.getItemId(), w.getId(), ctrlDown); }
@SneakyThrows public static void queueWidgetActionPacket( int actionFieldNo, int widgetId, int itemId, int childId) { switch (actionFieldNo) { case 1: PacketReflection.sendPacket(PacketDef.getIfButton1(), widgetId, childId, itemId); break; case 2: PacketReflection.sendPacket(PacketDef.getIfButton2(), widgetId, childId, itemId); break; case 3: PacketReflection.sendPacket(PacketDef.getIfButton3(), widgetId, childId, itemId); break; case 4: PacketReflection.sendPacket(PacketDef.getIfButton4(), widgetId, childId, itemId); break; case 5: PacketReflection.sendPacket(PacketDef.getIfButton5(), widgetId, childId, itemId); break; case 6: PacketReflection.sendPacket(PacketDef.getIfButton6(), widgetId, childId, itemId); break; case 7: PacketReflection.sendPacket(PacketDef.getIfButton7(), widgetId, childId, itemId); break; case 8: PacketReflection.sendPacket(PacketDef.getIfButton8(), widgetId, childId, itemId); break; case 9: PacketReflection.sendPacket(PacketDef.getIfButton9(), widgetId, childId, itemId); break; case 10: PacketReflection.sendPacket(PacketDef.getIfButton10(), widgetId, childId, itemId); break; } }
@SneakyThrows public static void queueWidgetAction(Widget widget, String... actionlist) { if (widget == null) { System.out.println("call to queueWidgetAction with null widget"); return; } List<String> actions = Arrays.stream(widget.getActions()).collect(Collectors.toList()); for (int i = 0; i < actions.size(); i++) { if (actions.get(i) == null) continue; actions.set(i, actions.get(i).toLowerCase()); } int num = -1; for (String action : actions) { for (String action2 : actionlist) { if (action != null && Text.removeTags(action).equalsIgnoreCase(action2)) { num = actions.indexOf(action.toLowerCase()) + 1; } } } if (num < 1 || num > 10) { return; } queueWidgetActionPacket(num, widget.getId(), widget.getItemId(), widget.getIndex()); }
public static void queueWidgetOnWidget(Widget srcWidget, Widget destWidget) { queueWidgetOnWidget( srcWidget.getId(), srcWidget.getIndex(), srcWidget.getItemId(), destWidget.getId(), destWidget.getIndex(), destWidget.getItemId()); }
public static void queueWidgetOnWidget( int sourceWidgetId, int sourceSlot, int sourceItemId, int destinationWidgetId, int destinationSlot, int destinationItemId) { PacketReflection.sendPacket( PacketDef.getIfButtonT(), sourceWidgetId, sourceSlot, sourceItemId, destinationWidgetId, destinationSlot, destinationItemId); }
public static void queueResumePause(int widgetId, int childId) { PacketReflection.sendPacket(PacketDef.getResumePausebutton(), widgetId, childId); }
public static boolean useItem(String name, String... actions) { return BankInventory.search() .withName(name) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(int id, String... actions) { return BankInventory.search() .withId(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(Predicate<? super Widget> predicate, String... actions) { return BankInventory.search() .filter(predicate) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItemIndex(int index, String... actions) { return BankInventory.search() .indexIs(index) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(Widget item, String... actions) { if (item == null) { return false; } MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return true; }
public static boolean interact(String name, String... actions) { return TileObjects.search() .withName(name) .first() .flatMap( tileObject -> { MousePackets.queueClickPacket(); ObjectPackets.queueObjectAction(tileObject, false, actions); return Optional.of(true); }) .orElse(false); }
public static boolean interact(int id, String... actions) { return TileObjects.search() .withId(id) .first() .flatMap( tileObject -> { MousePackets.queueClickPacket(); ObjectPackets.queueObjectAction(tileObject, false, actions); return Optional.of(true); }) .orElse(false); }
public static boolean interact(TileObject tileObject, String... actions) { if (tileObject == null) { return false; } ObjectComposition comp = TileObjectQuery.getObjectComposition(tileObject); if (comp == null) { return false; } MousePackets.queueClickPacket(); ObjectPackets.queueObjectAction(tileObject, false, actions); return true; }
public static boolean useItem(String name, String... actions) { return Inventory.search() .withName(name) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(int id, String... actions) { return Inventory.search() .withId(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(Set<Integer> id, String... actions) { return Inventory.search() .withSet(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(Predicate<? super Widget> predicate, String... actions) { return Inventory.search() .filter(predicate) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItemIndex(int index, String... actions) { return Inventory.search() .indexIs(index) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(String name, String... actions) { return Bank.search() .withName(name) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(int id, String... actions) { return Bank.search() .withId(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(Predicate<? super Widget> predicate, String... actions) { return Bank.search() .filter(predicate) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItemIndex(int index, String... actions) { return Bank.search() .indexIs(index) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean offerItem(String name) { return GrandExchangeInventory.search() .withName(name) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Offer"); return Optional.of(true); }) .orElse(false); }
public static boolean offerItem(int id) { return GrandExchangeInventory.search() .withId(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Offer"); return Optional.of(true); }) .orElse(false); }
public static boolean offerItem(Predicate<? super Widget> predicate) { return GrandExchangeInventory.search() .filter(predicate) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Offer"); return Optional.of(true); }) .orElse(false); }
public static boolean offerItemIndex(int index) { return GrandExchangeInventory.search() .indexIs(index) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Offer"); return Optional.of(true); }) .orElse(false); }
public static boolean offerItem(Widget item) { if (item == null) { return false; } MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Offer"); return true; }
public static boolean useItem(String name, String... actions) { return ShopInventory.search() .withName(name) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(int id, String... actions) { return ShopInventory.search() .withId(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItem(Predicate<? super Widget> predicate, String... actions) { return ShopInventory.search() .filter(predicate) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean useItemIndex(int index, String... actions) { return ShopInventory.search() .indexIs(index) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static boolean interact(Player player, String... actions) { if (player == null) { return false; } MousePackets.queueClickPacket(); PlayerPackets.queuePlayerAction(player, actions); return true; }
public static boolean interact(String name, String... actions) { return Players.search() .withName(name) .first() .flatMap( Player -> { MousePackets.queueClickPacket(); PlayerPackets.queuePlayerAction(Player, actions); return Optional.of(true); }) .orElse(false); }
public static boolean interact(Predicate<? super Player> predicate, String... actions) { return Players.search() .filter(predicate) .first() .flatMap( Player -> { MousePackets.queueClickPacket(); PlayerPackets.queuePlayerAction(Player, actions); return Optional.of(true); }) .orElse(false); }
public static void flickPrayers(Prayer... prayers) { prayerMap.forEach( (prayer, widgetInfoExtended) -> { setPrayerState(prayer, false); }); for (Prayer prayer : prayers) { setPrayerState(prayer, true); } }
public static void toggleNormalPrayer(int packedWidgID) { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetActionPacket(1, packedWidgID, -1, -1); }
public static void toggleNormalPrayers(List<Integer> packedWidgIDs) { for (Integer packedWidgID : packedWidgIDs) { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetActionPacket(1, packedWidgID, -1, -1); } }
public static void togglePrayer() { MousePackets.queueClickPacket(0, 0); WidgetPackets.queueWidgetActionPacket(1, quickPrayerWidgetID, -1, -1); }
public static boolean interact(String name, String... actions) { return NPCs.search() .withName(name) .first() .flatMap( npc -> { MousePackets.queueClickPacket(); NPCPackets.queueNPCAction(npc, actions); return Optional.of(true); }) .orElse(false); }
public static boolean interact(int id, String... actions) { return NPCs.search() .withId(id) .first() .flatMap( npc -> { MousePackets.queueClickPacket(); NPCPackets.queueNPCAction(npc, actions); return Optional.of(true); }) .orElse(false); }
public static boolean interact(Predicate<? super NPC> predicate, String... actions) { return NPCs.search() .filter(predicate) .first() .flatMap( npc -> { MousePackets.queueClickPacket(); NPCPackets.queueNPCAction(npc, actions); return Optional.of(true); }) .orElse(false); }
public static boolean interactIndex(int index, String... actions) { return NPCs.search() .indexIs(index) .first() .flatMap( npc -> { MousePackets.queueClickPacket(); NPCPackets.queueNPCAction(npc, actions); return Optional.of(true); }) .orElse(false); }
public static boolean interact(NPC npc, String... actions) { if (npc == null) { return false; } NPCComposition comp = NPCQuery.getNPCComposition(npc); if (comp == null) { return false; } MousePackets.queueClickPacket(); NPCPackets.queueNPCAction(npc, actions); return true; }
public static boolean buyOne(String name) { return Shop.search() .withName(name) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 1"); return Optional.of(true); }) .orElse(false); }
public static boolean buyOne(int id) { return Shop.search() .withId(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 1"); return Optional.of(true); }) .orElse(false); }
public static boolean buyOne(Set<Integer> id) { return Shop.search() .withSet(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 1"); return Optional.of(true); }) .orElse(false); }
public static boolean buyOne(Predicate<? super Widget> predicate) { return Shop.search() .filter(predicate) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 1"); return Optional.of(true); }) .orElse(false); }
public static boolean buyOneIndex(int index) { return Shop.search() .indexIs(index) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 1"); return Optional.of(true); }) .orElse(false); }
public static boolean buyOne(Widget item) { if (item == null) { return false; } MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 1"); return true; }
public static boolean buyFive(String name) { return Shop.search() .withName(name) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 5"); return Optional.of(true); }) .orElse(false); }
public static boolean buyFive(int id) { return Shop.search() .withId(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 5"); return Optional.of(true); }) .orElse(false); }
public static boolean buyFive(Set<Integer> id) { return Shop.search() .withSet(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 5"); return Optional.of(true); }) .orElse(false); }
public static boolean buyFive(Predicate<? super Widget> predicate) { return Shop.search() .filter(predicate) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 5"); return Optional.of(true); }) .orElse(false); }
public static boolean buyFiveIndex(int index) { return Shop.search() .indexIs(index) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 5"); return Optional.of(true); }) .orElse(false); }
public static boolean buyFive(Widget item) { if (item == null) { return false; } MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 5"); return true; }
public static boolean buyTen(String name) { return Shop.search() .withName(name) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 10"); return Optional.of(true); }) .orElse(false); }
public static boolean buyTen(int id) { return Shop.search() .withId(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 10"); return Optional.of(true); }) .orElse(false); }
public static boolean buyTen(Set<Integer> id) { return Shop.search() .withSet(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 10"); return Optional.of(true); }) .orElse(false); }
public static boolean buyTen(Predicate<? super Widget> predicate) { return Shop.search() .filter(predicate) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 10"); return Optional.of(true); }) .orElse(false); }
public static boolean buyTenIndex(int index) { return Shop.search() .indexIs(index) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 10"); return Optional.of(true); }) .orElse(false); }
public static boolean buyTen(Widget item) { if (item == null) { return false; } MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 10"); return true; }
public static boolean buyFifty(String name) { return Shop.search() .withName(name) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 50"); return Optional.of(true); }) .orElse(false); }
public static boolean buyFifty(int id) { return Shop.search() .withId(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 50"); return Optional.of(true); }) .orElse(false); }
public static boolean buyFifty(Set<Integer> id) { return Shop.search() .withSet(id) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 50"); return Optional.of(true); }) .orElse(false); }
public static boolean buyFifty(Predicate<? super Widget> predicate) { return Shop.search() .filter(predicate) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 50"); return Optional.of(true); }) .orElse(false); }
public static boolean buyFiftyIndex(int index) { return Shop.search() .indexIs(index) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 50"); return Optional.of(true); }) .orElse(false); }
public static boolean buyFifty(Widget item) { if (item == null) { return false; } MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, "Buy 50"); return true; }
@Subscribe public void onMenuOptionClicked(MenuOptionClicked e) { if (config.debug()) { client.addChatMessage(ChatMessageType.GAMEMESSAGE, "Packet Utils", e.toString(), null); System.out.println(e); } }
@SneakyThrows public void cleanup() { if (!loadedConfigName.equals(makeString())) { for (int i = 0; i < 10; i++) { log.error("ETHAN VANN PLUGINS LOADED WITH INCORRECT CONFIG DATA THIS IS NOT SUPPORTED"); log.error( "DEVELOPERS SHOULD IGNORE BUG REPORTS CONTAINING THIS LINE UNTIL THIS ISSUE IS" + " RESOLVED"); } } else { log.info("config loaded from correct path"); } Path codeSource = RuneLite.RUNELITE_DIR.toPath().resolve("PacketUtils"); List<Path> toDelete = new ArrayList<>(); toDelete.add(codeSource.resolve("vanilla.jar")); toDelete.add(codeSource.resolve("patched.jar")); toDelete.add(codeSource.resolve("doAction.class")); toDelete.add(codeSource.resolve("decompiled.txt")); for (Path path : toDelete) { Files.deleteIfExists(path); } }
public static void downloadVanillaJar(Path vanillaOutputPath, URL rlConfigURL) throws IOException { BufferedReader configReader = new BufferedReader(new InputStreamReader(rlConfigURL.openConnection().getInputStream())); while (configReader.ready()) { String line = configReader.readLine(); if (line == null) { continue; } if (line.contains("runelite.gamepack")) { URL clientURL = new URL(line.split("=")[1]); log.info("Downloading vanilla client from " + clientURL); try (InputStream clientStream = clientURL.openStream()) { Files.copy(clientStream, vanillaOutputPath, StandardCopyOption.REPLACE_EXISTING); } } } configReader.close(); }
@Override public void shutDown() { log.info("Shutdown"); }
public String makeString() { return RuneLiteProperties.getVersion() + "-" + client.getRevision() + ".txt"; }
public static int TO_GROUP(int id) { return id >>> 16; }
public static int TO_CHILD(int id) { return id & 0xFFFF; }
public static int PACK(int groupId, int childId) { return groupId << 16 | childId; }
public static Class loadClassFromClientClassLoader(String name) { try { ClassLoader clientLoader = getClient().getClass().getClassLoader(); return clientLoader.loadClass(name); } catch (ClassNotFoundException e) { e.printStackTrace(); } return null; }
static Field fetchPacketField(String name) { try { Class ClientPacket = getClientPacketClass(); return ClientPacket.getDeclaredField(name); } catch (NoSuchFieldException e) { e.printStackTrace(); return null; } }
private static BigInteger modInverse(BigInteger val) { BigInteger shift = BigInteger.ONE.shiftLeft(32); return val.modInverse(shift); }
private static int modInverse(int val) { return modInverse(BigInteger.valueOf(val)).intValue(); }
@ConfigItem(keyName = "debug", name = "debug", description = "enable menuaction debug output") default boolean debug() { return false; }
@ConfigItem( keyName = "alwaysOn", name = "Always enabled.", description = "Makes this plugin always enabled on startup if the revision matches.") default boolean alwaysOn() { return false; }
@Override public Dimension render(Graphics2D graphics) { panelComponent.getChildren().clear(); LineComponent timeout = buildLine("Timeout: ", String.valueOf(plugin.timeout)); panelComponent.getChildren().add(timeout); return null; }
@ConfigItem( keyName = "boneName", name = "Bone name", description = "The name of the bone to use on the altar", position = 2) default String boneName() { return "Dragon bones"; }
@ConfigItem( keyName = "altarName", name = "Altar name", description = "The name of the altar to use", position = 3) default String altarName() { return "Chaos altar"; }
@Override protected void shutDown() throws Exception { keyManager.unregisterKeyListener(toggle); overlayManager.remove(overlay); timeout = 0; started = false; }
@Override protected void startUp() throws Exception { this.randomDelay = this.randomDelay(); }
@Subscribe public void onGameTick(GameTick event) { if (this.checkIdleLogout()) { this.randomDelay = this.randomDelay(); Executors.newSingleThreadExecutor().submit(this::pressKey); } }
private long randomDelay() { return (long) clamp(Math.round(this.random.nextGaussian() * 8000.0)); }
private static double clamp(double val) { return Math.max(1.0, Math.min(13000.0, val)); }
private void pressKey() { KeyEvent keyPress = new KeyEvent( this.client.getCanvas(), KeyEvent.KEY_PRESSED, System.currentTimeMillis(), 0, KeyEvent.VK_SPACE, KeyEvent.CHAR_UNDEFINED); this.client.getCanvas().dispatchEvent(keyPress); KeyEvent keyRelease = new KeyEvent( this.client.getCanvas(), KeyEvent.KEY_RELEASED, System.currentTimeMillis(), 0, KeyEvent.VK_SPACE, KeyEvent.CHAR_UNDEFINED); this.client.getCanvas().dispatchEvent(keyRelease); KeyEvent keyTyped = new KeyEvent( this.client.getCanvas(), KeyEvent.KEY_TYPED, System.currentTimeMillis(), 0, KeyEvent.VK_SPACE, KeyEvent.CHAR_UNDEFINED); this.client.getCanvas().dispatchEvent(keyTyped); }
@Subscribe public void onGameTick(GameTick e) { if (!EthanApiPlugin.loggedIn()) { return; } if (runIsOff() && hasMoreThanZeroEnergy()) { enableRun(); } }
boolean runIsOff() { return EthanApiPlugin.getClient().getVarpValue(173) == 0; }
boolean hasMoreThanZeroEnergy() { return EthanApiPlugin.getClient().getEnergy() > 100; }
void enableRun() { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetActionPacket(1, 10485787, -1, -1); }
public static void main(String[] args) throws Exception { ExternalPluginManager.loadBuiltin( EthanApiPlugin.class, PacketUtilsPlugin.class, PiggyUtilsPlugin.class , AutoBonerPlugin.class, EthanPrayerFlickerPlugin.class, LeftClickBlackJackPlugin.class, ItemCombinerPlugin.class); RuneLite.main(args); }
@Override public Dimension render(Graphics2D graphics) { panelComponent.getChildren().clear(); LineComponent logName = buildLine("Logs: ", plugin.logName); LineComponent timeout = buildLine("Timeout: ", String.valueOf(plugin.timeout)); panelComponent.getChildren().add(logName); if (plugin.location != null) { LineComponent location = buildLine("Location: ", plugin.location.toString()); panelComponent.getChildren().add(location); } panelComponent.getChildren().add(timeout); if (plugin.startTiles != null) { String lineString = String.format("%s/%s", plugin.lastStartTile + 1, plugin.startTiles.size()); LineComponent line = buildLine("Line: ", lineString); panelComponent.getChildren().add(line); } return panelComponent.render(graphics); }
private void renderTile( final Graphics2D graphics, final LocalPoint dest, final Color color, final Color fillColor, @Nullable String label) { if (dest == null) { return; } final Polygon poly = Perspective.getCanvasTilePoly(client, dest); if (poly == null) { return; } OverlayUtil.renderPolygon(graphics, poly, color, fillColor, new BasicStroke((float) 1.5)); if (!Strings.isNullOrEmpty(label)) { Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, dest, label, 0); if (canvasTextLocation != null) { OverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, color); } } }
@Override protected void startUp() throws Exception { keyManager.registerKeyListener(toggle); overlayManager.add(overlay); timeout = 0; lastStartTile++; clientThread.invoke( () -> { location = config.getLocation(); startTiles = location.getStartTiles(); logName = config.getLogs(); }); }
@Override protected void shutDown() throws Exception { keyManager.unregisterKeyListener(toggle); overlayManager.remove(overlay); started = false; timeout = 0; lastStartTile = -1; firstFire = true; }
@Subscribe public void onConfigChanged(ConfigChanged event) { if (!event.getGroup().equals("AutoFiremaking")) return; }
public void depositInventory() { Widget depositInventory = client.getWidget(WidgetInfo.BANK_DEPOSIT_INVENTORY); if (depositInventory != null) { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(depositInventory, "Deposit inventory"); } }
public boolean hasTinderbox() { return Inventory.search().nameContains("inderbox").first().isPresent(); }
public boolean hasLogs() { return Inventory.search().nameContains(logName).first().isPresent(); }
public boolean isStandingOnFire() { WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation(); return TileObjects.search().nameContains("ire").result().stream() .anyMatch(fire -> fire.getWorldLocation().equals(playerLocation)); }
private void handleStartFire() { if (isStandingOnFire()) { getNextFreeTileInLine() .ifPresent( freeTile -> { MousePackets.queueClickPacket(); MovementPackets.queueMovement(freeTile); timeout = 3; }); } Inventory.search() .onlyUnnoted() .nameContains("inderbox") .first() .ifPresent( tinderbox -> { Inventory.search() .onlyUnnoted() .nameContains(logName) .first() .ifPresent( logs -> { MousePackets.queueClickPacket(); MousePackets.queueClickPacket(); WidgetPackets.queueWidgetOnWidget(tinderbox, logs); firstFire = false; }); }); }
@Override @SneakyThrows public void startUp() { timeout = 0; }
@Subscribe public void onGameTick(GameTick event) throws NoSuchFieldException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, IllegalAccessException { int hitpoints = this.client.getBoostedSkillLevel(Skill.HITPOINTS); int prayer = this.client.getBoostedSkillLevel(Skill.PRAYER); int magic = this.client.getBoostedSkillLevel(Skill.MAGIC); int stamina = client.getEnergy() / 100; int ranged = this.client.getBoostedSkillLevel(Skill.RANGED); int strength = this.client.getBoostedSkillLevel(Skill.STRENGTH); if (hitpoints < config.HealthLowAmount()) { handleAction(config.HealthActions()); } if (prayer < config.PrayerLowAmount()) { handleAction(config.PrayerActions()); } if (magic < config.MagicLowAmount()) { handleAction(config.MagicActions()); } if (stamina < config.StaminaLowAmount()) { handleAction(config.StaminaActions()); } if (ranged < config.RangeLowAmount()) { handleAction(config.RangeActions()); } if (strength < config.StrengthLowAmount()) { handleAction(config.StrengthActions()); } if (config.AntiFireToggle()) { handleAntiFire(); } if (config.AntiVenomToggle()) { handleAntiVenom(); } }
public void handleAction(String actionParam) { String[] Actions = actionParam.split("\n"); for (String Action : Actions) { if (!Action.contains(":")) { continue; } String action = Action.split(":")[0]; String itemCSV = Action.split(":")[1]; String[] items = itemCSV.split(","); for (String item : items) { Optional<Widget> itemBeingUsed = StringUtils.isNumeric(item) ? Inventory.search().withId(Integer.parseInt(item)).first() : Inventory.search().matchesWildCardNoCase(item).first(); if (itemBeingUsed.isPresent()) { InventoryInteraction.useItem(itemBeingUsed.get(), action); break; } } } }
@ConfigItem( keyName = "HealthLowAmount", name = "Health Low Amount", description = "Health low actions will fire when health falls below this value") default int HealthLowAmount() { return 0; }
@ConfigItem( keyName = "HealthLowActions", name = "Health Low Actions", description = "List of item actions to use when health falls below value") default String HealthActions() { return ""; }
@ConfigItem( keyName = "StaminaLowAmount", name = "Stamina Low Amount", description = "Health low actions will fire when stamina falls below this value") default int StaminaLowAmount() { return 0; }
@ConfigItem( keyName = "StaminaLowActions", name = "Stamina Low Actions", description = "List of item actions to use when stamina falls below value") default String StaminaActions() { return ""; }
@ConfigItem( keyName = "RangeLowAmount", name = "Range Low Amount", description = "Health low actions will fire when range falls below this value") default int RangeLowAmount() { return 0; }
@ConfigItem( keyName = "RangeLowActions", name = "Range Low Actions", description = "List of item actions to use when range falls below value") default String RangeActions() { return ""; }
@ConfigItem( keyName = "PrayerLowAmount", name = "Prayer Low Amount", description = "Health low actions will fire when prayer falls below this value") default int PrayerLowAmount() { return 0; }
@ConfigItem( keyName = "PrayerLowActions", name = "Prayer Low Actions", description = "List of item actions to use when prayer falls below value") default String PrayerActions() { return ""; }
@ConfigItem( keyName = "MagicLowAmount", name = "Magic Low Amount", description = "Health low actions will fire when magic falls below this value") default int MagicLowAmount() { return 0; }
@ConfigItem( keyName = "MagicLowActions", name = "Magic Low Actions", description = "List of item actions to use when magic falls below value") default String MagicActions() { return ""; }
@ConfigItem( keyName = "StrengthLowAmount", name = "Strength Low Amount", description = "Health low actions will fire when strength falls below this value") default int StrengthLowAmount() { return 0; }
@ConfigItem( keyName = "StrengthLowActions", name = "Strength Low Actions", description = "List of item actions to use when strength falls below value") default String StrengthActions() { return ""; }
@ConfigItem( keyName = "AntiFireToggle", name = "AntiFire Toggle", description = "", position = 200) default boolean AntiFireToggle() { return false; }
@ConfigItem( keyName = "AntiFireActions", name = "AntiFire Actions", description = "List of item actions to use when not anti-fired", position = 201) default String AntiFireActions() { return ""; }
@ConfigItem( keyName = "AntiVenomToggle", name = "AntiVenom Toggle", description = "", position = 202) default boolean AntiVenomToggle() { return false; }
@ConfigItem( keyName = "AntiVenomActions", name = "AntiVenom Actions", description = "List of item actions to use when infliced with venom/poison", position = 203) default String AntiPoisonActions() { return ""; }
@ConfigItem( keyName = "combatrange", name = "combat range only", description = "When checked you will only teleport from players able to attack you") default boolean combatrange() { return true; }
@ConfigItem( keyName = "notify", name = "chat notification on enter wilderness?", description = "When enabled the plugin will tell you if you brought a teleport item or not when" + " entering the wilderness") default boolean alert() { return true; }
@ConfigItem(keyName = "autoPray", name = "Auto Prayers", description = "") default boolean autoPray() { return false; }
@ConfigItem(keyName = "awakened", name = "Awakened Vardorvis", description = "", position = 0) default boolean awakened() { return false; }
@Override protected void startUp() throws Exception { overlayManager.add(overlay); }
@Override protected void shutDown() throws Exception { overlayManager.remove(overlay); }
private void handleMageFirstGameTick() { if (mageTicks > 0) { if (!PrayerUtil.isPrayerActive(Prayer.PROTECT_FROM_MAGIC)) { PrayerUtil.togglePrayer(Prayer.PROTECT_FROM_MAGIC); } } else if (rangeTicks > 0) { if (!PrayerUtil.isPrayerActive(Prayer.PROTECT_FROM_MISSILES)) { PrayerUtil.togglePrayer(Prayer.PROTECT_FROM_MISSILES); } } else { if (!PrayerUtil.isPrayerActive(Prayer.PROTECT_FROM_MELEE)) { PrayerUtil.togglePrayer(Prayer.PROTECT_FROM_MELEE); } } }
private void handleRangeFirstGameTick() { if (rangeTicks > 0) { if (!PrayerUtil.isPrayerActive(Prayer.PROTECT_FROM_MISSILES)) { PrayerUtil.togglePrayer(Prayer.PROTECT_FROM_MISSILES); } } else if (mageTicks > 0) { if (!PrayerUtil.isPrayerActive(Prayer.PROTECT_FROM_MAGIC)) { PrayerUtil.togglePrayer(Prayer.PROTECT_FROM_MAGIC); } } else { if (!PrayerUtil.isPrayerActive(Prayer.PROTECT_FROM_MELEE)) { PrayerUtil.togglePrayer(Prayer.PROTECT_FROM_MELEE); } } }
private void doBloodCaptcha() { List<Widget> captchaBlood = Widgets.search() .filter(widget -> widget.getParentId() != 9764864) .hiddenState(false) .withAction("Destroy") .result(); if (!captchaBlood.isEmpty()) { captchaBlood.forEach( x -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(x, "Destroy"); }); } }
public boolean isInFight() { return client.isInInstancedRegion() && NPCs.search().nameContains(VARDOVIS).nearestToPlayer().isPresent(); }
@Override public Dimension render(Graphics2D graphics2D) { if (!plugin.isInFight()) { return null; } panelComponent.getChildren().clear(); BufferedImage prayerImage; prayerImage = getPrayerImage(plugin.getPrayerSprite()); panelComponent.setBackgroundColor( client.isPrayerActive(plugin.getCorrectPrayer()) ? Color.GREEN : Color.RED); panelComponent.getChildren().add(new ImageComponent(prayerImage)); return super.render(graphics2D); }
@ConfigItem(keyName = "bar", name = "Bar", description = "Which bar you will use", position = 1) default Bar bar() { return Bar.MITHRIL; }
@ConfigItem( keyName = "item", name = "Item", description = "Which item you will make", position = 2) default SmithingItem item() { return SmithingItem.PLATE_BODY; }
@ConfigItem( keyName = "tickDelay", name = "Tick Delay", description = "Slow down certain actions", position = 3) default int tickDelay() { return 0; }
@Override @SneakyThrows public void startUp() { overlayManager.add(overlay); timeout = 0; isSmithing = false; keyManager.registerKeyListener(toggle); log.info(config.bar().getName() + " - " + config.item().toString()); }
@Override public void shutDown() { isSmithing = false; timeout = 0; idleTicks = 0; started = false; keyManager.unregisterKeyListener(toggle); overlayManager.remove(overlay); }
private boolean hasBarsButNotEnough() { return InventoryUtil.hasItem(config.bar().getName()) && !hasEnoughBars(); }
private boolean hasEnoughBars() { return (Inventory.getItemAmount(config.bar().getName()) >= config.item().getBarsRequired()); }
private boolean canSmithBars() { return Inventory.search().withName(config.bar().getName()).result().size() > 5 && !Inventory.search().withName("Hammer").empty(); }
private void findBank() { Optional<NPC> banker = NPCs.search().withAction("Bank").withId(2897).nearestToPlayer(); Optional<TileObject> bank = TileObjects.search().withAction("Bank").nearestToPlayer(); if (!Bank.isOpen()) { if (banker.isPresent()) { NPCInteraction.interact(banker.get(), "Bank"); timeout = config.tickDelay() == 0 ? 1 : config.tickDelay(); } else if (bank.isPresent()) { TileObjectInteraction.interact(bank.get(), "Bank"); timeout = config.tickDelay() == 0 ? 1 : config.tickDelay(); } else { client.addChatMessage( ChatMessageType.GAMEMESSAGE, "", "Couldn't find bank or banker", null); EthanApiPlugin.stopPlugin(this); } } }
private void bankHandler() { if (!Bank.isOpen()) return; Widget depositInventory = client.getWidget(WidgetInfo.BANK_DEPOSIT_INVENTORY); if (depositInventory != null) { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(depositInventory, "Deposit inventory"); } Bank.search() .withName("Hammer") .first() .ifPresentOrElse( hammer -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(hammer, "Withdraw-1"); }, () -> { if (Inventory.getItemAmount("Hammer") > 0) return; EthanApiPlugin.sendClientMessage("No hammer in bank or inventory"); EthanApiPlugin.stopPlugin(this); }); Bank.search() .withName(config.bar().getName()) .first() .ifPresentOrElse( bar -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(bar, "Withdraw-All"); }, () -> { EthanApiPlugin.sendClientMessage("No bars left"); EthanApiPlugin.stopPlugin(this); }); timeout = config.tickDelay(); }
@Override public Dimension render(Graphics2D graphics) { panelComponent.getChildren().clear(); LineComponent timeout = buildLine("Timeout: ", String.valueOf(plugin.timeout)); LineComponent idleTicks = buildLine("Idle Ticks: ", String.valueOf(plugin.idleTicks)); LineComponent started = buildLine("Started: ", String.valueOf(plugin.started)); panelComponent.getChildren().add(started); panelComponent.getChildren().add(timeout); panelComponent.getChildren().add(idleTicks); return panelComponent.render(graphics); }
@ConfigItem(keyName = "oneTickFlick", name = "One Tick Flick", description = "") default boolean oneTickFlick() { return true; }
@ConfigItem( keyName = "rigourUnlocked", name = "Rigour Unlocked", description = "Do you have rigour?") default boolean rigourUnlocked() { return true; }
@Subscribe public void onGameTick(GameTick event) { if (!inFight()) { return; } Prayer nextPrayer = prayerMap.get(client.getTickCount()); if (nextPrayer != null) { if (shouldPray != nextPrayer && client.isPrayerActive(shouldPray)) { PrayerUtil.togglePrayer(shouldPray); } shouldPray = nextPrayer; } if (config.oneTickFlick()) { oneTickFlick(); } else { autoPrayer(); } }
private void oneTickFlick() { if (PrayerUtil.isPrayerActive(shouldPray)) { PrayerUtil.togglePrayer(shouldPray); } if (config.rigourUnlocked()) { if (PrayerUtil.isPrayerActive(Prayer.RIGOUR)) { PrayerUtil.togglePrayer(Prayer.RIGOUR); } PrayerUtil.togglePrayer(Prayer.RIGOUR); } else { if (PrayerUtil.isPrayerActive(Prayer.EAGLE_EYE)) { PrayerUtil.togglePrayer(Prayer.EAGLE_EYE); } PrayerUtil.togglePrayer(Prayer.EAGLE_EYE); } PrayerUtil.togglePrayer(shouldPray); }
private void autoPrayer() { if (!PrayerUtil.isPrayerActive(shouldPray)) { PrayerUtil.togglePrayer(shouldPray); } }
private void setupJadPrayers(NPC npc) { int animationID = EthanApiPlugin.getAnimation(npc); if (animationID == 2656 || animationID == 7592) { prayerMap.put(client.getTickCount() + 2, Prayer.PROTECT_FROM_MAGIC); } else if (animationID == 2652 || animationID == 7593) { prayerMap.put(client.getTickCount() + 2, Prayer.PROTECT_FROM_MISSILES); } }
private boolean inFight() { return NpcUtil.nameContainsNoCase("-jad") .filter( npc -> !npc.getName().toLowerCase().contains("jalrek-jad") && !npc.getName().toLowerCase().contains("tzrek-jad")) .nearestToPlayer() .isPresent(); }
@Override protected void startUp() throws Exception { breakHandler.registerPlugin(this); keyManager.registerKeyListener(toggle); overlayManager.add(overlay); }
@Override protected void shutDown() throws Exception { breakHandler.unregisterPlugin(this); keyManager.unregisterKeyListener(toggle); overlayManager.remove(overlay); }
@Override public Dimension render(Graphics2D graphics) { panelComponent .getChildren() .add(TitleComponent.builder().text("Ethan 3t4g").color(Color.WHITE).build()); panelComponent .getChildren() .add( TitleComponent.builder() .text(plugin.isStarted() ? "Running" : "Paused") .color(plugin.isStarted() ? Color.GREEN : Color.RED) .build()); return super.render(graphics); }
@ConfigItem(keyName = "e3t4gToggle", name = "Toggle", description = "") default Keybind e3t4gToggle() { return Keybind.NOT_SET; }
@Override protected void startUp() throws Exception { overlayManager.add(overlay); timeout = 0; isSmithing = false; keyManager.registerKeyListener(toggle); log.info(config.bar().getName() + " - " + config.item().toString()); }
@Override protected void shutDown() throws Exception { isSmithing = false; timeout = 0; idleTicks = 0; started = false; keyManager.unregisterKeyListener(toggle); overlayManager.remove(overlay); }
public boolean hasHammer() { return !Inventory.search().nameContains("Hammer").empty(); }
public boolean hasBarsButNotEnough() { return InventoryUtil.hasItem(config.bar().getName()) && !hasEnoughBars(); }
public boolean hasEnoughBars() { return (Inventory.getItemAmount(config.bar().getName()) >= config.item().getBarsRequired()); }
@Override public boolean validate() { anvil = TileObjects.search().withName("Anvil").nearestToPlayer(); Widget smithingInterface = plugin .getClient() .getWidget(WidgetInfoExtended.SMITHING_INVENTORY_ITEMS_CONTAINER.getPackedId()); return anvil.isPresent() && smithingInterface == null && plugin.hasEnoughBars() && plugin.hasHammer(); }
@Override public void execute() { log.info("interacting with anvil"); boolean action = interactObject(anvil.get(), "Smith"); if (!action) log.info("failed anvil interaction"); plugin.timeout = config.tickDelay() == 0 ? 1 : config.tickDelay(); }
@Override public boolean validate() { return !Bank.isOpen() && (!plugin.hasEnoughBars() || plugin.hasBarsButNotEnough() || !plugin.hasHammer()); }
@Override public void execute() { log.info("Open Bank"); findBank(); }
private void findBank() { Optional<NPC> banker = NPCs.search().withAction("Bank").withId(2897).nearestToPlayer(); Optional<TileObject> bank = TileObjects.search().withAction("Bank").nearestToPlayer(); if (!Bank.isOpen()) { if (banker.isPresent()) { interactNpc(banker.get(), "Bank"); plugin.timeout = config.tickDelay() == 0 ? 1 : config.tickDelay(); } else if (bank.isPresent()) { interactObject(bank.get(), "Bank"); plugin.timeout = config.tickDelay() == 0 ? 1 : config.tickDelay(); } else { EthanApiPlugin.sendClientMessage("Couldn't find bank or banker"); EthanApiPlugin.stopPlugin(plugin); } } }
@Override public boolean validate() { Widget smithingInterface = plugin .getClient() .getWidget(WidgetInfoExtended.SMITHING_INVENTORY_ITEMS_CONTAINER.getPackedId()); return smithingInterface != null && plugin.hasEnoughBars() && plugin.hasHammer(); }
@Override public void execute() { log.info("Smithing"); MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction( plugin.getClient().getWidget(config.item().getWidgetInfo().getPackedId()), "Smith", "Smith set"); plugin.isSmithing = true; plugin.timeout = 5 * (27 / config.item().getBarsRequired()); }
@Override public boolean validate() { return Bank.isOpen() && (!plugin.hasEnoughBars() || plugin.hasBarsButNotEnough() || !plugin.hasHammer()); }
@Override public void execute() { log.info("Do Banking"); bankHandler(); }
private void bankHandler() { Widget depositInventory = plugin.getClient().getWidget(WidgetInfoExtended.BANK_DEPOSIT_INVENTORY.getPackedId()); if (depositInventory != null) { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(depositInventory, "Deposit inventory"); } Bank.search() .withName("Hammer") .first() .ifPresentOrElse( hammer -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(hammer, "Withdraw-1"); }, () -> { if (Inventory.getItemAmount("Hammer") > 0) return; EthanApiPlugin.sendClientMessage("No hammer in bank or inventory"); EthanApiPlugin.stopPlugin(plugin); }); Bank.search() .withName(config.bar().getName()) .first() .ifPresentOrElse( bar -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(bar, "Withdraw-All"); }, () -> { EthanApiPlugin.sendClientMessage("No bars left"); EthanApiPlugin.stopPlugin(plugin); }); plugin.timeout = config.tickDelay(); }
@Range(min = 1, max = 10) @ConfigItem(keyName = "perTick", name = "Darts per tick", description = "", position = 1) default int perTick() { return 10; }
@ConfigItem(keyName = "broadBolts", name = "Broad Bolts?", description = "", position = 2) default boolean broadBolts() { return false; }
@Override protected void startUp() throws Exception { keyManager.registerKeyListener(toggle); }
@Override protected void shutDown() throws Exception { keyManager.unregisterKeyListener(toggle); }
private void fletchDarts() { Widget feather = Inventory.search().nameContains("Feather").first().get(); Inventory.search() .nameContains(tipSearch) .first() .ifPresent( item -> { for (int i = 0; i < config.perTick(); i++) { MousePackets.queueClickPacket(); MousePackets.queueClickPacket(); WidgetPackets.queueWidgetOnWidget(item, feather); } }); }
private boolean hasDarts() { return Inventory.search().nameContains(tipSearch).first().isPresent(); }
private boolean hasFeather() { return Inventory.search().nameContains("Feather").first().isPresent(); }
public void registerPlugin(Plugin plugin) { registerPlugin(plugin, true); }
public void registerPlugin(Plugin plugin, boolean configurable) { plugins.put(plugin, configurable); pluginsSubject.onNext(plugins); }
public void unregisterPlugin(Plugin plugin) { plugins.remove(plugin); pluginsSubject.onNext(plugins); }
public void startPlugin(Plugin plugin) { activePlugins.add(plugin); activeSubject.onNext(activePlugins); startTimes.put(plugin, Instant.now()); amountOfBreaks.put(plugin, 0); }
public void stopPlugin(Plugin plugin) { activePlugins.remove(plugin); activeSubject.onNext(activePlugins); removePlannedBreak(plugin); stopBreak(plugin); startTimes.remove(plugin); amountOfBreaks.remove(plugin); }
public void planBreak(Plugin plugin, Instant instant) { plannedBreaks.put(plugin, instant); plannedBreaksSubject.onNext(plannedBreaks); }
public void removePlannedBreak(Plugin plugin) { plannedBreaks.remove(plugin); plannedBreaksSubject.onNext(plannedBreaks); }
public boolean isBreakPlanned(Plugin plugin) { return plannedBreaks.containsKey(plugin); }
public boolean shouldBreak(Plugin plugin) { if (!plannedBreaks.containsKey(plugin)) { return false; } return Instant.now().isAfter(getPlannedBreak(plugin)); }
public static boolean needsBankPin(Client client) { Widget w = client.getWidget(WidgetInfo.BANK_PIN_CONTAINER); return w != null && !w.isHidden(); }
public void startBreak(Plugin plugin) { int from = getOrDefaultFrom(plugin, configManager); int to = getOrDefaultTo(plugin, configManager); int random = new IntRandomNumberGenerator(from, to).nextInt(); removePlannedBreak(plugin); Instant breakUntil = Instant.now().plus(random, ChronoUnit.SECONDS); activeBreaks.put(plugin, breakUntil); activeBreaksSubject.onNext(activeBreaks); currentActiveBreaksSubject.onNext(Pair.of(plugin, breakUntil)); if (amountOfBreaks.containsKey(plugin)) { amountOfBreaks.put(plugin, amountOfBreaks.get(plugin) + 1); } else { amountOfBreaks.put(plugin, 1); } }
public void startBreak(Plugin plugin, Instant instant) { removePlannedBreak(plugin); activeBreaks.put(plugin, instant); activeBreaksSubject.onNext(activeBreaks); currentActiveBreaksSubject.onNext(Pair.of(plugin, instant)); if (amountOfBreaks.containsKey(plugin)) { amountOfBreaks.put(plugin, amountOfBreaks.get(plugin) + 1); } else { amountOfBreaks.put(plugin, 1); } }
public void stopBreak(Plugin plugin) { activeBreaks.remove(plugin); activeBreaksSubject.onNext(activeBreaks); }
public void removeExtraData(Plugin plugin, String key) { if (!extraData.containsKey(plugin)) { return; } extraData.get(plugin).remove(key); extraDataSubject.onNext(extraData); }
public void resetExtraData(Plugin plugin) { extraData.remove(plugin); extraDataSubject.onNext(extraData); }
public boolean isBreakActive(Plugin plugin) { return activeBreaks.containsKey(plugin); }
public void logoutNow(Plugin plugin) { logoutActionSubject.onNext(plugin); }
public @NonNull Observable<Plugin> getlogoutActionObservable() { return logoutActionSubject.hide(); }
public void loginNow(Plugin plugin) { loginActionSubject.onNext(plugin); }
protected void shutDown() { executorService.shutdown(); clientToolbar.removeNavigation(navButton); panel.pluginDisposable.dispose(); panel.activeDisposable.dispose(); panel.currentDisposable.dispose(); panel.startDisposable.dispose(); panel.configDisposable.dispose(); for (Disposable disposable : disposables.values()) { if (!disposable.isDisposed()) { disposable.dispose(); } } if (activeBreaks != null && !activeBreaks.isDisposed()) { activeBreaks.dispose(); } if (secondsDisposable != null && !secondsDisposable.isDisposed()) { secondsDisposable.dispose(); } if (activeDisposable != null && !activeDisposable.isDisposed()) { activeDisposable.dispose(); } if (logoutDisposable != null && !logoutDisposable.isDisposed()) { logoutDisposable.dispose(); } }
@Subscribe public void onConfigChanged(ConfigChanged configChanged) { chinBreakHandler.configChanged.onNext(configChanged); }
public void scheduleBreak(Plugin plugin) { int from = Integer.parseInt( configManager.getConfiguration( "piggyBreakHandler", sanitizedName(plugin) + "-thresholdfrom")) * 60; int to = Integer.parseInt( configManager.getConfiguration( "piggyBreakHandler", sanitizedName(plugin) + "-thresholdto")) * 60; int random = new IntRandomNumberGenerator(from, to).nextInt(); chinBreakHandler.planBreak(plugin, Instant.now().plus(random, ChronoUnit.SECONDS)); }
private void breakActivated(Pair<Plugin, Instant> pluginInstantPair) { Plugin plugin = pluginInstantPair.getKey(); if (!chinBreakHandler.getPlugins().get(plugin) || Boolean.parseBoolean( configManager.getConfiguration( "piggyBreakHandler", sanitizedName(plugin) + "-logout"))) { logout = true; state = State.LOGOUT; } }
public static String sanitizedName(Plugin plugin) { String input = plugin.getName().toLowerCase(); input = input.replaceAll("<[^>]*>", ""); input = input.replaceAll("\\[.*?\\]", ""); input = input.replaceAll("[^a-zA-Z0-9\\s]", ""); input = input.replaceAll("\\s+", ""); return input; }
public void pressShitKey(char key) { skeyEvent(401, key); skeyEvent(402, key); skeyEvent(400, key); }
private void skeyEvent(int id, char key) { KeyEvent e = new KeyEvent( client.getCanvas(), id, System.currentTimeMillis(), 0, KeyEvent.VK_UNDEFINED, key); client.getCanvas().dispatchEvent(e); }
private void resetQuickHopper() { displaySwitcherAttempts = 0; quickHopTargetWorld = null; }
@Subscribe public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked) { if (state == State.LOGIN_SCREEN) { Widget playButton = client.getWidget(WidgetID.LOGIN_CLICK_TO_PLAY_GROUP_ID, 78); if (playButton == null) { return; } menuAction(menuOptionClicked, "Play", "", 1, MenuAction.CC_OP, -1, playButton.getId()); state = State.INVENTORY; } else if (state == State.LOGOUT_BUTTON) { Widget logoutButton = client.getWidget(182, 8); Widget logoutDoorButton = client.getWidget(69, 23); int param1 = -1; if (logoutButton != null) { param1 = logoutButton.getId(); } else if (logoutDoorButton != null) { param1 = logoutDoorButton.getId(); } if (param1 == -1) { menuOptionClicked.consume(); return; } menuAction(menuOptionClicked, "Logout", "", 1, MenuAction.CC_OP, -1, param1); state = State.NULL; } }
private void click(Widget widget) { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(widget, widget.getActions()[0]); }
private void click() { executorService.submit( () -> { Point point = new Point(0, 0); mouseEvent(MouseEvent.MOUSE_ENTERED, point); mouseEvent(MouseEvent.MOUSE_EXITED, point); mouseEvent(MouseEvent.MOUSE_MOVED, point); mouseEvent(MouseEvent.MOUSE_PRESSED, point); mouseEvent(MouseEvent.MOUSE_RELEASED, point); mouseEvent(MouseEvent.MOUSE_CLICKED, point); }); }
private void mouseEvent(int id, Point point) { MouseEvent mouseEvent = new MouseEvent( client.getCanvas(), id, System.currentTimeMillis(), 0, point.getX(), point.getY(), 1, false, 1); client.getCanvas().dispatchEvent(mouseEvent); }
@SuppressWarnings("SameParameterValue") private void sendKey(int key) { keyEvent(KeyEvent.KEY_PRESSED, key); keyEvent(KeyEvent.KEY_RELEASED, key); }
private void keyEvent(int id, int key) { KeyEvent e = new KeyEvent( client.getCanvas(), id, System.currentTimeMillis(), 0, key, KeyEvent.CHAR_UNDEFINED); client.getCanvas().dispatchEvent(e); }
public boolean isValidBreak(Plugin plugin) { Map<Plugin, Boolean> plugins = chinBreakHandler.getPlugins(); if (!plugins.containsKey(plugin)) { return false; } if (!plugins.get(plugin)) { return true; } String thresholdfrom = configManager.getConfiguration( "piggyBreakHandler", sanitizedName(plugin) + "-thresholdfrom"); String thresholdto = configManager.getConfiguration("piggyBreakHandler", sanitizedName(plugin) + "-thresholdto"); String breakfrom = configManager.getConfiguration("piggyBreakHandler", sanitizedName(plugin) + "-breakfrom"); String breakto = configManager.getConfiguration("piggyBreakHandler", sanitizedName(plugin) + "-breakto"); return isNumeric(thresholdfrom) && isNumeric(thresholdto) && isNumeric(breakfrom) && isNumeric(breakto) && Integer.parseInt(thresholdfrom) <= Integer.parseInt(thresholdto) && Integer.parseInt(breakfrom) <= Integer.parseInt(breakto); }
public static boolean isNumeric(String strNum) { if (strNum == null) { return false; } try { Double.parseDouble(strNum); } catch (NumberFormatException nfe) { return false; } return true; }
public void menuAction( MenuOptionClicked menuOptionClicked, String option, String target, int identifier, MenuAction menuAction, int param0, int param1) { }
@ConfigItem( keyName = "stopAfterBreaks", name = "Stop after X breaks", description = "Stop after a given amount of breaks (0 to disable)", position = 1, section = misc) default int stopAfterBreaks() { return 0; }
@ConfigItem( keyName = "autoBankPin", name = "Auto Bank Pin", description = "Will automatically enter your bank pin", position = 2, section = misc) default boolean autoBankPin() { return false; }
@ConfigItem( keyName = "avoidWorldsPlayerCount", name = "Max Players", description = "Maximum amount of players a world should have when hopping", position = 3, section = misc) default int avoidWorldsPlayerCount() { return 1500; }
@ConfigItem( keyName = "avoidWorldsNumbers", name = "Avoid Worlds", description = "World numbers you want to avoid hopping to separated by commas.", position = 4, section = misc) default String avoidWorldsNumbers() { return "302,330"; }
@ConfigItem( keyName = "hop-after-break", name = "Hop world after break", description = "Hop to a different world after taking a break", position = 3, section = hoppingTitle) default boolean hopAfterBreak() { return false; }
@ConfigItem( keyName = "american", name = "American", description = "Enable hopping to American worlds", position = 4, section = hoppingTitle) default boolean american() { return false; }
@ConfigItem( keyName = "united-kingdom", name = "United kingdom", description = "Enable hopping to UK worlds", position = 5, section = hoppingTitle) default boolean unitedKingdom() { return false; }
@ConfigItem( keyName = "german", name = "German", description = "Enable hopping to German worlds", position = 6, section = hoppingTitle) default boolean german() { return false; }
@ConfigItem( keyName = "australian", name = "Australian", description = "Enable hopping to Australian worlds", position = 7, section = hoppingTitle) default boolean australian() { return false; }
@ConfigItem( keyName = "inactiveHoursToggle", name = "Enable Inactive Hours", description = "Enables Inactive Hours", position = 7, section = inactiveHoursTitle) default boolean inactiveHoursToggle() { return false; }
@ConfigItem( keyName = "inactiveStartTime", name = "Start Time", description = "Start time of the inactive period (24-hour format, e.g., 22:00)", position = 1, section = inactiveHoursTitle) default String inactiveStartTime() { return "00:00"; }
@ConfigItem( keyName = "inactiveEndTime", name = "End Time", description = "End time of the inactive period (24-hour format, e.g., 06:00)", position = 2, section = inactiveHoursTitle) default String inactiveEndTime() { return "00:00"; }
@Override protected Popup getPopup( Component owner, Component contents, int x, int y, boolean isHeavyWeightPopup) throws IllegalArgumentException { return super.getPopup(owner, contents, x, y, true); }
private static String decryptText(byte[] enc, SecretKey aesKey) throws NoSuchAlgorithmException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException { if (enc == null || enc.length == 0) { return ""; } Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); SecretKeySpec newKey = new SecretKeySpec(aesKey.getEncoded(), "AES"); cipher.init(Cipher.DECRYPT_MODE, newKey); return new String(cipher.doFinal(enc)); }
private static byte[] base64Decode(String data) { return Base64.getDecoder().decode(data); }
private static String base64Encode(byte[] data) { return Base64.getEncoder().encodeToString(data); }
public void addChangeListener(ChangeListener listener) { listeners.add(listener); }
private void fireStateChanged() { if (!listeners.isEmpty()) { ChangeEvent evt = new ChangeEvent(this); for (ChangeListener listener : listeners) { listener.stateChanged(evt); } } }
@Override public void insertUpdate(DocumentEvent e) { timer.restart(); }
@Override public void removeUpdate(DocumentEvent e) { timer.restart(); }
@Override public void changedUpdate(DocumentEvent e) { timer.restart(); }
public void init(Config config) { pluginConfig = getConfigDescriptor(config); try { configManager.setDefaultConfiguration(config, false); } catch (ThreadDeath e) { throw e; } catch (Throwable ex) { log.warn("Unable to reset plugin configuration", ex); } rebuild(); }
private void changeConfiguration( Component component, ConfigDescriptor cd, ConfigItemDescriptor cid) { if (component instanceof JCheckBox) { JCheckBox checkbox = (JCheckBox) component; configManager.setConfiguration( cd.getGroup().value(), cid.getItem().keyName(), "" + checkbox.isSelected()); } else if (component instanceof JSpinner) { JSpinner spinner = (JSpinner) component; configManager.setConfiguration( cd.getGroup().value(), cid.getItem().keyName(), "" + spinner.getValue()); } else if (component instanceof JComboBox) { JComboBox jComboBox = (JComboBox) component; configManager.setConfiguration( cd.getGroup().value(), cid.getItem().keyName(), ((Enum) jComboBox.getSelectedItem()).name()); } rebuild(); }
@Override public Object stringToValue(final String text) throws ParseException { final String trimmedText; if (text.endsWith(units)) { trimmedText = text.substring(0, text.length() - units.length()); } else { trimmedText = text; } try { return Integer.valueOf(trimmedText); } catch (NumberFormatException e) { throw new ParseException(trimmedText + " is not an integer.", 0); } }
@Override public String valueToString(final Object value) { return value + units; }
public static void setupDefaults() { ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false); ToolTipManager.sharedInstance().setInitialDelay(300); JPopupMenu.setDefaultLightWeightPopupEnabled(false); UIManager.put("Button.foreground", Color.WHITE); UIManager.put("MenuItem.foreground", Color.WHITE); UIManager.put("Panel.background", ColorScheme.DARK_GRAY_COLOR); UIManager.put("TextField.selectionBackground", ColorScheme.BRAND_ORANGE_TRANSPARENT); UIManager.put("TextField.selectionForeground", Color.WHITE); UIManager.put("FormattedTextField.selectionBackground", ColorScheme.BRAND_ORANGE_TRANSPARENT); UIManager.put("FormattedTextField.selectionForeground", Color.WHITE); UIManager.put("TextArea.selectionBackground", ColorScheme.BRAND_ORANGE_TRANSPARENT); UIManager.put("TextArea.selectionForeground", Color.WHITE); UIManager.put("SliderUI", SliderUI.class.getName()); System.setProperty("jgoodies.popupDropShadowEnabled", "false"); System.setProperty("sun.awt.noerasebackground", "true"); }
public static void removeButtonDecorations(AbstractButton button) { button.setBorderPainted(false); button.setContentAreaFilled(false); button.setFocusPainted(false); button.setMargin(new Insets(0, 0, 0, 0)); button.setOpaque(false); }
public static void addModalTooltip(AbstractButton button, String on, String off) { button.setToolTipText(button.isSelected() ? on : off); button.addItemListener(l -> button.setToolTipText(button.isSelected() ? on : off)); }
public static void pumpPendingEvents() { EventQueue eq = Toolkit.getDefaultToolkit().getSystemEventQueue(); if (eq.peekEvent() != null) { SecondaryLoop l = eq.createSecondaryLoop(); SwingUtilities.invokeLater(l::exit); l.enter(); } }
public static void syncExec(final Runnable r) throws InvocationTargetException, InterruptedException { if (EventQueue.isDispatchThread()) { r.run(); } else { EventQueue.invokeAndWait(r); } }
public int nextInt() { return randomIterator.nextInt(); }
private JSpinner createSpinner(int value) { SpinnerModel model = new SpinnerNumberModel(value, 0, Integer.MAX_VALUE, 1); JSpinner spinner = new JSpinner(model); Component editor = spinner.getEditor(); JFormattedTextField spinnerTextField = ((JSpinner.DefaultEditor) editor).getTextField(); spinnerTextField.setColumns(4); spinnerTextField.setFormatterFactory(new UnitFormatterFactory(Units.MINUTES)); return spinner; }
private JPanel notConfigurable() { JPanel contentPanel = new JPanel(new BorderLayout()); contentPanel.setBackground(ChinBreakHandlerPanel.BACKGROUND_COLOR); JMultilineLabel description = new JMultilineLabel(); description.setText("The break timings for this plugin are not configurable."); description.setFont(ChinBreakHandlerPanel.SMALL_FONT); description.setDisabledTextColor(Color.WHITE); description.setBackground(ChinBreakHandlerPanel.BACKGROUND_COLOR); contentPanel.add(description, BorderLayout.CENTER); return contentPanel; }
private JPanel typePanel() { String pluginName = ChinBreakHandlerPlugin.sanitizedName(plugin); JPanel contentPanel = new JPanel(new GridLayout(0, 2)); contentPanel.setBackground(ChinBreakHandlerPanel.BACKGROUND_COLOR); contentPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5)); ButtonGroup buttonGroup = new ButtonGroup(); JCheckBox logoutButton = new JCheckBox("Logout"); JCheckBox afkButton = new JCheckBox("AFK"); boolean logout = Boolean.parseBoolean( configManager.getConfiguration("piggyBreakHandler", pluginName + "-logout")); logoutButton.setSelected(logout); afkButton.setSelected(!logout); logoutButton.addActionListener( e -> configManager.setConfiguration( "piggyBreakHandler", pluginName + "-logout", logoutButton.isSelected())); afkButton.addActionListener( e -> configManager.setConfiguration( "piggyBreakHandler", pluginName + "-logout", !afkButton.isSelected())); buttonGroup.add(logoutButton); buttonGroup.add(afkButton); contentPanel.add(logoutButton); contentPanel.add(afkButton); return contentPanel; }
private int parseInt(String value, int def) { try { return Integer.parseInt(value); } catch (NumberFormatException e) { return def; } }
public static LoginMode parse(String s) { if (s == null || s.isEmpty()) { return LoginMode.MANUAL; } for (LoginMode mode : LoginMode.values()) { if (s.equalsIgnoreCase(mode.name())) { return mode; } } return LoginMode.MANUAL; }
public static String formatDuration(Duration duration) { long seconds = duration.getSeconds(); long absSeconds = Math.abs(seconds); return String.format( "%02d:%02d:%02d", absSeconds / 3600, (absSeconds % 3600) / 60, absSeconds % 60); }
private boolean isInInactiveHours() { LocalTime now = LocalTime.now(); if (inactiveStartTime.isBefore(inactiveEndTime)) { return !now.isBefore(inactiveStartTime) && !now.isAfter(inactiveEndTime); } else { return !now.isBefore(inactiveStartTime) || !now.isAfter(inactiveEndTime); } }
private void infoPanel() { infoPanel.removeAll(); infoPanel.setBackground(ChinBreakHandlerPanel.BACKGROUND_COLOR); infoPanel.setBorder( new CompoundBorder( new CompoundBorder( BorderFactory.createMatteBorder( 0, 0, 1, 0, ChinBreakHandlerPanel.PANEL_BACKGROUND_COLOR), BorderFactory.createLineBorder(ChinBreakHandlerPanel.BACKGROUND_COLOR)), BorderFactory.createEmptyBorder(5, 5, 5, 5))); GridBagConstraints c = new GridBagConstraints(); c.insets = new Insets(2, 0, 2, 0); c.weightx = 2; c.gridx = 0; c.gridy = 0; infoPanel.add(new JLabel("Total runtime"), c); c.insets = new Insets(2, 0, 2, 0); c.weightx = 1; c.gridx = 0; c.gridy = 1; infoPanel.add(runtimeLabel, c); c.insets = new Insets(2, 0, 2, 0); c.weightx = 2; c.gridx = 1; c.gridy = 0; infoPanel.add(new JLabel("Amount of breaks"), c); c.insets = new Insets(2, 0, 2, 0); c.weightx = 1; c.gridx = 1; c.gridy = 1; infoPanel.add(breaksLabel, c); }
private void emptyContentPanel() { contentPanel.removeAll(); contentPanel.revalidate(); contentPanel.repaint(); }
@Override public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException { String string = fb.getDocument().getText(0, fb.getDocument().getLength()) + text; if (string.length() <= 4) { super.replace(fb, offset, length, text, attrs); } }
@ConfigItem( keyName = "instructions", name = "", description = "Instructions.", position = -1, section = "instructionsConfig") default String instructions() { return "Go to Pollnivneach. Ensure your inventory is filled with items such as wines or a type" + " of food that leaves remnants behind. Our goal is to avoid obtaining coin" + " pouches. It is highly recommended to wear a Rogue's set and locate a Bandit or" + " Menaphite. \n\n" + " Spam click on the Bandit or Menaphite and let the magic of menu swapping occur" + " while you engage in blackjacking."; }
@ConfigItem( keyName = "pickpocketOnAggro", name = "Pickpocket when aggro'd", description = "Switches to \"Pickpocket\" when bandit is aggro'd. Saves food at the cost of slight" + " xp/h.", position = 0) default boolean pickpocketOnAggro() { return false; }
@ConfigItem( keyName = "random", name = "Randomly Miss 1 Pickpocket", description = "If enabled, this will randomly miss 1 pickpocket every so often." + "<br> Not sure why'd you want to do that, but you can.", position = 1) default boolean random() { return false; }
@Subscribe private void onChatMessage(ChatMessage event) { final String msg = event.getMessage(); if (event.getType() == ChatMessageType.SPAM && (msg.equals(SUCCESS_BLACKJACK) || (msg.equals(FAILED_BLACKJACK) && config.pickpocketOnAggro()))) { knockout = false; final int ticks = config.random() ? RandomUtils.nextInt(3, 4) : 4; nextKnockOutTick = client.getTickCount() + ticks; } }
@ConfigItem( keyName = "playerName", name = "Dropping player", description = "selects what players name to mark tiles", position = 0) default String playerName() { return ""; }
@Range(min = 1, max = 60) @ConfigItem( keyName = "showAmount", name = "Trail length", description = "Shows the length of the droppers trail", position = 1) default int showAmount() { return 10; }
@ConfigItem( position = 2, keyName = "overlayColor", name = "Overlay Color", description = "Configures the color of the overlay") default Color overlayColor() { return new Color(0, 150, 200); }
@ConfigItem( position = 3, keyName = "fontStyle", name = "Font Style", description = "Bold/Italics/Plain") default FontStyle fontStyle() { return FontStyle.BOLD; }
@Range(min = 10, max = 40) @ConfigItem( position = 4, keyName = "textSize", name = "Text Size", description = "Text Size for Timers.") default int textSize() { return 18; }
@Override public String toString() { return getName(); }
private Point centerPoint(Rectangle rect) { int x = (int) (rect.getX() + rect.getWidth() / 2); int y = (int) (rect.getY() + rect.getHeight() / 2); return new Point(x, y); }
public static void renderTextLocation( Graphics2D graphics, String txtString, int fontSize, int fontStyle, Color fontColor, Point canvasPoint, boolean shadows, int yOffset) { graphics.setFont(new Font("Arial", fontStyle, fontSize)); if (canvasPoint != null) { final Point canvasCenterPoint = new Point(canvasPoint.getX(), canvasPoint.getY() + yOffset); final Point canvasCenterPoint_shadow = new Point(canvasPoint.getX() + 1, canvasPoint.getY() + 1 + yOffset); if (shadows) { renderTextLocation(graphics, canvasCenterPoint_shadow, txtString, Color.BLACK); } renderTextLocation(graphics, canvasCenterPoint, txtString, fontColor); } }
public static void renderTextLocation( Graphics2D graphics, Point txtLoc, String text, Color color) { if (Strings.isNullOrEmpty(text)) { return; } int x = txtLoc.getX(); int y = txtLoc.getY(); graphics.setColor(Color.BLACK); graphics.drawString(text, x + 1, y + 1); graphics.setColor(color); graphics.drawString(text, x, y); }
@Override protected void startUp() { overlayManager.add(coreOverlay); reset(); }
@Override protected void shutDown() { overlayManager.remove(coreOverlay); reset(); }
private void shuffleList() { if (playerPath.size() > MAXPATHSIZE - 1) { playerPath.remove(0); } }
private void addCords() { while (true) { if (playerPath.size() >= MAXPATHSIZE) { playerPath.add(runningPlayer.getWorldLocation()); break; } playerPath.add(null); } }
public void registerPlugin(Plugin p, boolean configure) { performReflection("registerPlugin2", p, configure); }
public void registerPlugin(Plugin p) { performReflection("registerPlugin1", p); }
public void unregisterPlugin(Plugin p) { performReflection("unregisterPlugin1", p); }
public void startPlugin(Plugin p) { performReflection("startPlugin1", p); }
public void stopPlugin(Plugin p) { performReflection("stopPlugin1", p); }
public boolean isBreakActive(Plugin p) { Object o = performReflection("isBreakActive1", p); if (o != null) return (boolean) o; return false; }
public boolean shouldBreak(Plugin p) { Object o = performReflection("shouldBreak1", p); if (o != null) { boolean b = (boolean) o; return (boolean) o; } return false; }
public boolean needsBankPin(Client c) { Object o = performReflection("needsBankPin1", c); if (o != null) { return (boolean) o; } return false; }
public void startBreak(Plugin p) { performReflection("startBreak1", p); }
private Object performReflection(String methodName, Object... args) { if (checkReflection() && chinMethods.containsKey(methodName = methodName.toLowerCase())) try { return chinMethods.get(methodName).invoke(instance, args); } catch (IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } return null; }
public static boolean useItemNoCase(String name, String... actions) { return nameContainsNoCase(name) .first() .flatMap( item -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(item, actions); return Optional.of(true); }) .orElse(false); }
public static ItemQuery nameContainsNoCase(String name) { return Inventory.search() .filter(widget -> widget.getName().toLowerCase().contains(name.toLowerCase())); }
public static boolean hasItem(String name) { return getItemAmount(name, false) > 0; }
public static boolean hasItem(String name, boolean stacked) { return getItemAmount(name, stacked) > 0; }
public static boolean hasItem(String name, int amount) { return getItemAmount(name, false) >= amount; }
public static boolean hasItem(String name, int amount, boolean stacked) { return getItemAmount(name, stacked) >= amount; }
public static boolean hasItems(String... names) { for (String name : names) { if (!hasItem(name)) { return false; } } return true; }
public static boolean hasAnyItems(String... names) { for (String name : names) { if (hasItem(name)) { return true; } } return false; }
public static boolean hasAnyItems(Collection<Integer> itemIds) { for (Integer id : itemIds) { if (hasItem(id)) { return true; } } return false; }
public static boolean hasItem(int id) { return getItemAmount(id) > 0; }
public static int emptySlots() { return 28 - Inventory.search().result().size(); }
public static boolean runePouchContains(Collection<Integer> ids) { for (int runeId : ids) { if (!runePouchContains(runeId)) { return false; } } return true; }
public static boolean isPrayerActive(Prayer prayer) { return EthanApiPlugin.getClient().isPrayerActive(prayer); }
public static void togglePrayer(Prayer prayer) { if (prayer == null) { return; } MousePackets.queueClickPacket(); WidgetPackets.queueWidgetActionPacket(1, getPrayerWidgetId(prayer), -1, -1); }
public static void toggleMultiplePrayers(Prayer... prayers) { for (Prayer prayer : prayers) { togglePrayer(prayer); } }
public boolean isAutoRetaliating() { return client.getVarpValue(172) == 0; }
public boolean inArea(WorldArea area) { return area.contains(client.getLocalPlayer().getWorldLocation()); }
public boolean inRegion(int region) { return client.getLocalPlayer().getWorldLocation().getRegionID() == region; }
public boolean inRegion(int... regions) { for (int region : regions) { if (inRegion(region)) { return true; } } return false; }
public boolean hasItem(String name) { return Inventory.getItemAmount(name) > 0; }
public boolean hasItem(int id) { return Inventory.getItemAmount(id) > 0; }
public int runEnergy() { return client.getEnergy() / 100; }
public int specEnergy() { return client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) / 10; }
public int hp() { return client.getBoostedSkillLevel(Skill.HITPOINTS); }
public boolean isStaminaActive() { return client.getVarbitValue(Varbits.RUN_SLOWED_DEPLETION_ACTIVE) == 1; }
public boolean isRunning() { return client.getVarpValue(173) == 0; }
public boolean inMulti() { return client.getVarbitValue(Varbits.MULTICOMBAT_AREA) == 1; }
public boolean isInteracting() { return client.getLocalPlayer().isInteracting(); }
public boolean isBeingInteracted() { return NPCs.search().interactingWithLocal().first().isPresent(); }
public boolean isBeingInteracted(String name) { return NPCs.search() .filter(npc -> npc.getName() != null && npc.getName().equalsIgnoreCase(name)) .interactingWithLocal() .first() .isPresent(); }
public static WidgetInfoExtended parseStringForWidgetInfoExtended(String input) { for (WidgetInfoExtended value : WidgetInfoExtended.values()) { if (value.name().equalsIgnoreCase("SPELL_" + input.replace(" ", "_"))) { return value; } } return null; }
public static NPCQuery nameContainsNoCase(String name) { return NPCs.search() .filter( npcs -> npcs.getName() != null && npcs.getName().toLowerCase().contains(name.toLowerCase())); }
public static TileObjectQuery withNameNoCase(String name) { return TileObjects.search() .filter( tileObject -> { ObjectComposition comp = TileObjectQuery.getObjectComposition(tileObject); if (comp == null) return false; return comp.getName().toLowerCase().equals(name.toLowerCase()); }); }
public static TileObjectQuery nameContainsNoCase(String name) { return TileObjects.search() .filter( tileObject -> { ObjectComposition comp = TileObjectQuery.getObjectComposition(tileObject); if (comp == null) return false; return comp.getName().toLowerCase().contains(name.toLowerCase()); }); }
public static boolean hasItem(String name) { return Equipment.search().nameContainsNoCase(name).first().isPresent(); }
@Deprecated public static boolean hasItems(String... names) { for (String name : names) { if (!hasItem(name)) { return false; } } return true; }
public static boolean hasItems(int... ids) { for (int id : ids) { if (!hasItem(id)) { return false; } } return true; }
public static boolean hasItems(List<Integer> ids) { for (int id : ids) { if (!hasItem(id)) { return false; } } return true; }
public static boolean hasItem(int id) { return Equipment.search().withId(id).first().isPresent(); }
public static void depositAll() { Widget depositInventory = EthanApiPlugin.getClient().getWidget(WidgetInfo.BANK_DEPOSIT_INVENTORY); if (depositInventory != null) { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(depositInventory, "Deposit inventory"); } }
public static ItemQuery nameContainsNoCase(String name) { return Bank.search() .filter(widget -> widget.getName().toLowerCase().contains(name.toLowerCase())); }
public static boolean hasItem(int id) { return hasItem(id, 1, false); }
public static boolean hasItem(int id, int amount) { return getItemAmount(id, false) >= amount; }
public static boolean hasItem(int id, int amount, boolean stacked) { return getItemAmount(id, stacked) >= amount; }
public static int random(int min, int max) { return ThreadLocalRandom.current().nextInt(min, max + 1); }
public static WorldPoint randomizeTile(WorldPoint wp, int rX, int rY) { return wp.dx(random(-rX, rX + 1)).dy(random(-rY, rY + 1)); }
public static WorldPoint randomizeTile2(WorldPoint wp, int rX, int rY) { return wp.dx(random(rX, rX + 1)).dy(random(rY, rY + 1)); }
@Override public boolean validate() { return false; }
@Override public void execute() { interactNpc("Goblin", "Attack", true); }
public void addTask(AbstractTask task) { tasks.add(task); }
public void removeTask(AbstractTask task) { tasks.remove(task); }
public boolean hasTasks() { return !tasks.isEmpty(); }
public void runTasks() { for (AbstractTask task : tasks) { if (task.validate()) { task.execute(); break; } } }
@Override public boolean interactObject(TileObject object, String action) { if (object == null) return false; return TileObjectInteraction.interact(object, action); }
@Override public boolean interactObject(String objectName, String action, boolean nearest) { TileObjectQuery query = TileObjects.search().nameContains(objectName).withAction(action); Optional<TileObject> object = Optional.ofNullable( nearest ? query.nearestToPlayer().orElse(null) : query.first().orElse(null)); return interactObject(object.orElse(null), action); }
@Override public boolean interactObject(String objectName, String action, Predicate<TileObject> condition) { TileObject object = TileObjects.search() .nameContains(objectName) .withAction(action) .filter(condition) .first() .orElse(null); return interactObject(object, action); }
@Override public boolean interactNpc(NPC npc, String action) { if (npc == null) return false; return NPCInteraction.interact(npc, action); }
@Override public boolean interactNpc(String npcName, String action, boolean nearest) { NPCQuery query = NPCs.search().nameContains(npcName).withAction(action); Optional<NPC> npc = Optional.ofNullable( nearest ? query.nearestToPlayer().orElse(null) : query.first().orElse(null)); return interactNpc(npc.orElse(null), action); }
@Override public boolean interactNpc(String npcName, String action, Predicate<NPC> condition) { NPC npc = NPCs.search() .nameContains(npcName) .withAction("Attack") .filter(condition) .first() .orElse(null); return interactNpc(npc, action); }
private int[] convertToSolverFormat(int[] items, boolean useNormalSolver) { int lowestId = Integer.MAX_VALUE; int[] convertedItems = new int[items.length]; for (int id : items) { if (id == BLANK_TILE_VALUE) { continue; } if (lowestId > id) { lowestId = id; } } for (int i = 0; i < items.length; i++) { if (items[i] != BLANK_TILE_VALUE) { int value = items[i] - lowestId; if (!useNormalSolver) { value /= 2; } convertedItems[i] = value; } else { convertedItems[i] = BLANK_TILE_VALUE; } } return convertedItems; }
private void cacheItems(int[] items) { cachedItems = new int[items.length]; System.arraycopy(items, 0, cachedItems, 0, cachedItems.length); }
private void solve(int[] items, boolean useNormalSolver) { if (solverFuture != null) { solverFuture.cancel(true); } PuzzleState puzzleState = new PuzzleState(items); if (useNormalSolver) { solver = new PuzzleSolver(new IDAStar(new ManhattanDistance()), puzzleState); } else { solver = new PuzzleSolver(new IDAStarMM(new ManhattanDistance()), puzzleState); } solverFuture = executorService.submit(solver); }
@Override public Dimension render(Graphics2D graphics) { panelComponent.getChildren().clear(); LineComponent started = buildLine("Started: ", String.valueOf(plugin.started)); LineComponent timeout = buildLine("Timeout: ", String.valueOf(plugin.timeout)); LineComponent maxTraps = buildLine("Max Traps: ", String.valueOf(plugin.maxTraps)); LineComponent traps = buildLine("Caught traps: ", String.valueOf(plugin.helper.getCaughtTraps())); LineComponent trapSupplies = buildLine("Set traps: ", String.valueOf(plugin.helper.getSetTraps())); LineComponent tickRegion = buildLine("Ticks out of Region: ", String.valueOf(plugin.ticksNotInRegion)); panelComponent.getChildren().add(timeout); panelComponent.getChildren().add(started); panelComponent.getChildren().add(maxTraps); panelComponent.getChildren().add(traps); panelComponent.getChildren().add(trapSupplies); panelComponent.getChildren().add(tickRegion); return panelComponent.render(graphics); }
public boolean inRegion(int regionId) { return client.getLocalPlayer().getWorldLocation().getRegionID() == regionId; }
public boolean hasTrapSupplies() { return playerUtil.hasItem("Small fishing net") && playerUtil.hasItem("Rope"); }
@ConfigItem(keyName = "salamanderType", name = "Salamander", description = "", position = 1) default Salamander salamander() { return Salamander.RED_SALAMANDER; }
@ConfigItem( keyName = "maxArea", name = "Max dist", description = "Max distance from start tile to set traps", position = 2) default int maxDist() { return 10; }
@ConfigItem( name = "Tick Delay", keyName = "tickDelay", description = "Slow down plugin", position = 1, section = tickDelaySection) default int tickDelay() { return 0; }
@ConfigItem(keyName = "butterflyName", name = "Butterfly", description = "", position = 1) default ButterflyType butterfly() { return ButterflyType.RUBY_HARVEST; }
@ConfigItem( keyName = "tickDelay", name = "Tick delay", description = "Will slow the plugin by this many ticks", position = 2) default int tickDelay() { return 0; }
@Override protected void startUp() throws Exception { keyManager.registerKeyListener(toggle); timeout = 0; }
@Override protected void shutDown() throws Exception { keyManager.unregisterKeyListener(toggle); timeout = 0; started = false; }
private void checkRunEnergy() { if (playerUtil.isRunning() && playerUtil.runEnergy() <= 10) { log.info("Run"); MousePackets.queueClickPacket(); WidgetPackets.queueWidgetActionPacket(1, 10485787, -1, -1); } checkStamina(); }
private void checkStamina() { if (!playerUtil.isStaminaActive() && playerUtil.runEnergy() <= 70) { log.info("Stamina"); Inventory.search() .onlyUnnoted() .nameContains("Stamina pot") .withAction("Drink") .first() .ifPresent( stamina -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(stamina, "Drink"); timeout = 1; }); } }
@Override public Dimension render(Graphics2D graphics) { if (!config.drawTiles()) { return null; } if (PathingTesting.fullPath == null) { return null; } int i = 1; for (WorldPoint worldPoint : PathingTesting.fullPath) { drawTile( graphics, worldPoint, Color.MAGENTA, 25, String.valueOf(i), new BasicStroke((float) 1)); i++; } return null; }
private void drawTile( Graphics2D graphics, WorldPoint point, Color color, int alpha, String label, Stroke borderStroke) { WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation(); if (point.distanceTo(playerLocation) >= 32) { return; } LocalPoint lp = LocalPoint.fromWorld(client, point); if (lp == null) { return; } Polygon poly = Perspective.getCanvasTilePoly(client, lp); if (poly != null) { OverlayUtil.renderPolygon( graphics, poly, color, new Color(color.getRed(), color.getGreen(), color.getBlue(), alpha), borderStroke); } if (!Strings.isNullOrEmpty(label)) { Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, lp, label, 0); if (canvasTextLocation != null) { graphics.setFont(new Font("Arial", 1, 15)); OverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, color); } } }
@Override protected void startUp() throws Exception { currentPathDestination = null; path = null; goal = null; fullPath = null; overlay = new PathingTestingOverlay(EthanApiPlugin.getClient(), this, config); overlayManager.add(overlay); }
@Override protected void shutDown() throws Exception { currentPathDestination = null; path = null; goal = null; fullPath = null; overlayManager.remove(overlay); }
public static boolean pathingTo(WorldPoint a) { return goal != null && goal.equals(a); }
public static boolean pathing() { return goal != null; }
public static boolean walkTo(WorldPoint goal) { currentPathDestination = null; path = GlobalCollisionMap.findPath(goal); fullPath = new ArrayList<>(path); PathingTesting.goal = goal; currentPathDestination = null; if (path == null) { return false; } return true; }
private boolean isDoored(WorldPoint a, WorldPoint b) { Tile tA = getTile(a); Tile tB = getTile(b); if (tA == null || tB == null) { return false; } return isDoored(tA, tB); }
@ConfigItem(keyName = "x", name = "x", description = "") default int x() { return -1; }
@ConfigItem(keyName = "y", name = "y", description = "") default int y() { return -1; }
@ConfigItem(keyName = "run", name = "run", description = "") default boolean run() { return false; }
@ConfigItem(keyName = "stop", name = "stop", description = "") default boolean stop() { return false; }
@ConfigItem(keyName = "drawTiles", name = "drawTiles", description = "") default boolean drawTiles() { return false; }
private void castHumidify() { Widget humidify = SpellUtil.getSpellWidget(client, "humidify"); MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(humidify, "Cast"); timeout = 5; }
private void bank() { if (!Bank.isOpen()) { openBank(); return; } handleBankItems(); }
private void openBank() { Optional<TileObject> tileObject = TileObjects.search() .filter( object -> { ObjectComposition objectComposition = TileObjectQuery.getObjectComposition(object); return objectComposition.getName().toLowerCase().contains("bank") || Arrays.stream(objectComposition.getActions()) .anyMatch( action -> action != null && action.toLowerCase().contains("bank")); }) .nearestToPlayer(); if (tileObject.isEmpty()) { return; } TileObject bank = tileObject.get(); TileObjectInteraction.interact(bank, "Bank", "Use", "Open"); }
private void handleBankItems() { Optional<Widget> emptyJug = Inventory.search().withId(ItemID.JUG).first(); Optional<Widget> jugOfWater = Inventory.search().withId(ItemID.JUG_OF_WATER).first(); Optional<Widget> bankJug = Bank.search().withId(ItemID.JUG).first(); if (emptyJug.isEmpty() && jugOfWater.isPresent()) { MousePackets.queueClickPacket(); BankInventoryInteraction.useItem(ItemID.JUG_OF_WATER, "Deposit-All", "Deposit-all"); return; } if (emptyJug.isEmpty() && bankJug.isPresent()) { BankInteraction.useItem(bankJug.get(), "Withdraw-All", "Withdraw-all"); return; } if (jugOfWater.isEmpty() && emptyJug.isPresent()) { MousePackets.queueClickPacket(); MovementPackets.queueMovement(client.getLocalPlayer().getWorldLocation()); state = State.HUMIDIFY; } }
@Override public void startUp() { log.info("Plugin started"); overlayManager.add(overlay); initValues(); }
@Override public void shutDown() { log.info("Plugin shutdown"); resetValues(); overlayManager.remove(overlay); }
private void initValues() { setFarmingLevel(getGetPlayerFarmingLevel()); patchLayout = config.patchLayout().getLayout(); totalAmountOfPatches = patchLayout.length; defaultStartingPos = isInsideTitheFarm() ? config.patchLayout().getStartingPoint() : null; randomCount = randomCanCount.getRandomInteger(); clientThread.invoke( () -> Inventory.search() .withId(ItemID.GRICOLLERS_CAN) .first() .ifPresent(itm -> InventoryInteraction.useItem(itm, "Check"))); pluginJustEnabled = true; runEnergyDeviation = new IntegerRandomizer( config.minRunEnergyToIdleUnder(), config.minRunEnergyToIdleUnder() + 10) .getRandomInteger(); farmers.setGearName("Farmer's"); graceful.setGearName("Graceful"); }
private void resetValues() { emptyPatches.clear(); firstPhaseObjectsToFocus.clear(); secondPhaseObjectsToFocus.clear(); thirdPhaseObjectsToFocus.clear(); fourthPhaseObjectsToFocus.clear(); actionDelayHandler.setWaitForAction(false); needToRestoreRunEnergy = false; defaultStartingPos = null; pluginJustEnabled = false; actionDelayHandler.setLastActionTimer(0); randomCanCount.getOldValues().clear(); }
private boolean pluginStartedDuringARun() { if (pluginJustEnabled && !startingNewRun()) { sendClientMessage( "Incorrect plugin startup state: start the plugin when the patches are completely" + " empty."); return true; } return false; }
private boolean isGricollersCanFound() { return getAppropriateWateringCan() != null && getAppropriateWateringCan().getName().contains("Gricoller's"); }
private boolean isNeedToRefillGricollersCan() { if (!isGricollersCanFound()) { return false; } return gricollersChargesUsed >= randomCount; }
public boolean startingNewRun() { return emptyPatches.size() == totalAmountOfPatches; }
private void openFarmDoor() { if (actionDelayHandler.isWaitForAction()) { return; } TileObjects.search() .nameContains("Farm door") .first() .ifPresent(obj -> TileObjectInteraction.interact(obj, "Open")); actionDelayHandler.setWaitForAction(true); }
private WorldPoint playerDirection() { WorldPoint worldPoint; int playerOrientation = client.getLocalPlayer().getCurrentOrientation(); WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation(); switch (playerOrientation) { case 151: worldPoint = playerLocation.dx(-1).dy(-2); break; case 360: worldPoint = playerLocation.dx(-2).dy(-1); break; case 663: worldPoint = playerLocation.dx(-2).dy(1); break; case 872: worldPoint = playerLocation.dx(-1).dy(2); break; case 1176: worldPoint = playerLocation.dx(1).dy(2); break; case 1385: worldPoint = playerLocation.dx(2).dy(1); break; case 1688: worldPoint = playerLocation.dx(2).dy(-1); break; case 1897: worldPoint = playerLocation.dx(1).dy(-2); break; default: worldPoint = null; } return worldPoint; }
private int amountOfGrowingPatchesLeft() { return TileObjects.search().withAction("Water").result().size(); }
private void doAction(List<TileObject> collection) { TileObject patch = collection.get(0); if (actionDelayHandler.isWaitForAction()) { return; } TileObjectInteraction.interact(patch, "Water", "Harvest"); actionDelayHandler.setWaitForAction(true); log.info(getObjectAction(patch) + "ing"); }
private void useItemOnObject(Widget widget, TileObject tileObject) { Optional<Widget> optionalWidget = Optional.of(widget); if (actionDelayHandler.isWaitForAction()) { return; } optionalWidget.ifPresent( itm -> { MousePackets.queueClickPacket(); ObjectPackets.queueWidgetOnTileObject(itm, tileObject); }); actionDelayHandler.setWaitForAction(true); }
private void captureEmptyPatches() { if (!emptyPatches.isEmpty()) { emptyPatches.clear(); } for (int[] point : patchLayout) { WorldPoint worldPoint = WorldPoint.fromScene(client.getTopLevelWorldView(), point[0], point[1], 0); TileObjects.search() .withId(EMPTY_PATCH) .atLocation(worldPoint) .first() .ifPresent(emptyPatches::add); } }
private List<Widget> herbBox() { return Inventory.search().withId(ItemID.HERB_BOX).result(); }
private void openHerbBox() { Consumer<? super Widget> actionPredicate = itm -> InventoryInteraction.useItem(itm, "Bank-all"); if (config.oneTickBankAllHerbBoxes()) { herbBox().forEach(actionPredicate); } else { herbBox().stream().findFirst().ifPresent(actionPredicate); } }
private boolean firstTimeEnteringTitheFarm() { if (Widgets.search().withTextContains("Hey, young sir").first().isPresent()) { sendClientMessage( "You're entering the tithe farm for the first time. Please talk to the old man" + " yourself."); return true; } return false; }
@Subscribe private void onGameTick(GameTick event) { actionDelayHandler.handleLastActionTimer(); if (!gotRequiredItems() || firstTimeEnteringTitheFarm()) { stopPlugin(this); return; } if (!isInsideTitheFarm()) { handleLobby(); return; } captureEmptyPatches(); if (pluginStartedDuringARun()) { stopPlugin(this); return; } handleMinigame(); }
@Subscribe private void onAnimationChanged(AnimationChanged event) { Actor actor = event.getActor(); int animationId = actor.getAnimation(); if (!(actor instanceof Player)) { return; } if (animationId == -1 && (!isInsideTitheFarm() || startingNewRun())) { actionDelayHandler.setWaitForAction(false); } }
private void populateList(List<TileObject> list, TileObject tileObject) { if (!list.contains(tileObject)) { list.add(tileObject); } }
private void removeObjectFromListIfBlighted(List<TileObject> list, GameObject blightedObject) { list.removeIf( tileObject -> blightedObject.getWorldLocation().equals(tileObject.getWorldLocation())); }
@Subscribe private void onGameStateChanged(GameStateChanged event) { GameState gameState = event.getGameState(); switch (gameState) { case CONNECTION_LOST: case LOGIN_SCREEN: case LOGIN_SCREEN_AUTHENTICATOR: stopPlugin(this); break; default: } }
public boolean isInInventory() { return config.switchGearDuringHarvestingPhase() && !getGear().isEmpty(); }
public void gearSwitch() { if (plugin.actionDelayHandler.isWaitForAction()) { return; } getGear() .forEach( itm -> { InventoryInteraction.useItem(itm, this.action); log.info("Equipping {}", Text.removeTags(itm.getName())); }); }
private boolean farmingLevelIsInRange() { return getFarmingLevel() >= minLevelRequirement && getFarmingLevel() <= maxLevelRequirement; }
private void renderTextLocation( Graphics2D graphics, String text, WorldPoint worldPoint, Color color) { LocalPoint point = LocalPoint.fromWorld(client, worldPoint); if (point == null) { return; } Point textLocation = Perspective.getCanvasTextLocation(client, graphics, point, text, 0); if (textLocation != null) { OverlayUtil.renderTextLocation(graphics, textLocation, text, color); } }
private void renderTextOnActor( Graphics2D graphics, Actor actor, String text, Color color, int zOffSet) { Point textLocation = actor.getCanvasTextLocation(graphics, text, actor.getLogicalHeight() + zOffSet); if (textLocation != null) { OverlayUtil.renderTextLocation(graphics, textLocation, text, color); } }
@Override public Dimension render(Graphics2D graphics) { graphics.setFont(FontManager.getRunescapeFont()); if (config.enableDebug()) { List<TileObject> patches = new ArrayList<>(plugin.emptyPatches); for (TileObject tileObject : patches) { renderTextLocation( graphics, String.valueOf(patches.indexOf(tileObject) + 1), tileObject.getWorldLocation(), Color.WHITE); } renderTextOnActor( graphics, client.getLocalPlayer(), "Wait for action: " + plugin.actionDelayHandler.isWaitForAction(), Color.RED, 40); } if (plugin.isNeedToRestoreRunEnergy() && plugin.startingNewRun()) { renderTextLocation( graphics, "Idling until 100% energy", client.getLocalPlayer().getWorldLocation(), Color.RED); } return null; }
public void handleLastActionTimer() { if (this.waitForAction) { this.lastActionTimer++; } else { this.lastActionTimer = 0; } }
@ConfigItem( keyName = "layout", name = "Patch Layout", description = " ", position = 0, section = SETUP) default PatchLayout patchLayout() { return PatchLayout.REGULAR_LAYOUT; }
@ConfigItem( keyName = "minRunEnergyToIdleUnder", name = "Idle if run energy is under", description = " ", position = 1, section = SETUP) default int minRunEnergyToIdleUnder() { return 20; }
@ConfigItem( keyName = "useStaminaPot", name = "Use Stamina Potion", description = "Will use stamina potion to restore energy.", position = 2, section = SETUP) default boolean useStaminaPot() { return false; }
@ConfigItem( keyName = "oneTickBankAllHerbBoxes", name = "One tick bank-all Herb boxes", description = "Will mass bank-all herb boxes rather than just banking them one tick at a time", position = 3, section = SETUP) default boolean oneTickBankAllHerbBoxes() { return false; }
@ConfigItem( keyName = "switchGearDuringHarvestingPhase", name = "Switch gear for xp", description = "Will switch gear to farmer's equipment (if available) during harvesting phase.", position = 4, section = SETUP) default boolean switchGearDuringHarvestingPhase() { return false; }
@ConfigItem( keyName = "StopIfReachedFruitAmountFarmed", name = "Enable stop condition below", description = " ", position = 2, section = MISC) default boolean stopIfReachedFruitAmountFarmed() { return false; }
@ConfigItem( keyName = "maxFruitToFarm", name = "Maximum amount of fruit to farm", description = "How much fruit to farm before the plugin stops", position = 3, section = MISC) default int maxFruitToFarm() { return 200; }
@ConfigItem( keyName = "enableDebug", name = "Enable debug", description = " ", position = 4, section = OVERLAY) default boolean enableDebug() { return false; }
public void startUp() { this.keyManager.registerKeyListener(this.inputListener); }
public void shutDown() { this.keyManager.unregisterKeyListener(this.inputListener); }
@Subscribe public void onFocusChanged(FocusChanged event) { if (!event.isFocused()) { this.hotKeyPressed = false; } }
private void deprioritizeEntry(int id, int op_id) { MenuEntry[] menuEntries = this.client.getMenuEntries(); for (int i = menuEntries.length - 1; i >= 0; --i) { MenuEntry entry = menuEntries[i]; if (entry.getType().getId() != op_id || entry.getIdentifier() != id) continue; entry.setDeprioritized(true); menuEntries[i] = menuEntries[menuEntries.length - 1]; menuEntries[menuEntries.length - 1] = entry; this.client.setMenuEntries(menuEntries); break; } }
public void keyPressed(KeyEvent event) { if (this.config.hotkey().matches(event)) { this.plugin.setHotKeyPressed(true); } }
public void keyReleased(KeyEvent event) { if (this.config.hotkey().matches(event)) { this.plugin.setHotKeyPressed(false); } }
@ConfigItem( keyName = "hotkey", name = "Hotkey", description = "Sets the hotkey you want to hold to walk under", position = 1) public default Keybind hotkey() { return Keybind.SHIFT; }
public boolean rigourUnlocked() { return !(client.getVarbitValue(5451) == 0) && client.getRealSkillLevel(Skill.PRAYER) >= 74 && client.getRealSkillLevel(Skill.DEFENCE) >= 70; }
public boolean pietyUnlocked() { return client.getVarbitValue(3909) == 8 && client.getRealSkillLevel(Skill.PRAYER) >= 70 && client.getRealSkillLevel(Skill.DEFENCE) >= 70; }
public boolean auguryUnlucked() { return !(client.getVarbitValue(5452) == 0) && client.getRealSkillLevel(Skill.PRAYER) >= 77 && client.getRealSkillLevel(Skill.DEFENCE) >= 70; }
@Override protected void startUp() { isRange = true; forceTab = false; updatedWeapon = ""; }
private boolean isHunllefVarbitSet() { return client.getVarbitValue(9177) == 1; }
@Override protected void startUp() throws Exception { bankPin = false; breakHandler.registerPlugin(this); keyManager.registerKeyListener(toggle); this.overlayManager.add(overlay); }
@Override protected void shutDown() throws Exception { bankPin = false; breakHandler.unregisterPlugin(this); keyManager.unregisterKeyListener(toggle); this.overlayManager.remove(overlay); }
@Subscribe private void onGameTick(GameTick event) { if (!EthanApiPlugin.loggedIn() || !started || breakHandler.isBreakActive(this)) { return; } state = getNextState(); handleState(); }
private void findObject() { String objectName = config.objectToInteract(); if (config.useForestryTreeNotClosest() && config.expectedAction().equalsIgnoreCase("chop")) { TileObjects.search() .withName(objectName) .nearestToPoint(getObjectWMostPlayers()) .ifPresent( tileObject -> { ObjectComposition comp = TileObjectQuery.getObjectComposition(tileObject); TileObjectInteraction.interact(tileObject, comp.getActions()[0]); }); } else { TileObjects.search() .withName(objectName) .nearestToPlayer() .ifPresent( tileObject -> { ObjectComposition comp = TileObjectQuery.getObjectComposition(tileObject); TileObjectInteraction.interact( tileObject, comp.getActions()[ 0]); }); } }
private void findNpc() { String npcName = config.objectToInteract(); NPCs.search() .withName(npcName) .nearestToPlayer() .ifPresent( npc -> { NPCComposition comp = client.getNpcDefinition(npc.getId()); if (Arrays.stream(comp.getActions()) .filter(Objects::nonNull) .anyMatch(action -> action.equalsIgnoreCase(config.expectedAction()))) { NPCInteraction.interact(npc, config.expectedAction()); } else { NPCInteraction.interact(npc, comp.getActions()[0]); } }); }
private void dropItems() { List<Widget> itemsToDrop = Inventory.search() .filter(item -> !shouldKeep(item.getName()) && !isTool(item.getName())) .result(); for (int i = 0; i < Math.min( itemsToDrop.size(), RandomUtils.nextInt(config.dropPerTickOne(), config.dropPerTickTwo())); i++) { InventoryInteraction.useItem( itemsToDrop.get(i), "Drop"); } }
private boolean isDroppingItems() { return state == State .DROP_ITEMS; }
private boolean shouldKeep(String name) { List<String> itemsToKeep = new ArrayList<>( List.of( config .itemsToKeep() .split(","))); itemsToKeep.addAll( List.of( config .toolsToUse() .split( ","))); return itemsToKeep.stream() .anyMatch(i -> Text.removeTags(name.toLowerCase()).contains(i.toLowerCase())); }
private boolean hasTools() { String[] tools = config.toolsToUse().split(","); int numInventoryTools = Inventory.search() .filter(item -> isTool(item.getName())) .result() .size(); int numEquippedTools = Equipment.search() .filter(item -> isTool(item.getName())) .result() .size(); return numInventoryTools + numEquippedTools >= tools .length; }
private boolean isTool(String name) { String[] tools = config.toolsToUse().split(","); return Arrays.stream(tools) .anyMatch( i -> name.toLowerCase() .contains( i .toLowerCase())); }
private boolean shouldBank() { return config.shouldBank() && (NPCs.search().withAction("Bank").first().isPresent() || TileObjects.search().withAction("Bank").first().isPresent() || TileObjects.search().withAction("Collect").first().isPresent() && !bankPin); }
public void toggle() { if (!EthanApiPlugin.loggedIn()) { return; } started = !started; if (!started) { breakHandler.stopPlugin(this); } else { breakHandler.startPlugin(this); } }
@ConfigItem(keyName = "toggle", name = "Toggle", description = "", position = -2) default Keybind toggle() { return Keybind.NOT_SET; }
@ConfigItem( name = "Should Bank?", keyName = "shouldBank", description = "Search for a bank in the nearby area, if found bank when full", position = -3) default boolean shouldBank() { return false; }
@ConfigItem( keyName = "searchNpc", name = "Search NPCs (for fishing, etc)", description = "For things like fishing spots", position = -1) default boolean searchNpc() { return false; }
@ConfigItem( name = "Object", keyName = "objectToInteract", description = "Game obejct you will be interacting with", position = 0) default String objectToInteract() { return "Tree"; }
@ConfigItem( name = "Expected Action", keyName = "Expected Action", description = "The action you wish to do on the object", position = 1) default String expectedAction() { return "Chop"; }
@ConfigItem( name = "Tool(s)", keyName = "toolsToUse", description = "Tools required to act with your object, can type ` axe` or ` pickaxe` to ignore the" + " type", position = 2) default String toolsToUse() { return " axe"; }
@ConfigItem( name = "Keep Items", keyName = "itemToKeep", description = "Items you don't want dropped. Separate items by comma,no space. Good for UIM", position = 3) default String itemsToKeep() { return "coins,rune pouch,divine rune pouch,looting bag,clue scroll"; }
@ConfigItem( name = "Tick Delay Min", keyName = "tickDelayMin", description = "Lower bound of tick delay, can set both to 0 to remove delay", position = 4, section = tickDelaySection) default int tickdelayMin() { return 0; }
@Range() @ConfigItem( name = "Tick Delay Max", keyName = "tickDelayMax", description = "Upper bound of tick delay, can set both to 0 to remove delay", position = 5, section = tickDelaySection) default int tickDelayMax() { return 3; }
@Range(max = 9) @ConfigItem( name = "Drop Per Tick Min", keyName = "numToDrop1", description = "Minimum amount of items dropped per tick", position = 6, section = dropConfigSection) default int dropPerTickOne() { return 1; }
@Range(max = 9) @ConfigItem( name = "Drop Per Tick Max", keyName = "numToDrop2", description = "Maximum amount of items dropped per tick", position = 7, section = dropConfigSection) default int dropPerTickTwo() { return 3; }
@ConfigItem( name = "Forestry Tree", keyName = "dropItems", description = "Object w most players,UNCHECK IF NOT WC", position = 5) default boolean useForestryTreeNotClosest() { return false; }
@Override public Dimension render(Graphics2D graphics) { panelComponent.setPreferredSize(new Dimension(200, 320)); panelComponent .getChildren() .add( TitleComponent.builder() .text("Piggy Power Skiller") .color(new Color(255, 157, 249)) .build()); panelComponent .getChildren() .add( TitleComponent.builder() .text(plugin.started ? "Running" : "Paused") .color(plugin.started ? Color.GREEN : Color.RED) .build()); panelComponent .getChildren() .add( LineComponent.builder() .left("State: ") .leftColor(new Color(255, 157, 249)) .right(plugin.state == null || !plugin.started ? "STOPPED" : plugin.state.name()) .rightColor(Color.WHITE) .build()); panelComponent .getChildren() .add( LineComponent.builder() .left("Trying to: ") .leftColor(new Color(255, 157, 249)) .right(plugin.config.expectedAction() + " " + plugin.config.objectToInteract()) .rightColor(Color.WHITE) .build()); return super.render(graphics); }
@ConfigItem(keyName = "herbType", name = "Herb Type", description = "", position = 1) default HerbType herbType() { return HerbType.GUAM; }
@Range(max = 10) @ConfigItem( keyName = "herbAmount", name = "Herbs per tick", description = "Number of herbs you clean per tick", position = 2) default int herbAmount() { return 10; }
@Override protected void startUp() throws Exception { keyManager.registerKeyListener(toggle); overlayManager.add(overlay); breakHandler.registerPlugin(this); }
@Override protected void shutDown() throws Exception { keyManager.unregisterKeyListener(toggle); overlayManager.remove(overlay); breakHandler.unregisterPlugin(this); }
private void findBank() { Optional<TileObject> chest = TileObjects.search().withName("Bank chest").nearestToPlayer(); Optional<NPC> banker = NPCs.search().withAction("Bank").nearestToPlayer(); Optional<TileObject> booth = TileObjects.search().withAction("Bank").nearestToPlayer(); if (chest.isPresent()) { TileObjectInteraction.interact(chest.get(), "Use"); return; } if (booth.isPresent()) { TileObjectInteraction.interact(booth.get(), "Bank"); return; } if (banker.isPresent()) { NPCInteraction.interact(banker.get(), "Bank"); return; } if (!chest.isPresent() && !booth.isPresent() && !banker.isPresent()) { client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "couldn't find bank or banker", null); EthanApiPlugin.stopPlugin(this); } }
private void handleBank() { if (!hasHerbsInBank()) { return; } Optional<Widget> cleanHerb = Inventory.search().filter(item -> cleanHerbs.contains(item.getItemId())).first(); if (cleanHerb.isPresent()) { Widget widget = client.getWidget(WidgetInfo.BANK_DEPOSIT_INVENTORY); MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(widget, "Deposit", "Deposit inventory"); return; } Bank.search() .nameContains(config.herbType().getItemName()) .filter( item -> { int herbLvl = client.getBoostedSkillLevel(Skill.HERBLORE); int maxHerb = grimyHerbLevels.get(item.getItemId()); return herbLvl >= maxHerb; }) .first() .ifPresent(item -> BankInteraction.useItem(item, "Withdraw-All")); }
private void handleCleanHerb() { List<Widget> itemList = Inventory.search().nameContains(config.herbType().getItemName()).result(); for (int i = 0; i < config.herbAmount(); i++) { InventoryInteraction.useItem(itemList.get(i), "Clean"); } }
private boolean hasHerbsInInventory() { return Inventory.search().nameContains(config.herbType().getItemName()).first().isPresent(); }
private boolean hasHerbsInBank() { return Bank.search().nameContains(config.herbType().getItemName()).first().isPresent(); }
private boolean isBankOpen() { Widget bank = client.getWidget(WidgetInfo.BANK_CONTAINER); return bank != null && !bank.isHidden(); }
@Override public Dimension render(Graphics2D graphics) { panelComponent .getChildren() .add(TitleComponent.builder().text("Piggy Herb Cleaner").color(Color.WHITE).build()); panelComponent .getChildren() .add( TitleComponent.builder() .text(plugin.isStarted() ? "Running" : "Paused") .color(plugin.isStarted() ? Color.GREEN : Color.RED) .build()); return super.render(graphics); }
@ConfigItem(keyName = "Food", name = "Food", description = "", position = 0) default String food() { return "Raw salmon"; }
@ConfigItem( keyName = "frequency", name = "Minutes", description = "How often to feed your kitten", position = 1) default int frequency() { return 20; }
@ConfigItem(keyName = "stroke", name = "Stroke", description = "Stroke your kitten", position = 2) default boolean stroke() { return true; }
@Override protected void startUp() throws Exception { clientThread.invokeLater( () -> { timeout = minutesToGameTicks(config.frequency()); EthanApiPlugin.sendClientMessage("Kitten Feeder started"); EthanApiPlugin.sendClientMessage( "ONLY FEEDS EVERY `X` MINUTES - DONT BLAME ME IF YOUR CAT DIES"); }); }
@Override protected void shutDown() throws Exception { timeout = 0; }
private Optional<NPC> kitten() { return NPCs.search() .interactingWithLocal() .filter(k -> Objects.requireNonNull(k.getName()).contains("itten")) .first(); }
private boolean hasFollower() { return client.getVarpValue(447) > 0; }
public int minutesToGameTicks(int minutes) { return (minutes * 60000) / 600; }
@ConfigItem( keyName = "prioritizeBloodDeath", name = "Always use blood/death altars", description = "Will ignore point balance for these altars and always use them if available.", position = 2, section = autoRiftsConfig) default boolean prioritizeBloodDeath() { return true; }
@ConfigItem( keyName = "dropRunes", name = "Drop Runes", description = "Drop Runes instead of depositing (kek uim)", position = 3, section = autoRiftsConfig) default boolean dropRunes() { return false; }
@ConfigItem( keyName = "dropRunesFilter", name = "Drop Runes Filter", description = "If Drop Runes is not enabled and this has runes entered, the type of rune entered here" + " will still get dropped, others will get deposited (ex: air, Mind, Body). Add" + " runes with full name, air rune, mind rune , cosmic rune, etc... and split with" + " comma ','", position = 5, section = autoRiftsConfig) default String dropRunesFilter() { return ""; }
@ConfigItem( keyName = "usePouches", name = "Use Essence Pouches?", description = "Requires NPC Contact runes in Rune Pouch or Redwood lit Lantern", position = 6, section = autoRiftsConfig) default boolean usePouches() { return false; }
@ConfigItem( keyName = "hasBook", name = "Abyssal Book in bank? (IMPORTANT FOR NPC CONTACT)", description = "IMPORTANT TO USE NPC CONTACT", position = 7, section = autoRiftsConfig) default boolean hasBook() { return true; }
@ConfigItem( keyName = "startFrags", name = "Starting Fragments (0 to wait for first portal)", description = "How many fragments you should get before leaving the starting zone", position = 8, section = autoRiftsConfig) default int startingFrags() { return 0; }
@ConfigItem( keyName = "ignoreAir", name = "Ignore Air Altar", description = "", position = 61, section = ignoreSection) default boolean ignoreAir() { return false; }
@ConfigItem( keyName = "ignoreMind", name = "Ignore Mind Altar", description = "", position = 62, section = ignoreSection) default boolean ignoreMind() { return false; }
@ConfigItem( keyName = "ignoreWater", name = "Ignore Water Altar", description = "", position = 63, section = ignoreSection) default boolean ignoreWater() { return false; }
@ConfigItem( keyName = "ignoreEarth", name = "Ignore Earth Altar", description = "", position = 64, section = ignoreSection) default boolean ignoreEarth() { return false; }
@ConfigItem( keyName = "ignoreFire", name = "Ignore Fire Altar", description = "", position = 65, section = ignoreSection) default boolean ignoreFire() { return false; }
@ConfigItem( keyName = "ignoreBody", name = "Ignore Body Altar", description = "", position = 66, section = ignoreSection) default boolean ignoreBody() { return false; }
@ConfigItem( keyName = "ignoreCosmic", name = "Ignore Cosmic Altar", description = "", position = 67, section = ignoreSection) default boolean ignoreCosmic() { return false; }
@ConfigItem( keyName = "ignoreChaos", name = "Ignore Chaos Altar", description = "", position = 68, section = ignoreSection) default boolean ignoreChaos() { return false; }
@ConfigItem( keyName = "ignoreNature", name = "Ignore Nature Altar", description = "", position = 69, section = ignoreSection) default boolean ignoreNature() { return false; }
@ConfigItem( keyName = "ignoreLaw", name = "Ignore Law Altar", description = "", position = 70, section = ignoreSection) default boolean ignoreLaw() { return false; }
@ConfigItem( keyName = "ignoreDeath", name = "Ignore Death Altar", description = "", position = 71, section = ignoreSection) default boolean ignoreDeath() { return false; }
@ConfigItem( keyName = "ignoreBlood", name = "Ignore Blood Altar", description = "", position = 72, section = ignoreSection) default boolean ignoreBlood() { return false; }
@Range(max = 10) @ConfigItem( keyName = "tickDelayMin", name = "Game Tick Min", description = "", position = 101, section = delayTickConfig) default int tickDelayMin() { return 1; }
@Range(max = 10) @ConfigItem( keyName = "tickDelayMax", name = "Game Tick Max", description = "", position = 102, section = delayTickConfig) default int tickDelayMax() { return 3; }
@ConfigItem( keyName = "tickDelayEnabled", name = "Tick delay", description = "enables some tick delays", position = 103, section = delayTickConfig) default boolean tickDelay() { return false; }
public void deregister() { eventBus.unregister(this); }
public void fillPouches() { int essenceAmount = Inventory.getItemAmount(ItemID.GUARDIAN_ESSENCE); List<Pouch> result = getEmptyPouches(); for (Pouch pouch : result) { Optional<Widget> emptyPouch = Inventory.search().withId(pouch.getPouchID()).first(); if (emptyPouch.isPresent()) { Widget p = emptyPouch.get(); InventoryInteraction.useItem(p, "Fill"); int essenceWithdrawn = pouch.getEssenceTotal() - pouch.getCurrentEssence(); if (essenceAmount - essenceWithdrawn >= 0) { essenceAmount -= essenceWithdrawn; pouch.setCurrentEssence(pouch.getEssenceTotal()); } else { pouch.setCurrentEssence(pouch.getCurrentEssence() + essenceAmount); essenceAmount = 0; } if (essenceAmount == 0) { break; } } } }
public boolean hasEmptyPouches() { for (Pouch pouch : pouches) { if (!isPouchFull(pouch)) { return true; } } return false; }
private boolean isPouchFull(Pouch pouch) { return pouch.getCurrentEssence() == pouch.getEssenceTotal(); }
public boolean hasDegradedPouches() { return Inventory.search().idInList(DEGRADED_POUCH_IDS).first().isPresent(); }
@Override protected void startUp() throws Exception { keyManager.registerKeyListener(toggle); overlayManager.add(overlay); breakHandler.registerPlugin(this); timeout = 0; timer = Instant.now(); pouchManager.register(); riftState.register(); }
@Override protected void shutDown() throws Exception { keyManager.unregisterKeyListener(toggle); overlayManager.remove(overlay); breakHandler.stopPlugin(this); breakHandler.unregisterPlugin(this); pouchManager.deregister(); riftState.deregister(); timeout = 0; toggle(); timer = Instant.now(); }
private void climbLargeMine() { if (EthanApiPlugin.isMoving()) { return; } Optional<TileObject> tileObject = TileObjects.search().withAction("Climb").nearestToPlayer(); if (tileObject.isEmpty()) { return; } TileObject rubble = tileObject.get(); TileObjectInteraction.interact(rubble, "Climb"); timeout = tickDelay(); }
private void craftEssence() { if (riftState.isGameStarted()) { Optional<TileObject> tileObject = TileObjects.search().nameContains(Constants.WORKBENCH).nearestToPlayer(); if (tileObject.isEmpty()) { return; } TileObject workbench = tileObject.get(); TileObjectInteraction.interact(workbench, "Work-at"); timeout = tickDelay(); } }
private void mineHugeGuardians() { Optional<TileObject> tileObject = TileObjects.search().nameContains(Constants.HUGE_REMAINS).nearestToPlayer(); if (tileObject.isEmpty()) { return; } TileObject remains = tileObject.get(); TileObjectInteraction.interact(remains, "Mine"); timeout = tickDelay(); }
private void enterGame() { if (canEnterBarrier) { TileObjects.search() .withName("Barrier") .first() .ifPresent(tileObject -> TileObjectInteraction.interact(tileObject, "Quick-pass")); timeout = 1; return; } Optional<Widget> dialog = Widgets.search().withId(15007475).hiddenState(false).first(); if (dialog.isEmpty()) { TileObjects.search() .withName("Barrier") .first() .ifPresent(tileObject -> TileObjectInteraction.interact(tileObject, "Quick-pass")); return; } String dialogText = dialog.get().getText(); if (dialogText.contains("the rift is already being guarded")) { timeout = 10; clickContinue(); return; } if (dialogText.contains("the adventurers within are just finishing up.")) { canEnterBarrier = true; timeout = 1; } }
private void clickContinue() { Widgets.search() .withTextContains("Click here to continue") .first() .ifPresent( widget -> { MousePackets.queueClickPacket(); WidgetPackets.queueResumePause(widget.getId(), -1); }); }
private int tickDelay() { return config.tickDelay() ? ThreadLocalRandom.current().nextInt(config.tickDelayMin(), config.tickDelayMax()) : 0; }
private boolean isMining() { return MiningAnimationIDs.contains(client.getLocalPlayer().getAnimation()); }
private void addMessage(String message) { client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null); }
private boolean hasRuneAmount(int runeId, int amount) { return (client.getVarbitValue(Varbits.RUNE_POUCH_RUNE1) == runeId && client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT1) >= amount) || (client.getVarbitValue(Varbits.RUNE_POUCH_RUNE2) == runeId && client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT2) >= amount) || (client.getVarbitValue(Varbits.RUNE_POUCH_RUNE3) == runeId && client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT3) >= amount) || (client.getVarbitValue(Varbits.RUNE_POUCH_RUNE4) == runeId && client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT4) >= amount); }
private boolean canDepositRune(int runeId) { return (client.getVarbitValue(Varbits.RUNE_POUCH_RUNE1) == runeId && client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT1) < 16000) || (client.getVarbitValue(Varbits.RUNE_POUCH_RUNE2) == runeId && client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT2) < 16000) || (client.getVarbitValue(Varbits.RUNE_POUCH_RUNE3) == runeId && client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT3) < 16000) || (client.getVarbitValue(Varbits.RUNE_POUCH_RUNE4) == runeId && client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT4) < 16000); }
private boolean isOnLunar() { return client.getVarbitValue(4070) == 2; }
private boolean hasNPCContactRunes() { return hasRuneAmount(1, 2) && hasRuneAmount(14, 1) && hasRuneAmount(9, 1); }
private boolean hasPowerEssence() { return Inventory.getItemAmount(ItemID.CATALYTIC_GUARDIAN_STONE) > 0 || Inventory.getItemAmount(ItemID.ELEMENTAL_GUARDIAN_STONE) > 0; }
private boolean hasPowerCell() { return Inventory.search().idInList(PoweredCellList).first().isPresent(); }
private void enterPortal() { if (EthanApiPlugin.isMoving()) { return; } Optional<TileObject> tileObject = nameContainsNoCase(Constants.PORTAL) .filter(to -> to.getWorldLocation().getY() >= Constants.OUTSIDE_BARRIER_Y) .nearestToPlayer(); if (tileObject.isEmpty()) { MousePackets.queueClickPacket(); MovementPackets.queueMovement(new WorldPoint(3615, 9499, 0)); return; } TileObject portal = tileObject.get(); TileObjectInteraction.interact(portal, "Enter", "Exit", "Use"); timeout = tickDelay(); }
private void exitAltar() { lastAltar = null; if (EthanApiPlugin.isMoving()) { return; } Optional<TileObject> tileObject = TileObjects.search().nameContains(Constants.PORTAL).nearestToPlayer(); if (tileObject.isEmpty()) { return; } TileObject portal = tileObject.get(); TileObjectInteraction.interact(portal, "Use"); timeout = tickDelay(); }
private void powerGuardian() { Optional<NPC> npc = NPCs.search().nameContains(Constants.GREAT_GUARDIAN).nearestToPlayer(); if (npc.isEmpty()) { return; } NPC guardian = npc.get(); NPCInteraction.interact(guardian, "Power-up"); timeout = tickDelay(); }
private void repairPouch() { if (!Widgets.search().withTextContains("What do you want?").hiddenState(false).empty() || !Widgets.search().withTextContains("Can you repair").hiddenState(false).empty()) { MousePackets.queueClickPacket(); WidgetPackets.queueResumePause(15138821, -1); MousePackets.queueClickPacket(); WidgetPackets.queueResumePause(14352385, config.hasBook() ? 1 : 2); MousePackets.queueClickPacket(); WidgetPackets.queueResumePause(14221317, -1); MousePackets.queueClickPacket(); EthanApiPlugin.invoke(-1, -1, 26, -1, -1, -1, "", "", -1, -1); timeout = 0; if (config.usePouches()) { clientThread.invokeLater(() -> pouchManager.refreshPouches()); } } else { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetActionPacket( 2, WidgetInfoExtended.SPELL_NPC_CONTACT.getPackedId(), -1, -1); timeout = 15; } }
private void depositRunes() { Optional<TileObject> tileObject = TileObjects.search().withAction("Deposit-runes").nearestToPlayer(); if (tileObject.isEmpty()) { return; } TileObject runeDeposit = tileObject.get(); TileObjectInteraction.interact(runeDeposit, "Deposit-runes"); timeout = tickDelay(); }
private int neededFrags() { return Inventory.getEmptySlots() + pouchManager.getAvailableSpace() + 5; }
private void enterRift() { TileObject nextAltar = riftState.getNextAltar(); if (nextAltar == null) { return; } if (nextAltar == lastAltar && EthanApiPlugin.isMoving()) { return; } lastAltar = nextAltar; TileObjectInteraction.interact(nextAltar, "Enter"); timeout = tickDelay(); }
private boolean hasDegradePrevention() { return Equipment.search().withId(ItemID.ABYSSAL_LANTERN_REDWOOD_LOGS).first().isPresent() || Equipment.search().withId(ItemID.RUNECRAFT_CAPE).first().isPresent() || Equipment.search().withId(ItemID.RUNECRAFT_CAPET).first().isPresent(); }
private boolean isWidgetVisible() { Optional<Widget> widget = Widgets.search().withId(Constants.PARENT_WIDGET).first(); return widget.isPresent() && !widget.get().isHidden(); }
public boolean isOutsideBarrier() { return client.getLocalPlayer().getWorldLocation().getY() <= Constants.OUTSIDE_BARRIER_Y && !isInAltar(); }
public boolean isInLargeMine() { return !isInAltar() && client.getLocalPlayer().getWorldLocation().getX() >= Constants.LARGE_MINE_X; }
public boolean isInHugeMine() { return !isInAltar() && client.getLocalPlayer().getWorldLocation().getX() <= Constants.HUGE_MINE_X; }
public boolean isGameBusy() { return !isInAltar() && isOutsideBarrier() && TileObjects.search().withId(Constants.BARRIER_BUSY_ID).nearestToPlayer().isPresent(); }
public boolean isPortalSpawned() { Widget portalWidget = client.getWidget(PORTAL_WIDGET_ID); return portalWidget != null && !portalWidget.isHidden(); }
private boolean isCatalytic(TileObject altar) { Set<Integer> catalyticAltars = Set.of(43705, 43709, 43706, 43710, 43711, 43708, 43712, 43707); return catalyticAltars.contains(altar.getId()); }
public static int GetCellTier(int cellID) { switch (cellID) { case ItemID.WEAK_CELL: return 1; case ItemID.MEDIUM_CELL: return 2; case ItemID.STRONG_CELL: return 3; case ItemID.OVERCHARGED_CELL: return 4; default: return -1; } }
public static int GetShieldTier(int shieldID) { switch (shieldID) { case ObjectID.INACTIVE_CELL_TILE: return 0; case ObjectID.WEAK_CELL_TILE: return 1; case ObjectID.MEDIUM_CELL_TILE: return 2; case ObjectID.STRONG_CELL_TILE: return 3; case ObjectID.OVERPOWERED_CELL_TILE: return 4; default: return -1; } }
@Override protected void startUp() throws Exception { overlay = new CalvarionHelperOverlay(client, this); overlayManager.add(overlay); }
@Subscribe public void onGameTick(GameTick e) { lightning.forEach((k, v) -> lightning.put(k, v - 1)); lightning.entrySet().removeIf(entry -> entry.getValue() <= 0); swing.forEach((k, v) -> swing.put(k, v - 1)); swing.entrySet().removeIf(entry -> entry.getValue() <= 0); }
@ConfigItem(keyName = "lightning", name = "lightning colour", description = "") default Color lightning() { return Color.RED; }
@ConfigItem(keyName = "swing", name = "swing colour", description = "") default Color swing() { return Color.BLUE; }
@ConfigItem(keyName = "lightningFill", name = "lightning fill colour", description = "") @Alpha default Color lightningFill() { return new Color(0, 0, 0, 50); }
@Alpha @ConfigItem(keyName = "swingFill", name = "swing fill colour", description = "") default Color swingFill() { return new Color(0, 0, 0, 50); }
@Override public Dimension render(Graphics2D graphics) { plugin.lightning.forEach( (lightningTile, i) -> { if (lightningTile == null) { return; } renderArea( graphics, LocalPoint.fromWorld(client, lightningTile), plugin.config.lightning(), 1, plugin.config.lightningFill()); }); AtomicReference<Area> area = new AtomicReference<>(); plugin.swing.forEach( (swingTile, i) -> { if (swingTile == null) { return; } OverlayUtil.renderPolygon( graphics, Perspective.getCanvasTilePoly(client, LocalPoint.fromWorld(client, swingTile)), plugin.config.swing(), plugin.config.swingFill(), new BasicStroke((float) 1)); }); return null; }
private void renderArea( final Graphics2D graphics, final LocalPoint dest, final Color color, final double borderWidth, final Color fillColor) { if (dest == null) { return; } final Polygon poly = Perspective.getCanvasTileAreaPoly(client, dest, 3); if (poly == null) { return; } OverlayUtil.renderPolygon( graphics, poly, color, fillColor, new BasicStroke((float) borderWidth)); }
public static Bubbles getNearestBubble( WorldPoint worldPoint, int radius, Bubbles lastVisitedBubble) { return Arrays.stream(values()) .filter(bubble -> bubble != lastVisitedBubble) .filter(bubble -> bubble.getLocation().distanceTo(worldPoint) <= radius) .min(Comparator.comparingInt(bubble -> bubble.getLocation().distanceTo(worldPoint))) .orElse(null); }
private int tickDelay() { return config.tickDelay() ? ThreadLocalRandom.current().nextInt(config.tickDelayMin(), config.tickDelayMax()) : 3; }
@Override protected void startUp() throws Exception { keyManager.registerKeyListener(toggle); overlayManager.add(overlay); timeout = 0; clientThread.invoke(this::setVals); }
@Override protected void shutDown() throws Exception { keyManager.unregisterKeyListener(toggle); overlayManager.remove(overlay); timeout = 0; started = false; unsetVals(); }
private void unsetVals() { swampToads = null; bloatedToads = null; bloatedToadsItem = null; birds = null; ammoId = -1; }
private void doChompy() { checkRunEnergy(); log.info(state.toString()); if (Equipment.search().withId(ammoId).empty()) { EthanApiPlugin.sendClientMessage("No Ogre arrows or Brutal arrows left"); EthanApiPlugin.stopPlugin(this); } switch (state) { case KILL_BIRD: handleKillBird(); break; case FILL_BELLOWS: handleFillBellows(); break; case DROP_TOAD: handleDropToad(); break; case INFLATE_TOAD: handleInflateToad(); break; case WAITING: timeout = tickDelay(); break; default: determineNextState(); break; } }
private void determineNextState() { if (!birds.empty()) { state = State.KILL_BIRD; } else if (!hasFilledBellows() && !TileObjects.search().nameContains("wamp bubble").empty()) { state = State.FILL_BELLOWS; } else if (!bloatedToadsItem.empty()) { state = State.DROP_TOAD; } else if (bloatedToadsItem.empty() && hasFilledBellows()) { state = State.INFLATE_TOAD; } else { state = State.WAITING; } }
private void handleKillBird() { birds .first() .ifPresent( npc -> { MousePackets.queueClickPacket(); NPCPackets.queueNPCAction(npc, "Attack"); }); }
public boolean hasFilledBellows() { return Inventory.search().nameContains("bellows (").first().isPresent(); }
public boolean isStandingOnToad() { WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation(); return NPCs.search().nameContains("loated Toad").result().stream() .anyMatch(toad -> toad.getWorldLocation().equals(playerLocation)); }
private void handleDropToad() { if (isStandingOnToad()) { MousePackets.queueClickPacket(); MovementPackets.queueMovement(getNearestFreeTile().get()); timeout = tickDelay(); } else { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(bloatedToadsItem.first().get(), "Drop"); timeout = tickDelay(); } }
private void handleInflateToad() { swampToads .nearestToPlayer() .ifPresent( npc -> { MousePackets.queueClickPacket(); NPCPackets.queueNPCAction(npc, "Inflate"); log.info("Inflating Toad"); timeout = tickDelay(); log.info(String.valueOf(timeout)); }); }
@Range(max = 10) @ConfigItem( keyName = "tickDelayMin", name = "Game Tick Min", description = "", position = 2, section = delayTickConfig) default int tickDelayMin() { return 4; }
@Range(max = 20) @ConfigItem( keyName = "tickDelayMax", name = "Game Tick Max", description = "", position = 3, section = delayTickConfig) default int tickDelayMax() { return 15; }
@ConfigItem( keyName = "tickDelayEnabled", name = "Tick delay", description = "enables some tick delays", position = 4, section = delayTickConfig) default boolean tickDelay() { return false; }
@ConfigItem(keyName = "Toggle", name = "Toggle", description = "") default Keybind toggle() { return Keybind.NOT_SET; }
@ConfigItem( keyName = "minimapToggle", name = "Toggle with Minimap Orb", description = "Toggle using the Minimap Orb") default boolean minimapToggle() { return false; }
private void togglePrayer() { clientThread.invoke( () -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetActionPacket(1, quickPrayerWidgetID, -1, -1); }); }
public void switchAndUpdatePrayers(int i) { clientThread.invoke( () -> { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetActionPacket(1, 5046276, -1, i); }); updatePrayers(); }
public void updatePrayers() { togglePrayer(); togglePrayer(); }
private static boolean containsRegion(int[] regions, int regionID) { return Arrays.stream(regions).anyMatch(region -> region == regionID); }
@ConfigItem(keyName = "agilityToggle", name = "Toggle", description = "", position = 0) default Keybind agilityToggle() { return Keybind.NOT_SET; }
@Range(max = 10) @ConfigItem( keyName = "tickDelayMin", name = "Game Tick Min", description = "", position = 2, section = delayTickConfig) default int tickDelayMin() { return 1; }
@Range(max = 10) @ConfigItem( keyName = "tickDelayMax", name = "Game Tick Max", description = "", position = 3, section = delayTickConfig) default int tickDelayMax() { return 3; }
@ConfigItem( keyName = "Course", name = "Course", description = "Supported agility courses", position = 6, section = agilitySection) default Course course() { return Course.GNOME; }
@ConfigItem( keyName = "foodName", name = "Food Name", description = "Name of food to eat (i.e Cake)", position = 7, section = agilitySection) default String foodName() { return ""; }
@ConfigItem( keyName = "camelotTeleport", name = "Use Camelot Teleport", description = "Use Camelot Teleport if you have hard diaries completed. Requires Air Runes or (Air" + " Staff equipped) and Law Runes in inventory", position = 9, section = agilitySection) default boolean camelotTeleport() { return false; }
@ConfigItem( keyName = "mogPickup", name = "Pick up Mark of Grace", description = "Enable to pick up Marks of Grace", position = 10, section = agilitySection) default boolean mogPickup() { return true; }
@ConfigItem( keyName = "mogStack", name = "Ardougne marks stack", description = "The number of marks of grace to be stacked before it is picked up at Ardougne.", position = 11, section = agilitySection) default int mogStack() { return 0; }
@ConfigItem( keyName = "lowHP", name = "Stop/Eat at HP", description = "Stop/Eat if HP goes below given threshold", position = 12, section = agilitySection) default int lowHP() { return 5; }
@ConfigItem( keyName = "boostWithPie", name = "Enable Summer Pies", description = "Enable using Summer Pies", position = 13, section = agilitySection) default boolean boostWithPie() { return false; }
@ConfigItem( keyName = "pieLevel", name = "Min boost level", description = "A Summer Pie will be used whenever your Agility drops below this level", position = 14, section = agilitySection) default int pieLevel() { return 80; }
@ConfigItem( keyName = "keepGoing", name = "Keep Running", description = "Keep running after out of Pies/Food in bank", position = 15, section = agilitySection) default boolean keepGoing() { return false; }
@Range(min = 10, max = 100) @ConfigItem( keyName = "enableRun", name = "Enable Run", description = "Amount of run energy restored to run back on", position = 15, section = agilitySection) default int enableRun() { return 50; }
@ConfigItem( keyName = "highAlch", name = "High Alch", description = "Items you want to high alch, supports wildcards '*'", position = 16, section = agilitySection) default String highAlch() { return "Rune *"; }
private boolean shouldAlch() { return highAlchTimeout <= 0 && !config.highAlch().isEmpty() && highAlch; }
private void eatFood() { Optional<Widget> food = InventoryUtil.nameContainsNoCase(config.foodName()).first(); if (food.isPresent()) { MousePackets.queueClickPacket(); InventoryInteraction.useItem(food.get(), "Eat"); } }
private void resetVals() { markOfGraceTile = null; markOfGrace = null; startAgility = false; timer = null; mogSpawnCount = 0; mogCollectCount = 0; mogInventoryCount = -1; marksPerHour = 0; }
private void resetValsNoTimer() { markOfGraceTile = null; startAgility = false; mogSpawnCount = 0; mogCollectCount = 0; mogInventoryCount = -1; marksPerHour = 0; }
private boolean shouldEatSummerPie() { return config.boostWithPie() && (client.getBoostedSkillLevel(Skill.AGILITY) < config.pieLevel()) && (InventoryUtil.getItemAmount(ItemID.SUMMER_PIE) > 0 || InventoryUtil.getItemAmount(ItemID.HALF_A_SUMMER_PIE) > 0); }
private boolean shouldCastTeleport() { return config.camelotTeleport() && client.getBoostedSkillLevel(Skill.MAGIC) >= 45 && CAMELOT_TELE_LOC.distanceTo(client.getLocalPlayer().getWorldLocation()) <= 3 && (Inventory.getItemAmount(ItemID.LAW_RUNE) > 0 && Inventory.getItemAmount(ItemID.AIR_RUNE) >= 5 || Inventory.getItemAmount(ItemID.LAW_RUNE) > 0 && AIR_STAFFS.contains( client.getLocalPlayer().getPlayerComposition().getEquipmentId(KitType.WEAPON))); }
private boolean shouldRestock() { if (config.foodName().isEmpty() && !config.boostWithPie()) { return false; } if (!config.foodName().isBlank()) { return InventoryUtil.nameContainsNoCase(config.foodName()).empty(); } if (config.boostWithPie()) { return Inventory.search().matchesWildCardNoCase("*summer pie*").empty(); } return false; }
private boolean isBankPinOpen() { Widget bankPinWidget = client.getWidget(213, 0); if (bankPinWidget == null) { return false; } return !bankPinWidget.isHidden(); }
private void eatSummerPie() { InventoryUtil.nameContainsNoCase("summer pie") .first() .ifPresent( item -> { InventoryInteraction.useItem(item, "Eat"); }); }
@Provides private RooftopAgilityConfig provideConfig(ConfigManager manager) { return manager.getConfig(RooftopAgilityConfig.class); }
@Override protected void startUp() throws Exception { timer = Instant.now(); overlayManager.add(overlay); keyManager.registerKeyListener(agilityToggle); breakHandler.registerPlugin(this); highAlch = !config.highAlch().isBlank(); }
@Override protected void shutDown() throws Exception { resetVals(); overlayManager.remove(overlay); breakHandler.unregisterPlugin(this); keyManager.unregisterKeyListener(agilityToggle); }
@SneakyThrows private boolean isStackable(Widget item) { ItemComposition itemComposition = EthanApiPlugin.itemDefs.get(item.getItemId()); return itemComposition.isStackable(); }
private String formatNumber(double value) { if (value >= 1_000_000) { return String.format("%.1fm", value / 1_000_000); } else if (value >= 100_000) { return String.format("%.0fk", value / 1_000); } else if (value >= 10_000) { return String.format("%.1fk", value / 1_000); } else { return String.valueOf((int) value); } }
@Override public Dimension render(Graphics2D graphics) { if (!plugin.isOverlayVisible()) { return null; } Instant startTime = plugin.getStartTime(); Duration runtime = Duration.between(startTime, Instant.now()); long seconds = runtime.getSeconds(); long hours = seconds / 3600; long minutes = (seconds % 3600) / 60; long secondsLeft = seconds % 60; int expGained = plugin.getExperienceGained(); double xpPerHour = expGained * 3600.0 / seconds; panelComponent .getChildren() .add(TitleComponent.builder().text("[PP] Lava Runecrafter").color(Color.WHITE).build()); panelComponent .getChildren() .add( LineComponent.builder() .left("Runtime:") .right(String.format("%02d:%02d:%02d", hours, minutes, secondsLeft)) .build()); panelComponent .getChildren() .add(LineComponent.builder().left("XP Gained:").right(String.valueOf(expGained)).build()); panelComponent .getChildren() .add(LineComponent.builder().left("XP/Hour:").right(formatNumber(xpPerHour)).build()); return super.render(graphics); }
@ConfigItem( keyName = "TeleMethod", name = "Teleport Method", description = "Which method you will use to get to the altar") default TeleportMethods TeleMethod() { return TeleportMethods.RING_OF_DUELING; }
@ConfigItem( keyName = "VialSmasher", name = "Vial Smasher Enabled", description = "Does the account have vial smasher enabled?") default boolean VialSmasher() { return false; }
@ConfigItem( keyName = "EssenceType", name = "Essence Type", description = "Select the type of essence to use") default EssenceType EssenceType() { return EssenceType.PURE_ESSENCE; }
@ConfigItem( keyName = "MinTickDelay", name = "Minimum Tick Delay", description = "Minimum tick delay between actions") default int MinTickDelay() { return 1; }
@ConfigItem( keyName = "MaxTickDelay", name = "Maximum Tick Delay", description = "Maximum tick delay between actions") default int MaxTickDelay() { return 3; }
private void applyRandomDelay() { timeout = getRandomTickDelay(); }
@Override @SneakyThrows public void startUp() { timeout = 0; pouches = new HashMap<>(); breakHandler.registerPlugin(this); startTime = Instant.now(); startingExp = client.getSkillExperience(Skill.RUNECRAFT); experienceGained = 0; overlayVisible = true; overlayManager.add(overlay); }
@Override public void shutDown() { timeout = 0; pouches = new HashMap<>(); breakHandler.unregisterPlugin(this); overlayManager.remove(overlay); overlayVisible = false; }
public boolean pouchesDegraded() { return EthanApiPlugin.getItemFromList( new int[] { ItemID.MEDIUM_POUCH_5511, ItemID.LARGE_POUCH_5513, ItemID.GIANT_POUCH_5515, ItemID.COLOSSAL_POUCH_26786 }, WidgetInfo.INVENTORY) != null; }
public void handleWithdraw() { int freeSlots = EthanApiPlugin.getEmptySlots(WidgetInfo.INVENTORY); for (Widget pouch : pouches.keySet()) { if (pouches.get(pouch)[0] > 0) { int taken = Math.min(pouches.get(pouch)[0], freeSlots); pouches.put(pouch, new int[] {pouches.get(pouch)[0] - taken, pouches.get(pouch)[1]}); freeSlots -= taken; Widget realPouch = EthanApiPlugin.getItem(pouch.getItemId(), WidgetInfo.INVENTORY); if (realPouch == null) { pouches.put(pouch, new int[] {0, pouches.get(pouch)[1]}); continue; } MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(realPouch, "Empty"); } if (freeSlots == 0) { break; } } }
public int essenceInPouches() { int sum = 0; for (Widget pouch : pouches.keySet()) { sum += pouches.get(pouch)[0]; } return sum; }
public int essenceNeeded() { int essenceNeeded = 0; for (Widget pouch : pouches.keySet()) { int[] values = pouches.get(pouch); essenceNeeded += values[1] - values[0]; } return essenceNeeded; }
private boolean isEssence(int itemId) { switch (config.EssenceType()) { case DAEYALT_ESSENCE: return itemId == ItemID.DAEYALT_ESSENCE; case PURE_ESSENCE: default: return itemId == ItemID.PURE_ESSENCE; } }
public boolean isOverlayVisible() { return overlayVisible; }
@Override public void startUp() { timeout = 0; keyManager.registerKeyListener(toggle); }
@Override public void shutDown() { timeout = 0; started = false; keyManager.unregisterKeyListener(toggle); }
@Subscribe public void onGameTick(GameTick event) { Player player = client.getLocalPlayer(); if (!started || EthanApiPlugin.isMoving()) return; if (timeout > 0) { timeout--; return; } idleTicks = client.getLocalPlayer().getAnimation() == -1 ? idleTicks + 1 : 0; doAerial2(); }
private boolean staminaIsActive() { return client.getVarbit(Varbits.RUN_SLOWED_DEPLETION_ACTIVE).equals(1); }
private static void toggleRunEnergy() { log.info("turning run on"); MousePackets.queueClickPacket(); WidgetPackets.queueWidgetActionPacket(1, 10485787, -1, -1); }
@Override public void startUp() { lastHitsplat = 0; moving = false; movements = new ArrayList<>(); }
@ConfigItem( keyName = "dropIfInvFull", name = "Drop if inventory is full", description = "* Drop all selected items when the inventory is full", position = 1) default boolean dropIfInvFull() { return false; }
@ConfigItem( keyName = "itemIds", name = "Item IDs or names", description = "<html>* Item IDs or names of the items you want to drop<br>" + "* Names support wildcards (i.e. *karam* or *salmon" + "* Separate with comma or comma and space</html>", position = 2) default String itemIdsOrNames() { return "100, 200, trout, *salmon"; }
@Range(min = 2, max = 10) @ConfigItem( keyName = "maxPerTick", name = "Max items per tick", description = "<html>* The max amount of items to drop each tick<br>" + "* The minimum amount is always 2</html>", position = 3) default int maxPerTick() { return 10; }
@Override protected void startUp() { keyManager.registerKeyListener(dropItemsHotkey); itemsToDrop.clear(); itemNames.clear(); dropping = false; updateItemIds(); }
@Override protected void shutDown() { dropping = false; keyManager.unregisterKeyListener(dropItemsHotkey); }
@Subscribe private void onConfigChanged(ConfigChanged configChanged) { if (!configChanged.getGroup().equals(config.GROUP)) return; if (!configChanged.getKey().equals("itemIds")) return; updateItemIds(); }
@Subscribe private void onGameTick(GameTick gameTick) { if (!dropping && config.dropIfInvFull() && Inventory.full()) { buildItemQueue(); dropping = true; } if (dropping) { dropItems(); } }
private void buildItemQueue() { itemsToDrop.clear(); itemsToDrop.addAll(Inventory.search().idInList(itemIds).result()); for (String name : itemNames) { itemsToDrop.addAll( Inventory.search() .matchesWildCardNoCase(name) .filter(w -> !itemsToDrop.contains(w)) .result()); } }
private void updateItemIds() { if (config.itemIdsOrNames().trim().isEmpty()) { itemIds.clear(); itemNames.clear(); return; } var parts = config.itemIdsOrNames().trim().split(", |,"); for (String part : parts) { try { int id = Integer.parseInt(part.trim()); itemIds.add(id); } catch (NumberFormatException ignored) { itemNames.add(part.trim()); } } }
private void dropItems() { int numOfItems = getRandomIntBetweenRange(2, config.maxPerTick()); for (int i = 0; i < numOfItems; i++) { if (itemsToDrop.peek() == null) { dropping = false; return; } InventoryInteraction.useItem(itemsToDrop.poll(), "Drop"); } if (itemsToDrop.isEmpty()) dropping = false; }
public static WeaponType checkWeaponOnPlayer(Client client, Player attacker) { int itemId = attacker.getPlayerComposition().getEquipmentId(KitType.WEAPON); ItemComposition itemComposition = client.getItemDefinition(itemId); String weaponNameGivenLowerCase = itemComposition.getName().toLowerCase(); if (itemId == -1) { return WEAPON_MELEE; } if (weaponNameGivenLowerCase.toLowerCase().contains("null")) { return WEAPON_MELEE; } for (String meleeWeaponName : meleeWeaponNames) { if (weaponNameGivenLowerCase.contains(meleeWeaponName) && !weaponNameGivenLowerCase.contains("thrownaxe")) { return WEAPON_MELEE; } } for (String rangedWeaponName : rangedWeaponNames) { if (weaponNameGivenLowerCase.contains(rangedWeaponName)) { return WEAPON_RANGED; } } for (String magicWeaponName : magicWeaponNames) { if (weaponNameGivenLowerCase.contains(magicWeaponName)) { return WEAPON_MAGIC; } } return WEAPON_UNKNOWN; }
@Override public Dimension render(Graphics2D graphics) { renderPotentialPlayers(graphics); renderAttackingPlayers(graphics); return null; }
private void renderNameAboveHead(Graphics2D graphics, Player player, Color color) { final String name = Text.sanitize(player.getName()); final int offset = player.getLogicalHeight() + 40; Point textLocation = player.getCanvasTextLocation(graphics, name, offset); if (textLocation != null) { OverlayUtil.renderTextLocation(graphics, textLocation, name, color); } }
private void renderHighlightedPlayer(Graphics2D graphics, Player player, Color color) { try { OverlayUtil.renderPolygon(graphics, player.getConvexHull(), color); } catch (NullPointerException ignored) { } }
private void renderTileUnderPlayer(Graphics2D graphics, Player player, Color color) { Polygon poly = player.getCanvasTilePoly(); OverlayUtil.renderPolygon(graphics, poly, color); }
private void renderPrayAgainstOnPlayer(Graphics2D graphics, Player player, Color color) { final int offset = (player.getLogicalHeight() / 2) + 75; BufferedImage icon; switch (WeaponType.checkWeaponOnPlayer(client, player)) { case WEAPON_MELEE: icon = plugin.getProtectionIcon(WeaponType.WEAPON_MELEE); prayerToActivate = Prayer.PROTECT_FROM_MELEE; break; case WEAPON_MAGIC: icon = plugin.getProtectionIcon(WeaponType.WEAPON_MAGIC); prayerToActivate = Prayer.PROTECT_FROM_MAGIC; break; case WEAPON_RANGED: icon = plugin.getProtectionIcon(WeaponType.WEAPON_RANGED); prayerToActivate = Prayer.PROTECT_FROM_MISSILES; break; default: icon = null; break; } try { if (icon != null) { Point point = player.getCanvasImageLocation(icon, offset); OverlayUtil.renderImageLocation(graphics, point, icon); } else { if (config.drawUnknownWeapons()) { int itemId = player.getPlayerComposition().getEquipmentId(KitType.WEAPON); ItemComposition itemComposition = client.getItemDefinition(itemId); final String str = itemComposition.getName().toUpperCase(); Point point = player.getCanvasTextLocation(graphics, str, offset); OverlayUtil.renderTextLocation(graphics, point, str, color); } } } catch (Exception ignored) { } }
@ConfigItem( position = 0, keyName = "attackerPlayerColor", name = "Attacker color", description = "This is the color that will be used to highlight attackers.") default Color attackerPlayerColor() { return new Color(0xFF0006); }
@ConfigItem( position = 1, keyName = "potentialPlayerColor", name = "Potential Attacker color", description = "This is the color that will be used to highlight potential attackers.") default Color potentialPlayerColor() { return new Color(0xFFFF00); }
@ConfigItem( position = 2, keyName = "attackerTargetTimeout", name = "Attacker Timeout", description = "Seconds until attacker is no longer highlighted.") default int attackerTargetTimeout() { return 10; }
@ConfigItem( position = 3, keyName = "potentialTargetTimeout", name = "Potential Attacker Timeout", description = "Seconds until potential attacker is no longer highlighted.") default int potentialTargetTimeout() { return 10; }
@ConfigItem( position = 4, keyName = "newSpawnTimeout", name = "New Player Timeout", description = "Seconds until logged in/spawned player is no longer highlighted.") default int newSpawnTimeout() { return 5; }
@ConfigItem( position = 5, keyName = "ignoreFriends", name = "Ignore Friends", description = "This lets you decide whether you want friends to be highlighted by this plugin.") default boolean ignoreFriends() { return true; }
@ConfigItem( position = 6, keyName = "ignoreClanMates", name = "Ignore Clan Mates", description = "This lets you decide whether you want clan mates to be highlighted by this plugin.") default boolean ignoreClanMates() { return true; }
@ConfigItem( position = 7, keyName = "markNewPlayer", name = "Mark new player as potential attacker", description = "Marks someone that logged in or teleported as a potential attacker for your safety\n" + "DO NOT RUN THIS IN WORLD 1-2 GRAND EXCHANGE!") default boolean markNewPlayer() { return false; }
@ConfigItem( position = 8, keyName = "drawTargetPrayAgainst", name = "Draw what to pray on attacker", description = "Tells you what to pray from what weapon the attacker is holding") default boolean drawTargetPrayAgainst() { return true; }
@ConfigItem( position = 9, keyName = "drawPotentialTargetPrayAgainst", name = "Draw what to pray on potential attacker", description = "Tells you what to pray from what weapon the potential attacker is holding") default boolean drawPotentialTargetPrayAgainst() { return true; }
@ConfigItem( position = 10, keyName = "drawTargetPrayAgainstPrayerTab", name = "Draw what to pray from prayer tab", description = "Tells you what to pray from what weapon the attacker is holding from the prayer tab") default boolean drawTargetPrayAgainstPrayerTab() { return false; }
@ConfigItem( position = 11, keyName = "drawTargetsName", name = "Draw name on attacker", description = "Configures whether or not the attacker\'s name should be shown") default boolean drawTargetsName() { return true; }
@ConfigItem( position = 12, keyName = "drawPotentialTargetsName", name = "Draw name on potential attacker", description = "Configures whether or not the potential attacker\'s name should be shown") default boolean drawPotentialTargetsName() { return true; }
@ConfigItem( position = 13, keyName = "drawTargetHighlight", name = "Draw highlight around attacker", description = "Configures whether or not the attacker should be highlighted") default boolean drawTargetHighlight() { return true; }
@ConfigItem( position = 14, keyName = "drawPotentialTargetHighlight", name = "Draw highlight around potential attacker", description = "Configures whether or not the potential attacker should be highlighted") default boolean drawPotentialTargetHighlight() { return true; }
@ConfigItem( position = 15, keyName = "drawTargetTile", name = "Draw tile under attacker", description = "Configures whether or not the attacker\'s tile be highlighted") default boolean drawTargetTile() { return false; }
@ConfigItem( position = 16, keyName = "drawPotentialTargetTile", name = "Draw tile under potential attacker", description = "Configures whether or not the potential attacker\'s tile be highlighted") default boolean drawPotentialTargetTile() { return false; }
@ConfigItem( position = 17, keyName = "drawUnknownWeapons", name = "Draw unknown weapons", description = "Configures whether or not the unknown weapons should be shown when a player equips one") default boolean drawUnknownWeapons() { return false; }
@ConfigItem( position = 18, keyName = "activatePrayer", name = "Activate Prayer", description = "Automatically activates your protection prayer") default boolean activatePrayer() { return false; }
private void renderPrayerToClick(Graphics2D graphics, Player player) { Widget PROTECT_FROM_MAGIC = client.getWidget(PrayerUtil.getPrayerWidgetId(Prayer.PROTECT_FROM_MAGIC)); Widget PROTECT_FROM_RANGED = client.getWidget(PrayerUtil.getPrayerWidgetId(Prayer.PROTECT_FROM_MISSILES)); Widget PROTECT_FROM_MELEE = client.getWidget(PrayerUtil.getPrayerWidgetId(Prayer.PROTECT_FROM_MELEE)); Color color = Color.RED; if (PROTECT_FROM_MELEE.isHidden()) { return; } switch (WeaponType.checkWeaponOnPlayer(client, player)) { case WEAPON_MAGIC: OverlayUtil.renderPolygon( graphics, rectangleToPolygon(PROTECT_FROM_MAGIC.getBounds()), color); break; case WEAPON_MELEE: OverlayUtil.renderPolygon( graphics, rectangleToPolygon(PROTECT_FROM_MELEE.getBounds()), color); break; case WEAPON_RANGED: OverlayUtil.renderPolygon( graphics, rectangleToPolygon(PROTECT_FROM_RANGED.getBounds()), color); break; default: break; } }
private static Polygon rectangleToPolygon(Rectangle rect) { int[] xpoints = {rect.x, rect.x + rect.width, rect.x + rect.width, rect.x}; int[] ypoints = {rect.y, rect.y, rect.y + rect.height, rect.y + rect.height}; return new Polygon(xpoints, ypoints, 4); }
@Provides PrayAgainstPlayerConfig provideConfig(ConfigManager configManager) { return configManager.getConfig(PrayAgainstPlayerConfig.class); }
@Override protected void startUp() { potentialPlayersAttackingMe = new ArrayList<>(); playersAttackingMe = new ArrayList<>(); overlayManager.add(overlay); overlayManager.add(overlayPrayerTab); }
@Override protected void shutDown() throws Exception { overlayManager.remove(overlay); overlayManager.remove(overlayPrayerTab); }
@Subscribe private void onPlayerDespawned(PlayerDespawned playerDespawned) { PlayerContainer container = findPlayerInAttackerList(playerDespawned.getPlayer()); PlayerContainer container2 = findPlayerInPotentialList(playerDespawned.getPlayer()); if (container != null) { playersAttackingMe.remove(container); } if (container2 != null) { potentialPlayersAttackingMe.remove(container2); } }
private void resetPlayerFromAttackerContainerTimer(PlayerContainer container) { removePlayerFromAttackerContainer(container); PlayerContainer newContainer = new PlayerContainer( container.getPlayer(), System.currentTimeMillis(), (config.attackerTargetTimeout() * 1000)); playersAttackingMe.add(newContainer); }
void removePlayerFromPotentialContainer(PlayerContainer container) { if ((potentialPlayersAttackingMe != null) && (!potentialPlayersAttackingMe.isEmpty())) { potentialPlayersAttackingMe.remove(container); } }
void removePlayerFromAttackerContainer(PlayerContainer container) { if ((playersAttackingMe != null) && (!playersAttackingMe.isEmpty())) { playersAttackingMe.remove(container); } }
private boolean isBlockAnimation(int anim) { switch (anim) { case BLOCK_DEFENDER: case BLOCK_NO_SHIELD: case BLOCK_SHIELD: case BLOCK_SWORD: case BLOCK_UNARMED: return true; default: return false; } }
private void loadProtectionIcons() { for (int i = 0; i < PROTECTION_ICONS.length; i++) { final int resource = PROTECTION_ICONS[i]; ProtectionIcons[i] = rgbaToIndexedBufferedImage( ProtectionIconFromSprite(spriteManager.getSprite(resource, 0))); } }
private static BufferedImage rgbaToIndexedBufferedImage(final BufferedImage sourceBufferedImage) { final BufferedImage indexedImage = new BufferedImage( sourceBufferedImage.getWidth(), sourceBufferedImage.getHeight(), BufferedImage.TYPE_BYTE_INDEXED); final ColorModel cm = indexedImage.getColorModel(); final IndexColorModel icm = (IndexColorModel) cm; final int size = icm.getMapSize(); final byte[] reds = new byte[size]; final byte[] greens = new byte[size]; final byte[] blues = new byte[size]; icm.getReds(reds); icm.getGreens(greens); icm.getBlues(blues); final WritableRaster raster = indexedImage.getRaster(); final int pixel = raster.getSample(0, 0, 0); final IndexColorModel resultIcm = new IndexColorModel(8, size, reds, greens, blues, pixel); final BufferedImage resultIndexedImage = new BufferedImage(resultIcm, raster, sourceBufferedImage.isAlphaPremultiplied(), null); resultIndexedImage.getGraphics().drawImage(sourceBufferedImage, 0, 0, null); return resultIndexedImage; }
private static BufferedImage ProtectionIconFromSprite(final BufferedImage freezeSprite) { final BufferedImage freezeCanvas = ImageUtil.resizeCanvas( freezeSprite, PROTECTION_ICON_DIMENSION.width, PROTECTION_ICON_DIMENSION.height); return ImageUtil.outlineImage(freezeCanvas, PROTECTION_ICON_OUTLINE_COLOR); }
@ConfigItem( keyName = "itemOneName", name = "Item One (Tool/Vial)", description = "Name of the first item", position = 2, section = configuration) default String itemOneName() { return ""; }
@ConfigItem( keyName = "itemOneAmt", name = "Item One Amount", description = "Amount of the first item", position = 3, section = configuration) default int itemOneAmt() { return 14; }
@ConfigItem( keyName = "itemTwoName", name = "Item Two (Herb/Second/Gem/Etc.)", description = "Name of the second item", position = 4, section = configuration) default String itemTwoName() { return ""; }
@ConfigItem( keyName = "itemTwoAmt", name = "Item Two Amount", description = "Amount of the second item", position = 4, section = configuration) default int itemTwoAmt() { return 14; }
@Range(max = 10) @ConfigItem( keyName = "tickDelayMin", name = "Banking Tick Min", description = "", position = 7, section = tickDelayConfig) default int tickDelayBankingMin() { return 2; }
@Range(max = 15) @ConfigItem( keyName = "tickDelayMax", name = "Banking Tick Max", description = "", position = 8, section = tickDelayConfig) default int tickDelayBankingMax() { return 3; }
@ConfigItem( keyName = "tickDelayEnabled", name = "Enable Tick Delay", description = "enables some tick delays", position = 6, section = tickDelayConfig) default boolean tickDelayBanking() { return false; }
@Override public Dimension render(Graphics2D graphics) { panelComponent .getChildren() .add(TitleComponent.builder().text("Piggy Item Combiner").color(Color.WHITE).build()); panelComponent .getChildren() .add( TitleComponent.builder() .text(plugin.isStarted() ? "Running" : "Paused") .color(plugin.isStarted() ? Color.GREEN : Color.RED) .build()); return super.render(graphics); }
@Override protected void startUp() throws Exception { isMaking = false; keyManager.registerKeyListener(toggle); overlayManager.add(overlay); breakHandler.registerPlugin(this); }
@Override protected void shutDown() throws Exception { isMaking = false; keyManager.unregisterKeyListener(toggle); overlayManager.remove(overlay); breakHandler.unregisterPlugin(this); }
@Subscribe private void onGameTick(GameTick event) { if (client.getGameState() != GameState.LOGGED_IN || !started || EthanApiPlugin.isMoving() || client.getLocalPlayer().getAnimation() != -1 || breakHandler.isBreakActive(this)) { afkTicks = 0; return; } if (tickDelay > 0) { tickDelay--; return; } if (!hasItems(Bank.isOpen())) { isMaking = false; } if (isMaking) { return; } if (breakHandler.shouldBreak(this)) { breakHandler.startBreak(this); return; } Widget potionWidget = client.getWidget(17694734); if (potionWidget != null && !potionWidget.isHidden()) { MousePackets.queueClickPacket(); WidgetPackets.queueResumePause(17694734, config.itemTwoAmt()); isMaking = true; return; } if (hasItems(Bank.isOpen())) { useItems(); } else { doBanking(); } tickDelay = tickDelayBanking(); }
private void findBank() { Optional<TileObject> chest1 = TileObjects.search().withName("Bank chest").nearestToPlayer(); Optional<TileObject> chest2 = TileObjects.search().withName("Bank Chest").nearestToPlayer(); Optional<TileObject> chest3 = TileObjects.search().withName("Bank Chest-wreck").nearestToPlayer(); Optional<NPC> banker = NPCs.search().withAction("Bank").nearestToPlayer(); Optional<TileObject> booth = TileObjects.search().withAction("Bank").nearestToPlayer(); if (chest1.isPresent()) { TileObjectInteraction.interact(chest1.get(), "Use"); return; } if (chest2.isPresent()) { TileObjectInteraction.interact(chest2.get(), "Use"); return; } if (chest3.isPresent()) { TileObjectInteraction.interact(chest3.get(), "Use"); return; } if (booth.isPresent()) { TileObjectInteraction.interact(booth.get(), "Bank"); return; } if (banker.isPresent()) { NPCInteraction.interact(banker.get(), "Bank"); return; } client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "couldn't find bank or banker", null); EthanApiPlugin.stopPlugin(this); }
private boolean hasItems(boolean bank) { return bank ? !BankInventory.search().withName(config.itemOneName()).empty() && !BankInventory.search().withName(config.itemTwoName()).empty() : Inventory.search().withName(config.itemOneName()).first().isPresent() && Inventory.search().withName(config.itemTwoName()).first().isPresent(); }
private void doBanking() { if (!Bank.isOpen()) { findBank(); return; } Widget depositInventory = client.getWidget(WidgetInfo.BANK_DEPOSIT_INVENTORY); if (depositInventory != null) { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(depositInventory, "Deposit inventory"); } Bank.search() .withName(config.itemOneName()) .first() .ifPresentOrElse( item -> { BankInteraction.withdrawX(item, config.itemOneAmt()); }, () -> { EthanApiPlugin.stopPlugin(this); }); Bank.search() .withName(config.itemTwoName()) .first() .ifPresentOrElse( item -> { BankInteraction.withdrawX(item, config.itemTwoAmt()); }, () -> { EthanApiPlugin.stopPlugin(this); }); }
private void useItems() { Widget itemOne = Inventory.search() .filter(item -> item.getName().contains(config.itemOneName())) .first() .get(); Widget itemTwo = Inventory.search() .filter(item -> item.getName().contains(config.itemTwoName())) .first() .get(); MousePackets.queueClickPacket(); MousePackets.queueClickPacket(); WidgetPackets.queueWidgetOnWidget(itemOne, itemTwo); }
private int tickDelayBanking() { return config.tickDelayBanking() ? ThreadLocalRandom.current() .nextInt(config.tickDelayBankingMin(), config.tickDelayBankingMax()) : 0; }
@Override protected void startUp() { forceTab = false; }
public boolean inFight() { return Arrays.stream(client.getMapRegions()).anyMatch(x -> x == 15258); }
@Subscribe public void onNpcSpawned(NpcSpawned e) { if (!inFight()) {} }
public boolean handleSecondary() { Optional<Widget> secondary = Bank.search().withId(config.secondary().getId()).first(); if (secondary.isEmpty()) { client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "no secondary second try", null); return false; } if (config.secondary() == Secondary.GIANT_SEAWEED) { MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(secondary.get(), "Withdraw-1"); MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(secondary.get(), "Withdraw-1"); MousePackets.queueClickPacket(); WidgetPackets.queueWidgetAction(secondary.get(), "Withdraw-1"); return true; } BankInteraction.withdrawX(secondary.get(), config.secondary().getSandAmount()); return true; }
@ConfigItem( keyName = "Secondary", name = "Secondary", description = "Which secondary you will use") default Secondary secondary() { return Secondary.GIANT_SEAWEED; }
@ConfigItem(keyName = "info", name = "Information", description = "", position = 0) default String info() { return "Dialogue continuer works with quest helper.\n\n" + "Dismiss random will check for random npcs that are targeting you and reachable" + " every 2 ticks and dismiss them.\n\n" + "Only unnoted empty vials and jugs are dropped"; }
@ConfigItem( name = "Continue Dialogue", description = "", position = 20, keyName = "continueDialogue") default boolean continueDialogue() { return true; }
@ConfigItem(name = "Dismiss Randoms", description = "", position = 30, keyName = "dismissRandoms") default boolean dismissRandoms() { return true; }
@ConfigItem( name = "Drop Empty Vials", description = "", position = 40, keyName = "dropEmptyVials") default boolean dropEmptyVials() { return true; }
@ConfigItem( name = "Drop Empty Wine Jugs", description = "", position = 50, keyName = "dropEmptyWineJugs") default boolean dropEmptyWineJugs() { return true; }
private void registerListeners() { PluginManager pluginManager = Bukkit.getPluginManager(); pluginManager.registerEvents(new JoinListener(), this); pluginManager.registerEvents(new QuitListener(), this); pluginManager.registerEvents(new ChatEditor(), this); pluginManager.registerEvents(new InputListener(), this); pluginManager.registerEvents(new ClickableMessages(), this); pluginManager.registerEvents(new BackCommandListener(), this); }
public void loadWorlds() { Path worldsFile = Paths.get("worlds.txt"); if (Files.exists(worldsFile)) { try { List<String> worldNames = Files.readAllLines(worldsFile); List<String> validWorldNames = worldNames.stream().filter(this::worldExists).collect(Collectors.toList()); for (String worldName : validWorldNames) { Bukkit.createWorld(new WorldCreator(worldName)); } Files.write(worldsFile, validWorldNames); } catch (IOException e) { e.printStackTrace(); } } }
private boolean worldExists(String worldName) { File worldFolder = new File(Bukkit.getWorldContainer(), worldName); return worldFolder.exists(); }
public static CompletableFuture<String> listen(UUID uuid) { CompletableFuture<String> future = new CompletableFuture<>(); listenerMap.put(uuid, future); return future; }
@EventHandler public void onChat(AsyncPlayerChatEvent event) { Player player = event.getPlayer(); UUID uuid = player.getUniqueId(); if (listenerMap.containsKey(uuid)) { event.setCancelled(true); CompletableFuture<String> future = listenerMap.remove(uuid); future.complete(event.getMessage()); } }
@EventHandler public void onDeath(PlayerDeathEvent event) { Player player = event.getEntity(); SettingsAPI.setLastPosition(player, player.getLocation()); }
public static String get(String path, Boolean usePrefix) { String language = LanguageLoader.getLanguage(); Map<?, ?> langMap = loadLanguageFile(language); String text = (String) langMap.get(path); if (text == null) { return "Missing translation: " + path; } if (prefix == null || !usePrefix) { return text; } else { return prefix + " " + text; } }
public static String get(String path, HashMap<String, String> replacements, Boolean usePrefix) { String text = get(path, usePrefix); return applyReplacements(text, replacements); }
public static String get(String path) { return get(path, true); }
public static String get(String path, HashMap<String, String> replacements) { return get(path, replacements, true); }
private static Map<?, ?> loadLanguageFile(String language) { Gson gson = new Gson(); File file = new File(Main.getInstance().getDataFolder() + "/lang/" + language + ".json"); try (Reader reader = Files.newBufferedReader(file.toPath())) { return gson.fromJson(reader, Map.class); } catch (IOException e) { throw new RuntimeException("Failed to load language file: " + language, e); } }
private static String applyReplacements(String text, HashMap<String, String> replacements) { for (Map.Entry<String, String> entry : replacements.entrySet()) { text = text.replace(entry.getKey(), entry.getValue()); } return text; }
public static void checkAndApplyMigrations() { ensureDatabaseFileExists(); createMigrationsTable(); applyMigrations(); }
private static void ensureDatabaseFileExists() { File dbFile = new File("plugins/Nextron/data.db"); if (!dbFile.exists()) { try { dbFile.getParentFile().mkdirs(); dbFile.createNewFile(); } catch (IOException e) { throw new RuntimeException("Failed to create database file", e); } } }
private static void createMigrationsTable() { String sql = "CREATE TABLE IF NOT EXISTS migrations (id INTEGER PRIMARY KEY, version INTEGER NOT NULL)"; try (Connection conn = Config.getConnection(); Statement stmt = conn.createStatement()) { stmt.execute(sql); } catch (SQLException e) { Bukkit.getLogger().log(Level.SEVERE, "Failed to create migrations table", e); } }
private static void updateMigrationVersion(int version) { String sql = "INSERT INTO migrations (version) VALUES (?)"; try (Connection conn = Config.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) { pstmt.setInt(1, version); pstmt.executeUpdate(); } catch (SQLException e) { Bukkit.getLogger().log(Level.SEVERE, "Failed to update migration version", e); } }
@Override public int compareTo(MigrationFile other) { return Integer.compare(this.version, other.version); }
public static Connection getConnection() throws SQLException { if (connection == null || connection.isClosed()) { connection = DriverManager.getConnection(DB_URL); try (Statement stmt = connection.createStatement()) { stmt.execute("PRAGMA foreign_keys = ON;"); stmt.execute("PRAGMA journal_mode = DELETE;"); stmt.execute("PRAGMA synchronous = FULL;"); } connection.setAutoCommit(true); } return connection; }
public static void closeConnection() { try { if (connection != null && !connection.isClosed()) { connection.close(); } } catch (SQLException e) { Logger.getLogger(Config.class.getName()) .log(Level.SEVERE, "Failed to close database connection", e); } connection = null; }
public static void executeUpdate(String sql) throws SQLException { try (Connection conn = getConnection(); Statement stmt = conn.createStatement()) { stmt.executeUpdate(sql); } finally { closeConnection(); } }
public static void executeQuery(String sql, ResultSetHandler handler) throws SQLException { try (Connection conn = getConnection(); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(sql)) { handler.handle(rs); } finally { closeConnection(); } }
public void addCustomChart(CustomChart chart) { metricsBase.addCustomChart(chart); }
private void appendPlatformData(JsonObjectBuilder builder) { builder.appendField("playerAmount", getPlayerAmount()); builder.appendField("onlineMode", Bukkit.getOnlineMode() ? 1 : 0); builder.appendField("bukkitVersion", Bukkit.getVersion()); builder.appendField("bukkitName", Bukkit.getName()); builder.appendField("javaVersion", System.getProperty("java.version")); builder.appendField("osName", System.getProperty("os.name")); builder.appendField("osArch", System.getProperty("os.arch")); builder.appendField("osVersion", System.getProperty("os.version")); builder.appendField("coreCount", Runtime.getRuntime().availableProcessors()); }
private void appendServiceData(JsonObjectBuilder builder) { builder.appendField("pluginVersion", plugin.getDescription().getVersion()); }
public void addCustomChart(CustomChart chart) { this.customCharts.add(chart); }
private void startSubmitting() { final Runnable submitTask = () -> { if (!enabled || !checkServiceEnabledSupplier.get()) { scheduler.shutdown(); return; } if (submitTaskConsumer != null) { submitTaskConsumer.accept(this::submitData); } else { this.submitData(); } }; long initialDelay = (long) (1000 * 60 * (3 + Math.random() * 3)); long secondDelay = (long) (1000 * 60 * (Math.random() * 30)); scheduler.schedule(submitTask, initialDelay, TimeUnit.MILLISECONDS); scheduler.scheduleAtFixedRate( submitTask, initialDelay + secondDelay, 1000 * 60 * 30, TimeUnit.MILLISECONDS); }
private void submitData() { final JsonObjectBuilder baseJsonBuilder = new JsonObjectBuilder(); appendPlatformDataConsumer.accept(baseJsonBuilder); final JsonObjectBuilder serviceJsonBuilder = new JsonObjectBuilder(); appendServiceDataConsumer.accept(serviceJsonBuilder); JsonObjectBuilder.JsonObject[] chartData = customCharts.stream() .map(customChart -> customChart.getRequestJsonObject(errorLogger, logErrors)) .filter(Objects::nonNull) .toArray(JsonObjectBuilder.JsonObject[]::new); serviceJsonBuilder.appendField("id", serviceId); serviceJsonBuilder.appendField("customCharts", chartData); baseJsonBuilder.appendField("service", serviceJsonBuilder.build()); baseJsonBuilder.appendField("serverUUID", serverUuid); baseJsonBuilder.appendField("metricsVersion", METRICS_VERSION); JsonObjectBuilder.JsonObject data = baseJsonBuilder.build(); scheduler.execute( () -> { try { sendData(data); } catch (Exception e) { if (logErrors) { errorLogger.accept("Could not submit bStats metrics data", e); } } }); }
private static byte[] compress(final String str) throws IOException { if (str == null) { return null; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); try (GZIPOutputStream gzip = new GZIPOutputStream(outputStream)) { gzip.write(str.getBytes(StandardCharsets.UTF_8)); } return outputStream.toByteArray(); }
@Override protected JsonObjectBuilder.JsonObject getChartData() throws Exception { String value = callable.call(); if (value.isEmpty()) { return null; } return new JsonObjectBuilder().appendField("value", value).build(); }
@Override protected JsonObjectBuilder.JsonObject getChartData() throws Exception { JsonObjectBuilder valuesBuilder = new JsonObjectBuilder(); Map<String, Integer> map = callable.call(); if (map == null || map.isEmpty()) { return null; } for (Map.Entry<String, Integer> entry : map.entrySet()) { valuesBuilder.appendField(entry.getKey(), new int[] {entry.getValue()}); } return new JsonObjectBuilder().appendField("values", valuesBuilder.build()).build(); }
public JsonObjectBuilder.JsonObject getRequestJsonObject( BiConsumer<String, Throwable> errorLogger, boolean logErrors) { JsonObjectBuilder builder = new JsonObjectBuilder(); builder.appendField("chartId", chartId); try { JsonObjectBuilder.JsonObject data = getChartData(); if (data == null) { return null; } builder.appendField("data", data); } catch (Throwable t) { if (logErrors) { errorLogger.accept("Failed to get data for custom chart with id " + chartId, t); } return null; } return builder.build(); }
@Override protected JsonObjectBuilder.JsonObject getChartData() throws Exception { int value = callable.call(); if (value == 0) { return null; } return new JsonObjectBuilder().appendField("value", value).build(); }
public JsonObjectBuilder appendNull(String key) { appendFieldUnescaped(key, "null"); return this; }
public JsonObjectBuilder appendField(String key, String value) { if (value == null) { throw new IllegalArgumentException("JSON value must not be null"); } appendFieldUnescaped(key, "\"" + escape(value) + "\""); return this; }
public JsonObjectBuilder appendField(String key, int value) { appendFieldUnescaped(key, String.valueOf(value)); return this; }
public JsonObjectBuilder appendField(String key, JsonObject object) { if (object == null) { throw new IllegalArgumentException("JSON object must not be null"); } appendFieldUnescaped(key, object.toString()); return this; }
public JsonObjectBuilder appendField(String key, String[] values) { if (values == null) { throw new IllegalArgumentException("JSON values must not be null"); } String escapedValues = Arrays.stream(values) .map(value -> "\"" + escape(value) + "\"") .collect(Collectors.joining(",")); appendFieldUnescaped(key, "[" + escapedValues + "]"); return this; }
public JsonObjectBuilder appendField(String key, int[] values) { if (values == null) { throw new IllegalArgumentException("JSON values must not be null"); } String escapedValues = Arrays.stream(values).mapToObj(String::valueOf).collect(Collectors.joining(",")); appendFieldUnescaped(key, "[" + escapedValues + "]"); return this; }
public JsonObjectBuilder appendField(String key, JsonObject[] values) { if (values == null) { throw new IllegalArgumentException("JSON values must not be null"); } String escapedValues = Arrays.stream(values).map(JsonObject::toString).collect(Collectors.joining(",")); appendFieldUnescaped(key, "[" + escapedValues + "]"); return this; }
private void appendFieldUnescaped(String key, String escapedValue) { if (builder == null) { throw new IllegalStateException("JSON has already been built"); } if (key == null) { throw new IllegalArgumentException("JSON key must not be null"); } if (hasAtLeastOneField) { builder.append(","); } builder.append("\"").append(escape(key)).append("\":").append(escapedValue); hasAtLeastOneField = true; }
public JsonObject build() { if (builder == null) { throw new IllegalStateException("JSON has already been built"); } JsonObject object = new JsonObject(builder.append("}").toString()); builder = null; return object; }
private static String escape(String value) { final StringBuilder builder = new StringBuilder(); for (int i = 0; i < value.length(); i++) { char c = value.charAt(i); if (c == '"') { builder.append("\\\""); } else if (c == '\\') { builder.append("\\\\"); } else if (c <= '\u000F') { builder.append("\\u000").append(Integer.toHexString(c)); } else if (c <= '\u001F') { builder.append("\\u00").append(Integer.toHexString(c)); } else { builder.append(c); } } return builder.toString(); }
@Override public String toString() { return value; }
public static int countWords(String s) { int wordCount = 0; boolean word = false; int endOfLine = s.length() - 1; for (int i = 0; i < s.length(); i++) { if (Character.isLetter(s.charAt(i)) && i != endOfLine) { word = true; } else if (!Character.isLetter(s.charAt(i)) && word) { wordCount++; word = false; } else if (Character.isLetter(s.charAt(i)) && i == endOfLine) { wordCount++; } } return wordCount; }
public static boolean isVersionNewer(String remoteVersion, String currentVersion) { int remote = Integer.parseInt(remoteVersion.replaceAll("\\D+", "")); int current = Integer.parseInt(currentVersion.replaceAll("\\D+", "")); if (String.valueOf(current).length() == 4 && String.valueOf(remote).length() == 4) return remote > current; else if (String.valueOf(remote).length() == 4) return !(Integer.parseInt( String.valueOf(remote).substring(0, String.valueOf(remote).length() - 1)) <= current); else if (String.valueOf(current).length() == 4) return remote >= Integer.parseInt( String.valueOf(current).substring(0, String.valueOf(current).length() - 1)); return remote > current; }
public ItemBuilder addEnchantment(Enchantment enchantment, int level) { itemMeta.addEnchant(enchantment, level, true); return this; }
public ItemStack build() { item.setItemMeta(itemMeta); return item; }
public static ItemStack createSkull(String url) { ItemStack head = new ItemStack(Material.PLAYER_HEAD); if (url.isEmpty()) return head; SkullMeta headMeta = (SkullMeta) head.getItemMeta(); GameProfile profile = new GameProfile(UUID.randomUUID(), null); profile.getProperties().put("textures", new Property("textures", url)); try { Field profileField = headMeta.getClass().getDeclaredField("profile"); profileField.setAccessible(true); profileField.set(headMeta, profile); } catch (IllegalArgumentException | NoSuchFieldException | SecurityException | IllegalAccessException error) { error.printStackTrace(); } head.setItemMeta(headMeta); return head; }
public void saveConfig() { try { save(this.path); } catch (IOException ex) { ex.printStackTrace(); } }
@Override public boolean persist() { return true; }
@Override public String onPlaceholderRequest(Player player, @NotNull String params) { if (player == null) return ""; if (params.equalsIgnoreCase("rank")) return RankAPI.getRank(player); if (params.equalsIgnoreCase("homes_count")) return String.valueOf(HomeAPI.getHomes(player).size()); if (params.equalsIgnoreCase("warps_count")) return String.valueOf(WarpAPI.getWarps().size()); return null; }
public static void rename(Player player, String oldRank, String newRank) { String sql = "UPDATE ranks SET name = ? WHERE name = ?"; try { PreparedStatement ps = Config.getConnection().prepareStatement(sql); ps.setString(1, newRank.substring(1).toLowerCase()); ps.setString(2, oldRank.toLowerCase()); int affectedRows = ps.executeUpdate(); if (affectedRows == 0) { player.sendMessage(Main.getPrefix() + TextAPI.get("rank.dontexists")); return; } player.sendMessage( Main.getPrefix() + TextAPI.get("rank.rename.success") .replace("%r", oldRank.toLowerCase()) .replace("%n", newRank.toLowerCase().substring(1))); Main.getInstance().getTablistManager().setAllPlayerTeams(); } catch (SQLException e) { LOGGER.log(Level.SEVERE, "Error renaming rank: " + oldRank + " to " + newRank, e); } }
public static boolean allowsFeedback(Player player) { String sql = "SELECT feedback FROM user_settings WHERE uuid = '" + player.getUniqueId() + "'"; try { final boolean[] feedback = {true}; Config.executeQuery( sql, rs -> { if (rs.next()) { feedback[0] = rs.getBoolean("feedback"); } }); return feedback[0]; } catch (SQLException e) { LOGGER.log(Level.SEVERE, "Error checking feedback: " + player.getName(), e); } return true; }
public static boolean allowsTPAs(Player player) { String sql = "SELECT allowtpas FROM user_settings WHERE uuid = '" + player.getUniqueId() + "'"; try { final boolean[] allowTPAs = {false}; Config.executeQuery( sql, rs -> { if (rs.next()) { allowTPAs[0] = !rs.getBoolean("allowtpas"); } }); return allowTPAs[0]; } catch (SQLException e) { LOGGER.log(Level.SEVERE, "Error checking allowTPAs: " + player.getName(), e); } return false; }
public static boolean allowsVanishMessage(Player player) { String sql = "SELECT vanish_message FROM user_settings WHERE uuid = '" + player.getUniqueId() + "'"; try { final boolean[] vanishMessage = {true}; Config.executeQuery( sql, rs -> { if (rs.next()) { vanishMessage[0] = rs.getBoolean("vanish_message"); } }); return vanishMessage[0]; } catch (SQLException e) { LOGGER.log(Level.SEVERE, "Error checking vanish message: " + player.getName(), e); } return true; }
public static boolean isVanish(Player player) { return SettingsAPI.getVanished(player); }
private static void startVanishActionBar(Player player) { UUID playerUUID = player.getUniqueId(); stopVanishActionBar(player); BukkitTask task = Bukkit.getScheduler() .runTaskTimer( Main.getInstance(), () -> { Player onlinePlayer = Bukkit.getPlayer(playerUUID); if (onlinePlayer != null && onlinePlayer.isOnline() && isVanish(onlinePlayer)) { onlinePlayer .spigot() .sendMessage(ChatMessageType.ACTION_BAR, new TextComponent(VANISH_MESSAGE)); } else { stopVanishActionBar(onlinePlayer); } }, 0L, 20L); vanishTasks.put(playerUUID, task); }
private static void stopVanishActionBar(Player player) { if (player != null) { player.spigot().sendMessage(ChatMessageType.ACTION_BAR, new TextComponent("")); BukkitTask task = vanishTasks.remove(player.getUniqueId()); if (task != null) { task.cancel(); } } }
@Execute public void helpCommand(@Context CommandSender sender, @Arg Optional<Help> commandName) { if (commandName.isEmpty()) { displayAllCommands(sender); } else { displayCommandDetails(sender, commandName.get()); } }
@Execute(name = "nick") @Permission("nextron.nick") public void nickCommand(@Context Player player, @Arg String nick) { player.setDisplayName(nick); SettingsAPI.setNick(player, nick); }
@Execute(name = "resetnick") @Permission("nextron.resetnick") public void resetnickCommand(@Context Player player) { player.setDisplayName(player.getName()); SettingsAPI.setNick(player, player.getName()); }
@Execute public void pingCommand(@Context CommandSender sender, @Arg Optional<Player> target) { if (target.isPresent()) { sender.sendMessage( Main.getPrefix() + TextAPI.get("ping.other") .replace("%t", target.get().getName()) .replace("%p", String.valueOf(target.get().getPing()))); return; } if (!(sender instanceof Player player)) { sender.sendMessage(Main.getCommandInstance()); return; } player.sendMessage( Main.getPrefix() + TextAPI.get("ping").replace("%p", String.valueOf(player.getPing()))); }
@Execute public void invseeCommand(@Context Player player, @Arg Player target) { if (target != player) { player.openInventory(target.getInventory()); } else { player.sendMessage(Main.getPrefix() + TextAPI.get("invsee.error")); } }
@Execute( name = "warp", aliases = {"w"}) @Permission("nextron.warp") public void warpCommand(@Context Player player, @Arg Warp warp) { Location location = WarpAPI.getWarp(warp.getName().toLowerCase()); if (location == null) { player.sendMessage( Main.getPrefix() + TextAPI.get("warp.error").replace("%w", warp.getName().toLowerCase())); return; } player.teleport(location); if (SettingsAPI.allowsFeedback(player)) player.sendMessage( Main.getPrefix() + TextAPI.get("warp.success").replace("%w", warp.getName().toLowerCase())); player.playSound(player.getLocation(), Sound.ENTITY_ENDERMAN_TELEPORT, 1.0f, 1.0f); }
@Execute void enderchestCommand(@Context Player player, @Arg Optional<Player> target) { if (target.isEmpty()) { player.openInventory(player.getEnderChest()); } else { if (!player.hasPermission("nextron.enderchest.other")) { player.sendMessage(Main.getNoPerm()); return; } player.openInventory(target.get().getEnderChest()); } }
@Execute public void sudoCommand(@Context CommandSender sender, @Arg Player target, @Join String command) { target.chat("/" + command); sender.sendMessage( Main.getPrefix() + TextAPI.get("sudo.success").replace("%t", target.getName()).replace("%b", command)); }
@Execute void backCommand(@Context CommandSender sender, @Arg Optional<Player> target) { Player player = (Player) sender; if (target.isEmpty()) { teleportBack(player); } else { teleportBack(target.get()); player.sendMessage( Main.getPrefix() + TextAPI.get("back.other.success").replace("%p", target.get().getName())); } }
private void teleportBack(Player player) { Location lastPosition = SettingsAPI.getLastPosition(player); if (lastPosition != null) { SettingsAPI.setBack(player, true); player.teleport(lastPosition); } else { player.sendMessage(Main.getPrefix() + TextAPI.get("back.no_position")); } }
@Execute public void menuCommand(@Context Player player) { GUIs.mainGui(player); player.playSound(player.getLocation(), Sound.BLOCK_BARREL_OPEN, 100, 1); }
@Execute( name = "gmc", aliases = {"creative", "gm1"}) @Permission("nextron.gamemode.creative") public void creative(@Context CommandSender sender, @Arg Optional<Player> target) { if (target.isEmpty()) { if (!(sender instanceof Player player)) { sender.sendMessage(Main.getCommandInstance()); return; } player.setGameMode(GameMode.CREATIVE); player.sendMessage( Main.getPrefix() + TextAPI.get("gamemode.success").replace("%g", "creative")); } else { Player pTarget = target.get(); pTarget.setGameMode(GameMode.CREATIVE); sender.sendMessage( Main.getPrefix() + TextAPI.get("gamemode.other.success") .replace("%t", pTarget.getName()) .replace("%g", "creative")); } }
@Execute( name = "gms", aliases = {"survival", "gm0"}) @Permission("nextron.gamemode.survival") public void survival(@Context CommandSender sender, @Arg Optional<Player> target) { if (target.isEmpty()) { if (!(sender instanceof Player player)) { sender.sendMessage(Main.getCommandInstance()); return; } player.setGameMode(GameMode.SURVIVAL); player.sendMessage( Main.getPrefix() + TextAPI.get("gamemode.success").replace("%g", "survival")); } else { Player pTarget = target.get(); pTarget.setGameMode(GameMode.SURVIVAL); sender.sendMessage( Main.getPrefix() + TextAPI.get("gamemode.other.success") .replace("%t", pTarget.getName()) .replace("%g", "survival")); } }
@Execute( name = "gmsp", aliases = {"spectator", "gm3"}) @Permission("nextron.gamemode.spectator") public void spectator(@Context CommandSender sender, @Arg Optional<Player> target) { if (target.isEmpty()) { if (!(sender instanceof Player player)) { sender.sendMessage(Main.getCommandInstance()); return; } player.setGameMode(GameMode.SPECTATOR); player.sendMessage( Main.getPrefix() + TextAPI.get("gamemode.success").replace("%g", "spectator")); } else { Player pTarget = target.get(); pTarget.setGameMode(GameMode.SPECTATOR); sender.sendMessage( Main.getPrefix() + TextAPI.get("gamemode.other.success") .replace("%t", pTarget.getName()) .replace("%g", "spectator")); } }
@Execute( name = "gma", aliases = {"adventure", "gm2"}) @Permission("nextron.gamemode.adventure") public void adventure(@Context CommandSender sender, @Arg Optional<Player> target) { if (target.isEmpty()) { if (!(sender instanceof Player player)) { sender.sendMessage(Main.getCommandInstance()); return; } player.setGameMode(GameMode.ADVENTURE); player.sendMessage( Main.getPrefix() + TextAPI.get("gamemode.success").replace("%g", "adventure")); } else { Player pTarget = target.get(); pTarget.setGameMode(GameMode.ADVENTURE); sender.sendMessage( Main.getPrefix() + TextAPI.get("gamemode.other.success") .replace("%t", pTarget.getName()) .replace("%g", "adventure")); } }
@Execute( name = "gamemode", aliases = {"gm"}) @Permission("nextron.gamemode") public void gamemode( @Context CommandSender sender, @Arg GameMode gamemode, @Arg Optional<Player> target) { if (target.isEmpty()) { if (!(sender instanceof Player player)) { sender.sendMessage(Main.getCommandInstance()); return; } player.setGameMode(gamemode); player.sendMessage( Main.getPrefix() + TextAPI.get("gamemode.success").replace("%g", gamemode.toString().toLowerCase())); } else { if (!sender.hasPermission("nextron.gamemode.other")) { sender.sendMessage(Main.getNoPerm()); return; } Player pTarget = target.get(); pTarget.setGameMode(gamemode); sender.sendMessage( Main.getPrefix() + TextAPI.get("gamemode.other.success") .replace("%t", pTarget.getName()) .replace("%g", gamemode.toString().toLowerCase())); } }
@Execute() void featuresCommand(@Context Player player) { if (!player.isOp()) { player.sendMessage(Main.getNoPerm()); return; } GUIs.featureGui(player); player.playSound(player.getLocation(), Sound.BLOCK_BARREL_OPEN, 100, 1); }
@Execute(name = "world create") @Permission("nextron.world.create") public void createWorldCommand( @Context CommandSender sender, @Arg String name, @Arg Optional<Seed> seed) { sender.sendMessage(Main.getPrefix() + TextAPI.get("world.create.start").replace("%w", name)); Bukkit.getScheduler() .runTask( Main.getInstance(), () -> { WorldCreator wc = new WorldCreator(name); wc.environment(World.Environment.NORMAL); wc.type(WorldType.NORMAL); seed.ifPresent(value -> wc.seed(value.getSeed())); wc.createWorld(); sender.sendMessage( Main.getPrefix() + TextAPI.get("world.create.finished").replace("%w", name)); }); try (FileWriter writer = new FileWriter("worlds.txt", true)) { writer.write(name + "\n"); } catch (IOException e) { throw new RuntimeException(e); } }
@Execute(name = "world load") @Permission("nextron.world.load") public void loadCommand(@Context CommandSender sender, @Arg String worldName) { File worldFolder = new File(Bukkit.getServer().getWorldContainer().getAbsolutePath(), worldName); if (!worldFolder.exists()) { sender.sendMessage( Main.getPrefix() + TextAPI.get("world.load.notexist").replace("%w", worldName)); return; } World world = Bukkit.getWorld(worldName); if (world == null) { sender.sendMessage( Main.getPrefix() + TextAPI.get("world.load.start").replace("%w", worldName)); WorldCreator wc = new WorldCreator(worldName); wc.createWorld(); sender.sendMessage( Main.getPrefix() + TextAPI.get("world.load.success").replace("%w", worldName)); } else { sender.sendMessage( Main.getPrefix() + TextAPI.get("world.load.error").replace("%w", worldName)); } try (FileWriter writer = new FileWriter("worlds.txt", true)) { writer.write(worldName + "\n"); } catch (IOException e) { throw new RuntimeException(e); } }
public boolean deleteWorld(String worldName) { World world = Bukkit.getWorld(worldName); if (world == null) { return false; } if (!Bukkit.unloadWorld(world, true)) { return false; } Path worldFolder = Paths.get(Bukkit.getWorldContainer().getAbsolutePath(), worldName); try { Files.walk(worldFolder) .map(Path::toFile) .sorted((o1, o2) -> -o1.compareTo(o2)) .forEach(File::delete); } catch (IOException e) { e.printStackTrace(); return false; } return true; }
@Execute( name = "home", aliases = {"h"}) @Permission("nextron.home") public void home(@Context Player player, @Arg Optional<Home> home) { if (home.isEmpty()) { Location defaultHome = HomeAPI.getHome(player, "default"); if (defaultHome != null) { player.teleport(defaultHome); player.playSound(player.getLocation(), Sound.ENTITY_ENDERMAN_TELEPORT, 100, 1); player.sendMessage(Main.getPrefix() + TextAPI.get("home.default.success")); } else { player.sendMessage(Main.getPrefix() + TextAPI.get("home.default.error")); } return; } Location homeLocation = HomeAPI.getHome(player, home.get().getName().toLowerCase()); if (homeLocation != null) { player.teleport(homeLocation); player.playSound(player.getLocation(), Sound.ENTITY_ENDERMAN_TELEPORT, 100, 1); player.sendMessage( Main.getPrefix() + TextAPI.get("home.success").replace("%h", home.get().getName().toLowerCase())); } else { player.sendMessage( Main.getPrefix() + TextAPI.get("home.notfound").replace("%h", home.get().getName().toLowerCase())); } }
@Execute public void godCommand(@Context CommandSender sender, @Arg Optional<Player> target) { if (target.isEmpty()) { if (!(sender instanceof Player player)) { sender.sendMessage(Main.getCommandInstance()); return; } player.setInvulnerable(!player.isInvulnerable()); if (player.isInvulnerable()) player.sendMessage(Main.getPrefix() + TextAPI.get("god.on")); else player.sendMessage(Main.getPrefix() + TextAPI.get("god.off")); } else { if (!sender.hasPermission("nextron.god.other")) { sender.sendMessage(Main.getNoPerm()); return; } Player targetPlayer = target.get(); targetPlayer.setInvulnerable(!targetPlayer.isInvulnerable()); if (targetPlayer.isInvulnerable()) sender.sendMessage( Main.getPrefix() + TextAPI.get("god.on.other").replace("%p", targetPlayer.getName())); else sender.sendMessage( Main.getPrefix() + TextAPI.get("god.off.other").replace("%p", targetPlayer.getName())); } }
@Execute public void renameCommand(@Context Player player, @Join String name) { ItemMeta itemMeta = player.getInventory().getItemInMainHand().getItemMeta(); if (itemMeta == null) { player.sendMessage(Main.getPrefix() + TextAPI.get("rename.error")); return; } itemMeta.setDisplayName(ChatColor.translateAlternateColorCodes('&', String.valueOf(name))); player.getInventory().getItemInMainHand().setItemMeta(itemMeta); }
@Execute public void tpdenyCommand(@Context Player player) { Player target = Main.tpa.get(player); if (target != null) { Main.tpa.remove(player); Main.tpa.remove(target); player.sendMessage( Main.getPrefix() + TextAPI.get("tpdeny.player").replace("%p", target.getName())); target.sendMessage( Main.getPrefix() + TextAPI.get("tpdeny.target").replace("%p", player.getName())); target.playSound(target.getLocation(), Sound.ENTITY_PILLAGER_AMBIENT, 100, 0.5f); } else { player.sendMessage(Main.getPrefix() + TextAPI.get("tpaccept.error")); } }
@Execute public void tpacceptCommand(@Context Player player) { Player target = Main.tpa.get(player); boolean isTpaHere = false; if (target == null) { target = Main.tpahere.get(player); isTpaHere = true; } if (target != null) { target.teleport(player.getLocation()); String successMessage = Main.getPrefix() + TextAPI.get("tpaccept.player.success").replace("%p", player.getName()); if (SettingsAPI.allowsFeedback(target)) { target.sendMessage(successMessage); } if (SettingsAPI.allowsFeedback(player)) { player.sendMessage( Main.getPrefix() + TextAPI.get("tpaccept.target.success").replace("%t", target.getName())); } target.playSound(player.getLocation(), Sound.ENTITY_ENDERMAN_TELEPORT, 1.0f, 1.0f); if (isTpaHere) { Main.tpahere.remove(player); Main.tpahere.remove(target); } else { Main.tpa.remove(player); Main.tpa.remove(target); } } else { player.sendMessage(Main.getPrefix() + TextAPI.get("tpaccept.error")); } }
@Execute(name = "day") @Permission("nextron.day") public void dayCommand(@Context Player player) { Objects.requireNonNull(player.getLocation().getWorld()).setTime(1000); player.sendMessage(Main.getPrefix() + TextAPI.get("time.success").replace("%d", "day")); }
@Execute(name = "night") @Permission("nextron.night") public void nightCommand(@Context Player player) { Objects.requireNonNull(player.getLocation().getWorld()).setTime(13000); player.sendMessage(Main.getPrefix() + TextAPI.get("time.success").replace("%d", "night")); }
@Execute(name = "midnight") @Permission("nextron.midnight") public void midnightCommand(@Context Player player) { Objects.requireNonNull(player.getLocation().getWorld()).setTime(18000); player.sendMessage(Main.getPrefix() + TextAPI.get("time.success").replace("%d", "midnight")); }
@Execute(name = "noon") @Permission("nextron.noon") public void noonCommand(@Context Player player) { Objects.requireNonNull(player.getLocation().getWorld()).setTime(6000); player.sendMessage(Main.getPrefix() + TextAPI.get("time.success").replace("%d", "noon")); }
@Execute public void hatCommand(@Context Player player) { ItemStack itemStack = player.getInventory().getItemInMainHand(); player.getInventory().setHelmet(itemStack); player.sendMessage(Main.getPrefix() + TextAPI.get("hat.success")); }
@Execute(name = "rank") @Permission("nextron.rank") public void rankCommand(@Context Player player) { List<String> ranks = RankAPI.getRanks(); if (ranks.isEmpty()) { player.sendMessage(Main.getPrefix() + TextAPI.get("maingui.no.ranks")); player.playSound(player.getLocation(), Sound.ENTITY_PILLAGER_AMBIENT, 100, 0.5f); return; } RankGUIs.manager(player); }
@Execute(name = "rank remove") @Permission("nextron.rank.remove") public void removeRankCommand(@Context CommandSender sender, @Arg Player target) { RankAPI.removeRanks(target); RankAPI.checkRank(target); sender.sendMessage( Main.getPrefix() + TextAPI.get("rank.remove.success").replace("%t", target.getName())); }
@Execute(name = "rank delete") @Permission("nextron.rank.delete") public void removeRankCommand(@Context CommandSender sender, @Arg Rank rank) { RankAPI.deleteRank((Player) sender, rank.getName().toLowerCase()); }
@Execute(name = "rank create") @Permission("nextron.rank.create") public void createRankCommand(@Context Player player) { RankGUIs.templateRanks(player); }
@Execute public void headCommand(@Context Player player, @Arg Player target) { ItemStack item = new ItemStack(Material.PLAYER_HEAD, 1); SkullMeta meta = (SkullMeta) item.getItemMeta(); meta.setDisplayName(target.getName()); meta.setOwningPlayer(target); item.setItemMeta(meta); Inventory inventory = player.getInventory(); inventory.addItem(item); if (SettingsAPI.allowsFeedback(player)) player.sendMessage( Main.getPrefix() + TextAPI.get("head.success").replace("%t", target.getName())); }
@Override protected ParseResult<Language> parse( Invocation<CommandSender> invocation, Argument<Language> argument, String s) { List<String> languages = getAvailableLanguages(); if (languages.contains(s.toLowerCase())) { return ParseResult.success(new Language(s)); } return ParseResult.failure( Main.getPrefix() + TextAPI.get("language.set.error").replace("%l", String.join(", ", languages))); }
@Override public SuggestionResult suggest( Invocation<CommandSender> invocation, Argument<Language> argument, SuggestionContext context) { List<String> languages = getAvailableLanguages(); return SuggestionResult.of( languages.stream() .filter( language -> language .toLowerCase() .startsWith(context.getCurrent().toString().toLowerCase())) .collect(Collectors.toList())); }
@Override public SuggestionResult suggest( Invocation<CommandSender> invocation, Argument<Warp> argument, SuggestionContext context) { List<String> warps = WarpAPI.getWarps(); return SuggestionResult.of( warps.stream() .filter( warpName -> warpName .toLowerCase() .startsWith(context.getCurrent().toString().toLowerCase())) .collect(Collectors.toList())); }
@Override protected ParseResult<Home> parse( Invocation<CommandSender> invocation, Argument<Home> argument, String s) { if (invocation.sender() instanceof Player player) { var section = HomeAPI.getHomes(player); if (section.contains(s.toLowerCase()) && !s.equalsIgnoreCase("default")) { return ParseResult.success(new Home(s.toLowerCase())); } } return ParseResult.failure(Main.getPrefix() + TextAPI.get("home.notfound").replace("%h", s)); }
@Override public SuggestionResult suggest( Invocation<CommandSender> invocation, Argument<Home> argument, SuggestionContext context) { if (invocation.sender() instanceof Player player) { var section = HomeAPI.getHomes(player); return SuggestionResult.of( section.stream() .filter( homeName -> homeName .toLowerCase() .startsWith(context.getCurrent().toString().toLowerCase()) && !homeName.equalsIgnoreCase("default")) .collect(Collectors.toList())); } return SuggestionResult.of(new ArrayList<>()); }
@Override protected ParseResult<Feature> parse( Invocation<CommandSender> invocation, Argument<Feature> context, String supplied) { List<String> features = getAvailableRanks(); if (features.contains(supplied.toLowerCase())) { return ParseResult.success(new Feature(supplied)); } return ParseResult.failure(Main.getPrefix() + TextAPI.get("feature.validvalues")); }
@Override public SuggestionResult suggest( Invocation<CommandSender> invocation, Argument<Feature> argument, SuggestionContext context) { return SuggestionResult.of(getAvailableRanks()); }
@Override public SuggestionResult suggest( Invocation<CommandSender> invocation, Argument<GameMode> argument, SuggestionContext context) { return SuggestionResult.of(GAME_MODE_ARGUMENTS.keySet()); }
@Override protected ParseResult<Rank> parse( Invocation<CommandSender> invocation, Argument<Rank> argument, String s) { List<String> ranks = getAvailableRanks(); if (ranks.isEmpty()) { return ParseResult.failure(Main.getPrefix() + TextAPI.get("rank.dontexists")); } if (ranks.contains(s.toLowerCase())) { return ParseResult.success(new Rank(s)); } return ParseResult.failure(Main.getPrefix() + TextAPI.get("rank.dontexists")); }
@Override public SuggestionResult suggest( Invocation<CommandSender> invocation, Argument<Rank> argument, SuggestionContext context) { List<String> ranks = getAvailableRanks(); if (ranks.isEmpty()) { return SuggestionResult.of(new ArrayList<>()); } return SuggestionResult.of( ranks.stream() .filter( rank -> rank.toLowerCase().startsWith(context.getCurrent().toString().toLowerCase())) .collect(Collectors.toList())); }
@Override protected ParseResult<Seed> parse( Invocation<CommandSender> invocation, Argument<Seed> argument, String s) { long seed; try { seed = Long.parseLong(s); } catch (NumberFormatException e) { return ParseResult.failure(Main.getPrefix() + TextAPI.get("world.create.seed.error")); } return ParseResult.success(new Seed(seed)); }
@Override protected ParseResult<Help> parse( Invocation<CommandSender> invocation, Argument<Help> argument, String s) { if (HelpBase.commands.containsKey(s)) { return ParseResult.success( new Help(s, HelpBase.getName(s), HelpBase.getDescription(s), HelpBase.getUsage(s))); } return ParseResult.failure(Main.getPrefix() + TextAPI.get("help.command.error")); }
@Override public SuggestionResult suggest( Invocation<CommandSender> invocation, Argument<Help> argument, SuggestionContext context) { return SuggestionResult.of( HelpBase.commands.keySet().stream() .filter( cmd -> cmd.toLowerCase().startsWith(context.getCurrent().toString().toLowerCase())) .collect(Collectors.toList())); }
private MenuItem createMenuItem(String title) { MenuItem menuItem = new MenuItem(title); menuItem.setOnAction(this::handleEvent); return menuItem; }
private Menu createDockMenu() { Menu dockMenu = createSampleMenu(); MenuItem open = new MenuItem("New Window"); open.setGraphic(new ImageView(new Image(openIcon.toString()))); open.setOnAction(e -> createNewStage()); dockMenu.getItems().addAll(new SeparatorMenuItem(), open); return dockMenu; }
private Menu createSampleMenu() { Menu trayMenu = new Menu(); trayMenu.setGraphic(new ImageView(new Image(menuIcon.toString()))); MenuItem reload = new MenuItem("Reload"); reload.setGraphic(new ImageView(new Image(refreshIcon.toString()))); reload.setOnAction(this::handleEvent); MenuItem print = new MenuItem("Print"); print.setGraphic(new ImageView(new Image(printIcon.toString()))); print.setOnAction(this::handleEvent); Menu share = new Menu("Share"); MenuItem mail = new MenuItem("Mail"); mail.setOnAction(this::handleEvent); share.getItems().add(mail); trayMenu.getItems().addAll(reload, print, new SeparatorMenuItem(), share); return trayMenu; }
private void handleEvent(ActionEvent actionEvent) { System.out.println("clicked " + actionEvent.getSource()); }
private static void createNewStage() { Stage stage = new Stage(); stage.setScene(new Scene(new StackPane())); stage.setTitle(CHILD_WINDOW_TITLE + " " + (counter++)); stage.show(); }
public static void main(String[] args) { launch(args); }
@Override public void start(Stage primaryStage) { StackPane root = new StackPane(); primaryStage.setScene(new Scene(root, 300, 250)); primaryStage.requestFocus(); primaryStage.show(); MenuToolkit tk = MenuToolkit.toolkit(); Menu defaultApplicationMenu = tk.createDefaultApplicationMenu("test"); tk.setApplicationMenu(defaultApplicationMenu); defaultApplicationMenu.getItems().get(1).setText("Hide all the otters"); }
@Override public void start(Stage primaryStage) { primaryStage.setScene(new Scene(new StackPane())); primaryStage.show(); MenuToolkit tk = MenuToolkit.toolkit(); AboutStageBuilder aboutStageBuilder = AboutStageBuilder.start("About MyApp") .withAppName("MyApp") .withCloseOnFocusLoss() .withText("Line 1\nLine2") .withVersionString("Version 1.0b") .withCopyright("Copyright \u00A9 " + Calendar.getInstance().get(Calendar.YEAR)); try { IcnsParser parser = IcnsParser.forFile(AboutStageBuilder.DEFAULT_APP_ICON); aboutStageBuilder = aboutStageBuilder.withImage(new Image(parser.getIconStream(IcnsType.ic08))); } catch (IOException e) { } Menu applicationMenu = tk.createDefaultApplicationMenu("MyApp", aboutStageBuilder.build()); MenuBar bar = new MenuBar(); bar.getMenus().add(applicationMenu); tk.setMenuBar(bar); Menu menu = new Menu("test"); MenuItem myItem = new MenuItem("Hallo welt"); menu.getItems().add(myItem); tk.setDockIconMenu(menu); }
@Override public void start(Stage primaryStage) { primaryStage.setScene(new Scene(new StackPane())); MenuToolkit tk = MenuToolkit.toolkit(); Menu applicationMenu = tk.createDefaultApplicationMenu("MyApp"); MenuItem item1 = new MenuItem("Show window"); item1.setOnAction(e -> primaryStage.show()); MenuItem item2 = new MenuItem("Item2"); MenuItem item3 = new MenuItem("Item3"); item3.setOnAction(event -> System.out.println("Item3 clicked")); Menu submenu = new Menu("Submenu"); submenu.getItems().add(item2); Menu menu1 = new Menu("Menu1"); menu1.getItems().addAll(item1, submenu); Menu menu2 = new Menu("Menu2"); menu2.getItems().addAll(item3); MenuBar bar = new MenuBar(); bar.getMenus().addAll(applicationMenu, menu1, menu2); tk.setMenuBar(bar); }
public static void main(String[] args) { Application.launch(args); }
@Override public void start(Stage primaryStage) { MenuToolkit tk = MenuToolkit.toolkit(Locale.getDefault()); tk.setApplicationMenu(tk.createDefaultApplicationMenu("test")); MenuBar menuBar = new MenuBar(); menuBar.useSystemMenuBarProperty().set(true); Menu menu = new Menu("java"); MenuItem item = new MenuItem("Test"); Menu help = new Menu("Help"); menu.getItems().add(item); menuBar.getMenus().addAll(menu, help); primaryStage.setScene(new Scene(new Pane(menuBar))); primaryStage.setTitle("Test"); primaryStage.show(); }
@Override public void start(Stage primaryStage) { StackPane root = new StackPane(); primaryStage.setScene(new Scene(root, 300, 250)); primaryStage.requestFocus(); primaryStage.show(); MenuToolkit tk = MenuToolkit.toolkit(); MenuBar bar = new MenuBar(); MenuItem item1 = new MenuItem("Item1"); MenuItem item2 = new MenuItem("Item2"); MenuItem item3 = new MenuItem("Item3"); item3.setOnAction(event -> System.out.println("Item3 clicked")); MenuItem item4 = tk.createQuitMenuItem("my app"); Menu menu2 = new Menu("Menu2"); menu2.getItems().add(item2); Menu menu1 = new Menu("Menu1"); menu1.getItems().addAll(item1, menu2, item4); Menu menu3 = new Menu("Menu3"); menu3.getItems().addAll(item3); bar.getMenus().addAll(menu1, menu3); tk.setMenuBar(primaryStage, bar); }
@Override public void start(Stage primaryStage) { StackPane root = new StackPane(); primaryStage.setScene(new Scene(root, 300, 250)); primaryStage.requestFocus(); primaryStage.show(); MenuToolkit tk = MenuToolkit.toolkit(); MenuBar menuBar = new MenuBar(); Menu defaultApplicationMenu = tk.createDefaultApplicationMenu("test"); MenuItem addMenu = new MenuItem("Add menu"); addMenu.setOnAction( event -> menuBar.getMenus().add(new Menu("Added " + menuBar.getMenus().size()))); MenuItem addItem = new MenuItem("Add menu item"); addItem.setOnAction( actionEvent -> defaultApplicationMenu.getItems().add(4, new MenuItem("Added"))); defaultApplicationMenu.getItems().add(2, new SeparatorMenuItem()); defaultApplicationMenu.getItems().add(2, addItem); defaultApplicationMenu.getItems().add(2, addMenu); defaultApplicationMenu.getItems().add(2, new SeparatorMenuItem()); menuBar.getMenus().add(defaultApplicationMenu); tk.setMenuBar(menuBar); defaultApplicationMenu.getItems().get(1).setText("Hide all the otters"); }
@Test void testUnnamedItem() { MenuItem item = new MenuItem(); NSMenuItem nsMenuItem = MenuItemConverter.convert(item); Assertions.assertEquals("", nsMenuItem.title()); }
@Test void testItemWithTitle() { MenuItem item = new MenuItem("test"); NSMenuItem nsMenuItem = MenuItemConverter.convert(item); Assertions.assertEquals("test", nsMenuItem.title()); }
@Test void testItemWithAccelerator() { MenuItem item = new MenuItem("test"); item.setAccelerator(new KeyCodeCombination(KeyCode.Q, KeyCombination.ALT_DOWN)); NSMenuItem nsMenuItem = MenuItemConverter.convert(item); Assertions.assertEquals("q", nsMenuItem.keyEquivalent()); Assertions.assertEquals( NSEventModifierFlags.NSEventModifierFlagOption, nsMenuItem.keyEquivalentModifierMask()); }
@Test void testItemWithAction() { AtomicBoolean wasHandled = new AtomicBoolean(false); MenuItem item = new MenuItem("test"); item.setOnAction(actionEvent -> wasHandled.set(true)); NSMenuItem nsMenuItem = MenuItemConverter.convert(item); item.fire(); Assertions.assertTrue(wasHandled.get()); Assertions.assertNotNull(nsMenuItem); }
@Test void testItemUpdateTitle() { MenuItem item = new MenuItem(); NSMenuItem nsMenuItem = MenuItemConverter.convert(item); item.setText("test"); Assertions.assertEquals("test", nsMenuItem.title()); }
@Test void testItemUpdateAction() { AtomicBoolean wasHandled = new AtomicBoolean(false); MenuItem item = new MenuItem("test"); NSMenuItem nsMenuItem = MenuItemConverter.convert(item); item.setOnAction(actionEvent -> wasHandled.set(true)); item.fire(); Assertions.assertTrue(wasHandled.get()); Assertions.assertNotNull(nsMenuItem); }
@Test void testItemUpdateAccelerator() { MenuItem item = new MenuItem("test"); NSMenuItem nsMenuItem = MenuItemConverter.convert(item); item.setAccelerator(new KeyCodeCombination(KeyCode.Q, KeyCombination.ALT_DOWN)); Assertions.assertEquals("q", nsMenuItem.keyEquivalent()); Assertions.assertEquals( NSEventModifierFlags.NSEventModifierFlagOption, nsMenuItem.keyEquivalentModifierMask()); }
@Test void testEmptyMenu() { Menu menu = new Menu(); NSMenu nsMenu = MenuConverter.convert(menu); Assertions.assertEquals("", nsMenu.title()); }
@Test void testMenuWithTitle() { Menu menu = new Menu("test"); NSMenu nsMenu = MenuConverter.convert(menu); Assertions.assertEquals("test", nsMenu.title()); }
@Test void testMenuWithItems() { Menu menu = new Menu(); menu.getItems().add(new MenuItem()); NSMenu nsMenu = MenuConverter.convert(menu); Assertions.assertEquals(1, nsMenu.numberOfItems()); }
@Test void testUpdateTitle() { Menu menu = new Menu(); NSMenu nsMenu = MenuConverter.convert(menu); menu.setText("test"); Assertions.assertEquals("test", nsMenu.title()); }
@Test void testAddItem() { Menu menu = new Menu(); NSMenu nsMenu = MenuConverter.convert(menu); menu.getItems().add(new MenuItem()); Assertions.assertEquals(1, nsMenu.numberOfItems()); }
@Test void testRemoveItem() { Menu menu = new Menu(); MenuItem item = new MenuItem(); menu.getItems().add(item); NSMenu nsMenu = MenuConverter.convert(menu); menu.getItems().remove(item); Assertions.assertEquals(0, nsMenu.numberOfItems()); }
public static MenuToolkit toolkit() { return toolkit(Locale.ENGLISH); }
public static MenuToolkit toolkit(Locale locale) { return toolkit(new LabelMaker(locale)); }
public static MenuToolkit toolkit(LabelMaker labelMaker) { return new MenuToolkit(NativeAdapterProvider.getNativeAdapter(), labelMaker); }
public Menu createDefaultApplicationMenu(String appName) { return createDefaultApplicationMenu(appName, createDefaultAboutStage(appName)); }
public Menu createDefaultApplicationMenu(String appName, Stage aboutStage) { return new Menu( APP_NAME, null, createAboutMenuItem(appName, aboutStage), new SeparatorMenuItem(), createHideMenuItem(appName), createHideOthersMenuItem(), createUnhideAllMenuItem(), new SeparatorMenuItem(), createQuitMenuItem(appName)); }
public MenuItem createAboutMenuItem(String appName) { return createAboutMenuItem(appName, createDefaultAboutStage(appName)); }
@Beta public MenuItem createNativeAboutMenuItem(String appName) { return createAboutMenuItem(appName, event -> nativeAdapter.showAboutWindow(appName)); }
public MenuItem createAboutMenuItem( String appName, EventHandler<ActionEvent> actionEventEventHandler) { MenuItem about = new MenuItem(labelMaker.getLabel(LabelName.ABOUT, appName)); about.setOnAction(actionEventEventHandler); return about; }
private Stage createDefaultAboutStage(String appName) { AboutStageBuilder stageBuilder = AboutStageBuilder.start(labelMaker.getLabel(LabelName.ABOUT, appName)) .withAppName(appName) .withCloseOnFocusLoss() .withCopyright("Copyright \u00A9 " + Calendar.getInstance().get(Calendar.YEAR)); try { IcnsParser parser = IcnsParser.forFile(AboutStageBuilder.DEFAULT_APP_ICON); stageBuilder = stageBuilder.withImage(new Image(parser.getIconStream(IcnsType.ic09))); } catch (IOException e) { } return stageBuilder.build(); }
public MenuItem createAboutMenuItem(String appName, Stage aboutStage) { return createAboutMenuItem(appName, event -> aboutStage.show()); }
public MenuItem createQuitMenuItem(String appName) { MenuItem quit = new MenuItem(labelMaker.getLabel(LabelName.QUIT, appName)); quit.setOnAction(event -> nativeAdapter.quit()); quit.setAccelerator(new KeyCodeCombination(KeyCode.Q, KeyCombination.META_DOWN)); return quit; }
public MenuItem createUnhideAllMenuItem() { MenuItem unhideAll = new MenuItem(labelMaker.getLabel(LabelName.SHOW_ALL)); unhideAll.setOnAction(event -> nativeAdapter.showAllWindows()); return unhideAll; }
public MenuItem createHideOthersMenuItem() { MenuItem hideOthers = new MenuItem(labelMaker.getLabel(LabelName.HIDE_OTHERS)); hideOthers.setOnAction(event -> nativeAdapter.hideOtherApplications()); hideOthers.setAccelerator( new KeyCodeCombination(KeyCode.H, KeyCombination.META_DOWN, KeyCombination.ALT_DOWN)); return hideOthers; }
public MenuItem createHideMenuItem(String appName) { MenuItem hide = new MenuItem(labelMaker.getLabel(LabelName.HIDE, appName)); hide.setOnAction(event -> nativeAdapter.hide()); hide.setAccelerator(new KeyCodeCombination(KeyCode.H, KeyCombination.META_DOWN)); return hide; }
public MenuItem createMinimizeMenuItem() { MenuItem menuItem = new MenuItem(labelMaker.getLabel(LabelName.MINIMIZE)); menuItem.setAccelerator(new KeyCodeCombination(KeyCode.M, KeyCombination.META_DOWN)); menuItem.setOnAction(event -> StageUtils.minimizeFocusedStage()); return menuItem; }
public MenuItem createZoomMenuItem() { MenuItem menuItem = new MenuItem(labelMaker.getLabel(LabelName.ZOOM)); menuItem.setOnAction(event -> StageUtils.zoomFocusedStage()); return menuItem; }
public MenuItem createCloseWindowMenuItem() { MenuItem menuItem = new MenuItem(labelMaker.getLabel(LabelName.CLOSE_WINDOW)); menuItem.setAccelerator(new KeyCodeCombination(KeyCode.W, KeyCombination.META_DOWN)); menuItem.setOnAction(event -> StageUtils.closeCurrentStage()); return menuItem; }
public MenuItem createBringAllToFrontItem() { MenuItem menuItem = new MenuItem(labelMaker.getLabel(LabelName.BRING_ALL_TO_FRONT)); menuItem.setOnAction(event -> StageUtils.bringAllToFront()); return menuItem; }
public MenuItem createCycleWindowsItem() { MenuItem menuItem = new MenuItem(labelMaker.getLabel(LabelName.CYCLE_THROUGH_WINDOWS)); menuItem.setAccelerator(new KeyCodeCombination(KeyCode.BACK_QUOTE, KeyCombination.META_DOWN)); menuItem.setOnAction(event -> StageUtils.focusNextStage()); return menuItem; }
public void showContextMenu(Menu menu, MouseEvent event) { nativeAdapter.showContextMenu(menu, event); }
@SuppressWarnings("unused") public boolean systemUsesDarkMode() { return nativeAdapter.systemUsesDarkMode(); }
@SuppressWarnings("unused") public void unsetGlobalMenuBar() { MenuBarSyncListener.unregister(); }
public void autoAddWindowMenuItems(Menu menu) { menu.getItems().add(new SeparatorMenuItem()); StageUtils.getStages().addListener(new WindowMenuUpdateListener(menu)); }
protected Menu extractApplicationMenu(MenuBar menuBar) { return menuBar.getMenus().get(0); }
private void loadLabelsForLocale(Locale locale) { InputStream resource = getLabelResource(locale); if (resource != null) { try { loadLabels(resource); } catch (IOException e) { System.err.println("Unable to load properties: " + e.getMessage()); } } }
public void loadLabels(InputStream resource) throws IOException { properties.load(new InputStreamReader(resource, StandardCharsets.UTF_8)); }
public Stage build() { try { prepareStage(); } catch (IOException e) { e.printStackTrace(); } return stage; }
private void prepareStage() throws IOException { URL resource = AboutStageBuilder.class.getClassLoader().getResource("about.fxml"); FXMLLoader loader = new FXMLLoader(resource); Parent root = loader.load(); AboutController controller = loader.getController(); if (image != null) { controller.getContent().getChildren().add(image); } if (name != null) { controller.getContent().getChildren().add(name); } if (version != null) { controller.getContent().getChildren().add(version); } if (credits != null) { controller.getContent().getChildren().add(credits); } if (copyright != null) { controller.getContent().getChildren().add(copyright); } stage.setScene(new Scene(root)); }
public AboutStageBuilder withCloseOnFocusLoss() { stage .focusedProperty() .addListener( (observable, oldValue, newValue) -> { if (!newValue) { stage.close(); } }); return this; }
public AboutStageBuilder withSize(int with, int height) { stage.setMinWidth(with); stage.setMaxWidth(height); return this; }
public AboutStageBuilder withTitle(String title) { stage.setTitle(title); return this; }
public AboutStageBuilder withVersionString(String version) { this.version = new Label(version); this.version.getStyleClass().add("version"); return this; }
public AboutStageBuilder withAppName(String name) { this.name = new Label(name); this.name.getStyleClass().add("app_name"); return this; }
public AboutStageBuilder withText(String text) { return withTexts(Collections.singleton(new Text(text))); }
public AboutStageBuilder withTexts(Collection<Text> texts) { TextFlow creditsView = new TextFlow(); creditsView.setBorder(Border.EMPTY); creditsView.setTextAlignment(TextAlignment.CENTER); creditsView.getChildren().addAll(texts); setCredits(creditsView); return this; }
@SuppressWarnings("unused") public AboutStageBuilder withNode(Node node) { setCredits(node); return this; }
public AboutStageBuilder withCopyright(String copyright) { this.copyright = new Label(copyright); return this; }
public AboutStageBuilder withImage(Image image) { return withImage(image, DEFAULT_ICON_SIZE, DEFAULT_ICON_SIZE); }
public AboutStageBuilder withImage(Image image, double width, double height) { this.image = new ImageView(image); this.image.setFitWidth(width); this.image.setFitHeight(height); return this; }
public static AboutStageBuilder start(String title) { final Stage aboutStage = new Stage(); aboutStage.setResizable(false); return new AboutStageBuilder(aboutStage).withTitle(title).withSize(300, 300); }
public static Memory toMemory(byte[] data) { Memory memory = new Memory(data.length); memory.write(0, data, 0, data.length); return memory; }
public static MenuBar createMenuBar(ObservableList<Menu> menus) { MenuBar bar = new MenuBar(); bar.setUseSystemMenuBar(true); Bindings.bindContentBidirectional(bar.getMenus(), menus); return bar; }
public static void removeExistingMenuBar(ObservableList<Node> children) { children.removeAll( children.stream().filter(MenuBar.class::isInstance).collect(Collectors.toList())); }
private static void replaceMenuBar(ObservableList<Node> children, MenuBar createMenuBar) { removeExistingMenuBar(children); children.add(createMenuBar); }
private static ObservableList<Menu> extractSubMenus(MenuBar bar) { return new FilteredList<>(bar.getMenus(), menu -> bar.getMenus().indexOf(menu) > 0); }
public static void bringAllToFront() { Optional<Stage> focusedStage = getFocusedStage(); getStages().forEach(Stage::toFront); focusedStage.ifPresent(Stage::toFront); }
public static void zoomFocusedStage() { getFocusedStage() .ifPresent( stage -> { ObservableList<Screen> screens = Screen.getScreensForRectangle( stage.getX(), stage.getY(), stage.getWidth(), stage.getHeight()); if (screens.size() == 1) { StageUtils.setStageSize(stage, screens.get(0).getBounds()); } }); }
public static void minimizeFocusedStage() { getFocusedStage().ifPresent(stage -> stage.setIconified(true)); }
public static void closeCurrentStage() { getFocusedStage().ifPresent(Stage::close); }
public static void focusNextStage() { ObservableList<Stage> stages = getStages(); int currentStageIndex = getFocusedStageIndex(stages); if (currentStageIndex < stages.size() - 1) { stages.get(currentStageIndex + 1).toFront(); } else if (!stages.isEmpty()) { stages.get(0).toFront(); } }
private static void updateStages() { List<Stage> currentStages = windows.stream() .filter(Stage.class::isInstance) .map(Stage.class::cast) .collect(Collectors.toList()); stages.removeIf(stage -> !currentStages.contains(stage)); currentStages.stream() .filter(currentStage -> !stages.contains(currentStage)) .forEach(stages::add); }
@Override public void hide() { Window.getWindows().stream().filter(Window::isFocused).findFirst().ifPresent(Window::hide); }
@Override public void hideOtherApplications() { }
@Override public void showAllWindows() { Window.getWindows().stream() .filter(Stage.class::isInstance) .map(Stage.class::cast) .forEach(Stage::show); }
@Override public boolean systemUsesDarkMode() { return false; }
public void showContextMenu(Menu menu, MouseEvent event) { Window.getWindows().stream() .filter(Window::isFocused) .findFirst() .ifPresent( window -> { ContextMenu contextMenu = new ContextMenu(); contextMenu.getItems().addAll(menu.getItems()); contextMenu.show(window, event.getScreenX(), event.getScreenY()); }); }
@Override public void showAboutWindow(String title) { AboutStageBuilder.start(title).build().show(); }
public static NSMenu convert(Menu menu) { if (menu == null) { return null; } String text = Optional.ofNullable(menu.getText()).orElse(""); NSMenu nsMenu = NSMenu.alloc().initWithTitle(text); Map<MenuItem, NSMenuItem> fxToNsMenuItems = new HashMap<>(); menu.getItems().forEach(item -> MenuConverter.addMenuItem(nsMenu, fxToNsMenuItems, item)); menu.textProperty().addListener((observable, oldValue, newValue) -> nsMenu.setTitle(newValue)); menu.getItems() .addListener( (ListChangeListener<MenuItem>) (change -> MenuConverter.handleMenuItemChange(nsMenu, fxToNsMenuItems, change))); NSCleaner.register(menu, nsMenu); return nsMenu; }
private static void addMenuItem( NSMenu nsMenu, Map<MenuItem, NSMenuItem> fxToNsMenuItems, MenuItem menuItem) { NSMenuItem nsMenuItem = getNsMenuItem(fxToNsMenuItems, menuItem); nsMenu.addItem(nsMenuItem); }
private static void addMenuItem( NSMenu nsMenu, Map<MenuItem, NSMenuItem> fxToNsMenuItems, MenuItem menuItem, int index) { NSMenuItem nsMenuItem = getNsMenuItem(fxToNsMenuItems, menuItem); nsMenu.insertItem(nsMenuItem, index); }
private static NSMenuItem getNsMenuItem( Map<MenuItem, NSMenuItem> fxToNsMenuItems, MenuItem menuItem) { NSMenuItem nsMenuItem = MenuItemConverter.convert(menuItem); if (menuItem instanceof Menu) { nsMenuItem.setSubmenu(MenuConverter.convert((Menu) menuItem)); } fxToNsMenuItems.put(menuItem, nsMenuItem); return nsMenuItem; }
private static void removeMenuItem( NSMenu nsMenu, Map<MenuItem, NSMenuItem> fxToNsMenuItems, MenuItem menuItem) { NSMenuItem nsMenuItem = fxToNsMenuItems.get(menuItem); if (nsMenuItem != null) { nsMenu.removeItem(nsMenuItem); fxToNsMenuItems.remove(menuItem); } }
public static NSMenuItem convert(MenuItem menuItem) { if (menuItem == null) { return null; } if (menuItem instanceof SeparatorMenuItem) { return ObjcToJava.invokeStatic(NSMenuItem.class, SEPARATOR_ITEM); } else { return convertMenuItem(menuItem); } }
private static NSMenuItem convertMenuItem(MenuItem menuItem) { FoundationCallback foundationCallback = getFoundationCallback(menuItem.getOnAction()); NSMenuItem nsMenuItem = createNsMenuItem(menuItem, foundationCallback); menuItem .textProperty() .addListener((observable, oldValue, newValue) -> nsMenuItem.setTitle(newValue)); menuItem .onActionProperty() .addListener( (observable, oldValue, newValue) -> updateAction(menuItem, nsMenuItem, newValue)); menuItem .acceleratorProperty() .addListener( (observable, oldValue, newValue) -> nsMenuItem.setKeyEquivalent(toKeyEquivalentString(newValue))); nsMenuItem.setKeyEquivalentModifierMask(toKeyEventModifierFlags(menuItem.getAccelerator())); menuItem .acceleratorProperty() .addListener( (observable, oldValue, newValue) -> nsMenuItem.setKeyEquivalentModifierMask(toKeyEventModifierFlags(newValue))); ImageConverter.convert(menuItem.getGraphic()).ifPresent(nsMenuItem::setImage); menuItem .graphicProperty() .addListener( (observable, oldValue, newValue) -> ImageConverter.convert(newValue).ifPresent(nsMenuItem::setImage)); NSCleaner.register(menuItem, nsMenuItem); registerCallbackForCleanup(menuItem, foundationCallback); return nsMenuItem; }
private static void updateAction( MenuItem menuItem, NSMenuItem nsMenuItem, EventHandler<ActionEvent> eventHandler) { FoundationCallback foundationCallback = getFoundationCallback(eventHandler); nsMenuItem.setTarget(foundationCallback.getTarget()); nsMenuItem.setAction(foundationCallback.getSelector()); registerCallbackForCleanup(menuItem, foundationCallback); }
private static void registerCallbackForCleanup( MenuItem menuItem, FoundationCallback foundationCallback) { if (foundationCallback != VOID_CALLBACK) { NSCleaner.register(menuItem, foundationCallback); } }
private static NSMenuItem createNsMenuItem( MenuItem menuItem, FoundationCallback foundationCallback) { String text = Optional.ofNullable(menuItem.getText()).orElse(""); NSMenuItem nsMenuItem = NSMenuItem.alloc() .initWithTitle( text, foundationCallback.getSelector(), toKeyEquivalentString(menuItem.getAccelerator())); nsMenuItem.setTarget(foundationCallback.getTarget()); return nsMenuItem; }
private static String toKeyEquivalentString(KeyCombination accelerator) { if (accelerator == null) { return ""; } return keyEquivalent(accelerator); }
private static String keyEquivalent(KeyCombination accelerator) { if (accelerator instanceof KeyCodeCombination) { return ((KeyCodeCombination) accelerator).getCode().getChar().toLowerCase(); } return ""; }
@Override public void onChanged(Change<? extends Window> change) { while (change.next()) { watchWindows(change.getAddedSubList()); } }
private void watchWindows(List<? extends Window> windows) { windows.forEach(this::handleWindowAdded); }
private void handleWindowAdded(Window added) { if (added.isShowing()) { action.run(); } else { added .showingProperty() .addListener( (observableValue, oldValue, newValue) -> { if (Boolean.TRUE.equals(newValue)) { action.run(); } }); } }
private void checkFocusedStage() { Optional<Stage> focusedStage = stages.stream().filter(Stage::isFocused).findFirst(); createdMenuItems.forEach( (key, value) -> value.setSelected(focusedStage.isPresent() && focusedStage.get().equals(key))); }
@Override public void onChanged(ListChangeListener.Change<? extends Stage> c) { while (c.next()) { updateWindowMenuItems(c.getAddedSubList(), c.getRemoved()); } }
private void updateWindowMenuItems(List<? extends Stage> add, List<? extends Stage> remove) { removeItemsFromMenu(remove); addItemsToMenu(add); }
private void addItemsToMenu(List<? extends Stage> add) { Menu menu = windowMenu.get(); if (add != null && menu != null) { add.forEach(stage -> addWindowMenuItem(stage, menu)); } }
private void removeItemsFromMenu(List<? extends Stage> remove) { Menu menu = windowMenu.get(); if (remove != null && menu != null) { remove.forEach(stage -> removeWindowMenuItem(stage, menu)); } }
private void removeWindowMenuItem(Stage stage, Menu menu) { MenuItem menuItem = createdMenuItems.get(stage); if (menuItem != null) { menu.getItems().remove(menuItem); } }
private void addWindowMenuItem(Stage stage, Menu menu) { CheckMenuItem item = new CheckMenuItem(stage.getTitle()); item.setOnAction(event -> stage.toFront()); createdMenuItems.put(stage, item); menu.getItems().add(item); }
public static void register(MenuBar menuBar) { MenuBarSyncListener.menuBar = menuBar; if (instance == null) { instance = new MenuBarSyncListener(); StageUtils.getStages().addListener(instance); } }
public static void unregister() { if (instance != null) { StageUtils.getStages().removeListener(instance); instance = null; } }
@Override public void onChanged(ListChangeListener.Change<? extends Stage> stageChanges) { while (stageChanges.next()) { stageChanges.getAddedSubList().forEach(stage -> MenuBarUtils.setMenuBar(stage, menuBar)); } }
public static IcnsParser forFile(String path) throws IOException { return forFile(new File(path)); }
public static IcnsParser forFile(File file) throws IOException { IcnsParser parser = new IcnsParser(file); parser.parse(); return parser; }
public void parse() throws IOException { try (InputStream fileInputStream = new FileInputStream(icnsFile)) { try (DataInputStream dataInputStream = new DataInputStream(fileInputStream)) { parseHeader(dataInputStream); parseIcons(dataInputStream); } } }
@SuppressWarnings("unused") public boolean hasIconType(IcnsType iconType) { return iconMap.containsKey(iconType.getOsType()); }
private InputStream createIconInputStream(String osType) throws IOException { IcnsIcon icon = iconMap.get(osType); InputStream iconData = new FileInputStream(icnsFile); iconData.skip(icon.offset); return new IcnsInputStream(iconData, icon.length); }
private void parseIcons(DataInputStream dataInputStream) throws IOException { while (offset < length) { IcnsIcon icon = readNextIcon(dataInputStream); if (icon.length <= 0) { break; } iconMap.put(icon.type, icon); offset += icon.length; } }
private void parseHeader(DataInputStream stream) throws IOException { int magic = stream.readInt(); if (magic != MAGIC) { throw new IllegalArgumentException("Provided file is not a valid icns file"); } length = stream.readInt(); offset += HEADER_SIZE; }
private IcnsIcon readNextIcon(DataInputStream stream) throws IOException { byte[] type = new byte[4]; stream.read(type); int skipLength = stream.readInt(); stream.skipBytes(skipLength - HEADER_SIZE); return new IcnsIcon(new String(type), offset + HEADER_SIZE, skipLength); }
@Override public int read() throws IOException { if (remainingBytes <= 0) { return -1; } remainingBytes--; return other.read(); }
default boolean coordAccessible(int x, int y) { return (getXBase(x) != -1) && (getYBase(y) != -1); }
default boolean coordInbounds(int x, int y) { return getBounds().contains(x, y); }
public static ByteArrayMemoryish initNewTable(int dc, int w, int h, int i, int[] defVals) { ByteArrayMemoryish bam = new ByteArrayMemoryish(new byte[20 + (w * h * i * 2)]); bam.set32LE(0, dc); bam.set32LE(4, w); bam.set32LE(8, h); bam.set32LE(12, i); bam.set32LE(16, w * h * i); for (int j = 0; j < (w * h); j++) for (int l = 0; l < i; l++) bam.set16LE(20 + ((j + (l * (w * h))) * 2), (short) defVals[l]); return bam; }
@Override public boolean coordAccessible(int x, int y) { return (x >= 0) && (x < width) && (y >= 0) && (y < height); }
public ByteArrayMemoryish resize(int w, int h, int[] defVals) { ByteArrayMemoryish bam = RubyTable.initNewTable(dimensionCount, w, h, planeCount, defVals); RubyTable n = new RubyTable(bam); for (int i = 0; i < width; i++) { if (w <= i) break; for (int j = 0; j < height; j++) { if (h <= j) break; for (int k = 0; k < planeCount; k++) n.setTiletype(i, j, k, getTiletype(i, j, k)); } } return bam; }
public String toString() { String st = "BigNum "; for (int i = 0; i < data.length; i++) { String s = Integer.toHexString(data[i] & 0xFF); if (s.length() == 1) s = "0" + s; st += s; } return st; }
public byte[] toRuby() { byte[] basis = data; boolean neg = isNegative(); if (neg) basis = negate().data; basis = reduceCore(basis); byte[] finale = new byte[basis.length + 1]; finale[0] = (byte) (neg ? '-' : '+'); System.arraycopy(basis, 0, finale, 1, basis.length); return finale; }
public long truncateToLong() { long p = 1; long res = 0; byte[] iData = signExtendCore(data, Math.max(8, data.length)); for (int i = iData.length - 1; i >= 0; i--) { res |= p * (iData[i] & 0xFFL); p <<= 8; if (p == 0) return res; } return res; }
private static void negateCore(byte[] data) { for (int i = 0; i < data.length; i++) data[i] = (byte) ((~data[i]) & 0xFF); for (int i = data.length - 1; i >= 0; i--) { if (data[i] != -1) { data[i]++; break; } else { data[i] = 0; } } }
public RubyBigNum negate() { if (cacheNegate != null) return cacheNegate; byte[] newData = new byte[data.length + 1]; if (data.length > 0) if (data[0] < 0) newData[0] = (byte) 0xFF; System.arraycopy(data, 0, newData, 1, data.length); negateCore(newData); return cacheNegate = new RubyBigNum(reduceCore(newData), true); }
public RubyBigNum add(RubyBigNum other) { byte[] ba = signExtendCore(data, Math.max(data.length + 1, other.data.length + 1)); byte[] bb = signExtendCore(other.data, Math.max(data.length + 1, other.data.length + 1)); boolean carry = false; for (int i = ba.length - 1; i >= 0; i--) { int a = ba[i] & 0xFF; int b = bb[i] & 0xFF; int c = a + b; if (carry) c++; boolean ncarry = c >= 0x100; c &= 0xFF; ba[i] = (byte) c; carry = ncarry; } return new RubyBigNum(reduceCore(ba), true); }
public int compare(RubyBigNum other) { RubyBigNum r2 = other.negate().add(this); if (r2.data.length == 0) return 0; if (r2.data[0] < 0) return -1; for (int i = 0; i < r2.data.length; i++) if (r2.data[i] != 0) return 1; throw new RuntimeException( "Reducer isn't working properly. At this point the data should definitely be 0, but reducer" + " didn't reduce it to 0 bytes."); }
public RubyBigNum shiftR(boolean arithmetic) { if (!arithmetic) if (cacheRShift != null) return cacheRShift; byte[] newData = new byte[data.length]; System.arraycopy(data, 0, newData, 0, data.length); for (int i = newData.length - 1; i >= 0; i--) { int nextBit = 0; if (i > 0) { nextBit = (newData[i - 1] & 1) << 7; } else if (arithmetic) { nextBit = newData[i] & 0x80; } newData[i] = (byte) (((newData[i] >> 1) & 0x7F) | nextBit); } RubyBigNum res = new RubyBigNum(newData, true); if (!arithmetic) cacheRShift = res; return res; }
public RubyBigNum shiftL(boolean arithmetic) { if (!arithmetic) if (cacheLShift != null) return cacheLShift; byte[] newData = new byte[data.length + 1]; if (arithmetic) if (data.length != 0) if (data[0] < 0) newData[0] = (byte) 0xFF; System.arraycopy(data, 0, newData, 1, data.length); for (int i = 0; i < newData.length; i++) { int nextBit = 0; if (i < newData.length - 1) nextBit = (newData[i + 1] & 0x80) >> 7; newData[i] = (byte) ((newData[i] << 1) | nextBit); } RubyBigNum res = new RubyBigNum(reduceCore(newData), true); if (!arithmetic) cacheLShift = res; return res; }
private static byte[] reduceCore(byte[] ba) { int removable = 0; boolean signSet = false; boolean sign = false; for (int i = 0; i < ba.length; i++) { boolean nSign = ba[i] < 0; if (!signSet) { sign = nSign; signSet = true; } byte expected = sign ? (byte) -1 : 0; if (expected != ba[i]) { break; } else { removable++; } } if (removable == 0) return ba; if (removable == ba.length) { if (!sign) { return new byte[0]; } else { return new byte[] {(byte) 0xFF}; } } else { if ((ba[removable] < 0) != sign) removable--; if (removable < 0) throw new RuntimeException( "Should be impossible : removable was moved under 0 when sign was unequal."); } byte[] res = new byte[ba.length - removable]; System.arraycopy(ba, removable, res, 0, res.length); return res; }
private static byte[] signExtendCore(byte[] data, int max) { byte[] mx = new byte[max]; if (data.length > max) throw new RuntimeException( "sign extend used incorrectly, max must be at least the input length"); System.arraycopy(data, 0, mx, max - data.length, data.length); if (data.length > 0) if (data[0] < 0) for (int i = 0; i < max - data.length; i++) mx[i] = -1; return mx; }
public boolean isNegative() { if (data.length == 0) return false; return data[0] < 0; }
public boolean isZero() { if (data.length == 0) return true; for (int i = 0; i < data.length; i++) if (data[i] != 0) return false; return true; }
@Override public IRIOGeneric newObjectO(String n, @NonNull DMContext context) { return new IRIOGeneric(context); }
public static long load32(DataInputStream dis) throws IOException { byte b = dis.readByte(); if (b == 0) return 0; if (b == 1) return dis.readUnsignedByte(); if (b == -1) return -(256 - dis.readUnsignedByte()); if (b == 2) return load16LE(dis); if (b == -2) return -(65536 - load16LE(dis)); if (b == 3) return load24LE(dis); if (b == -3) return -(0x1000000L - load24LE(dis)); if (b == 4) return load32LE(dis); if (b == -4) return -(0x100000000L - load32LE(dis)); long r = b; if (r >= 0) { r -= 5; } else { r += 5; } return r; }
private static long load32LE(DataInputStream dis) throws IOException { long a = load16LE(dis); return a | (load16LE(dis) << 16); }
private static long load24LE(DataInputStream dis) throws IOException { long a = load16LE(dis); return a | (dis.readUnsignedByte() << 16); }
private static long load16LE(DataInputStream dis) throws IOException { long a = dis.readUnsignedByte(); return a | (dis.readUnsignedByte() << 8); }
public static void save32STM(DataOutputStream dis, long v) throws IOException { if (v == 0) { dis.write(0); return; } boolean neg = false; if (v < 0) neg = true; int b = 4; if (neg) { if (v >= -0x1000000) b = 3; if (v >= -0x10000) b = 2; if (v >= -0x100) b = 1; dis.write(-b); } else { if (v < 0x1000000) b = 3; if (v < 0x10000) b = 2; if (v < 0x100) b = 1; dis.write(b); } save32LE(dis, v, b); }
public void save32(DataOutputStream dis, long v) throws IOException { save32STM(dis, v); }
private static void save32LE(DataOutputStream dis, long v, int bytes) throws IOException { if (bytes > 0) dis.write((int) (v & 0xFF)); if (bytes > 1) dis.write((int) ((v >> 8) & 0xFF)); if (bytes > 2) dis.write((int) ((v >> 16) & 0xFF)); if (bytes > 3) dis.write((int) ((v >> 24) & 0xFF)); }
@Override public IRIOGeneric loadObjectFromFile(String filename, @NonNull DMContext context) { return loadObjectFromFile(new IRIOGeneric(context), filename); }
public IRIOGeneric loadObjectFromFile(IRIOGeneric rio, String filename) { try { String fullPath = prefix + filename + postfix; InputStream inp; try { inp = fs.intoPath(fullPath).openRead(); } catch (Exception e) { System.err.println(fullPath + " wasn't found."); return null; } DataInputStream dis = new DataInputStream(inp); if (dis.readUnsignedByte() != 0x04) throw new IOException("mgk[0]!=0x04"); if (dis.readUnsignedByte() != 0x08) throw new IOException("mgk[1]!=0x08"); LinkedList<IRIO> objCache = new LinkedList<>(); LinkedList<String> strCache = new LinkedList<>(); loadValue(rio, dis, objCache, strCache); dis.close(); return rio; } catch (Exception ioe) { System.err.println("In file " + filename + ":"); ioe.printStackTrace(); return null; } }
@Override public void saveObjectToFile(String filename, RORIO object) throws IOException { OutputStream oup = fs.intoPath(prefix + filename + postfix).openWrite(); DataOutputStream dis = new DataOutputStream(oup); dis.write(new byte[] {4, 8}); saveValue(dis, object, new SaveCaches()); dis.close(); }
public int indexOfSym(String s) { Integer idx = symCache.get(s); if (idx == null) return -1; return idx; }
public void addSym(String s) { symCache.put(s, symCacheNextIndex++); }
private void saveSymbol(DataOutputStream dis, String sym, SaveCaches caches) throws IOException { int symInd = caches.indexOfSym(sym); if (symInd >= 0) { dis.write((int) ';'); save32(dis, symInd); } else { dis.write((int) ':'); byte[] d = sym.getBytes("UTF-8"); save32(dis, d.length); dis.write(d); caches.addSym(sym); } }
private void saveHashCore(DataOutputStream dis, RORIO content, SaveCaches caches) throws IOException { DMKey[] me = content.getHashKeys(); save32(dis, me.length); for (DMKey cKey : me) { try { saveValue(dis, cKey, caches); saveValue(dis, content.getHashVal(cKey), caches); } catch (Exception ex) { throw new IOException("Hit catch at HK " + cKey, ex); } } }
private void saveIVarsCore(DataOutputStream dis, RORIO iVars, SaveCaches caches) throws IOException { String[] iVarKeys = iVars.getIVars(); if (iVarKeys == null) { save32(dis, 0); return; } save32(dis, iVarKeys.length); for (int i = 0; i < iVarKeys.length; i++) { String key = iVarKeys[i]; try { saveSymbol(dis, key, caches); saveValue(dis, iVars.getIVar(key), caches); } catch (Exception ex) { throw new IOException("Hit catch at IVar " + key, ex); } } }
private IRIOGeneric loadValue( DataInputStream dis, LinkedList<IRIO> objs, LinkedList<String> syms, @NonNull DMContext context) throws IOException { IRIOGeneric rio = new IRIOGeneric(context); loadValue(rio, dis, objs, syms); return rio; }
@Override public Iterator<Integer> iterator() { return new ArrayIterator(source); }
@Override public boolean hasNext() { return index < source.length; }
@Override public Integer next() { if (index >= source.length) throw new NoSuchElementException("Read off of end of IntArrayIterable"); return source[index++]; }
public static void writeIMIStringBody(DataOutputStream dos, byte[] data, boolean binary) throws IOException { for (int i = 0; i < data.length; i++) { boolean escape = binary; if (data[i] < 32) { escape = true; } else if (data[i] == '\"') { escape = true; } else if (data[i] == '\\') { escape = true; } if (escape) { String b = Integer.toHexString(data[i] & 0xFF); if (b.length() == 1) { b = "\\0" + b; } else { b = "\\" + b; } dos.writeBytes(b); } else { dos.writeByte(data[i]); } } dos.writeByte('\"'); }
public static void writeIMIStringBody(DataOutputStream dos, MemoryishR data, boolean binary) throws IOException { for (int i = 0; i < data.length; i++) { boolean escape = binary; byte b = data.getS8(i); if (b < 32) { escape = true; } else if (b == '\"') { escape = true; } else if (b == '\\') { escape = true; } if (escape) { String bx = Integer.toHexString(b & 0xFF); if (bx.length() == 1) { bx = "\\0" + bx; } else { bx = "\\" + bx; } dos.writeBytes(bx); } else { dos.writeByte(b); } } dos.writeByte('\"'); }
private static String incrementIndent(String indent) { String n2 = indent + " "; if (n2.endsWith(" ")) return n2.substring(0, n2.length() - 4) + "\t"; return n2; }
public static long readIMINumber(InputStream inp, int terminator) throws IOException { long val = 0; long mul = 1; while (true) { int p = inp.read(); boolean ok = false; if (p >= '0') { if (p <= '9') { val *= 10; val += p - '0'; ok = true; } } if (p == '-') { mul *= -1; ok = true; } if (p == terminator) break; if (!ok) throw new IOException("Unknown char " + p); } return val * mul; }
public static byte[] readIMIStringBody(InputStream inp) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); int escapeState = 0; int escapeHex = 0; String hexStr = "0123456789abcdef"; while (true) { int b = inp.read(); if (b == -1) throw new IOException("Early termination during string."); int io = hexStr.indexOf(Character.toLowerCase(b)); switch (escapeState) { case 0: if (b == '\"') { return baos.toByteArray(); } else if (b == '\\') { escapeState = 1; } else { baos.write(b); } break; case 1: if (io == -1) throw new IOException("Cannot have -1 index on first hex digit"); escapeHex = io << 4; escapeState = 2; break; case 2: if (io == -1) throw new IOException("Cannot have -1 index on second hex digit"); escapeHex |= io; baos.write(escapeHex); escapeState = 0; break; } } }
public static String readString(Reader r) throws IOException { StringBuilder s = new StringBuilder(); int c = r.read(); while (c != -1) { if (c == '"') break; if (c == '\\') { c = r.read(); if (c == -1) break; if (c == 'u') { int v = 0; for (int i = 0; i < 4; i++) { c = r.read(); v = (v << 4) | handleHexDig(c); if (c == -1) break; } s.append((char) v); } else if (c == '"') { s.append('\"'); } else if (c == '\\') { s.append('\\'); } else if (c == '/') { s.append('/'); } else if (c == 'b') { s.append('\b'); } else if (c == 'f') { s.append('\f'); } else if (c == 'n') { s.append('\n'); } else if (c == 'r') { s.append('\r'); } else if (c == 't') { s.append('\t'); } else { throw new IOException("Unknown escape " + c); } } else { s.append((char) c); } c = r.read(); } if (c == -1) throw new IOException("String terminated too early"); return s.toString(); }
private static int handleHexDig(int c) throws IOException { if (c == '0') return 0; if (c == '1') return 1; if (c == '2') return 2; if (c == '3') return 3; if (c == '4') return 4; if (c == '5') return 5; if (c == '6') return 6; if (c == '7') return 7; if (c == '8') return 8; if (c == '9') return 9; if ((c == 'A') || (c == 'a')) return 10; if ((c == 'B') || (c == 'b')) return 11; if ((c == 'C') || (c == 'c')) return 12; if ((c == 'D') || (c == 'd')) return 13; if ((c == 'E') || (c == 'e')) return 14; if ((c == 'F') || (c == 'f')) return 15; throw new IOException("Unknown hex char"); }
private long putAreaAt(int base, int lenBytes, long v) { long vBase = (lenBytes - 1) * 8; for (int i = 0; i < lenBytes; i++) { data.set8(base + i, (byte) ((v >> vBase) & 0xFF)); vBase -= 8; } return v; }
private void putAt(int base, int bitNumber, int len, int val) { int adv = bitNumber / 8; base += adv; bitNumber -= adv * 8; int byteCount = (len + 7) / 8; if ((bitNumber + len) > (byteCount * 8)) byteCount++; long maskUS = (1L << len) - 1; long shift = (byteCount * 8) - (len + bitNumber); long data = getAreaAt(base, byteCount); data &= ~(maskUS << shift); data |= (val & maskUS) << shift; putAreaAt(base, byteCount, data); }
public void putPixel(int x, int y, int v) { if (upDown) y = height - (y + 1); putAt(dataZoneBase + (scanStride * y), x * bpp, bpp, v); }
public void putPalette(int col, int v) { data.set32LE(paletteZoneBase + (col * 4), v); }
public static byte[] prepareBMP( int w, int h, int bpp, int paletteSize, boolean topDown, boolean cMode) { if (bpp <= 8) if (paletteSize == 0) throw new RuntimeException( "paletteSize = 0 is only really valid for 16-bit, 24-bit, or 32-bit."); int scanWB = (((bpp * w) + 31) / 32) * 4; int monoWB = ((w + 31) / 32) * 4; int palSize = paletteSize * 4; int bufSize = scanWB * h; int aH = h; if (cMode) { aH *= 2; bufSize += monoWB * h; } if (topDown) aH = -aH; byte[] data = new byte[0x36 + palSize + bufSize]; ByteBuffer bb = ByteBuffer.wrap(data); bb.order(ByteOrder.LITTLE_ENDIAN); bb.put(0x00, (byte) 'B'); bb.put(0x01, (byte) 'M'); bb.putInt(0x02, data.length); bb.put(0x06, (byte) 243); bb.put(0x07, (byte) 177); bb.put(0x08, (byte) 164); bb.put(0x09, (byte) 142); bb.putInt(0x0A, 0x36 + palSize); bb.putInt(0x0E, 0x28); bb.putInt(0x12, w); bb.putInt(0x16, aH); bb.putInt(0x1A, 1); bb.putInt(0x1C, bpp); bb.putInt(0x1E, 0); bb.putInt(0x22, bufSize); bb.putInt(0x26, 0); bb.putInt(0x2A, 0); bb.putInt(0x2E, paletteSize); bb.putInt(0x32, paletteSize); return data; }
@Override public ILoadedObject loadObject(String filename, @NonNull DMContext context) { W rio = loadObjectFromFile(filename, context); if (rio == null) return null; return new OldObjectBackendLoadedObject(rio, filename); }
@Override public ILoadedObject newObject(String filename, @NonNull DMContext context) { return new OldObjectBackendLoadedObject(newObjectO(filename, context), filename); }
@SuppressWarnings("unchecked") @Override public void save() throws IOException { saveObjectToFile(fn, (R) intern); }
@Override public IkaMap newObjectO(String n, @NonNull DMContext context) { return new IkaMap(context, 160, 120); }
private IkaEvent convertEventToRuby(NPChar.NPCCharacter io, DMContext dm2c) { IkaEvent res = new IkaEvent(dm2c); int px = rounder(io.posX); int py = rounder(io.posY); res.x.setFX(px); res.y.setFX(py); res.tox.setFX(rounder(io.ofsX) - px); res.toy.setFX(rounder(io.ofsY) - py); res.type.setFX(io.entityType); res.status.setFX(io.entityStatus); res.scriptId.setFX(io.eventID); res.collisionType.setFX(io.collisionType); return res; }
private int rounder(double pos) { return (int) (pos + 0.5); }
@Override public IRIO newObjectO(String n, @NonNull DMContext context) { return new IRIOGeneric(context); }
@Override public IRIO loadObjectFromFile(String filename, @NonNull DMContext context) { try (InputStream inp = fs.intoPath(root + filename + ext).openRead()) { return loadJSONFromStream(context, inp); } catch (Exception e) { e.printStackTrace(); return null; } }
public static IRIO loadJSONFromStream(@NonNull DMContext context, InputStream inp) throws IOException { LinkedList<String> tokens = new LinkedList<String>(); Reader r = new InputStreamReader(inp, StandardCharsets.UTF_8); tokenize(tokens, r); return loadFromTokens(context, tokens); }
private static void tokenize(LinkedList<String> tokens, Reader r) throws IOException { int c = r.read(); while (c != -1) { boolean next = false; if (singleCharBreaker(c)) { tokens.add(Character.toString((char) c)); next = true; } else if (((c >= '0') && (c <= '9')) || (c == '-')) { String s = ""; while (((c >= '0') && (c <= '9')) || (c == '.') || (c == '-') || (c == '+') || (c == 'e') || (c == 'E')) { s += (char) c; c = r.read(); while (c < 33) { if (c == -1) break; c = r.read(); } } tokens.add(s); } else if (c == '"') { String s = JsonStringIO.readString(r); tokens.add("\"" + s); next = true; } else if (c < 33) { next = true; } else { String s = ""; while (c >= 33) { if (singleCharBreaker(c)) break; s += (char) c; c = r.read(); } tokens.add(s); } if (next) c = r.read(); } }
private static boolean singleCharBreaker(int c) { return (c == '[') || (c == ']') || (c == ':') || (c == '{') || (c == '}') || (c == ','); }
@Override public void saveObjectToFile(String filename, RORIO object) throws IOException { try (OutputStream oup = fs.intoPath(root + filename + ext).openWrite()) { saveJSONToStream(oup, object); } }
public static void saveJSONToStream(OutputStream oup, RORIO object) throws IOException { try (DataOutputStream dos = new DataOutputStream(oup)) { saveValue(dos, object); } }
public static int readU8(InputStream src) throws IOException { int i = src.read(); if (i < 0) throw new IOException("EOF unexpected"); return i; }
public static int readS32(InputStream src) throws IOException { int b1 = readU8(src); int b2 = readU8(src); int b3 = readU8(src); int b4 = readU8(src); return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1; }
public static void writeS32(OutputStream os, int i) throws IOException { ByteBuffer t = ByteBuffer.wrap(new byte[4]); t.order(ByteOrder.LITTLE_ENDIAN); t.putInt(i); os.write(t.array()); }
public static int readU16(InputStream src) throws IOException { int b1 = readU8(src); int b2 = readU8(src); return (b2 << 8) | b1; }
public static void writeU16(OutputStream os, int i) throws IOException { ByteBuffer t = ByteBuffer.wrap(new byte[2]); t.order(ByteOrder.LITTLE_ENDIAN); t.putShort((short) i); os.write(t.array()); }
public static byte[] readBytes(InputStream src, int l) throws IOException { byte[] data = new byte[l]; int o = 0; while (o < l) { int rs = src.read(data, o, l - o); if (rs <= 0) throw new IOException("EOF"); o += rs; } return data; }
public static String decodeRbFloat(byte[] strVal) { int firstNull = strVal.length; for (int i = 0; i < strVal.length; i++) { if (strVal[i] == 0) { firstNull = i; break; } } byte[] text = new byte[firstNull]; System.arraycopy(strVal, 0, text, 0, text.length); return new String(text, Charset.forName("UTF-8")); }
public static boolean encodeRbFloat(IRIO target, String text, boolean jsonCoerce) { if (jsonCoerce) { try { long l = Long.parseLong(text); target.setFX(l); return true; } catch (NumberFormatException e) { } } try { Double.parseDouble(text); target.setFloat(text.getBytes(StandardCharsets.UTF_8)); return true; } catch (NumberFormatException e) { } return false; }
public static void resizeArrayTo(IRIO target, int sizeFixed) { while (target.getALen() > sizeFixed) target.rmAElem(sizeFixed); int alen; while ((alen = target.getALen()) < sizeFixed) target.addAElem(alen); }
@Override public boolean overwriteWith(ILoadedObject other) { return false; }
public static IObjectBackend create( FSBackend fs, String odbBackend, String dataPath, String dataExt) { if (odbBackend.equals("r48")) { return new R48ObjectBackend(fs, dataPath, dataExt); } else if (odbBackend.equals("ika")) { return new IkaObjectBackend(fs, dataPath); } else if (odbBackend.equals("lcf2000")) { return new R2kObjectBackend(fs, dataPath); } else if (odbBackend.equals("json")) { return new JsonObjectBackend(fs, dataPath, dataExt); } else if (odbBackend.equals("cs")) { return new CSObjectBackend(fs, dataPath); } else { throw new RuntimeException("Unknown ODB backend " + odbBackend); } }
@Override public IRIO newObjectO(String fn, @NonNull DMContext context) { if (fn.endsWith(".lmt")) return new MapTree(context); if (fn.endsWith(".lmu")) return new MapUnit(context); if (fn.endsWith(".ldb")) return new Database(context); if (fn.endsWith(".lsd")) return new Save(context); return new IRIOGeneric(context); }
@Override public IRIO loadObjectFromFile(String filename, @NonNull DMContext context) { filename = root + filename; try (InputStream fis = fs.intoPath(filename).openRead()) { try { if (filename.endsWith(".lmu")) { return R2kIO.readLmu(context, fis); } else if (filename.endsWith(".lmt")) { return R2kIO.readLmt(context, fis); } else if (filename.endsWith(".ldb")) { return R2kIO.readLdb(context, fis); } else if (filename.endsWith(".lsd")) { return R2kIO.readLsd(context, fis); } } catch (Exception e) { e.printStackTrace(); return null; } } catch (Exception ex) { } return null; }
@Override public void saveObjectToFile(String filename, RORIO object) throws IOException { filename = root + filename; ByteArrayOutputStream baos = new ByteArrayOutputStream(); if (filename.endsWith(".lmu")) { R2kIO.writeLmu(baos, (MapUnit) object); } else if (filename.endsWith(".lmt")) { R2kIO.writeLmt(baos, (MapTree) object); } else if (filename.endsWith(".ldb")) { R2kIO.writeLdb(baos, (Database) object); } else if (filename.endsWith(".lsd")) { R2kIO.writeLsd(baos, (Save) object); } else { throw new IOException("Unknown how to save " + filename + " (lmu/lmt/ldb)"); } try (OutputStream fos = fs.intoPath(filename).openWrite()) { baos.writeTo(fos); } }
@Override public IRIOGeneric newObjectO(String nt, @NonNull DMContext context) { return new IRIOGeneric(context); }
@Override public IRIO loadObjectFromFile(String filename, @NonNull DMContext context) { InputStream inp; try { inp = fs.intoPath(pfx + filename).openRead(); } catch (IOException e1) { System.err.println("Couldn't load CS " + pfx + filename); e1.printStackTrace(); return null; } try { IRIO res = null; String fnl = filename.toLowerCase(); if (fnl.endsWith("pxm")) { res = loadPXM(inp, context); } else if (fnl.endsWith("pxa")) { res = loadPXA(inp, context); } else if (fnl.endsWith("stage.tbl")) { res = loadStageTBL(inp, context); } inp.close(); return res; } catch (IOException ioe) { try { inp.close(); } catch (IOException e) { } ioe.printStackTrace(); } return null; }
private IRIOGeneric loadStageTBL(InputStream inp, @NonNull DMContext context) throws IOException { int stages = inp.available() / 200; IRIOGeneric rio = newObjectO("", context); rio.setArray(stages); for (int i = 0; i < stages; i++) { IRIO tileset = loadFixedFormatString(inp, 0x20, context); IRIO filename = loadFixedFormatString(inp, 0x20, context); int backgroundScroll = inp.read(); backgroundScroll |= inp.read() << 8; backgroundScroll |= inp.read() << 16; backgroundScroll |= inp.read() << 24; IRIO bkg = loadFixedFormatString(inp, 0x20, context); IRIO npc1 = loadFixedFormatString(inp, 0x20, context); IRIO npc2 = loadFixedFormatString(inp, 0x20, context); int boss = inp.read(); IRIO name = loadFixedFormatString(inp, 0x23, context); IRIO rio2 = rio.getAElem(i).setObject("Stage"); rio2.addIVar("@tileset").setDeepClone(tileset); rio2.addIVar("@filename").setDeepClone(filename); rio2.addIVar("@background_scroll").setFX(backgroundScroll); rio2.addIVar("@sf_bkg").setDeepClone(bkg); rio2.addIVar("@sf_npc1").setDeepClone(npc1); rio2.addIVar("@sf_npc2").setDeepClone(npc2); rio2.addIVar("@boss").setFX(boss); rio2.addIVar("@name").setDeepClone(name); } return rio; }
private IRIO loadFixedFormatString(InputStream inp, int i, @NonNull DMContext context) throws IOException { byte[] bt = new byte[i]; if (inp.read(bt) != i) throw new IOException("Insufficient data"); for (int j = 0; j < bt.length; j++) { if (bt[j] == 0) { byte[] nbt = new byte[j]; System.arraycopy(bt, 0, nbt, 0, j); bt = nbt; break; } } return newObjectO("", context).setString(bt, context.encoding); }
private IRIO loadPXA(InputStream inp, @NonNull DMContext context) throws IOException { return loadRT(inp, 16, 16, context); }
private IRIO loadPXM(InputStream inp, @NonNull DMContext context) throws IOException { if (inp.read() != 'P') throw new IOException("Magic PXM 0x10 incorrect"); if (inp.read() != 'X') throw new IOException("Magic PXM 0x10 incorrect"); if (inp.read() != 'M') throw new IOException("Magic PXM 0x10 incorrect"); if (inp.read() != 0x10) throw new IOException("Magic PXM 0x10 incorrect"); int w = inp.read(); w |= inp.read() << 8; int h = inp.read(); h |= inp.read() << 8; return loadRT(inp, w, h, context); }
private IRIO loadRT(InputStream inp, int w, int h, @NonNull DMContext context) throws IOException { ByteArrayMemoryish bam = RubyTable.initNewTable(2, w, h, 1, new int[] {0}); RubyTable rt = new RubyTable(bam); for (int j = 0; j < h; j++) for (int i = 0; i < w; i++) rt.setTiletype(i, j, 0, (short) inp.read()); return newObjectO("", context).setUser("Table", bam.data); }
@Override public void saveObjectToFile(String filename, IRIO object) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); String fnl = filename.toLowerCase(); if (fnl.endsWith("pxm")) { savePXM(baos, object); } else if (fnl.endsWith("pxa")) { savePXA(baos, object); } else if (fnl.endsWith("stage.tbl")) { saveStageTBL(baos, object); } else { throw new IOException("I don't know how to save that"); } try (OutputStream os = fs.intoPath(pfx + filename).openWrite()) { baos.writeTo(os); } }
private void writeFixedFormatString(ByteArrayOutputStream baos, IRIO strsym, int i) throws IOException { byte[] bt = new byte[i]; byte[] nbt = strsym.getBufferInEncoding(strsym.context.encoding); System.arraycopy(nbt, 0, bt, 0, Math.min(nbt.length, bt.length - 1)); baos.write(bt); }
private void savePXA(ByteArrayOutputStream baos, IRIO o) throws IOException { RubyTableR rt = new RubyTableR(o.getBuffer()); for (int j = 0; j < 16; j++) for (int i = 0; i < 16; i++) baos.write(rt.getTiletype(i, j, 0)); }
private void savePXM(ByteArrayOutputStream baos, IRIO o) throws IOException { baos.write('P'); baos.write('X'); baos.write('M'); baos.write(0x10); RubyTableR rt = new RubyTableR(o.getBuffer()); if (rt.width > 0xFFFF) throw new RuntimeException("Width > 0xFFFF!"); if (rt.height > 0xFFFF) throw new RuntimeException("Height > 0xFFFF!"); baos.write(rt.width & 0xFF); baos.write((rt.width >> 8) & 0xFF); baos.write(rt.height & 0xFF); baos.write((rt.height >> 8) & 0xFF); for (int j = 0; j < rt.height; j++) for (int i = 0; i < rt.width; i++) baos.write(rt.getTiletype(i, j, 0)); }
public void data_add() { data = new IRIOFixedUser( context, "Table", RubyTable.initNewTable(3, defaultWidth, defaultHeight, 1, new int[1]).data); }
public void palette_add() { palette = new IRIOFixedUser(context, "Table", RubyTable.initNewTable(3, 256, 1, 4, new int[4]).data); }
@Override public Integer convertIRIOtoKey(RORIO i) { return (int) i.getFX(); }
@Override public DMKey convertKeyToIRIO(Integer i) { return DMKey.of(i); }
@Override public IkaEvent newValue() { return new IkaEvent(IkaMap.this.context); }
private static void doubleToFixedPoint(double d, OutputStream fos) throws IOException { int dd = (int) Math.floor(d); dd = dd << 14; double fractional = d - Math.floor(d); fractional *= 1 << 14; dd += (int) fractional; fos.write((dd & 0xFF)); fos.write((dd & 0xFF00) >> 8); fos.write((dd & 0xFF0000) >> 16); fos.write((dd & 0xFF000000) >> 24); }
private static double fixedPointToDouble(InputStream ins) throws IOException { int i = ins.read(); i |= ins.read() << 8; i |= ins.read() << 16; i |= ins.read() << 24; return i / ((double) (1 << 14)); }
public void load(InputStream ins) throws IOException { for (int p = 0; p < npcTable.length; p++) { NPCCharacter nc = new NPCCharacter(); boolean sw = ins.read() != 0; nc.collisionType = ins.read(); nc.entityType = ins.read(); nc.eventID = ins.read(); nc.entityStatus = ins.read(); nc.entityStatus |= ins.read() << 8; nc.posX = fixedPointToDouble(ins); nc.posY = fixedPointToDouble(ins); nc.ofsX = fixedPointToDouble(ins); nc.ofsY = fixedPointToDouble(ins); nc.exists = sw; npcTable[p] = nc; } }
public void save(OutputStream fos) throws IOException { for (int p = 0; p < npcTable.length; p++) { NPCCharacter nc = npcTable[p]; if (nc.exists) { fos.write(1); } else { fos.write(0); } fos.write(nc.collisionType); fos.write(nc.entityType); fos.write(nc.eventID); fos.write(nc.entityStatus & 0xFF); fos.write((nc.entityStatus & 0xFF00) >> 8); doubleToFixedPoint(nc.posX, fos); doubleToFixedPoint(nc.posY, fos); doubleToFixedPoint(nc.ofsX, fos); doubleToFixedPoint(nc.ofsY, fos); } }
@Override public Runnable saveState() { final boolean currentNullness = nulled; return () -> { nulled = currentNullness; }; }
@Override public void rmIVar(String sym) { if (nulled) throw new UnsupportedOperationException(); target.rmIVar(sym); }
@Override public IRIO addIVar(String sym) { if (nulled) return null; return target.addIVar(sym); }
@Override public MemoryishRW editUser() { if (nulled) throw new UnsupportedOperationException(); return target.editUser(); }
@Override public void putBuffer(byte[] data) { if (nulled) throw new UnsupportedOperationException(); target.putBuffer(data); }
@Override public IRIO addAElem(int i) { if (nulled) throw new UnsupportedOperationException(); return target.addAElem(i); }
@Override public void rmAElem(int i) { if (nulled) throw new UnsupportedOperationException(); target.rmAElem(i); }
@Override public IRIO addHashVal(DMKey key) { if (nulled) throw new UnsupportedOperationException(); return target.addHashVal(key); }
@Override public void removeHashVal(DMKey key) { if (nulled) throw new UnsupportedOperationException(); target.removeHashVal(key); }
@Override public void set8(long at, int v) { trackingWillChange(); super.set8(at, v); }
@Override public Runnable saveState() { byte[] copy = data.clone(); return () -> { System.arraycopy(copy, 0, data, 0, data.length); }; }
@Override public void trackingMarkClean() { clean = true; }
private void trackingWillChange() { if (clean) { if (context.changes.getLicensesToUnpackData() != 0) return; clean = false; context.changes.modifying(this); } }
public final @NonNull Block openUnpackLicense() { licensesToUnpackData.incrementAndGet(); return theLicenseToUnpackData; }
@Override public void modifying(IDM3Data modifiedData) {}
@SuppressWarnings("unchecked") @Override public Runnable saveState() { HashMap<K, V> nkv = (HashMap<K, V>) hashVal.clone(); return () -> { hashVal.clear(); hashVal.putAll(nkv); }; }
@Override public V addHashVal(DMKey key) { trackingWillChange(); K k = convertIRIOtoKey(key); V v = newValue(); hashVal.put(k, v); return v; }
@Override public void removeHashVal(DMKey key) { trackingWillChange(); K k = convertIRIOtoKey(key); hashVal.remove(k); }
@Override public IRIO addIVar(String sym) { return null; }
public String decString() { return new String(getBufferCopy(), getBufferEnc()); }
public final String toStringLong(String indent) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); try { IMIUtils.createIMIDump(new DataOutputStream(baos), this, indent); return new String(baos.toByteArray(), "UTF-8"); } catch (Exception ioe) { StringWriter sw = new StringWriter(); ioe.printStackTrace(new PrintWriter(sw)); return indent + "Couldn't dump: " + ioe + "\n" + sw; } }
@Override public final String toString() { String data = ""; int type = getType(); if (type == 'u') return getSymbol() + ";" + getBuffer().length + "b"; if (type == 'o') return getSymbol(); if (type == '[') data = getALen() + "]"; if (type == ':') data = getSymbol(); if (type == '"') return "\"" + decString() + "\""; if (type == 'f') return decString() + "f"; if (type == 'i') return Long.toString(getFX()); if (type == 'l') { String str2 = "L"; RubyBigNum working = new RubyBigNum(getBuffer(), false); boolean negated = false; if (working.isNegative()) { negated = true; working = working.negate(); } if (working.compare(RubyBigNum.ZERO) == 0) { str2 = "0L"; } else { while (working.compare(RubyBigNum.ZERO) > 0) { RubyBigNum[] res = working.divide(RubyBigNum.TEN); str2 = ((char) ('0' + res[1].truncateToLong())) + str2; working = res[0]; } } if (negated) str2 = "-" + str2; return str2; } if (type == '0') return "null"; return ((char) type) + data; }
public static boolean rubyTypeEquals(RORIO a, RORIO b) { if (a == b) return true; int aType = a.getType(); if (aType != b.getType()) return false; if (aType == 'o') return a.getSymbol().equals(b.getSymbol()); if (aType == 'u') return a.getSymbol().equals(b.getSymbol()); return true; }
public static boolean rubyEquals(RORIO a, RORIO b) { if (a == b) return true; int aType = a.getType(); if (aType != b.getType()) return false; if (aType == 'i') return a.getFX() == b.getFX(); if (aType == '\"') return a.decString().equals(b.decString()); if (aType == 'f') return a.decString().equals(b.decString()); if (aType == 'l') return new RubyBigNum(a.getBuffer(), true).compare(new RubyBigNum(b.getBuffer(), true)) == 0; if (aType == ':') return a.getSymbol().equals(b.getSymbol()); if (aType == 'T') return true; if (aType == 'F') return true; if (aType == '0') return true; return false; }
public static boolean rubySuitableKey(int i) { return (i == 'i' || i == '"' || i == 'f' || i == 'l' || i == ':' || i == 'T' || i == 'F' || i == '0'); }
@Override public Runnable saveState() { final DMBlob saved = userVal; return () -> userVal = saved; }
@Override public MemoryishRW editUser() { return userVal; }
@Override public void putBuffer(byte[] data) { trackingWillChange(); userVal = new DMBlob(context, data.clone()); }
@Override public Runnable saveState() { final IRIO[] saved = arrVal.clone(); return () -> arrVal = saved.clone(); }
@Override public T addAElem(int i) { trackingWillChange(); T rio = newValue(); IRIO[] old = arrVal; IRIO[] newArr = new IRIO[old.length + 1]; System.arraycopy(old, 0, newArr, 0, i); newArr[i] = rio; System.arraycopy(old, i, newArr, i + 1, old.length - i); arrVal = newArr; return rio; }
@Override public void rmAElem(int i) { trackingWillChange(); IRIO[] old = arrVal; IRIO[] newArr = new IRIO[old.length - 1]; System.arraycopy(old, 0, newArr, 0, i); System.arraycopy(old, i + 1, newArr, i + 1 - 1, old.length - (i + 1)); arrVal = newArr; }
public void trackingWillChange() { if (clean) { if (context.changes.getLicensesToUnpackData() != 0) return; clean = false; context.changes.modifying(this); } }
@Override public Runnable saveState() { return value ? () -> { value = true; } : () -> { value = false; }; }
@Override public final @Nullable IRIO apply(@Nullable IRIO t) { return (IRIO) getRO(t); }
public final @Nullable IRIO add(@Nullable IRIO input) { try { return addImpl(input); } catch (Throwable t) { if (strict) throw new RuntimeException("DMPath.add in strict mode...", t); t.printStackTrace(); return null; } }
public final @Nullable IRIO del(@Nullable IRIO input) { try { return delImpl(input); } catch (Throwable t) { if (strict) throw new RuntimeException("DMPath.del in strict mode...", t); t.printStackTrace(); return null; } }
public final RORIO traceRoute(RORIO target, RORIO[] elements, int offset) { try { return traceRouteImpl(target, elements, offset); } catch (Throwable t) { if (strict) throw new RuntimeException("DMPath.traceRoute in strict mode...", t); t.printStackTrace(); return null; } }
protected @Nullable IRIO addImpl(@Nullable IRIO input) { throw new RuntimeException("This path is unaddable."); }
protected @Nullable IRIO delImpl(@Nullable IRIO input) { throw new RuntimeException("This path is undeletable."); }
public final RORIO[] traceRouteComplete(RORIO target) { RORIO[] res = new RORIO[traceRouteSize + 1]; res[0] = target; traceRoute(target, res, 1); return res; }
public DMPath with(DMPath next) { return Concat.concat(strict, this, next); }
public DMPath[] breakdown() { return new DMPath[] {this}; }
public DMPath withIVar(String iv) { return with(new IVar(iv, strict)); }
public DMPath withHash(DMKey hashVal) { return with(new Hash(hashVal, strict)); }
public DMPath withArray(int index) { return with(new Array(index, strict)); }
public DMPath withArrayLength() { return with(new ArrayLength(strict)); }
public DMPath withDefVal() { return with(new HashDefaultValue(strict)); }
public DMPath withFail() { return with(new Fail(strict)); }
private static int totalTraceRouteSize(DMPath[] inputs) { int total = 0; for (DMPath dmp : inputs) total += dmp.traceRouteSize; return total; }
private static DMPath concat(boolean strict, DMPath... contents) { LinkedList<DMPath> res = new LinkedList<>(); for (DMPath dmp : contents) { if (dmp instanceof Concat) { for (DMPath dmpi : ((Concat) dmp).components) res.add(dmpi); } else if (dmp instanceof Empty) { } else { res.add(dmp); } } if (res.size() == 0) return strict ? EMPTY_STRICT : EMPTY_RELAXED; if (res.size() == 1) return res.get(0); return new Concat(strict, res.toArray(new DMPath[0])); }
@Override public String toString() { StringBuilder sb = new StringBuilder(); for (DMPath dmp : components) { sb.append(dmp); sb.append(','); } return sb.toString(); }
@Override protected IRIO addImpl(IRIO input) { for (int i = 0; i < components.length - 1; i++) { if (input == null) return null; input = (IRIO) components[i].getImpl(input); } return components[components.length - 1].addImpl(input); }
@Override protected IRIO delImpl(IRIO input) { for (int i = 0; i < components.length - 1; i++) { if (input == null) return null; input = (IRIO) components[i].getImpl(input); } return components[components.length - 1].delImpl(input); }
@Override protected RORIO traceRouteImpl(RORIO target, RORIO[] elements, int offset) { for (DMPath dmp : components) { target = dmp.traceRouteImpl(target, elements, offset); offset += dmp.traceRouteSize; } return target; }
@Override public DMPath[] breakdown() { return components.clone(); }
@Override public String toString() { return "empty"; }
@Override protected IRIO addImpl(IRIO input) { return input; }
@Override protected RORIO traceRouteImpl(RORIO target, RORIO[] elements, int offset) { return target; }
@Override protected RORIO traceRouteImpl(RORIO target, RORIO[] elements, int offset) { return elements[offset] = getImpl(target); }
@Override public String toString() { return "fail"; }
@Override public IRIO addImpl(IRIO input) { return null; }
@Override protected RORIO traceRouteImpl(RORIO target, RORIO[] elements, int offset) { return null; }
@Override public String toString() { return "i:" + key; }
@Override protected IRIO addImpl(IRIO input) { if (input == null) return null; IRIO res = input.addIVar(key); if (res == null) System.err.println("Warning: Failed to create IVar " + key + " in " + input); return res; }
@Override protected IRIO delImpl(IRIO input) { if (input == null) return null; IRIO old = input.getIVar(key); input.rmIVar(key); return old; }
@Override public String toString() { return "h:" + key; }
@Override protected IRIO addImpl(IRIO input) { if (input == null) return null; if (input.getType() != '{' && input.getType() != '}') return null; return input.addHashVal(key); }
@Override protected IRIO delImpl(IRIO input) { if (input == null) return null; if (input.getType() != '{' && input.getType() != '}') return null; IRIO old = input.getHashVal(key); input.removeHashVal(key); return old; }
@Override public String toString() { return "a:" + index; }
@Override protected IRIO addImpl(IRIO input) { if (input == null) return null; if (input.getType() != '[') return null; if (index < 0 || index >= input.getALen()) return null; return input.getAElem(index); }
@Override public String toString() { return "arrayLength"; }
@Override public String toString() { return "hashDefaultValue"; }
@Override protected IRIO addImpl(IRIO input) { if (input == null) return null; if (input.getType() != '}') return null; return input.getHashDefVal(); }
@Override public final DMKey asKey() { if (cachedDMKey != null && RORIO.rubyEquals(this, cachedDMKey)) return cachedDMKey; return cachedDMKey = DMKey.ofInternal(this); }
public IRIO appendAElem() { return addAElem(getALen()); }
public static String[] copyStringArray(String[] iVarKeys) { String[] n2 = new String[iVarKeys.length]; System.arraycopy(iVarKeys, 0, n2, 0, n2.length); return iVarKeys; }
@Override @SuppressWarnings("unchecked") public Runnable saveState() { final int typeC = type; final String symValC = symVal; final String[] iVarKeysC = (iVarKeys != null) ? iVarKeys.clone() : null; final IRIO[] iVarValsC = (iVarVals != null) ? iVarVals.clone() : null; final HashMap<DMKey, IRIO> hashValC = (hashVal != null) ? (HashMap<DMKey, IRIO>) hashVal.clone() : null; final IRIO hashDefValC = hashDefVal; final IRIO[] arrValC = (arrVal != null) ? arrVal.clone() : null; final DMBlob userValC = userVal; final String strValC = strVal; final long fixnumValC = fixnumVal; return () -> { type = typeC; symVal = symValC; iVarKeys = (iVarKeysC != null) ? iVarKeysC.clone() : null; iVarVals = (iVarValsC != null) ? iVarValsC.clone() : null; hashVal = (hashValC != null) ? (HashMap<DMKey, IRIO>) hashValC.clone() : null; hashDefVal = hashDefValC; arrVal = (arrValC != null) ? arrValC.clone() : null; userVal = userValC; strVal = strValC; fixnumVal = fixnumValC; }; }
@Override public void rmIVar(String s) { if (iVarKeys == null) return; for (int i = 0; i < iVarKeys.length; i++) { if (iVarKeys[i].equals(s)) { trackingWillChange(); String[] oldKeys = iVarKeys; IRIO[] oldVals = iVarVals; iVarKeys = new String[oldKeys.length - 1]; iVarVals = new IRIO[oldVals.length - 1]; System.arraycopy(oldKeys, 0, iVarKeys, 0, i); System.arraycopy(oldVals, 0, iVarVals, 0, i); System.arraycopy(oldKeys, i + 1, iVarKeys, i, oldKeys.length - (i + 1)); System.arraycopy(oldVals, i + 1, iVarVals, i, oldKeys.length - (i + 1)); return; } } }
@Override public void removeHashVal(DMKey rubyIO) { trackingWillChange(); hashVal.remove(rubyIO); }
@Override public IRIO addIVar(String sym) { rmIVar(sym); trackingWillChange(); IRIOGeneric rio = new IRIOGeneric(context); if (iVarKeys == null) { iVarKeys = new String[] {sym}; iVarVals = new IRIO[] {rio}; return rio; } String[] oldKeys = iVarKeys; IRIO[] oldVals = iVarVals; iVarKeys = new String[oldKeys.length + 1]; iVarVals = new IRIO[oldVals.length + 1]; System.arraycopy(oldKeys, 0, iVarKeys, 1, iVarKeys.length - 1); System.arraycopy(oldVals, 0, iVarVals, 1, iVarVals.length - 1); iVarKeys[0] = sym; iVarVals[0] = rio; return rio; }
@Override public String decString() { return strVal; }
@Override public void putBuffer(byte[] data) { trackingWillChange(); userVal = new DMBlob(context, data.clone()); if (type == '"' || type == 'f') strVal = new String(data, charset); }
@Override public IRIO addAElem(int i) { trackingWillChange(); IRIO rio = new IRIOGeneric(context); IRIO[] old = arrVal; IRIO[] newArr = new IRIO[old.length + 1]; System.arraycopy(old, 0, newArr, 0, i); newArr[i] = rio; System.arraycopy(old, i, newArr, i + 1, old.length - i); arrVal = newArr; return rio; }
@Override public IRIO addHashVal(DMKey key) { removeHashVal(key); IRIO rt = new IRIOGeneric(context); hashVal.put(key, rt); return rt; }
static @NonNull DMKey ofInternal(RORIO src) { int t = src.getType(); if (t == 'i') { return of(src.getFX()); } else if (t == 'l') { return new DMKey(Subtype.Bignum, 0, src.getBufferCopy(), null, null); } else if (t == '"') { return ofStr(src.decString()); } else if (t == 'f') { return ofFloat(src.decString()); } else if (t == ':') { return ofSym(src.decString()); } else if (t == 'T') { return TRUE; } else if (t == 'F') { return FALSE; } else if (t == '0') { return NULL; } else { IRIOGeneric refVal = new IRIOGeneric(EMBEDDED_CONTEXT); refVal.setDeepClone(src); return new DMKey(Subtype.Reference, 0, null, null, refVal); } }
public static DMKey of(long l) { return new DMKey(Subtype.Fixnum, l, null, null, null); }
public static DMKey of(boolean b) { return b ? TRUE : FALSE; }
public static DMKey ofStr(String s) { return new DMKey(Subtype.String, 0, null, s, null); }
public static DMKey ofFloat(String s) { return new DMKey(Subtype.String, 0, null, s, null); }
public static DMKey ofSym(String s) { return new DMKey(Subtype.Symbol, 0, null, s, null); }
@Override public int hashCode() { if (st == Subtype.Bignum) { return 0; } else if (st == Subtype.Fixnum) { return (int) fxVal; } else if (st == Subtype.False) { return 1; } else if (st == Subtype.True) { return 2; } else if (st == Subtype.Null) { return 3; } else if (st == Subtype.String || st == Subtype.Symbol) { return strVal.hashCode(); } return super.hashCode(); }
@Override public boolean equals(Object var1) { if (!(var1 instanceof DMKey)) return false; return IRIO.rubyEquals(this, (DMKey) var1); }
@Override public String decString() { if (st == Subtype.String) return strVal; return refVal.decString(); }
@Override public void rmIVar(String sym) { throw new UnsupportedOperationException(); }
@Override public MemoryishRW editUser() { throw new UnsupportedOperationException(); }
@Override public void putBuffer(byte[] data) { throw new UnsupportedOperationException(); }
@Override public IRIO addAElem(int i) { throw new UnsupportedOperationException(); }
@Override public void rmAElem(int i) { throw new UnsupportedOperationException(); }
@Override public IRIO addHashVal(DMKey key) { throw new UnsupportedOperationException(); }
@Override public void removeHashVal(DMKey key) { throw new UnsupportedOperationException(); }
@Override public Runnable saveState() { final long saved = val; return () -> val = saved; }
protected final void unpack() { if (!hasUnpackedYet) { hasUnpackedYet = true; try (Block license = context.changes.openUnpackLicense()) { unpackImpl(); } } }
@Override protected final void initialize() { }
@Override public final IRIO addIVar(String sym) { unpack(); return super.addIVar(sym); }
@Override public Object addField(Field f) { unpack(); return super.addField(f); }
@Override public final void rmIVar(String sym) { unpack(); super.rmIVar(sym); }
public @Nullable FXOBinding byIVar(String iVar) { return fxoBindings.get(iVar); }
public @Nullable Consumer<IRIO> iVarAddByFieldName(String field) { return fieldNameToIVarAdd.get(field); }
public static FixedObjectProps forClass(Class<?> clazz) { FixedObjectProps data = cache.get(clazz); if (data == null) { data = new FixedObjectProps(clazz); cache.put(clazz, data); } return data; }
protected final void reAddAllIVars() { try { for (FXOBinding f : cachedFields.fxoBindingsArray) { if (!f.optional) { addIVar(f.iVar); } else { trackingWillChange(); f.field.set(this, null); } } } catch (Exception e) { throw new RuntimeException(e); } }
@Override public IRIO addIVar(String sym) { FXOBinding f = cachedFields.byIVar(sym); if (f != null) return (IRIO) addFieldImpl(f.field, f.iVarAdd); return null; }
public Object addField(Field f) { return addFieldImpl(f, cachedFields.iVarAddByFieldName(f.getName())); }
private Object addFieldImpl(Field f, Consumer<IRIO> factory) { if (factory == null) return null; trackingWillChange(); factory.accept(this); try { Object res = f.get(this); if (res == null) throw new RuntimeException("Factory did not actually set a non-null value"); return res; } catch (Exception ex) { throw new RuntimeException("At field: " + f, ex); } }
@Override public void rmIVar(String sym) { FXOBinding f = cachedFields.byIVar(sym); if (f != null) { if (f.optional) { trackingWillChange(); try { f.field.set(this, null); return; } catch (IllegalAccessException e) { throw new RuntimeException(e); } } } super.rmIVar(sym); }
@SuppressWarnings("unchecked") public static @Nullable Consumer<IRIO> createIVarAddFor(@NonNull Field f) { try { Field m = null; try { m = f.getDeclaringClass().getDeclaredField(f.getName() + "_add"); } catch (Exception e2) { } if (m != null) { return (Consumer<IRIO>) m.get(null); } Method m2 = null; try { m2 = f.getDeclaringClass().getDeclaredMethod(f.getName() + "_add"); } catch (Exception e2) { } if (m2 != null) { final Method m2f = m2; return (v) -> { try { m2f.invoke(v); } catch (Exception e) { throw new RuntimeException("At field: " + f, e); } }; } Function<DMContext, Object> factory = createFactoryFor(f); if (factory == null) return null; return (obj) -> { try { f.set(obj, factory.apply(obj.context)); } catch (Exception e) { throw new RuntimeException("At field: " + f, e); } }; } catch (Exception e) { throw new RuntimeException("At field: " + f, e); } }
private static @Nullable Function<DMContext, Object> createFactoryFor(@NonNull Field f) throws NoSuchMethodException { final DMCXSupplier fxd = f.getAnnotation(DMCXSupplier.class); DMCXInteger fxi = f.getAnnotation(DMCXInteger.class); DMCXBoolean fxb = f.getAnnotation(DMCXBoolean.class); boolean fxo = f.isAnnotationPresent(DMCXObject.class); return createFactoryFor(f, f.getType(), fxd, fxi, fxb, fxo); }
public static Save readLsd(DMContext dm2c, InputStream fis) throws IOException { String magic = R2kUtil.decodeLcfString(dm2c, IntUtils.readBytes(fis, R2kUtil.readLcfVLI(fis))); if (!magic.equals("LcfSaveData")) System.err.println("Loading a file which pretends to be an LCF save file but says " + magic); Save mu = new Save(dm2c); mu.importData(fis); return mu; }
public static void writeLsd(OutputStream fos, Save rio) throws IOException { byte[] d = R2kUtil.encodeLcfString(rio.context, "LcfSaveData"); R2kUtil.writeLcfVLI(fos, d.length); fos.write(d); rio.exportData(fos); }
public static Database readLdb(DMContext context, InputStream fis) throws IOException { String magic = R2kUtil.decodeLcfString(context, IntUtils.readBytes(fis, R2kUtil.readLcfVLI(fis))); if (!magic.equals("LcfDataBase")) System.err.println("Loading a file which pretends to be an LCF database but says " + magic); Database mu = new Database(context); mu.importData(fis); return mu; }
public static void writeLdb(OutputStream fos, Database db) throws IOException { byte[] d = R2kUtil.encodeLcfString(db.context, "LcfDataBase"); R2kUtil.writeLcfVLI(fos, d.length); fos.write(d); db.exportData(fos); }
public static MapUnit readLmu(DMContext dm2c, InputStream fis) throws IOException { String magic = R2kUtil.decodeLcfString(dm2c, IntUtils.readBytes(fis, R2kUtil.readLcfVLI(fis))); if (!magic.equals("LcfMapUnit")) System.err.println("Loading a file which pretends to be an LCF map but says " + magic); MapUnit mu = new MapUnit(dm2c); mu.importData(fis); return mu; }
public static void writeLmu(OutputStream fos, MapUnit rio) throws IOException { byte[] d = R2kUtil.encodeLcfString(rio.context, "LcfMapUnit"); R2kUtil.writeLcfVLI(fos, d.length); fos.write(d); rio.exportData(fos); }
public static MapTree readLmt(DMContext dm2c, InputStream fis) throws IOException { String magic = R2kUtil.decodeLcfString(dm2c, IntUtils.readBytes(fis, R2kUtil.readLcfVLI(fis))); if (!magic.equals("LcfMapTree")) System.err.println("Loading a file which pretends to be an LCF map tree but says " + magic); MapTree mu = new MapTree(dm2c); mu.importData(fis); return mu; }
public static void writeLmt(OutputStream fos, MapTree db) throws IOException { byte[] d = R2kUtil.encodeLcfString(db.context, "LcfMapTree"); R2kUtil.writeLcfVLI(fos, d.length); fos.write(d); db.exportData(fos); }
private static ByteArrayInputStream baos(byte[] data) { return new ByteArrayInputStream(data); }
private static void baosCleanup(ByteArrayInputStream a) throws IOException { if (a.available() > 0) throw new IOException("Not all of the data was consumed in the operation."); }
public static int readLcfVLI(byte[] data) throws IOException { ByteArrayInputStream a = baos(data); int r = readLcfVLI(a); baosCleanup(a); return r; }
public static int readLcfVLI(InputStream src) throws IOException { int v = 0; while (true) { int b = IntUtils.readU8(src); v = v << 7; v |= b & 0x7F; if ((b & 0x80) == 0) break; } return v; }
public static void writeLcfVLI(OutputStream os, int i) throws IOException { long r = i & 0xFFFFFFFFL; LinkedList<Integer> bytes = new LinkedList<Integer>(); while (r > 0x7F) { bytes.add((int) (r & 0x7F)); r >>= 7; } bytes.add((int) (r & 0x7F)); Collections.reverse(bytes); int bc = bytes.size(); for (int ib : bytes) { if (bc > 1) { os.write(ib | 0x80); bc--; } else { os.write(ib); } } }
public static String decodeLcfString(DMContext dm2c, byte[] data) { return new String(data, dm2c.encoding); }
public static byte[] encodeLcfString(DMContext dm2c, String text) { return text.getBytes(dm2c.encoding); }
public static void unkToRio(IRIO map, HashMap<Integer, byte[]> unknownChunks) { if (unknownChunks.isEmpty()) return; IRIO hash = map.addIVar("@__LCF__unknown"); hash.setHash(); for (Map.Entry<Integer, byte[]> e : unknownChunks.entrySet()) { hash.addHashVal(DMKey.of(e.getKey())).setUser("Blob", e.getValue()); } }
public static void rioToUnk(IRIO mt, HashMap<Integer, byte[]> unknownChunks) { mt = mt.getIVar("@__LCF__unknown"); if (mt != null) for (DMKey k : mt.getHashKeys()) unknownChunks.put((int) k.getFX(), mt.getHashVal(k).getBufferCopy()); }
@Override public byte[] get() { byte[] data = new byte[i]; for (int j = 0; j < i; j++) data[j] = i1; return data; }
public static <T> void importSparse( HashMap<Integer, T> map, Supplier<T> constructor, InputStream bais) throws IOException { map.clear(); int entries = readLcfVLI(bais); for (int i = 0; i < entries; i++) { int k = readLcfVLI(bais); T target = constructor.get(); try { ((IR2kInterpretable) target).importData(bais); } catch (IOException e) { throw new IOException("In element " + i, e); } catch (RuntimeException e) { throw new RuntimeException("In element " + i, e); } map.put(k, target); } }
public static void exportSparse(HashMap<Integer, ?> map, OutputStream baos) throws IOException { LinkedList<Integer> sort = new LinkedList<Integer>(map.keySet()); Collections.sort(sort); writeLcfVLI(baos, sort.size()); for (Integer i : sort) { writeLcfVLI(baos, i); ((IR2kInterpretable) map.get(i)).exportData(baos); } }
@Override public Runnable saveState() { final byte[] saved = data; final ByteArrayMemoryish savedBAM = dataBAM; final String savedDecoded = dataDecoded; return () -> { data = saved; dataBAM = savedBAM; dataDecoded = savedDecoded; }; }
@Override public void putBuffer(byte[] dat) { trackingWillChange(); data = dat; dataBAM = new ByteArrayMemoryish(data); dataDecoded = new String(dat, encoding); }
@Override public String decString() { return dataDecoded; }
@Override public void importData(InputStream bais) throws IOException { putBuffer(IntUtils.readBytes(bais, bais.available())); }
@Override public boolean canOmitChunk() { return false; }
@Override public void exportData(OutputStream baos) throws IOException { baos.write(data); }
@Override public void exportData(OutputStream baos) throws IOException { getBuffer().getBulk(baos); }
@Override public void importData(InputStream bais) throws IOException { setBool(R2kUtil.readLcfVLI(bais) != 0); }
@Override public boolean canOmitChunk() { return false; }
@Override public void exportData(OutputStream baos) throws IOException { R2kUtil.writeLcfVLI(baos, getBool() ? 1 : 0); }
@Override public Runnable saveState() { IRIOBoolean[] storedArray = flagData.clone(); return () -> System.arraycopy(storedArray, 0, flagData, 0, flagData.length); }
@Override public void importData(InputStream bais) throws IOException { int value = IntUtils.readU8(bais); importData(value); }
public void importData(int flag) { for (int i = 0; i < 8; i++) flagData[i].setBool((flag & (1 << i)) != 0); }
@Override public void exportData(OutputStream baos) throws IOException { int value = 0; for (int i = 0; i < 8; i++) if (flagData[i].getType() == 'T') value |= 1 << i; baos.write(value); }
@Override public IRIO addIVar(String sym) { for (int i = 0; i < flags.length; i++) { String s = flags[i]; if (s.equals(sym)) { trackingWillChange(); return flagData[i] = new IRIOBoolean(context, false); } } return null; }
@Override public Runnable saveState() { final byte saved = value; return () -> value = saved; }
@Override public void importData(InputStream bais) throws IOException { value = (byte) IntUtils.readU8(bais); }
@Override public void exportData(OutputStream baos) throws IOException { baos.write(value); }
@Override public Runnable saveState() { final int saved = i; return () -> i = saved; }
@Override public void importData(InputStream bais) throws IOException { i = R2kUtil.readLcfVLI(bais); }
@Override public void exportData(OutputStream baos) throws IOException { R2kUtil.writeLcfVLI(baos, i); }
@Override public Runnable saveState() { final short saved = value; return () -> value = saved; }
@Override public void importData(InputStream bais) throws IOException { value = (short) IntUtils.readU16(bais); }
@Override public void exportData(OutputStream baos) throws IOException { IntUtils.writeU16(baos, value); }
@Override public Runnable saveState() { final double saved = v; return () -> v = saved; }
@Override public String decString() { return Double.toString(v); }
@Override public void putBuffer(byte[] data) { trackingWillChange(); v = Double.parseDouble(IntUtils.decodeRbFloat(data)); }
@Override public void importData(InputStream bais) throws IOException { byte[] data = new byte[8]; if (bais.read(data) != 8) throw new IOException("Didn't get whole double"); DataInputStream dis = new DataInputStream(new ByteArrayInputStream(data)); swap(data, 7, 0); swap(data, 6, 1); swap(data, 5, 2); swap(data, 4, 3); v = dis.readDouble(); }
private void swap(byte[] data, int i, int i1) { byte p = data[i]; data[i] = data[i1]; data[i1] = p; }
@Override public void exportData(OutputStream baos) throws IOException { ByteArrayOutputStream preswap = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(preswap); dos.writeDouble(v); byte[] data = preswap.toByteArray(); swap(data, 7, 0); swap(data, 6, 1); swap(data, 5, 2); swap(data, 4, 3); baos.write(data); }
@Override public void importData(InputStream bais) throws IOException { setFX(IntUtils.readS32(bais)); }
@Override public void exportData(OutputStream baos) throws IOException { IntUtils.writeS32(baos, (int) getFX()); }
@Override public IRIONullable<V> newValue() { return new IRIONullable<V>(constructor.get(), true); }
@Override public void importData(InputStream bais) throws IOException { HashMap<Integer, V> hashVal = new HashMap<>(); R2kUtil.importSparse(hashVal, constructor, bais); int maxEnt = -1; for (Map.Entry<Integer, V> ent : hashVal.entrySet()) if (maxEnt < ent.getKey()) maxEnt = ent.getKey(); arrVal = new IRIO[maxEnt + 1]; for (int i = 0; i < arrVal.length; i++) { V entVal = hashVal.get(i); if (entVal == null) { arrVal[i] = newValue(); } else { arrVal[i] = new IRIONullable<V>(entVal, false); } } }
@Override public void exportData(OutputStream baos) throws IOException { HashMap<Integer, V> hashVal = new HashMap<>(); for (int i = 0; i < arrVal.length; i++) { @SuppressWarnings("unchecked") IRIONullable<V> v = (IRIONullable<V>) arrVal[i]; if (!v.nulled) hashVal.put(i, v.target); } R2kUtil.exportSparse(hashVal, baos); }
@Override public IRIOFixedUser newValue() { return new IRIOFixedUser(context, "Blob", new byte[0]); }
protected final HashMap<Integer, byte[]> dm2Pack() throws IOException { if (packedChunkData != null) return packedChunkData; HashMap<Integer, byte[]> ws = new HashMap<Integer, byte[]>(); dm2PackIntoMap(ws); if (unknownChunks != null) for (Map.Entry<Integer, IRIOFixedUser> uv : unknownChunks.hashVal.entrySet()) ws.put(uv.getKey(), uv.getValue().getBufferCopy()); return ws; }
@Override protected void unpackImpl() { HashMap<Integer, byte[]> pcd = packedChunkData; packedChunkData = null; unknownChunks = null; dm2UnpackFromMapDestructively(pcd); if (pcd.size() > 0) { setUnknownChunks(); for (Map.Entry<Integer, byte[]> me : pcd.entrySet()) unknownChunks.hashVal.put(me.getKey(), new IRIOFixedUser(context, "Blob", me.getValue())); } }
@Override protected void erasePackedDataImpl() { packedChunkData = null; }
protected void dm2PackIntoMap(HashMap<Integer, byte[]> pcd) throws IOException { for (Field f : cachedFields.fieldsArray) { DM2LcfBinding dlb = f.getAnnotation(DM2LcfBinding.class); if (dlb != null) { IR2kInterpretable iri; try { iri = (IR2kInterpretable) f.get(this); } catch (IllegalAccessException e) { throw new RuntimeException(e); } if (iri != null) { if (!iri.canOmitChunk()) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); iri.exportData(baos); pcd.put(dlb.value(), baos.toByteArray()); } DM2LcfSizeBinding dlb2 = f.getAnnotation(DM2LcfSizeBinding.class); if (dlb2 != null) { IR2kSizable isi; try { isi = (IR2kSizable) f.get(this); } catch (IllegalAccessException e) { throw new RuntimeException(e); } if (isi != null) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); isi.exportSize(baos); pcd.put(dlb2.value(), baos.toByteArray()); } } } } } }
public void importData(InputStream src) throws IOException { packedChunkData = new HashMap<Integer, byte[]>(); while (true) { if (src.available() == 0) if (terminatable()) break; int cid = R2kUtil.readLcfVLI(src); if (cid == 0) break; int len = R2kUtil.readLcfVLI(src); byte[] data = IntUtils.readBytes(src, len); packedChunkData.put(cid, data); } }
@Override public void exportData(OutputStream baos) throws IOException { HashMap<Integer, byte[]> packed = dm2Pack(); LinkedList<Integer> keys = new LinkedList<Integer>(packed.keySet()); Collections.sort(keys); for (Integer i : keys) { byte[] data = packed.get(i); R2kUtil.writeLcfVLI(baos, i); R2kUtil.writeLcfVLI(baos, data.length); baos.write(data); } if (!terminatable()) baos.write(0); }
@Override public void importData(InputStream bais) throws IOException { LinkedList<V> array = new LinkedList<V>(); while (bais.available() > 0) { try { V v = newValue(); ((IR2kInterpretable) v).importData(bais); array.add(v); } catch (IOException re) { if (trustData) throw new IOException("While parsing in array of " + (newValue().getClass()), re); } catch (RuntimeException re) { if (trustData) throw new IOException("While parsing in array of " + (newValue().getClass()), re); } } arrVal = array.toArray(new IRIO[0]); }
@Override public void exportData(OutputStream baos) throws IOException { for (IRIO v : arrVal) ((IR2kInterpretable) v).exportData(baos); }
@Override public void exportSize(OutputStream baos) throws IOException { int v = arrVal.length; if (!sizeUnit) { ByteArrayOutputStream b2 = new ByteArrayOutputStream(); exportData(b2); v = b2.size(); } switch (sizeMode) { case 0: R2kUtil.writeLcfVLI(baos, v); break; case 1: if (v > 255) throw new IOException("Too big array."); baos.write(v); break; default: throw new RuntimeException("unknown B " + sizeMode); } }
@Override public V newValue() { return constructor.get(); }
@Override public void importData(InputStream bais) throws IOException { R2kUtil.importSparse(hashVal, constructor, bais); }
@Override public void exportData(OutputStream baos) throws IOException { R2kUtil.exportSparse(hashVal, baos); }
@Override public void importData(InputStream bais) throws IOException { hashVal.clear(); int k = 0; while (bais.available() > 0) { try { V v = newValue(); ((IR2kInterpretable) v).importData(bais); hashVal.put(k++, v); } catch (IOException re) { if (trustData) throw new IOException("While parsing in array of " + (newValue().getClass()), re); } catch (RuntimeException re) { if (trustData) throw new IOException("While parsing in array of " + (newValue().getClass()), re); } } }
@Override public void exportData(OutputStream baos) throws IOException { int maxIdx = -1; for (Integer rio : hashVal.keySet()) if (rio > maxIdx) maxIdx = rio; for (int i = 0; i <= maxIdx; i++) { V v = hashVal.get(i); if (v == null) v = newValue(); ((IR2kInterpretable) v).exportData(baos); } }
@Override public void exportSize(OutputStream baos) throws IOException { int v; if (!sizeUnit) { ByteArrayOutputStream b2 = new ByteArrayOutputStream(); exportData(b2); v = b2.size(); } else { v = 0; for (Integer rio : hashVal.keySet()) if (rio >= v) v = rio + 1; } switch (sizeMode) { case 0: R2kUtil.writeLcfVLI(baos, v); break; case 1: if (v > 255) throw new IOException("Too big array."); baos.write(v); break; default: throw new RuntimeException("unknown B " + sizeMode); } }
@Override public Runnable saveState() { IRIOFixnum[] storedArray = array.clone(); return () -> System.arraycopy(storedArray, 0, array, 0, array.length); }
@Override public void importData(InputStream bais) throws IOException { for (int i = 0; i < array.length; i++) array[i].setFX(IntUtils.readU16(bais)); }
@Override public void exportData(OutputStream baos) throws IOException { for (int i = 0; i < array.length; i++) IntUtils.writeU16(baos, (int) array[i].getFX()); }
@Override public IRIO addAElem(int i) { if (i == 0) throw new RuntimeException("The text cannot be inserted."); return super.addAElem(i - 1); }
@Override public void rmAElem(int i) { if (i == 0) throw new RuntimeException("The text cannot be removed."); super.rmAElem(i - 1); }
@Override public IRIO newValue() { return new IRIOFixnum(context, 0); }
@Override public MoveCommand newValue() { return new MoveCommand(context); }
@Override public void importData(InputStream bais) throws IOException { int codeVal = R2kUtil.readLcfVLI(bais); code.setFX(codeVal); indent.setFX(R2kUtil.readLcfVLI(bais)); parameters.text.putBuffer(IntUtils.readBytes(bais, R2kUtil.readLcfVLI(bais))); if (codeVal != 11330) { moveCommands = null; parameters.arrVal = new IRIO[R2kUtil.readLcfVLI(bais)]; for (int i = 0; i < parameters.arrVal.length; i++) parameters.arrVal[i] = new IRIOFixnum(context, R2kUtil.readLcfVLI(bais)); } else { parameters.arrVal = new IRIO[4]; int[] remainingStream = new int[R2kUtil.readLcfVLI(bais) - 4]; for (int i = 0; i < parameters.arrVal.length; i++) parameters.arrVal[i] = new IRIOFixnum(context, R2kUtil.readLcfVLI(bais)); for (int i = 0; i < remainingStream.length; i++) remainingStream[i] = R2kUtil.readLcfVLI(bais); addIVar("@move_commands"); moveCommands.arrVal = MoveCommand.fromEmbeddedData(context, remainingStream); } }
@Override public void exportData(OutputStream baos) throws IOException { int codeVal = (int) code.getFX(); R2kUtil.writeLcfVLI(baos, (int) codeVal); R2kUtil.writeLcfVLI(baos, (int) indent.getFX()); MemoryishR buf = parameters.text.getBuffer(); R2kUtil.writeLcfVLI(baos, (int) buf.length); buf.getBulk(baos); if (codeVal != 11330) { R2kUtil.writeLcfVLI(baos, parameters.arrVal.length); for (int i = 0; i < parameters.arrVal.length; i++) R2kUtil.writeLcfVLI(baos, (int) parameters.arrVal[i].getFX()); } else { int[] encoded = MoveCommand.toEmbeddedData(moveCommands); R2kUtil.writeLcfVLI(baos, encoded.length + 4); for (int i = 0; i < 4; i++) R2kUtil.writeLcfVLI(baos, (int) parameters.arrVal[i].getFX()); for (int i = 0; i < encoded.length; i++) R2kUtil.writeLcfVLI(baos, encoded[i]); } }
@Override public void importData(InputStream fis) throws IOException { mapInfos.importData(fis); mapOrder.arrVal = new IRIO[R2kUtil.readLcfVLI(fis)]; for (int i = 0; i < mapOrder.arrVal.length; i++) mapOrder.arrVal[i] = new IRIOFixnum(context, R2kUtil.readLcfVLI(fis)); activeNode.importData(fis); start = new MapTreeStart(context); start.importData(fis); }
@Override public void exportData(OutputStream baos) throws IOException { mapInfos.exportData(baos); R2kUtil.writeLcfVLI(baos, mapOrder.arrVal.length); for (int i = 0; i < mapOrder.arrVal.length; i++) R2kUtil.writeLcfVLI(baos, (int) ((IRIOFixnum) mapOrder.arrVal[i]).getFX()); activeNode.exportData(baos); start.exportData(baos); }
private static int moveCommandClassifier(int code) { int para = 0; if ((code == 34) || (code == 35)) para |= 0x100; if ((code == 32) || (code == 33) || (code == 34) || (code == 35)) para += 1; if (code == 35) para += 2; return para; }
public static MoveCommand[] fromEmbeddedData(DMContext ctx, int[] remainingStream) { try { return fromEmbeddedDataInside(ctx, remainingStream); } catch (Exception ex) { StringBuilder sb = new StringBuilder(); sb.append("In MoveCommand stream"); for (int i : remainingStream) { sb.append(' '); sb.append(i); } throw new RuntimeException(sb.toString(), ex); } }
public static int popMetaInteger(Iterator<Integer> si) { int res = 0; while (true) { int val = si.next(); res = (res << 7) | (val & 0x7F); if ((val & 0x80) == 0) break; } return res; }
public static void addMetaInteger(List<Integer> si, int val) { addMetaInteger(si, val, false); }
private static void addMetaInteger(List<Integer> si, int val, boolean markLast) { if ((val & 0xFFFFFF80) != 0) addMetaInteger(si, (val >> 7) & 0x01FFFFFF, true); val &= 0x7F; if (markLast) val |= 0x80; si.add(val); }
private static MoveCommand[] fromEmbeddedDataInside(DMContext ctx, int[] remainingStream) { Iterator<Integer> si = new IntArrayIterable.ArrayIterator(remainingStream); LinkedList<MoveCommand> mcs = new LinkedList<MoveCommand>(); while (si.hasNext()) { int code = si.next(); MoveCommand mc = new MoveCommand(ctx); mc.code.setFX(code); IRIOFixnum a = new IRIOFixnum(ctx, 0); IRIOFixnum b = new IRIOFixnum(ctx, 0); IRIOFixnum c = new IRIOFixnum(ctx, 0); mc.parameters.arrVal = new IRIO[] {a, b, c}; int mcc = moveCommandClassifier(code); if ((mcc & 0x100) != 0) { byte[] newText = new byte[popMetaInteger(si)]; for (int i = 0; i < newText.length; i++) newText[i] = (byte) (int) si.next(); mc.parameters.text.putBuffer(newText); } if ((mcc & 0xFF) > 0) a.setFX(popMetaInteger(si)); if ((mcc & 0xFF) > 1) b.setFX(popMetaInteger(si)); if ((mcc & 0xFF) > 2) c.setFX(popMetaInteger(si)); if ((mcc & 0xFF) > 3) throw new RuntimeException("invalid MCC"); mcs.add(mc); } return mcs.toArray(new MoveCommand[0]); }
public static int[] toEmbeddedData(IRIOFixedArray<MoveCommand> moveCommands) { LinkedList<Integer> res = new LinkedList<Integer>(); for (IRIO mci : moveCommands.arrVal) { MoveCommand mc = (MoveCommand) mci; int codeVal = (int) mc.code.getFX(); res.add(codeVal); int mcc = moveCommandClassifier(codeVal); if ((mcc & 0x100) != 0) { MemoryishR text = mc.parameters.text.getBuffer(); addMetaInteger(res, (int) text.length); for (int i = 0; i < text.length; i++) res.add(text.getU8(i)); } if ((mcc & 0xFF) > 0) addMetaInteger(res, (int) mc.parameters.arrVal[0].getFX()); if ((mcc & 0xFF) > 1) addMetaInteger(res, (int) mc.parameters.arrVal[1].getFX()); if ((mcc & 0xFF) > 2) addMetaInteger(res, (int) mc.parameters.arrVal[2].getFX()); if ((mcc & 0xFF) > 3) throw new RuntimeException("invalid MCC"); } int[] r = new int[res.size()]; int idx = 0; for (Integer i : res) r[idx++] = i; return r; }
@Override public void importData(InputStream bais) throws IOException { int codeVal = R2kUtil.readLcfVLI(bais); code.setFX(codeVal); addIVar("@parameters"); IRIOFixnum a = new IRIOFixnum(context, 0); IRIOFixnum b = new IRIOFixnum(context, 0); IRIOFixnum c = new IRIOFixnum(context, 0); parameters.arrVal = new IRIO[] {a, b, c}; int mcc = moveCommandClassifier(codeVal); if ((mcc & 0x100) != 0) parameters.text.putBuffer(IntUtils.readBytes(bais, R2kUtil.readLcfVLI(bais))); for (int i = 0; i < (mcc & 0xFF); i++) parameters.arrVal[i].setFX(R2kUtil.readLcfVLI(bais)); }
@Override public void exportData(OutputStream baos) throws IOException { int codeVal = (int) code.getFX(); R2kUtil.writeLcfVLI(baos, codeVal); int mcc = moveCommandClassifier(codeVal); if ((mcc & 0x100) != 0) { MemoryishR data = parameters.text.getBuffer(); R2kUtil.writeLcfVLI(baos, (int) data.length); data.getBulk(baos); } for (int i = 0; i < (mcc & 0xFF); i++) R2kUtil.writeLcfVLI(baos, (int) parameters.arrVal[i].getFX()); }
@Override public void importData(InputStream bais) throws IOException { l.setFX(IntUtils.readS32(bais)); u.setFX(IntUtils.readS32(bais)); r.setFX(IntUtils.readS32(bais)); d.setFX(IntUtils.readS32(bais)); }
@Override public void exportData(OutputStream baos) throws IOException { IntUtils.writeS32(baos, (int) l.getFX()); IntUtils.writeS32(baos, (int) u.getFX()); IntUtils.writeS32(baos, (int) r.getFX()); IntUtils.writeS32(baos, (int) d.getFX()); }
@Override public void importData(InputStream bais) throws IOException { byte[] md = new byte[50 * 6 * 2]; bais.read(md); parameters1.importData(new ByteArrayInputStream(md)); if (bais.available() > 0) { addIVar("@51to99_2k3"); parameters2.importData(bais); } else { parameters2 = null; } }
@Override public void exportData(OutputStream baos) throws IOException { parameters1.exportData(baos); if (parameters2 != null) parameters2.exportData(baos); }
@Override public BattleParamBlock newValue() { return new BattleParamBlock(context); }
@Override public void importData(InputStream bais) throws IOException { while (true) { int idx = R2kUtil.readLcfVLI(bais); if (idx == 0) break; int len = R2kUtil.readLcfVLI(bais); byte[] data = IntUtils.readBytes(bais, len); if (idx == 1) { this.putBuffer(data); } else { System.err.println("UNKNOWN SVStore CHUNK: " + idx); } } }
@Override public void exportData(OutputStream baos) throws IOException { R2kUtil.writeLcfVLI(baos, 1); MemoryishR data = getBuffer(); R2kUtil.writeLcfVLI(baos, (int) data.length); data.getBulk(baos); baos.write(0); }
@Override protected void dm2UnpackFromMapDestructively(HashMap<Integer, byte[]> pcd) { super.dm2UnpackFromMapDestructively(pcd); byte[] layer0 = pcd.remove(71); byte[] layer1 = pcd.remove(72); if (layer0 == null) layer0 = new byte[20 * 15 * 2]; if (layer1 == null) layer1 = new byte[20 * 15 * 2]; int w = (int) width.getFX(); int h = (int) height.getFX(); ByteArrayMemoryish bam = RubyTable.initNewTable(3, w, h, 2, new int[] {0, 0}); System.arraycopy(layer0, 0, bam.data, 20, layer0.length); System.arraycopy(layer1, 0, bam.data, 20 + (w * h * 2), layer1.length); map = new IRIOFixedUser(context, "Table", bam.data); }
@Override protected void dm2PackIntoMap(HashMap<Integer, byte[]> pcd) throws IOException { super.dm2PackIntoMap(pcd); int w = (int) width.getFX(); int h = (int) height.getFX(); byte[] layer0 = new byte[w * h * 2]; byte[] layer1 = new byte[w * h * 2]; MemoryishR innerBytes = map.getBuffer(); innerBytes.getBulk(20, layer0, 0, layer0.length); innerBytes.getBulk(20 + (w * h * 2), layer1, 0, layer1.length); pcd.put(71, layer0); pcd.put(72, layer1); }
@Override public ByteR2kStruct newValue() { return new ByteR2kStruct(context, 0); }
@Override public boolean terminatable() { return true; }
@Override protected void dm2UnpackFromMapDestructively(HashMap<Integer, byte[]> pcd) { byte[] uv = pcd.get(3); if (uv != null) { ByteArrayMemoryish rt = RubyTable.initNewTable(3, 162, 1, 1, new int[] {0}); System.arraycopy(uv, 0, rt.data, 20, Math.min(uv.length, rt.data.length - 20)); pcd.put(3, rt.data); } uv = pcd.get(4); if (uv != null) pcd.put(4, bitfieldsToTable(uv)); uv = pcd.get(5); if (uv != null) pcd.put(5, bitfieldsToTable(uv)); super.dm2UnpackFromMapDestructively(pcd); }
@Override protected void dm2PackIntoMap(HashMap<Integer, byte[]> pcd) throws IOException { super.dm2PackIntoMap(pcd); byte[] uv = new byte[324]; MemoryishR terrainBuf = terrainTbl.getBuffer(); terrainBuf.getBulk(20, uv, 0, Math.min(uv.length, (int) terrainBuf.length - 20)); pcd.put(3, uv); pcd.put(4, tableToBitfields(lowPassTbl.getBufferCopy())); pcd.put(5, tableToBitfields(highPassTbl.getBufferCopy())); }
private byte[] bitfieldsToTable(byte[] dat) { ByteArrayMemoryish rt = RubyTable.initNewTable(3, dat.length, 1, 1, new int[] {0}); for (int i = 0; i < dat.length; i++) rt.data[20 + (i * 2)] = dat[i]; return rt.data; }
private byte[] tableToBitfields(byte[] src) { RubyTableR rt = new RubyTableR(src); byte[] r = new byte[rt.width]; for (int i = 0; i < r.length; i++) r[i] = (byte) rt.getTiletype(i, 0, 0); return r; }
@Override public ByteR2kStruct newValue() { return new ByteR2kStruct(context, 2); }
@Override protected void dm2UnpackFromMapDestructively(HashMap<Integer, byte[]> pcd) { super.dm2UnpackFromMapDestructively(pcd); byte[] flags = pcd.remove(1); if (flags != null) { if (flags.length == 1) { flagsA.importData(flags[0]); } else if (flags.length == 2) { flagsA.importData(flags[0]); flagsB.importData(flags[1]); } else { throw new RuntimeException("bad flags len " + flags.length); } } }
@Override protected void dm2PackIntoMap(HashMap<Integer, byte[]> pcd) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); flagsA.exportData(baos); flagsB.exportData(baos); pcd.put(1, baos.toByteArray()); super.dm2PackIntoMap(pcd); }
@Override public BooleanR2kStruct newValue() { return new BooleanR2kStruct(context, false); }
@Override public BooleanR2kStruct newValue() { return new BooleanR2kStruct(context, b); }
private BlobR2kStruct newBlankRemap() { byte[] blank = new byte[0x90]; for (int i = 0; i < blank.length; i++) blank[i] = (byte) i; return new BlobR2kStruct(context, "Table", bToTable(blank)); }
@Override protected void dm2UnpackFromMapDestructively(HashMap<Integer, byte[]> pcd) { byte[] lowerMap = pcd.get(0x15); if (lowerMap != null) pcd.put(0x15, bToTable(lowerMap)); byte[] upperMap = pcd.get(0x16); if (upperMap != null) pcd.put(0x16, bToTable(upperMap)); super.dm2UnpackFromMapDestructively(pcd); }
@Override protected void dm2PackIntoMap(HashMap<Integer, byte[]> pcd) throws IOException { super.dm2PackIntoMap(pcd); pcd.put(0x15, bFromTable(lowerTileRemap.getBuffer())); pcd.put(0x16, bFromTable(upperTileRemap.getBuffer())); }
private byte[] bToTable(byte[] dat) { ByteArrayMemoryish bam = RubyTable.initNewTable(3, dat.length, 1, 1, new int[] {0}); RubyTable rt = new RubyTable(bam); for (int i = 0; i < dat.length; i++) rt.setTiletype(i, 0, 0, (short) (dat[i] & 0xFF)); return bam.data; }
private byte[] bFromTable(MemoryishR instVarBySymbol) { RubyTableR rt = new RubyTableR(instVarBySymbol); byte[] data = new byte[rt.width]; for (int i = 0; i < data.length; i++) data[i] = (byte) rt.getTiletype(i, 0, 0); return data; }
@Override public ShortR2kStruct newValue() { return new ShortR2kStruct(context, 0); }
@Override protected void dm2UnpackFromMapDestructively(HashMap<Integer, byte[]> pcd) { super.dm2UnpackFromMapDestructively(pcd); inventoryView.arrVal = new IRIO[(int) inventorySize.getFX()]; for (int i = 0; i < inventoryView.arrVal.length; i++) { SaveItem si = new SaveItem(context); si.id = (ShortR2kStruct) inventoryIds.arrVal[i]; si.count = (ByteR2kStruct) inventoryCounts.arrVal[i]; si.usage = (ByteR2kStruct) inventoryUsage.arrVal[i]; inventoryView.arrVal[i] = si; } inventorySize = null; inventoryIds = null; inventoryCounts = null; inventoryUsage = null; }
@Override protected void dm2PackIntoMap(HashMap<Integer, byte[]> pcd) throws IOException { inventorySize = new IntegerR2kStruct(context, 0); inventoryIds = newShortArray(); inventoryCounts = newByteArray(); inventoryUsage = newByteArray(); super.dm2PackIntoMap(pcd); inventorySize = null; inventoryIds = null; inventoryCounts = null; inventoryUsage = null; }
@Override public void register(ToolRegistry registry) { registry.register(DevBuildTool.class); registry.register(ReleaseBuildTool.class); }
public void runInnards( ToolEnvironment env, String brand, String androidPackage, int androidVersionCode, boolean isDev) throws Exception { MajorRoutines.ready(env); if (env.hasAnyErrorOccurred()) return; if (!isDev) { env.info("Checking natives..."); NativesInstallTester.PREREQUISITE.run(); } env.info("Building R48..."); ProcessBuilder pb = new ProcessBuilder( "./releaser-core.sh", brand, androidPackage, releaseName, Integer.toString(androidVersionCode), isDev ? "1" : "0"); if (isDev) pb.environment().put("GABIEN_NATIVES_DEV", "1"); pb.directory(new File("releaser")); pb.inheritIO(); if (pb.start().waitFor() != 0) env.error("Error in releaser-core.sh"); }
@Override public void run(ToolEnvironment env) throws Exception { runInnards(env, "R48-DEV", "t20kdc.experimental.r48dev", 1, true); if (env.hasAnyErrorOccurred()) return; if (!(skipAndroid || noADB)) { env.info("Installing to Android device..."); Commands.runOptional(env, new File("."), "adb", "install", "-r", releaseName + ".apk"); } }
@Override public void run(ToolEnvironment env) throws Exception { runInnards(env, "R48", "t20kdc.experimental.r48", androidVersionCode, false); }
private void clickIcon(UITabBar.Tab sh, int ico) { sh.icons[ico].click(sh); }
public void selectTab(UIElement element) { App app = getApp(); app.ui.wm.tabPane.selectTab(element); }
private static boolean aContainsB(UIElement a, UIElement b) { if (a == null) return true; while (b != null) { if (b == a) return true; b = b.getParent(); } return false; }
private static String identifyCls(UIElement uie) { if (uie instanceof UIIconButton) return "symbol"; if (uie instanceof UITextButton) return "button"; if (uie instanceof UITextBox) return "textbox"; if (uie instanceof UILabel) return "label"; if (uie instanceof UIScrollLayout) return "scroll"; if (uie instanceof UIListLayout) return "list"; if (uie instanceof UITabPane) return "tabpane"; if (uie instanceof UIScrollbar) return "scrollbar"; return "?"; }
private static String identify(UIElement uie) { if (uie instanceof UIIconButton) return "symbol:" + ((Art.Symbol.Instance) (((UIIconButton) uie).symbol)).name(); if (uie instanceof UITextButton) return "button:" + ((UITextButton) uie).getText(); if (uie instanceof UITextBox) return "textbox:" + ((UITextBox) uie).getText(); if (uie instanceof UILabel) return "label:" + ((UILabel) uie).getText(); if (uie instanceof UIScrollLayout) return "scroll:"; if (uie instanceof UIListLayout) return "list:"; if (uie instanceof UITabPane) return "tabpane:"; if (uie instanceof UIScrollbar) return "scrollbar:"; return "?:" + uie.toString(); }
private static void addDescendant( UIElement uie, HashMap<UIElement, Rect> hs, Rect screenRect, UIElement s) { Rect sz = s.getParentRelativeBounds(); screenRect = new Rect(screenRect.x + sz.x, screenRect.y + sz.y, sz.width, sz.height); addElementAndDescendants(s, hs, screenRect); }
public void printTree() { for (UIElement uie : getAllControls().keySet()) System.out.println("\"" + fullIdentify(uie) + "\""); }
@Test public void testEventCommands() { App app = beginCommandProcedure(); runMainCommandProcedure( app, "RPG::EventCommand", "event", rpgEvInst.getIVar("@pages").getAElem(1).getIVar("@list")); }
@Test public void testMoveCommands() { App app = beginCommandProcedure(); runMainCommandProcedure( app, "RPG::MoveCommand", "move", rpgEvInst.getIVar("@pages").getAElem(1).getIVar("@move_route").getIVar("@list")); }
@Test public void testMoveCommandsEmbeddedInEventCommand() { App app = beginCommandProcedure(); IRIO lst = rpgEvInst.getIVar("@pages").getAElem(1).getIVar("@list"); IRIO res = addCommandInto(app, "RPG::EventCommand", lst); res.getIVar("@code").setFX(11330); rpgEv.modifyVal(rpgEvInst, rpgEvP, false); runMainCommandProcedure(app, "RPG::MoveCommand", "move", res.getIVar("@move_commands")); }
private IRIO addCommandInto(App app, String listType, IRIO iVar) { IRIO res = iVar.addAElem(0); SchemaPath.setDefaultValue(res, app.sdb.getSDBEntry(listType), DMKey.of(0)); rpgEv.modifyVal(rpgEvInst, rpgEvP, false); return res; }
private App beginCommandProcedure() { App app = new TestKickstart().kickstart("RAM/", "UTF-8", "r2k"); rpgEvInst = new Event(new DMContext(DMChangeTracker.Null.TESTS, StandardCharsets.UTF_8)); rpgEv = app.sdb.getSDBEntry("RPG::Event"); rpgEvP = new SchemaPath(rpgEv, new ObjectRootHandle.Isolated(rpgEv, rpgEvInst, "rpgEvP")); rpgEv.modifyVal(rpgEvInst, rpgEvP, true); return app; }
private void runMainCommandProcedure(App app, String cmdt, String cmd, IRIO iVar) { IRIO res = addCommandInto(app, cmdt, iVar); CMDB cmdb = app.cmdbs.getCMDB(cmd); for (int i : cmdb.knownCommandOrder) { res.getIVar("@code").setFX(i); rpgEv.modifyVal(rpgEvInst, rpgEvP, true); } }
@Test public void testEncode2kDatabase() { DMContext tests = new DMContext(DMChangeTracker.Null.TESTS, StandardCharsets.UTF_8); App app = new TestKickstart().kickstart("RAM/", "UTF-8", "r2k"); IRIO newObj = new IRIOGeneric(tests); SchemaPath.setDefaultValue(newObj, app.sdb.getSDBEntry("RPG::Database"), null); try { ByteArrayOutputStream baos = new ByteArrayOutputStream(); IMIUtils.createIMIDump(new DataOutputStream(baos), newObj, ""); IRIOGeneric test = new IRIOGeneric(tests); byte[] data = baos.toByteArray(); IMIUtils.runIMISegment(new ByteArrayInputStream(data), test); byte[] diff = IMIUtils.createIMIData(newObj, test, ""); if (diff != null) { System.out.println("-- Dbg : Data"); System.out.println(new String(data, "UTF-8")); System.out.println("-- Dbg : Diff"); System.out.println(new String(diff, "UTF-8")); throw new RuntimeException("There was an issue."); } } catch (IOException e) { throw new RuntimeException(e); } }
@Test public void testFullIOStack() throws IOException { TestKickstart kick = new TestKickstart(); App app = kick.kickstart("RAM/", "UTF-8", "r2k"); String[] fileDefs = new String[] {"hello.lmu", "world.ldb", "and.lmt", "you.lsd",}; app.odb.getObject("hello.lmu", true).ensureSaved(); app.odb.getObject("world.ldb", true).ensureSaved(); app.odb.getObject("and.lmt", true).ensureSaved(); app.odb.getObject("you.lsd", true).ensureSaved(); kick.resetODB(app); for (String s : fileDefs) { ObjectRootHandle i = app.odb.getObject(s, false); Assert.assertNotNull(i); } }
@Test public void testXYZ() throws IOException { App app = new TestKickstart().kickstart("RAM/", "UTF-8", "r2k"); testFormat(new XYZImageIOFormat(app.ilg), true); }
@Test public void testPNG8I() throws IOException { App app = new TestKickstart().kickstart("RAM/", "UTF-8", "r2k"); testFormat(new PNG8IImageIOFormat(app.ilg), false); }
private void testFormat(ImageIOFormat imageIOFormat, boolean expectedToLoseTransparency) throws IOException { LinkedList<Integer> pal = new LinkedList<>(); pal.add(0x00000000); pal.add(0xFFFF0000); pal.add(0xFF00FF00); pal.add(0xFF0000FF); ImageIOImage iioi = new ImageIOImage(2, 2, new int[] {0, 3, 2, 1}, pal); assertExpectedTestImageContents(iioi, false); byte[] data = imageIOFormat.saveFile(iioi); iioi = imageIOFormat.loadFile(data, null); assertExpectedTestImageContents(iioi, expectedToLoseTransparency); }
private void assertExpectedTestImageContents( ImageIOImage iioi, boolean expectedToLoseTransparency) { Assert.assertEquals(0, iioi.getRaw(0, 0)); Assert.assertEquals(3, iioi.getRaw(1, 0)); Assert.assertEquals(2, iioi.getRaw(0, 1)); Assert.assertEquals(1, iioi.getRaw(1, 1)); if (expectedToLoseTransparency) { Assert.assertEquals(0xFF000000, (int) iioi.palette.get(0)); } else { Assert.assertEquals(0x00000000, (int) iioi.palette.get(0)); } Assert.assertEquals(0xFFFF0000, (int) iioi.palette.get(1)); Assert.assertEquals(0xFF00FF00, (int) iioi.palette.get(2)); Assert.assertEquals(0xFF0000FF, (int) iioi.palette.get(3)); }
@Test public void testStringEquality() { DMContext tests = new DMContext(DMChangeTracker.Null.TESTS, StandardCharsets.UTF_8); IRIO rioA = new IRIOGeneric(tests).setString("Hello"); IRIO rioB = new IRIOGeneric(tests).setString("Goodbye"); IRIO rioC = new IRIOGeneric(tests).setString("Hello"); Assert.assertFalse(IRIO.rubyEquals(rioA, rioB)); Assert.assertTrue(IRIO.rubyEquals(rioA, rioA)); Assert.assertTrue(IRIO.rubyEquals(rioA, rioC)); }
@Parameterized.Parameters(name = "{0}") public static Collection<Object[]> data() { LinkedList<Object[]> tests = new LinkedList<Object[]>(); new TestKickstart().kickstartRFS(); final HashSet<String> schemas = new HashSet<String>(); for (String ed : EnginesList.getEngines(null).keySet()) schemas.add(ed); for (String st : schemas) tests.add(new Object[] {st}); return tests; }
@Test public void testAnd() { new TestKickstart().kickstartRFS(); MVMEnvR48 env = new MVMEnvR48((s) -> {}, (s) -> {}, "tok", true); MVMR48GlobalLibraries.add(env); env.include("vm/global", false); assertEquals(3L, env.evalString("(and 1 2 3)")); assertEquals(false, env.evalString("(and 1 #f 3)")); assertEquals(true, env.evalString("(and)")); assertEquals(1L, env.evalString("(and 1)")); }
@Test public void testOr() { new TestKickstart().kickstartRFS(); MVMEnvR48 env = new MVMEnvR48((s) -> {}, (s) -> {}, "tok", true); MVMR48GlobalLibraries.add(env); env.include("vm/global", false); assertEquals(1L, env.evalString("(or 1 2 3)")); assertEquals(1L, env.evalString("(or 1 #f 3)")); assertEquals(false, env.evalString("(or)")); assertEquals(1L, env.evalString("(or 1)")); }
@Test public void testCond() { new TestKickstart().kickstartRFS(); MVMEnvR48 env = new MVMEnvR48((s) -> {}, (s) -> {}, "tok", true); MVMR48GlobalLibraries.add(env); env.include("vm/global", false); assertEquals(true, env.evalString("(cond (#t) (#f) (#f))")); assertEquals( new DatumSymbol("yes"), env.evalString("(cond ((> 1 2) (quote no)) ((> 2 1) (quote yes)) (else (quote never)))")); assertEquals(false, env.evalString("(cond)")); assertEquals( new DatumSymbol("yes"), env.evalString("(cond ((> 1 2) (quote no)) (else (quote yes)))")); }
@Test public void test() { InterlaunchGlobals ilg = new TestKickstart().kickstartILG(); HelpFile.load(ilg, name); }
@Override public void newObj(int objId, final String objName, DatumSrcLoc sl) {}
@Override public void execCmd(String c, String[] args, Object[] argsObj, DatumSrcLoc sl) { if (c.equals(".")) { Object[] cmdLine = new Object[args.length]; for (int i = 0; i < cmdLine.length; i++) cmdLine[i] = args[i]; tests.add(cmdLine); } else { throw new RuntimeException("unknown command: " + c); } }
public static String findBasePath() { try { String home = System.getenv("HOME"); return home + "/R48LTE/assets/"; } catch (Exception ex) { return "/R48LTE/assets/"; } }
@Override public void register(IDM3Data irioData) { irioData.trackingMarkClean(); }
@Override public void modifying(IDM3Data modifiedData) { states.add(modifiedData.saveState()); }
@Test public void testR2KMoveCommandMetaInteger() { for (int i : intTestVectors) { List<Integer> li = new LinkedList<Integer>(); MoveCommand.addMetaInteger(li, i); System.out.println(i + " - encoded as " + li.size() + " ints"); int check = MoveCommand.popMetaInteger(li.iterator()); Assert.assertEquals(check, i); } }
@Test public void testR48() throws Exception { for (int i : intTestVectors) { testR48(i); } }
private void testR48(long l) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); R48ObjectBackend.save32STM(new DataOutputStream(baos), l); System.out.println(l + " encoded in " + baos.size() + " bytes"); long check = R48ObjectBackend.load32(new DataInputStream(new ByteArrayInputStream(baos.toByteArray()))); Assert.assertEquals(check, l); }
@Test public void testDeepCloneRPGMap() { DMContext tests = new DMContext(DMChangeTracker.Null.TESTS, StandardCharsets.UTF_8); App app = new TestKickstart().kickstart("RAM/", "UTF-8", "rxp"); IRIO newObj = new IRIOGeneric(tests); SchemaPath.setDefaultValue(newObj, app.sdb.getSDBEntry("RPG::Map"), null); IRIO newObj2 = new IRIOGeneric(tests).setDeepClone(newObj); try { byte[] dat = IMIUtils.createIMIData(newObj, newObj2, ""); if (dat != null) System.out.write(dat); } catch (IOException e) { e.printStackTrace(); } }
@Override public Boolean get() { if (waitFrame) { waitFrame = false; return false; } return true; }
@Override public Boolean get() { kick.currentTestPhase = phase; return true; }
public void thenClick(final String id) { thenClick(id, 0, 0); }
public void thenClick(final int i, final int i1) { thenClick(null, i, i1); }
@Override public Boolean get() { if (waitFrame) { Rect ctrl = wm.getControlRect(id); kick.pointer = new MobilePeripherals.DummyPointer(ctrl.x + ox, ctrl.y + oy); waitFrame = false; return false; } kick.pointer = null; return true; }
public void thenDrag(final int i, final int i1, final int i2, final int i3) { thenDrag(null, i, i1, i2, i3); }
public void thenDrag(final String n1, final int i, final int i1, final int i2, final int i3) { thenDrag(n1, i, i1, n1, i2, i3); }
@Override public Boolean get() { if (waitFrame == 0) { Rect ctrl = wm.getControlRect(n1); kick.pointer = new MobilePeripherals.DummyPointer(ctrl.x + i, ctrl.y + i1); waitFrame++; return false; } else if (waitFrame == 1) { Rect ctrl = wm.getControlRect(n2); kick.pointer.x = ctrl.x + i2; kick.pointer.y = ctrl.y + i3; waitFrame++; return false; } kick.pointer = null; return true; }
@Override public Boolean get() { if (waitFrame) { UIScrollLayout ctrl = (UIScrollLayout) wm.getControl(n1); GrandControlUtils.scroll(ctrl, wm.getControl(n2)); waitFrame = false; return false; } return true; }
@Override public Boolean get() { return kick.windowCount == wc; }
@Override public Boolean get() { if (waitFrame) { wm.clickIcon(getElement(title), idx); waitFrame = false; return false; } return true; }
@Override public Boolean get() { if (waitFrame) { wm.selectTab(getElement(title)); waitFrame = false; return false; } return true; }
@Override public Boolean get() { if (waitFrame) { kick.maintainText = s; kick.maintainTextEnter = true; waitFrame = false; return false; } return true; }
@Override public Boolean get() { if (waitFrame) { kick.windows.getLast().shutdown(); waitFrame = false; return false; } return true; }
public void execute(long expectedChecksum) { try { kick.kickstartRFS(); lUtils = new GrandLauncherUtils(new Launcher(true)); wm = new GrandWindowManagerUtils(this); kick.gwmu = wm; lUtils.launcher.run(); byte[] dat = createDump(); long checksum = 0; for (byte b : dat) checksum += b & 0xFF; FileOutputStream fos = new FileOutputStream("test-out/debug" + checksum + ".pak"); fos.write(dat); fos.close(); System.out.println("Test result: " + checksum); } catch (IOException ioe) { throw new RuntimeException(ioe); } }
private void associateNodesToLumps(VFSNode n, String path, LinkedList<DumpedLump> res) { if (n instanceof VFSFile) { res.add(new DumpedLump(path, ((VFSFile) n).contents.toByteArray())); } else if (n instanceof VFSDir) { for (Map.Entry<String, VFSNode> kp : ((VFSDir) n).contents.entrySet()) { associateNodesToLumps(kp.getValue(), path + "/" + kp.getKey(), res); } } }
private byte[] createDump() throws IOException { LinkedList<DumpedLump> l = new LinkedList<DumpedLump>(); associateNodesToLumps(kick.mockVFS, "", l); Collections.sort(l); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int knownPos = 12 + (l.size() * 64); baos.write('P'); baos.write('A'); baos.write('C'); baos.write('K'); IntUtils.writeS32(baos, 12); IntUtils.writeS32(baos, l.size() * 64); for (DumpedLump dl : l) { byte[] baseName = new byte[56]; int idx = 0; for (byte b : dl.name.getBytes("UTF-8")) baseName[idx++] = b; System.out.println(dl.name); baos.write(baseName); IntUtils.writeS32(baos, knownPos); IntUtils.writeS32(baos, dl.data.length); knownPos += dl.data.length; } for (DumpedLump dl : l) baos.write(dl.data); return baos.toByteArray(); }
@Override public int compareTo(DumpedLump o) { return name.compareTo(o.name); }
public static void initSynthesis2k3(GrandTestBuilder gtb) { gtb.thenSetPhase("initSynthesis2k3"); gtb.thenWaitWC(2); gtb.thenClick("button:Continue"); gtb.thenWaitFrame(); gtb.thenClick("button:RPG Maker 2000, 2003, or EasyRPG. (Android users, go here.)"); gtb.thenWaitFrame(); gtb.thenClick( "button:R2K[3?] (UTF-8) (Use for new games or languages not shown.)"); gtb.thenWaitWC(4); gtb.thenWaitFrame(); gtb.thenIcon("Please confirm...", 1); gtb.thenWaitFrame(); gtb.thenClick("button:2003 Template"); gtb.thenWaitFrame(); gtb.thenIcon("Information", 0); }
public static void initSynthesisRXP(GrandTestBuilder gtb) { gtb.thenSetPhase("initSynthesisRXP"); gtb.thenWaitWC(2); gtb.thenClick("button:Continue"); gtb.thenWaitFrame(); gtb.thenClick("button:RGSS Engines (RPG Maker XP, VX Ace)"); gtb.thenWaitFrame(); gtb.thenClick("button:RXP"); gtb.thenWaitWC(4); gtb.thenWaitFrame(); gtb.thenClick("button:This appears to be newly created. Click to create directories."); gtb.thenWaitFrame(); gtb.thenIcon("Information", 0); gtb.thenWaitFrame(); }
@Test public void testMIR2k3() { GrandTestBuilder gtb = new GrandTestBuilder(); GrandInitializers.initSynthesis2k3(gtb); gtb.thenSelectTab("MapInfos"); gtb.thenWaitFrame(); gtb.thenClick("button:1:First Map P0"); gtb.thenWaitFrame(); gtb.thenClick("button:Delete"); gtb.thenWaitFrame(); gtb.thenClick("button:Confirm"); gtb.thenWaitFrame(); performMapSystemTest(gtb); gtb.thenClick("symbol:Save"); gtb.thenCloseWindow(); gtb.thenCloseWindow(); gtb.execute(3581988); }
@Test public void testMIRXP() { GrandTestBuilder gtb = new GrandTestBuilder(); GrandInitializers.initSynthesisRXP(gtb); performMapSystemTest(gtb); gtb.thenClick("symbol:Save"); gtb.thenCloseWindow(); gtb.thenCloseWindow(); gtb.execute(282280); }
private void performMapSystemTest(GrandTestBuilder gtb) { gtb.thenSelectTab("MapInfos"); performInsertNewMap(gtb); performInsertNewMap(gtb); performInsertNewMap(gtb); performMoveOut(gtb, "2: P1"); performMoveOut(gtb, "3: P2"); performMoveTo(gtb, "3: P0", "1: P0"); performMoveTo(gtb, "2: P0", "1: P0"); }
private void performInsertNewMap(GrandTestBuilder gtb) { gtb.thenClick("button:<Insert New Map>"); gtb.thenIcon("Map ID?", 1); gtb.thenWaitFrame(); gtb.thenClick("button:Confirm"); gtb.thenWaitFrame(); gtb.thenSelectTab("MapInfos"); }
private void performMoveOut(GrandTestBuilder gtb, String p0_) { gtb.thenClick("button:" + p0_); gtb.thenWaitFrame(); gtb.thenClick("button:Move Out "); gtb.thenWaitFrame(); }
private void performMoveTo(GrandTestBuilder gtb, String s, String s1) { gtb.thenDrag("button:" + s, -4, 16, "button:" + s1, -4, 0); gtb.thenWaitFrame(); gtb.thenWaitFrame(); }
@Test public void runGrandSynthesisTest() { GrandTestBuilder gtb = new GrandTestBuilder(); GrandInitializers.initSynthesis2k3(gtb); editTerm(gtb); editMap(gtb); editNewMap(gtb); gtb.thenClick("symbol:Save"); gtb.thenWaitFrame(); gtb.thenCloseWindow(); gtb.thenCloseWindow(); runTheTest(gtb); }
private void editMap(GrandTestBuilder gtb) { gtb.thenSetPhase("GrandSynthesisTest:editMap"); gtb.thenSelectTab("Map"); gtb.thenWaitFrame(); gtb.thenClick("?:r48.map.UIMapView", 32, 96); gtb.thenWaitFrame(); editMapTile(gtb); editMapEvent(gtb); }
public void editMapTile(GrandTestBuilder gtb) { gtb.thenSetPhase("GrandSynthesisTest:editMapTile"); gtb.thenClick("button:L0"); gtb.thenWaitFrame(); gtb.thenIcon("T0", 1); gtb.thenClick("?: ATF", 35, 350); gtb.thenSelectTab("Map"); gtb.thenClick("?:r48.map.UIMapView", 336, 146); }
public void editMapEvent(GrandTestBuilder gtb) { gtb.thenSetPhase("GrandSynthesisTest:editMapEvent"); gtb.thenClick("button:Events"); gtb.thenWaitFrame(); gtb.thenIcon("Ev.Pick [0 total]", 1); gtb.thenSelectTab("Map"); gtb.thenClick("?:r48.map.UIMapView", 336, 146); gtb.thenWaitFrame(); gtb.thenSelectTab("Ev.Pick [0 total]"); gtb.thenClick("button:+ Add Event"); gtb.thenIcon("Ev.Pick [0 total]", 0); gtb.thenIcon(ev0001WName, 1); gtb.thenWaitFrame(); editMapEventGraphics(gtb); editMapEventMoveRoute(gtb); gtb.thenSetPhase("GrandSynthesisTest:editMapEvent (closing)"); gtb.thenIcon(ev0001WName, 0); }
private void editMapEventGraphics(GrandTestBuilder gtb) { gtb.thenSetPhase("GrandSynthesisTest:editMapEventGraphics"); gtb.thenClick("button:Graphics"); gtb.thenWaitFrame(); gtb.thenClick("button:2 : down"); gtb.thenWaitFrame(); gtb.thenClick("button:2 : down"); gtb.thenWaitFrame(); gtb.thenClick(ev0001Back); gtb.thenWaitFrame(); }
private void editNewMap(GrandTestBuilder gtb) { gtb.thenSetPhase("GrandSynthesisTest:editNewMap"); gtb.thenSelectTab("MapInfos"); gtb.thenClick("button:<Insert New Map>"); gtb.thenIcon("Map ID?", 1); gtb.thenWaitFrame(); gtb.thenClick("button:Confirm"); gtb.thenWaitFrame(); }
private void runTheTest(GrandTestBuilder gtb) { gtb.thenWaitFrame(); gtb.execute(3561671); }
public App kickstart(final String s2, final String encoding, final String engineDefId) { currentTestPhase = "Initial Phase"; kickstartRFS(); Charset charset; try { charset = Charset.forName(encoding); } catch (UnsupportedCharsetException uce) { throw new RuntimeException(uce); } InterlaunchGlobals ilg = kickstartILG(); EngineDef engine = EnginesList.getEngines(null).get(engineDefId); if (engine == null) throw new RuntimeException("missing engine def: " + engineDefId); return new App( ilg, charset, engine, GaBIEn.mutableDataFS.intoPath(s2), null, (s) -> {}, () -> "TEST"); }
@Override public IGrInDriver makeGrIn(String name, int w, int h, WindowSpecs ws) { ws.resizable = false; w = 960; h = 540; return new TestGrInDriver(name, ws, w, h); }
@Override public void startFileBrowser( String text, boolean saving, String exts, Consumer<String> result, String initialName) { waitingFileDialog = result; }
public InterlaunchGlobals kickstartILG() { kickstartRFS(); Art a = new Art(); Config c = new Config(false); c.applyUIGlobals(); return new InterlaunchGlobals( a, c, (vm) -> {}, (str) -> {}, (str) -> { throw new RuntimeException("TR issue during tests: " + str); }, true); }
public void resetODB(App app) { IObjectBackend backend = IObjectBackend.Factory.create( app.gameRoot, app.engine.odbBackend, app.engine.dataPath, app.engine.dataExt); app.odb = new ObjectDB(app, backend); }
@Override public void performOffset(int x, int y) { ofsX += x; ofsY += y; }
@Override public void clearOffset() { ofsX = 0; ofsY = 0; }
@Override public String maintain(int x, int y, int w, int h) { didMaintainThisFrame = true; return maintainText; }
@Override public boolean isEnterJustPressed() { return maintainTextEnter; }
@Override public void endSession() { sessionDeadYet = true; }
@Override public boolean isSessionDead() { return sessionDeadYet; }
@Override public String aroundTheBorderworldMaintain(TextboxMaintainer tm, int x, int y, int w, int h) { return "THIS SHOULD NOT BE CALLED"; }
@Override public void finishRemovingEditingSession() { }
@Override public void flush(IImage backBuffer) { try { FileOutputStream debugOut = new FileOutputStream("test-out/debug.png"); debugOut.write(backBuffer.createPNG()); debugOut.close(); } catch (Exception e) { e.printStackTrace(); } if (internalMaintainText != null) { if (!didMaintainThisFrame) { System.out.println("Maintain stop"); internalMaintainText = null; maintainText = null; } } didMaintainThisFrame = false; maintainTextEnter = false; super.flush(backBuffer); while (true) { if (waitingTestEntries.size() == 0) { gwmu.printTree(); throw new GrandExecutionError("Ran out of test sequence data."); } Supplier<Boolean> isb = waitingTestEntries.getFirst(); if (!isb.get()) break; waitingTestEntries.removeFirst(); } }
public static void scroll(UIScrollLayout ctrl, UIElement control) { int sh = ctrl.calcScrollHeight(ctrl.getSize()); if (sh != 0) { ctrl.scrollbar.scrollPoint += control.getParentRelativeBounds().y / (double) sh; if (ctrl.scrollbar.scrollPoint < 0) ctrl.scrollbar.scrollPoint = 0; if (ctrl.scrollbar.scrollPoint >= 1) ctrl.scrollbar.scrollPoint = 1; } }
public static void coreLogic( App app, LinkedList<UIEnumChoice.Option> finalMap, Function<IRIO, IRIO> innerMap, final @Nullable ObjectRootHandle targetILO, @Nullable SchemaElement dataSchema, IRIO target, boolean hash, String interpret) { if (hash) { for (DMKey key : target.getHashKeys()) handleVal( app, finalMap, innerMap, targetILO, dataSchema, target.getHashVal(key), key, interpret); } else { int alen = target.getALen(); for (int i = 0; i < alen; i++) { IRIO rio = target.getAElem(i); handleVal(app, finalMap, innerMap, targetILO, dataSchema, rio, DMKey.of(i), interpret); } } }
private void finalizeVals(LinkedList<UIEnumChoice.Option> finalMap) { Collections.sort(finalMap, UIEnumChoice.COMPARATOR_OPTION); SchemaElement ise = new EnumSchemaElement( app, finalMap, DMKey.of(defaultVal), EntryMode.INT, () -> T.s.enum_id); dict.setEntry(ise); }
public void sanitize() { finalizeVals(new LinkedList<UIEnumChoice.Option>()); }
public static void save(String fonts, RORIO prepare) { prepare(); R48ObjectBackend rob = new R48ObjectBackend(GaBIEn.mutableDataFS, PREFIX, ".r48"); try { rob.saveObjectToFile(fonts, prepare); } catch (IOException e) { throw new RuntimeException(e); } }
public static @Nullable IRIOGeneric load(String fonts) { R48ObjectBackend rob = new R48ObjectBackend(GaBIEn.mutableDataFS, PREFIX, ".r48"); return rob.loadObjectFromFile(fonts, newContext()); }
public static void saveJSON(String fonts, RORIO prepare) { prepare(); JsonObjectBackend rob = new JsonObjectBackend(GaBIEn.mutableDataFS, PREFIX, ".json"); try { rob.saveObjectToFile(fonts, prepare); } catch (IOException e) { throw new RuntimeException(e); } }
public static void prepare() { GaBIEn.makeDirectories(PREFIX); }
public static DMContext newContext() { return new DMContext(DMChangeTracker.Null.ADHOC_IO, StandardCharsets.UTF_8); }
@Override public boolean matches(RPGCommand target, @Nullable RORIO data) { return true; }
@Override public DynTrBase dynTrBase( DatumSrcLoc srcLoc, String id, @Nullable DatumSymbol mode, Object text, boolean isNLS) { return vmCtx.dynTrBase(srcLoc, id, mode, text, isNLS); }
public void performTranslatorDump(String fn) { vmCtx.dynTrDump(fn); }
public String format(RORIO rubyIO, String st, EnumSchemaElement.Prefix prefixEnums) { if (rubyIO == null) return ""; if (st != null) { FF1 handler = getNameDB(st); if (handler != null) { return handler.r(rubyIO); } else if (sdb.hasSDBEntry(st)) { SchemaElement ise = sdb.getSDBEntry(st); return format(rubyIO, ise, prefixEnums); } } return format(rubyIO, (SchemaElement) null, prefixEnums); }
public String format(RORIO rubyIO) { return format(rubyIO, (SchemaElement) null, EnumSchemaElement.Prefix.NoPrefix); }
public void finishInitOnMainThread() { ui.finishInitialization(); }
public void shutdown() { if (ui != null) { if (ui.mapContext != null) ui.mapContext.freeOsbResources(); ui.mapContext = null; } GaBIEn.hintFlushAllTheCaches(); }
@Override public void reportNonCriticalErrorToUser(String r, Throwable ioe) { ui.launchDialog(r, ioe); }
public static int natStrComp(String s, String s1) { int nma = numLen(s); int nmb = numLen(s1); if (nma == 0) if (nmb == 0) { nma = s.length(); nmb = s1.length(); } if (nma < nmb) return -1; if (nma > nmb) return 1; while (true) { if (s.length() == 0) return 0; if (s1.length() == 0) return 0; char a = s.charAt(0); char b = s1.charAt(0); if (a > b) return 1; if (a < b) return -1; s = s.substring(1); s1 = s1.substring(1); } }
private static int numLen(String s1) { int nm = 0; for (char c : s1.toCharArray()) { if ((c >= '0') && (c <= '9')) { nm++; } else { break; } } return nm; }
public static LinkedList<String> sortedKeysStr(Set<String> keys) { LinkedList<String> ios = new LinkedList<String>(keys); Collections.sort(ios, COMPARATOR_NATSTRCOMP); return ios; }
public static LinkedList<String> sortedKeysStrArr(String[] iVarKeys) { HashSet<String> hs = new HashSet<String>(); if (iVarKeys != null) Collections.addAll(hs, iVarKeys); return sortedKeysStr(hs); }
public static LinkedList<DMKey> sortedKeys(Set<DMKey> rubyIOs) { return sortedKeys(rubyIOs, RORIO::toString); }
public static LinkedList<DMKey> sortedKeys( Set<DMKey> rubyIOs, final Function<RORIO, String> toString) { LinkedList<DMKey> ios = new LinkedList<>(rubyIOs); Collections.sort(ios, (t0, t1) -> natStrComp(toString.apply(t0), toString.apply(t1))); return ios; }
public static LinkedList<DMKey> sortedKeysArr(DMKey[] iVarKeys) { HashSet<DMKey> hs = new HashSet<>(); if (iVarKeys != null) Collections.addAll(hs, iVarKeys); return sortedKeys(hs); }
public static LinkedList<DMKey> sortedKeysArr( DMKey[] iVarKeys, final Function<RORIO, String> toString) { HashSet<DMKey> hs = new HashSet<>(); if (iVarKeys != null) Collections.addAll(hs, iVarKeys); return sortedKeys(hs, toString); }
@Override public void setupEditor(@NonNull LinkedList<UIElement> usl, @NonNull Runnable onEdit) { instance.setupEditor(usl, onEdit); }
@Override public boolean matches(@Nullable RPGCommand target, @Nullable RORIO data) { if (target == null) return false; if (data == null) return false; if (target.textArg == -1) return false; return instance.matches(data.getIVar("@parameters").getAElem(target.textArg).decString()); }
public boolean evaluate(boolean old, boolean incoming) { switch (this) { case And: return old && incoming; case AndNot: return old && !incoming; case Or: return old || incoming; case OrNot: return old || !incoming; } return old; }
public @Nullable UIElement makeEditor() { return null; }
public static USFROperationMode[] listForApp(App app) { LinkedList<USFROperationMode> lls = new LinkedList<>(); lls.add(All.INSTANCE); for (ICommandClassifier icc : app.cmdClassifiers) if (icc instanceof ICommandClassifier.Immutable) lls.add(new CmdTag((ICommandClassifier.Immutable) icc)); return lls.toArray(new USFROperationMode[0]); }
@Override public String translate(App app) { return app.t.u.usl_modeAll; }
@Override public void locate(App app, SchemaPath root, Visitor visitor, boolean detailedPaths) { root.editor.visit(root.targetElement, root, makeMyVisitor(visitor), detailedPaths); }
@Override public String translate(App app) { return app.t.u.usl_modeCTag.r(base.getName(app)); }
@Override public void locate(App app, SchemaPath root, Visitor visitor, boolean detailedPaths) { Visitor mod = All.makeMyVisitor(visitor); root.editor.visit( root.targetElement, root, (element, target, path) -> { if (element instanceof RPGCommandSchemaElement) { RPGCommand rc = ((RPGCommandSchemaElement) element).getRPGCommand(target); if (base.matches(rc, target)) { element.visit(target, path, mod, detailedPaths); return false; } } return true; }, false); }
@Override default void setupEditor(LinkedList<UIElement> usl, Runnable onEdit) {}
@Override default Instance instance(App app) { return this; }
@Override public void setupEditor(@NonNull LinkedList<UIElement> usl, @NonNull Runnable onEdit) {}
@Override public boolean matches(@Nullable RPGCommand dbEntry, @Nullable RORIO cmd) { return false; }
@Override public String choiceToText(CMDB choice) { return choice.dbId; }
@Override public boolean matches(@Nullable RPGCommand dbEntry, @Nullable RORIO cmd) { if (rpgCommand == null) return true; return dbEntry == rpgCommand; }
@Override default boolean matches(String text) { int len = text.length(); for (int i = 0; i < len; i++) if (testChar(text.charAt(i))) return true; return false; }
@Override public boolean testChar(char c) { if (c >= 0x1100 && c <= 0x11FF) return true; if (c >= 0x3040 && c <= 0x31FF) return true; if (c >= 0x3400 && c <= 0x4DBF) return true; if (c >= 0x4E00 && c <= 0x9FFF) return true; if (c >= 0xA960 && c <= 0xA97F) return true; if (c >= 0xAC00 && c <= 0xD7FF) return true; if (c >= 0xFF65 && c <= 0xFFDF) return true; return false; }
@Override public boolean testChar(char c) { return c > 0xFF; }
@Override public boolean testChar(char c) { boolean l1orfw = (c <= 0xFF) || (c >= 0xFF00 && c <= 0xFF65) || (c >= 0xFFE0 && c <= 0xFFEF); return !l1orfw; }
@Override public Instance instance(App app) { final ICommandClassifier[] ents = app.cmdClassifiers.toArray(new ICommandClassifier[0]); ICommandClassifier de = app.commandTags.get("translatable"); return new CCCI(app, ents, de); }
@Override public boolean matches(@Nullable RPGCommand target, @Nullable RORIO data) { boolean value = true; boolean first = true; for (Entry ent : entries) { boolean m = ((ICommandClassifier.Instance) ent.cInstance).matches(target, data); if (first) value = m; else value = ent.chain.evaluate(value, m); first = false; } return value; }
@Override public boolean matches(@Nullable RPGCommand target, @Nullable RORIO data) { if (target == null) return false; return target.tags.contains(CommandTag.this); }
@Override public void setupEditor(@NonNull LinkedList<UIElement> usl, @NonNull Runnable onEdit) { UITextBox uil = new UITextBox(needle, app.f.dialogWindowTH); uil.onEdit = () -> { needle = uil.getText(); needleTLC = needle.toLowerCase(); }; usl.add(uil); }
@Override public boolean matches(String haystack) { switch (TextOperator.this) { case Contains: return haystack.contains(needle); case ContainsInsensitive: return haystack.toLowerCase().contains(needleTLC); case Equals: return haystack.equals(needle); case EqualsInsensitive: return haystack.toLowerCase().equals(needleTLC); } return false; }
public UIElement[] toArray() { return sites.toArray(new UIElement[0]); }
public void addSitesFromCommonEvents(IRIO[] commonEvents, final ICommandClassifier.Instance cf) { SchemaElement sch = objRoot.rootSchema; if (sch == null) { app.ui.launchDialog(T.u.cCommonEventsNoSchema); } else { SchemaPath rootSP = new SchemaPath(sch, objRoot); EventCommandArraySchemaElement ecase = RMFindTranslatables.getEventCommandArraySchemaElement(app, "EventListEditor"); for (IRIO rio : commonEvents) { SchemaElement cevElm = app.sdb.findSchemaFor(rio); if (cevElm == null) { app.ui.launchDialog(T.u.cCommonEventsNoSchema2); return; } SchemaPath commonEventSP = rootSP.newWindow(cevElm, rio); addSitesFromList(ecase, null, rio.getIVar("@list"), commonEventSP, cf); } } }
public static EventCommandArraySchemaElement getEventCommandArraySchemaElement( App app, String cmdbEditor) { return (EventCommandArraySchemaElement) AggregateSchemaElement.extractField(app.sdb.getSDBEntry(cmdbEditor), null); }
public static UIElement siteFromContext( App app, final EventCommandArraySchemaElement cmdbEditor, final @Nullable UIMapView mapView, final IRIO listObj, final int codeIndex, final IRIO command, final SchemaPath basePath) { final CMDB cmdb = cmdbEditor.database; String text = cmdb.buildGroupCodename(listObj, codeIndex, true); final UITextButton button = new UITextButton( text, app.f.schemaFieldTH, () -> { ISchemaHost shi = new UISchemaHostWindow(app, mapView); SchemaPath sp = basePath; sp = sp.tagSEMonitor(listObj, cmdbEditor, false); sp = sp.arrayHashIndex(DMKey.of(codeIndex), "C" + codeIndex); sp = sp.newWindow(cmdbEditor.getElementContextualWindowSchema(command), listObj); shi.pushPathTree(sp); }); return button; }
@Override public String choiceToText(C choice) { return choice.getName(app); }
@Override public String choiceToText(BooleanChainOperator choice) { return choice.getTranslatedName(app); }
@Override public Instance instance(App app) { final ITextAnalyzer[] ents = app.textAnalyzers.toArray(new ITextAnalyzer[0]); return new CCCI(app, ents, ents[0]); }
@Override public boolean matches(String text) { boolean value = true; boolean first = true; for (Entry ent : entries) { boolean m = ((ITextAnalyzer.Instance) ent.cInstance).matches(text); if (first) value = m; else value = ent.chain.evaluate(value, m); first = false; } return value; }
@Override public String uniqueToString() { return "M" + spriteSize + "." + spritesW + "." + spritesH; }
@Override public IImage process(IImage framesetCache) { if (framesetCache == null) return null; int[] originalData = framesetCache.getPixels(); int originalWidth = framesetCache.getWidth(); int[] cache = new int[spriteSize * spriteSize * spritesW * spritesH]; for (int y = 0; y < spritesH; y++) for (int x = 0; x < spritesW; x++) installMirror( cache, (x * spriteSize) + (spriteSize * spritesW * (y * spriteSize)), spriteSize * spritesW, originalData, (x * spriteSize) + (originalWidth * (y * spriteSize)), originalWidth); return GaBIEn.createImage(cache, spriteSize * spritesW, spriteSize * spritesH); }
private void installMirror( int[] cache, int base, int stride, int[] origData, int baseO, int strideO) { for (int i = 0; i < spriteSize; i++) installMirrorRow(cache, base + (stride * i), origData, baseO + (strideO * i)); }
private void installMirrorRow(int[] cache, int i, int[] origData, int i1) { for (int j = 0; j < spriteSize; j++) { int tx = i + j; if (tx >= cache.length) continue; int tx2 = i1 + ((spriteSize - 1) - j); if (tx2 >= origData.length) continue; cache[tx] = origData[tx2]; } }
private int[] sipMatrix(int[] baseA, int[] baseB, double v) { double v2 = -((v - 0.5d) * 2); int a = clamp((int) ((((v2 * Math.abs(v2)) + 1.0d) / 2.0d) * 255)); int b = 255 - a; int[] r = new int[9]; for (int i = 0; i < 9; i++) r[i] = ((baseA[i] * a) + (baseB[i] * b)) / 255; return r; }
@Override public String uniqueToString() { return "H" + shift; }
@Override public IImage process(IImage input) { int[] array = input.getPixels(); for (int i = 0; i < array.length; i++) array[i] = processCol(array[i]); return GaBIEn.createImage(array, input.getWidth(), input.getHeight()); }
public int processCol(int i) { int or = (i & 0xFF0000) >> 16; int og = (i & 0xFF00) >> 8; int ob = i & 0xFF; int ovalue = Math.max(Math.max(or, og), ob); int r = clamp(((matrix[0] * or) + (matrix[1] * og) + (matrix[2] * ob)) / 255); int g = clamp(((matrix[3] * or) + (matrix[4] * og) + (matrix[5] * ob)) / 255); int b = clamp(((matrix[6] * or) + (matrix[7] * og) + (matrix[8] * ob)) / 255); int value = Math.max(Math.max(r, g), b); if (value != 0) { int valueBoostFactor = (ovalue * 255) / value; r = clamp((r * valueBoostFactor) / 255); g = clamp((g * valueBoostFactor) / 255); b = clamp((b * valueBoostFactor) / 255); } return (i & 0xFF000000) | (r << 16) | (g << 8) | b; }
private int clamp(int i) { if (i < 0) return 0; if (i > 255) return 255; return i; }
public IImage process(IImage input, LinkedList<IImageEffect> effectsChain) { if (effectsChain.size() == 0) return input; String key = ""; for (IImageEffect effect : effectsChain) key += effect.uniqueToString() + ":"; HashMap<String, IImage> imageEffectMap = effectsMap.get(input); if (imageEffectMap == null) { imageEffectMap = new HashMap<String, IImage>(); effectsMap.put(input, imageEffectMap); } IImage result = imageEffectMap.get(key); if (result == null) { result = input; for (IImageEffect eff : effectsChain) result = eff.process(result); imageEffectMap.put(key, result); } return result; }
public IImage process(IImage input, IImageEffect... effectsChain) { if (effectsChain.length == 0) return input; String key = ""; for (IImageEffect effect : effectsChain) key += effect.uniqueToString() + ":"; HashMap<String, IImage> imageEffectMap = effectsMap.get(input); if (imageEffectMap == null) { imageEffectMap = new HashMap<String, IImage>(); effectsMap.put(input, imageEffectMap); } IImage result = imageEffectMap.get(key); if (result == null) { result = input; for (IImageEffect eff : effectsChain) result = eff.process(result); imageEffectMap.put(key, result); } return result; }
@Override public String uniqueToString() { return "*" + alpha + "," + red + "," + green + "," + blue; }
@Override public IImage process(IImage image) { int[] data = image.getPixels(); for (int i = 0; i < data.length; i++) { int a = (data[i] >> 24) & 0xFF; int r = (data[i] >> 16) & 0xFF; int g = (data[i] >> 8) & 0xFF; int b = data[i] & 0xFF; a = (a * alpha) / 255; r = (r * red) / 255; g = (g * green) / 255; b = (b * blue) / 255; if (a > 255) a = 255; if (r > 255) r = 255; if (g > 255) g = 255; if (b > 255) b = 255; data[i] = (a << 24) | (r << 16) | (g << 8) | b; } return GaBIEn.createImage(data, image.getWidth(), image.getHeight()); }
@Override public String uniqueToString() { return "T" + ar + "," + ag + "," + ab + "," + as; }
@Override public IImage process(IImage input) { int[] array = input.getPixels(); for (int i = 0; i < array.length; i++) { array[i] = processCol(array[i]); } return GaBIEn.createImage(array, input.getWidth(), input.getHeight()); }
private int processCol(int i) { int r = (i & 0xFF0000) >> 16; int g = (i & 0xFF00) >> 8; int b = i & 0xFF; int grey = (r + g + b) / 3; r = grey + mod1(r - grey, as); g = grey + mod1(g - grey, as); b = grey + mod1(b - grey, as); r = clamp(mod1(r, ar)); g = clamp(mod1(g, ag)); b = clamp(mod1(b, ab)); return (i & 0xFF000000) | (r << 16) | (g << 8) | b; }
private int mod1(int i, int m) { return (i * m) / 127; }
public void finish() { name = app.dTrFF1( srcLoc, TrNames.cmdbName(dbId, commandId), DatumLoader.readInlineList(srcLoc, nameRawUnlocalized)); }
public String formatName(@Nullable IRIO paramsObj) { return name.r(paramsObj); }
public boolean isAnchor(IRIO paramsObj) { return (indentPre + (indentPost.apply(paramsObj))) > 0; }
public boolean isAnchorVis(IRIO paramsObj) { return indentPre != 0 || (indentPost.apply(paramsObj) != 0); }
@Override public void applyTo( int idx, LinkedList<UIElement> elementList, IRIO targetParamArray, ISchemaHost launcher, SchemaPath path) { App app = launcher.getApp(); SchemaElement scse = app.sdbHelpers.makeSpriteSelector( PathSyntax.compile(app, "]" + idx), PathSyntax.compile(app, "]" + spritesheetTargstr), spritesheetId); elementList.add(scse.buildHoldingEditor(targetParamArray, launcher, path)); }
@Override public void applyTo( int idx, LinkedList<UIElement> elementList, IRIO targetParamArray, ISchemaHost launcher, SchemaPath path) { App app = launcher.getApp(); SchemaElement scse = new TonePickerSchemaElement( launcher.getApp(), PathSyntax.compile(app, "]" + tpA), PathSyntax.compile(app, "]" + tpB), PathSyntax.compile(app, "]" + tpC), PathSyntax.compile(app, "]" + tpD), tpBase); elementList.add(scse.buildHoldingEditor(targetParamArray, launcher, path)); }
@Override public void applyTo( int idx, LinkedList<UIElement> elementList, IRIO targetParamArray, ISchemaHost launcher, SchemaPath path) { String cName; int hue, dir, pat; try { cName = targetParamArray.getAElem(0).decString(); hue = (int) targetParamArray.getAElem(1).getFX(); dir = (int) targetParamArray.getAElem(2).getFX(); pat = (int) targetParamArray.getAElem(3).getFX(); } catch (Exception ex) { ex.printStackTrace(); return; } IRIOGeneric ig = new IRIOGeneric(launcher.getApp().ctxDisposableUTF8Encoding); ig.addIVar("@character_name").setString(cName); ig.addIVar("@character_hue").setFX(hue); ig.addIVar("@direction").setFX(dir); ig.addIVar("@pattern").setFX(pat); elementList.add( EPGDisplaySchemaElement.buildEditorFromObject( launcher.getApp(), launcher.getContextRenderer(), ig)); }
@Override public void newObj(int objId, String objName, DatumSrcLoc sl) throws IOException {}
private int[] compileData(String arg) { String[] rules = arg.split("/"); int[] rout = new int[3 * rules.length]; for (int i = 0; i < rules.length; i++) { String[] subs = rules[i].split(","); for (int j = 0; j < subs.length; j++) { if (subs[j].startsWith("0x")) { rout[(i * 3) + j] = Integer.parseInt(subs[j].substring(2), 16); } else { rout[(i * 3) + j] = Integer.parseInt(subs[j]); } } } return rout; }
public void draw(int x, int y, int t, int tiletype, int sprScale, IGrDriver igd) { for (TSDB.TSPicture tsp : pictures) tsp.draw(x, y, t, tiletype, sprScale, igd); }
public IImage compileSheet(int count, int tileSize) { IGrDriver workingImage = GaBIEn.makeOffscreenBuffer(tileSize * count, tileSize); for (int i = 0; i < count; i++) draw(i * tileSize, 0, 0, (short) i, 1, workingImage); IImage img2 = GaBIEn.createImage( workingImage.getPixels(), workingImage.getWidth(), workingImage.getHeight()); workingImage.shutdown(); return img2; }
public boolean testFlag(int tiletype) { for (int i = 0; i < flagData.length; i += 3) { switch (flagData[i + 2]) { case 0: if ((tiletype & flagData[i]) == flagData[i + 1]) return false; break; case 1: if ((tiletype < flagData[i]) || (tiletype > flagData[i + 1])) return false; break; default: return false; } } return true; }
public void draw(int ox, int oy, int t, int tiletype, int sprScale, IGrDriver igd) { if (!acceptable.apply(t)) return; boolean flagValid = testFlag(tiletype); ITexRegion img = flagValid ? imgOn : imgOff; if (img != null) igd.blitScaledImage( 0, 0, w, h, ox + (x * sprScale), oy + (y * sprScale), w * sprScale, h * sprScale, img); }
@Override public String toString() { return idName; }
public @Nullable SchemaPath makePath(boolean create) { SchemaElement se = schema; ObjectRootHandle ilo = getILO(create); if (se == null || ilo == null) return null; return new SchemaPath(se, ilo); }
public static DMKey decode(String unescape) { if (unescape.equals("nil")) return DMKey.NULL; if (unescape.equals("true")) return DMKey.TRUE; if (unescape.equals("false")) return DMKey.FALSE; boolean str = unescape.startsWith("$"); if (str) { return DMKey.ofStr(unescape.substring(1)); } else if (unescape.startsWith(":")) { return DMKey.ofSym(unescape.substring(1)); } else { return DMKey.of(Long.parseLong(unescape)); } }
public static String encode(RORIO val) { int type = val.getType(); if (type == '0') return "nil"; if (type == 'T') return "true"; if (type == 'F') return "false"; String v2 = ""; if (type == '"') { v2 = "$" + val.decString(); } else if (type == ':') { v2 = ":" + val.getSymbol(); } else if (type == 'i') { v2 += val.getFX(); } return v2; }
@Override public int itemHeight() { return useH; }
@Override public int itemCount() { if (imgTxt.equals("")) app.ui.launchDialog(T.u.spr_msgNoImage); if (countOvr != -1) return countOvr; return ((img.getHeight() + (cellH - 1)) / cellH) * rowCells; }
@Override public int mapValToIdx(long itemVal) { return (int) itemVal; }
@Override public long mapIdxToVal(int idx) { return idx; }
@Override public void drawItem(long t, int x, int y, int spriteScale, IGrDriver igd) { int row = ((int) t) / rowCells; int col = ((int) t) % rowCells; igd.blitScaledImage( (col * cellW) + useX, (row * cellH) + useY, useW, useH, x, y, useW * spriteScale, useH * spriteScale, img); }
public SchemaElement makeSpriteSelector( final PathSyntax varPath, final PathSyntax imgPath, final String imgPfx) { final Function<String, ISpritesheetProvider> args2 = spritesheets.get(imgPfx); return new SpritesheetCoreSchemaElement( app, (v) -> { return spritesheetN.get(imgPfx).r(); }, 0, varPath, (rubyIO) -> { return args2.apply(imgPath.getRO(rubyIO).decString()); }); }
public SchemaElement makePicPointerPatchID(SchemaElement varId, SchemaElement val) { final TrSchema S = varId.T.s; return new NamespacedIntegerSchemaElement( app, new NamespacedIntegerSchemaElement.Namespace[] { new NamespacedIntegerSchemaElement.Namespace( () -> S.ppp_constant, () -> S.ppp_constant_h, 0, 9999, 0, val), new NamespacedIntegerSchemaElement.Namespace( () -> S.ppp_idVarFN, () -> S.ppp_idVar, 10000, 49999, 10000, varId), new NamespacedIntegerSchemaElement.Namespace( () -> S.ppp_idNSfxFN, () -> S.ppp_idNSfx, 50000, Long.MAX_VALUE, 50000, varId), new NamespacedIntegerSchemaElement.Namespace( () -> S.ppp_unknown, null, Long.MIN_VALUE, -1, 0, new IntegerSchemaElement(app, -1)), }); }
public SchemaElement makePicPointerPatchVar(SchemaElement varId, FF0 vname, SchemaElement val) { final TrSchema S = varId.T.s; return new NamespacedIntegerSchemaElement( app, new NamespacedIntegerSchemaElement.Namespace[] { new NamespacedIntegerSchemaElement.Namespace(vname, null, 0, 9999, 0, val), new NamespacedIntegerSchemaElement.Namespace( () -> S.ppp_valVarFN, null, 10000, Long.MAX_VALUE, 10000, varId), new NamespacedIntegerSchemaElement.Namespace( () -> S.ppp_unknown, null, Long.MIN_VALUE, -1, 0, new IntegerSchemaElement(app, -1)), }); }
public final void registerModificationHandler(Consumer<SchemaPath> handler) { objectListenersMap.add(new WeakReference<Consumer<SchemaPath>>(handler)); }
public final void deregisterModificationHandler(Consumer<SchemaPath> handler) { Utils.implRemoveFromGOCMH(objectListenersMap, handler); }
public final void objectRootModified(SchemaPath path) { if (objectRootModifiedRecursion) { objectRootModifiedQueue.add(path); return; } try { objectRootModifiedRecursion = true; objectRootModifiedPass(path); while (!objectRootModifiedQueue.isEmpty()) { objectRootModifiedPass(objectRootModifiedQueue.pop()); } } finally { objectRootModifiedRecursion = false; } }
public void objectRootModifiedPass(SchemaPath path) { Utils.handleNotificationList(objectListenersMap, path); }
public static void implRemoveFromGOCMH( LinkedList<WeakReference<Consumer<SchemaPath>>> orCreateModificationHandlers, Consumer<SchemaPath> handler) { WeakReference<Consumer<SchemaPath>> wr = null; for (WeakReference<Consumer<SchemaPath>> w : orCreateModificationHandlers) { if (w.get() == handler) { wr = w; break; } } if (wr != null) orCreateModificationHandlers.remove(wr); }
public static void handleNotificationList( LinkedList<WeakReference<Consumer<SchemaPath>>> notifyObjectModified, SchemaPath sp) { if (notifyObjectModified == null) return; Iterator<WeakReference<Consumer<SchemaPath>>> it = notifyObjectModified.iterator(); while (it.hasNext()) { WeakReference<Consumer<SchemaPath>> spi = it.next(); Consumer<SchemaPath> ics = spi.get(); if (ics == null) it.remove(); } if (sp != null) { for (WeakReference<Consumer<SchemaPath>> spi : new LinkedList<>(notifyObjectModified)) { Consumer<SchemaPath> ics = spi.get(); if (ics != null && sp != null) ics.accept(sp); } } }
@SuppressWarnings("unchecked") @Override default void handle(Object value, DatumSrcLoc srcLoc) { try { receiveLine((List<Object>) value, srcLoc); } catch (Exception e) { throw new RuntimeException("@ " + srcLoc, e); } }
default void receiveLine(List<Object> args, DatumSrcLoc sl) throws IOException { String ctl = MVMU.coerceToString(args.get(0)); Object[] arga = new Object[args.size() - 1]; for (int i = 0; i < arga.length; i++) arga[i] = args.get(i + 1); receiveCmd(ctl, arga, sl); }
default void receiveCmd(String c, Object[] args, DatumSrcLoc sl) throws IOException { if (c.equals("obj")) { if (args.length != 2) throw new RuntimeException("args must be 3 long for obj"); newObj(MVMU.cInt(args[0]), MVMU.coerceToString(args[1]), sl); } else { String[] args2 = new String[args.length]; for (int i = 0; i < args2.length; i++) args2[i] = MVMU.coerceToString(args[i]); execCmd(c, args2, args, sl); } }
public static void readFile(@Nullable AppCore app, @NonNull String s, @NonNull IDatabase db) { DatumLoader.readEssential(s, app != null ? app.loadProgress : null, db); }
public static void readFile(String fn, IDatabase db) { readFile(null, fn, db); }
public void newCMDB(String a0) { if (cmdbs.containsKey(a0)) throw new RuntimeException("Attempted to overwrite CMDB: " + a0); CMDB cm = new CMDB(this, a0); cmdbs.put(a0, cm); cmdbEntries.add(cm); }
public void loadCMDB(String arg, String fn) { getCMDB(arg).load(fn); }
public void confirmAllExpectationsMet() { for (CMDB cmdb : cmdbs.values()) cmdb.check(); }
@Override public void onTimeTravel() { markObjectAsAmbiguouslyModified(dmcx.get().get(DMCONTEXT_LOADED_OBJECT)); }
private @Nullable ObjectRootHandle tryGetObjectInternal(String id) { WeakReference<ODBHandle> riow = objectMap.get(id); if (riow == null) return null; return riow.get(); }
private LinkedList<WeakReference<Consumer<SchemaPath>>> getOrCreateRootModificationHandlers( String p) { LinkedList<WeakReference<Consumer<SchemaPath>>> notifyObjectModified = objectRootListenersMap.get(p); if (notifyObjectModified == null) { notifyObjectModified = new LinkedList<WeakReference<Consumer<SchemaPath>>>(); objectRootListenersMap.put(p, notifyObjectModified); } return notifyObjectModified; }
public void registerModificationHandler(String root, Consumer<SchemaPath> handler) { getOrCreateRootModificationHandlers(root).add(new WeakReference<Consumer<SchemaPath>>(handler)); }
public void deregisterModificationHandler(String root, Consumer<SchemaPath> handler) { Utils.implRemoveFromGOCMH(getOrCreateRootModificationHandlers(root), handler); }
public void runPendingModifications() { LinkedList<Runnable> runs = new LinkedList<>(pendingModifications); pendingModifications.clear(); for (Runnable r : runs) r.run(); }
public int countModificationListeners(ObjectRootHandle p) { if (!(p instanceof ODBHandle)) return 0; ODBHandle rootHandle = (ODBHandle) p; int n = 0; LinkedList<WeakReference<Consumer<SchemaPath>>> notifyObjectModified = rootHandle.objectListenersMap; Utils.handleNotificationList(notifyObjectModified, null); if (notifyObjectModified != null) n += notifyObjectModified.size(); String r = rootHandle.id; notifyObjectModified = objectRootListenersMap.get(r); Utils.handleNotificationList(notifyObjectModified, null); if (notifyObjectModified != null) n += notifyObjectModified.size(); return n; }
public void ensureAllSaved() { for (ObjectRootHandle rio : new LinkedList<>(modifiedObjects)) rio.ensureSaved(); }
public void revertEverything() { app.timeMachine.clearUndoRedo(); LinkedList<ODBHandle> pokedObjects = new LinkedList<>(); for (ODBHandle lo : modifiedObjects) { DMContext context = createDM3Context(); IObjectBackend.ILoadedObject newVal; try (Block license = context.changes.openUnpackLicense()) { newVal = backend.loadObject(lo.id, context); } if (newVal != null) { if (!lo.ilo.overwriteWith(newVal)) lo.getObject().setDeepClone(newVal.getObject()); pokedObjects.add(lo); } } for (ObjectRootHandle lo : pokedObjects) markObjectAsAmbiguouslyModified(lo); modifiedObjects.removeAll(pokedObjects); pokedObjects = null; System.gc(); }
private void markObjectAsAmbiguouslyModified(ObjectRootHandle lo) { lo.objectRootModified(new SchemaPath(app.sdb.getSDBEntry("OPAQUE"), lo)); }
@Override public void objectRootModifiedPass(SchemaPath path) { super.objectRootModifiedPass(path); if (tryGetObjectInternal(id) == this) { modifiedObjects.add(this); Utils.handleNotificationList(getOrCreateRootModificationHandlers(id), path); } }
@Override public void ensureSaved() { try { if (tryGetObjectInternal(id) != this) throw new RuntimeException("We somehow lost object " + id); ilo.save(); modifiedObjects.remove(this); newlyCreatedObjects.remove(this); } catch (Exception ioe) { app.reportNonCriticalErrorToUser(T.u.odb_saveErr.r(id), ioe); ioe.printStackTrace(); return; } saveHook.accept(id); }
private @Nullable FF0 dTrExUnderscoreNull(String subkey, String defVal) { if (defVal.equals("_")) return null; return app.dTr(srcLoc, subkey, defVal); }
@Override public void newObj(int objId, String objName, DatumSrcLoc sl) { throw new RuntimeException("TMP"); }
@Override public boolean handlesAddition() { return true; }
@Override public boolean correctElement(IRIO array, int commandIndex, IRIO command) { return false; }
@Override public boolean majorCorrectElement(IRIO arr, int i, IRIO commandTarg, SchemaElement baseElement) { return false; }
@Override public boolean handlesAddition() { return false; }
private boolean checkCondition(IRIO command) { RORIO p = idx.getRO(command); if (p == null) return false; return inv ^ IRIO.rubyEquals(p, v); }
@Override public boolean handlesAddition() { return igb.handlesAddition(); }
@Override public boolean correctElement(IRIO array, int commandIndex, IRIO command) { if (!checkCondition(command)) return false; return igb.correctElement(array, commandIndex, command); }
@Override public boolean majorCorrectElement(IRIO arr, int i, IRIO commandTarg, SchemaElement baseElement) { if (!checkCondition(commandTarg)) return false; return igb.majorCorrectElement(arr, i, commandTarg, baseElement); }
private void useTag() { rc.paramSpecialTags.add(nextTag); nextTag = new LinkedList<RPGCommand.SpecialTag>(); }
private SchemaElement aliasingAwareSG(String s) { SchemaElement se = localAliasing.get(s); if (se == null) se = sdb.getSDBEntry(s); return se; }
public void check() { int fails1 = 0; for (RPGCommand rc : knownCommands.values()) { rc.finish(); if (rc.description == null) { System.err.print(rc.name.toString() + " "); fails1++; } } if (fails1 > 0) System.err.println(fails1 + " commands do not have descriptions."); }
public String buildCodename(IRIO target, boolean indent, boolean full) { String ext = ""; int cid = (int) target.getIVar("@code").getFX(); if (knownCommands.containsKey(cid)) { RPGCommand cmd = knownCommands.get(cid); ext = cmd.formatName(target.getIVar("@parameters")); } String spc = full ? lenForm(cid) + " " : ""; IRIO indentValue = target.getIVar("@indent"); if ((indentValue != null) && indent) { int len = (int) target.getIVar("@indent").getFX(); if (len < 0) spc += "(INDTERR" + len + ") "; } return spc + ext; }
public String buildGroupCodename(IRIO rubyIO, int start, boolean full) { String tx = buildCodename(rubyIO.getAElem(start), true, full); int groupLen = getGroupLengthCore(rubyIO, start); for (int i = 1; i < groupLen; i++) tx += "\n" + buildCodename(rubyIO.getAElem(start + i), true, full); return tx; }
private String lenForm(int cid) { String spc = Integer.toString(cid); while (spc.length() < digitCount) spc = "0" + spc; return spc; }
public RPGCommand entryOf(IRIO command) { int code = (int) command.getIVar("@code").getFX(); return knownCommands.get(code); }
public UIEnumChoice.Category[] buildEnum() { UIEnumChoice.Category[] ecats = new UIEnumChoice.Category[categories.length]; for (int i = 0; i < ecats.length; i++) { LinkedList<UIEnumChoice.Option> llo = new LinkedList<UIEnumChoice.Option>(); for (Integer key : knownCommandOrder) { RPGCommand rc = knownCommands.get(key); String text = key + ";" + rc.formatName(null); if (rc.category == i) llo.add(new UIEnumChoice.Option(text, DMKey.of((long) (int) key))); } ecats[i] = new UIEnumChoice.Category(categories[i].r(), llo); } return ecats; }
@Override public IRIO apply(IRIO a) { return getRW(a); }
public final @Nullable HashSet<RORIO> traceRO(RORIO v) { HashSet<RORIO> set = new HashSet<>(); RORIO[] res = path.traceRouteComplete(v); for (int i = 0; i < res.length; i++) if (res[i] instanceof RORIO) set.add((RORIO) res[i]); return set; }
public final IRIO add(IRIO v) { return path.add(v); }
public final IRIO del(IRIO v) { return path.del(v); }
public static String[] breakToken(String full) { int plannedIdx = full.length(); StringBuilder sb = new StringBuilder(); char[] ch = full.toCharArray(); boolean escape = false; for (int i = 0; i < ch.length; i++) { if (escape) { escape = false; sb.append(ch[i]); } else if (ch[i] == '#') { escape = true; } else { for (char c : breakersSDB2) { if (c == ch[i]) { plannedIdx = i; break; } } if (plannedIdx != full.length()) break; sb.append(ch[i]); } } if (plannedIdx == full.length()) { return new String[] {sb.toString(), ""}; } return new String[] {sb.toString(), full.substring(plannedIdx)}; }
public static PathSyntax compile(App parentContext, String arg) { return compile(parentContext.ilg.strict, arg); }
public static PathSyntax compile(MVMEnvR48 parentContext, String arg) { return compile(parentContext.strict, arg); }
public static PathSyntax compile(PathSyntax basePS, String arg) { return new PathSyntax( basePS.path.with(compile(basePS.path.strict, arg).path), basePS.decompiled + arg); }
public static PathSyntax compile(boolean strict) { return new PathSyntax(strict ? DMPath.EMPTY_STRICT : DMPath.EMPTY_RELAXED, ""); }
public static String poundEscape(String arg) { StringBuilder res = new StringBuilder(); for (char c : arg.toCharArray()) { boolean escape = false; if (c == '#') escape = true; for (char cb : breakersSDB2) { if (c == cb) { escape = true; break; } } if (escape) res.append('#'); res.append(c); } return res.toString(); }
public int nameFromWord(String w) { for (int i = 0; i < wordMap.length; i++) if (wordMap[i].equals(w)) return i; return 0; }
@Override public void newObj(int objId, String objName, DatumSrcLoc sl) { current = new Autotile(); current.name = objName; entries[objId] = current; }
@Override public void execCmd(String cmd, String[] args, Object[] argsObj, DatumSrcLoc sl) { if (cmd.equals("w")) { wordMap = args; } else if (cmd.equals("x")) { current = new Autotile(); current.name = "X" + autoIncrementingId; entries[autoIncrementingId++] = current; int[] cornerMapping = new int[] {0, 2, 3, 5, 9, 11}; for (int i = 0; i < 4; i++) current.corners[i] = cornerMapping[Integer.parseInt(args[i])]; } else if (cmd.equals("d")) { current.corners[0] = nameFromWord(args[0]); current.corners[1] = nameFromWord(args[1]); } else if (cmd.equals("D")) { current.corners[2] = nameFromWord(args[0]); current.corners[3] = nameFromWord(args[1]); } else { throw new RuntimeException("Unknown cmd: " + cmd); } }
public void calculateInverseMap(String file) { if (file.equals("$WallATs$")) { for (int i = 0; i < 256; i++) { boolean um = (i & 2) != 0; boolean ml = (i & 8) != 0; boolean mr = (i & 16) != 0; boolean lm = (i & 64) != 0; int p = 0; p |= (!ml) ? 1 : 0; p |= (!um) ? 2 : 0; p |= (!mr) ? 4 : 0; p |= (!lm) ? 8 : 0; inverseMap[i] = p; } return; } calculateInverseMapRulesEngine(file); }
@Override public void newObj(int objId, String objName, DatumSrcLoc sl) { boolean[] mustTrue = new boolean[8]; boolean[] mustFalse = new boolean[8]; String trueThings = objName.split("T")[1]; String falseThings = ""; String[] falseA = trueThings.split("F"); trueThings = falseA[0]; if (falseA.length != 1) falseThings = falseA[1]; for (char c : trueThings.toCharArray()) mustTrue[c - '0'] = true; for (char c : falseThings.toCharArray()) mustFalse[c - '0'] = true; int base = objId * 10; for (int i = 0; i < 8; i++) { rulesEngineMustTrue[base + i] = mustTrue[i]; rulesEngineMustFalse[base + i] = mustFalse[i]; } }
@Override public void execCmd(String c, String[] args, Object[] argsObj, DatumSrcLoc sl) { if (c.equals("C")) { if (args[0].equals("disable")) for (int i = 1; i < args.length; i++) avoidThese.add(Integer.parseInt(args[i])); } else { throw new RuntimeException("unknown command: " + c); } }
public void confirmAllExpectationsMet() { if (remainingExpected.size() > 0) throw new RuntimeException( "Remaining expectation " + remainingExpected.entrySet().iterator().next()); }
private MVMSlot ensureSDBEntrySlot(String text) { MVMSlot slot = app.vmCtx.ensureSlot(new DatumSymbol("SDB." + text)); slot.help = null; slot.type = MVMEnvR48.SCHEMAELEMENT_TYPE; return slot; }
public boolean hasSDBEntry(String text) { return app.vmCtx.getSlot(new DatumSymbol("SDB." + text)) != null; }
public DynamicSchemaElement ensureSDBProxy(String text) { MVMSlot ms = ensureSDBEntrySlot(text); if (ms.v != null) { if (!(ms.v instanceof DynamicSchemaElement)) throw new RuntimeException("DynamicSchemaElement expected: " + text); return (DynamicSchemaElement) ms.v; } else { DynamicSchemaElement npse = new DynamicSchemaElement((App) app, text); ms.v = npse; return npse; } }
public LinkedList<ObjectInfo> listFileDefs() { LinkedList<ObjectInfo> fd = new LinkedList<ObjectInfo>(); for (String s : app.engine.definesObjects) fd.add(new ObjectInfo(app, s)); return fd; }
public @Nullable SchemaElement findSchemaFor(@NonNull IRIO object) { if (object.getType() == 'o') return getSDBEntry(object.getSymbol()); return null; }
public void updateDictionaries(ObjectRootHandle map) { boolean needsMerge = false; for (DynamicSchemaUpdater dur : dictionaryUpdaterRunnables) needsMerge |= dur.actIfRequired(map); if (needsMerge) for (Runnable merge : mergeRunnables) merge.run(); }
public void kickAllDictionariesForMapChange() { for (DynamicSchemaUpdater dur : dictionaryUpdaterRunnables) dur.run(); }
public void addDUR(DynamicSchemaUpdater dur) { dictionaryUpdaterRunnables.add(dur); }
public void addMergeRunnable(String id, Supplier<SchemaElement> s) { final DynamicSchemaElement dse = ensureSDBProxy(id); mergeRunnables.add( () -> { dse.setEntry(s.get()); }); }
public void registerECA(EventCommandArraySchemaElement eventCommandArraySchemaElement) { eventCommandArrays.add(eventCommandArraySchemaElement); }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { return getEntry().buildHoldingEditor(target, launcher, path); }
@Override public @Nullable String windowTitleSuffix(SchemaPath path) { return getEntry().windowTitleSuffix(path); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { getEntry().modifyVal(target, path, setDefault); }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { getEntry().visit(target, path, v, detailedPaths); }
@Override public String toString() { return "(name proxy " + tx + ")"; }
@Override public String toString() { return "(dynamic proxy " + tx + ")"; }
public static Object readInline(DatumSrcLoc base, String text) { LinkedList<Object> result = readInlineList(base, text); if (result.size() == 0) throw new RuntimeException("No object at inline Datum at " + base); if (result.size() > 1) throw new RuntimeException("Too many objects at inline Datum at " + base); return result.get(0); }
public static LinkedList<Object> readInlineList(DatumSrcLoc base, String text) { LinkedList<Object> result = new LinkedList<>(); new DatumReaderTokenSource(base.toString(), text) .visit( decVisitor( (obj, srcLoc) -> { result.add(obj); })); return result; }
public static void readEssential( String filename, @Nullable Consumer<String> loadProgress, DatumTreeUtils.VisitorLambda eval) { if (!read(filename, loadProgress, eval)) throw new RuntimeException("Expected " + filename + " but it did not exist!"); }
public static void readEssential( String filename, @Nullable Consumer<String> loadProgress, DatumVisitor ddv) { if (!read(filename, loadProgress, ddv)) throw new RuntimeException("Expected " + filename + " but it did not exist!"); }
public static boolean read( String filename, @Nullable Consumer<String> loadProgress, DatumTreeUtils.VisitorLambda eval) { return read(filename, loadProgress, decVisitor(eval)); }
@Override public void performGlobalOverlay(MapViewDrawContext mvdc, boolean minimap) { if (mvdc.mouseStatus != null) { int tx = mvdc.mouseStatus.x / mvdc.tileSize; int ty = mvdc.mouseStatus.y / mvdc.tileSize; app.a.drawSelectionBox(tx, ty, mvdc.tileSize, mvdc.tileSize, 1, mvdc.igd); } }
@Override public void confirmAt(int x, int y, int pixx, int pixy, int layer, boolean first) { if (!first) return; mapView.mapTable.eventAccess.setEventXY(targetEventKey, x, y); mapToolContext.accept(new UIMTEventPicker(mapToolContext)); }
@Override @NonNull public String viewState(int mouseXT, int mouseYT) { return "EventMover." + mouseXT + "." + mouseYT; }
@Override public void performGlobalOverlay(MapViewDrawContext mvdc, boolean minimap) { mvdc.drawMouseIndicator(); }
@Override public void confirmAt(int x, int y, int pixx, int pixy, int layer, boolean first) { if (!first) return; if (!map.mapTable.outOfBounds(x, y)) map.pickTileHelper.accept(map.mapTable.getTiletype(x, y, layer)); }
@Override @NonNull public String viewState(int mouseXT, int mouseYT) { return "PickTile"; }
@Override public UIMTBase apply(IMapToolContext a) { UIMapView.performFullCacheFlush(view.app, view); return null; }
@Override public UIMTBase apply(IMapToolContext a) { app.ui.launchSchema(view.map.object, view); return null; }
@Override public UIMTBase apply(IMapToolContext a) { return new UIMTMapResizer(mtc); }
@Override public UIMTBase apply(IMapToolContext a) { IGrDriver igd = GaBIEn.makeOffscreenBuffer( view.tileSize * view.mapTable.width, view.tileSize * view.mapTable.height); view.mapTable.renderCore(igd, 0, 0, view.layerVis, view.currentLayer, view.debugToggle); AdHocSaveLoad.prepare(); OutputStream os = GaBIEn.getOutFile(Application.BRAND + "/shot.png"); if (os != null) { try { os.write(igd.createPNG()); os.close(); app.ui.launchDialog(T.m.dlgWroteShot); } catch (Exception e) { app.ui.launchDialog(e); } } else { app.ui.launchDialog(T.m.dlgFailedToOpenFile); } igd.shutdown(); return null; }
@Override public UIMTBase apply(IMapToolContext a) { view.debugToggle = !view.debugToggle; return null; }
@Override public UIMTBase apply(IMapToolContext a) { AtlasSet potential = a.getMapView().mapTable.renderer.tileRenderer.getAtlasSet(); if (potential == null) return null; for (IGrDriver ap : potential.pages) app.ui.wm.createWindow(new UIThumbnail(ap)); return null; }
@Override public void run() { UIMTBase ub = tb.apply(mtc); if (ub != null) mtc.accept(ub); }
@Override public void run() { int w = (int) a.getNumber(); if (w < 1) w = 1; int h = (int) b.getNumber(); if (h < 1) h = 1; view.mapTable.resize(w, h); view.passModificationNotification(); }
@Override public int shouldDrawAt( MapViewDrawContext.MouseStatus mouse, int tx, int ty, int there, int layer, int currentLayer) { return there; }
@Override public void performGlobalOverlay(MapViewDrawContext mvdc, boolean minimap) { if (minimap) return; for (int tx = mvdc.camT.x; tx < mvdc.camT.x + mvdc.camT.width; tx++) { if (map.mapTable.outOfBounds(tx, 0)) continue; for (int ty = mvdc.camT.y; ty < mvdc.camT.y + mvdc.camT.height; ty++) { if (map.mapTable.outOfBounds(tx, ty)) continue; int px = tx * mvdc.tileSize; int py = ty * mvdc.tileSize; int regionId = (map.mapTable.getTiletype(tx, ty, 3) & 0xFF00) >> 8; GaBIEn.engineFonts.f6.drawLAB(mvdc.igd, px, py, "R" + regionId, false); } } }
@Override public void confirmAt(int x, int y, int pixx, int pixy, int layer, boolean first) { if (!first) return; if (map.mapTable.outOfBounds(x, y)) return; int shadowBasis = map.mapTable.getTiletype(x, y, 3) & 0x0F; int sz = map.tileSize / 2; int flagId = 0; if (pixx > sz) flagId++; if (pixy > sz) flagId += 2; shadowBasis ^= 1 << flagId; map.mapTable.setTiletype(x, y, 3, (short) (shadowBasis | (regionId.getNumber() << 8))); map.passModificationNotification(); }
@Override @NonNull public String viewState(int mouseXT, int mouseYT) { return "ShadowLayer"; }
@Override public void run() { mapToolContext.accept(null); }
private int subFrame() { return ((int) (GaBIEn.getTime() * 4)) & 1; }
@Override public void performGlobalOverlay(MapViewDrawContext mvdc, boolean minimap) { if (!stage) return; if (minimap) return; UIMapView map = mapToolContext.getMapView(); int px = startX * mvdc.tileSize; int py = startY * mvdc.tileSize; if (subFrame() == 0) mvdc.igd.clearRect(0, 0, 255, px, py, map.tileSize, map.tileSize); mvdc.drawMouseIndicator(); }
@Override public void confirmAt(int x, int y, int pixx, int pixy, int layer, boolean first) { if (!first) return; if (stage) { UIMapView map = mapToolContext.getMapView(); if (!map.mapTable.outOfBounds(x, y)) { int minX = Math.min(startX, x); int maxX = Math.max(startX, x); int minY = Math.min(startY, y); int maxY = Math.max(startY, y); ByteArrayMemoryish bam = RubyTable.initNewTable( 3, (maxX - minX) + 1, (maxY - minY) + 1, map.mapTable.planeCount, new int[map.mapTable.planeCount]); RubyTable rt = new RubyTable(bam); for (int l = 0; l < map.mapTable.planeCount; l++) for (int i = minX; i <= maxX; i++) for (int j = minY; j <= maxY; j++) if (!map.mapTable.outOfBounds(i, j)) rt.setTiletype(i - minX, j - minY, l, map.mapTable.getTiletype(i, j, l)); IRIOGeneric rb = new IRIOGeneric(app.ctxClipboardUTF8Encoding); rb.setUser("Table", bam.data); map.app.theClipboard = rb; mapToolContext.accept(null); } } else { startX = x; startY = y; innerLabel.setText(T.m.tsFinishCopy); stage = true; } }
@Override @NonNull public String viewState(int mouseXT, int mouseYT) { return "CopyRect." + subFrame() + "." + mouseXT + "." + mouseYT; }
public static UIMTBase wrapUIMT(@NonNull IMapToolContext mtc, @NonNull UIElement svl) { UIMTBase r = new UIMTBase(mtc); r.changeInner(svl, true); return r; }
@Override public void run() { parent.selfClose = false; parent.hasClosed = false; mapToolContext.accept(parent); }
@Override public int shouldDrawAt( MapViewDrawContext.MouseStatus mouse, int tx, int ty, int there, int layer, int currentLayer) { if (mouse != null) { int minX = Math.min(startX, mouse.x); int maxX = Math.max(startX, mouse.x); int minY = Math.min(startY, mouse.y); int maxY = Math.max(startY, mouse.y); if (tx >= minX) if (ty >= minY) if (tx <= maxX) if (ty <= maxY) return parent.getTCSelected(tx - startX, ty - startY); } return there; }
@Override public void performGlobalOverlay(MapViewDrawContext mvdc, boolean minimap) { if (!minimap) if (subFrame() == 0) mvdc.drawIndicator(startX, startY, MapViewDrawContext.IndicatorStyle.SolidBlue); }
@Override public void confirmAt(int x, int y, int pixx, int pixy, int layer, boolean first) { if (!first) return; if (!parent.map.mapTable.outOfBounds(x, y)) { int minX = Math.min(startX, x); int maxX = Math.max(startX, x); int minY = Math.min(startY, y); int maxY = Math.max(startY, y); parent.performGeneralRectangle(layer, startX, startY, minX, minY, maxX, maxY); parent.selfClose = false; parent.hasClosed = false; mapToolContext.accept(parent); } }
@Override @NonNull public String viewState(int mouseXT, int mouseYT) { return "ATR." + subFrame() + "." + mouseXT + "." + mouseYT; }
@Override public String toString() { return T.m.tsEvPick.r(eventCache.size()); }
public static void showEvent(DMKey key, @NonNull UIMapView map, IRIO event) { IEventAccess.EventSchema root = map.mapTable.eventAccess.getEventSchema(key); if (root == null) return; key = root.key; map.app.ui.launchDisconnectedSchema(root.root, key, event, root.eventSchema, "E" + key, map); }
public static void showEventDivorced( App app, DMKey key, ObjectRootHandle map, IRIO event, SchemaElement eventSchema) { app.ui.launchDisconnectedSchema(map, key, event, eventSchema, "E" + key, null); }
@Override @NonNull public String viewState(int mouseXT, int mouseYT) { return "EventPicker"; }
@Override public void run() { for (UIButton<?> utb : options) utb.state = false; options.get(0).state = true; subtool = 0; }
@Override public void run() { for (UIButton<?> utb : options) utb.state = false; options.get(1).state = true; subtool = 1; }
@Override public void run() { for (UIButton<?> utb : options) utb.state = false; options.get(2).state = true; subtool = 2; }
public void refresh() { int ti = tabPane.getTabIndex(); int inTabIndex = 0; TileEditingTab tet = null; if (ti != -1) { tet = tileTabs[ti]; inTabIndex = tileMaps[ti].getSelected(); } setupView(false); if (tet != null) { for (int i = 0; i < tileTabs.length; i++) { if (!tileTabs[i].doNotUse) { if (tileTabs[i].compatibleWith(tet)) { tileMaps[i].setSelected(inTabIndex); tabPane.selectTab(tileMaps[i]); break; } } } } }
@Override public int shouldDrawAt( MapViewDrawContext.MouseStatus mouse, int tx, int ty, int there, int layer, int currentLayer) { if (layer != currentLayer) return there; if (mouse == null) return there; if (mouse.pressed) return there; int tab = tabPane.getTabIndex(); if (tab == -1) return there; UITileGrid map = tileMaps[tab]; if (subtool != 0) { if ((mouse.x == tx) && (mouse.y == ty)) { TileEditingTab tabInst = tileTabs[tab]; int selectedLocalTileIndex = map.getSelected(); if (tabInst.inActTilesRange(selectedLocalTileIndex)) return (short) tabInst.actTiles[selectedLocalTileIndex]; } return there; } int px = tx - mouse.x; int py = ty - mouse.y; if (px < 0) return there; if (py < 0) return there; if (px >= map.selWidth) return there; if (py >= map.selHeight) return there; return getTCSelected(px, py); }
@Override public void performGlobalOverlay(MapViewDrawContext mvdc, boolean minimap) {}
private static AutoTileTypeField getAutotileType( UIMapView map, int x, int y, int layer, AutoTileTypeField[] atBases, AutoTileTypeField preferred) { if (map.mapTable.outOfBounds(x, y)) return preferred; int m = map.mapTable.getTiletype(x, y, layer); return getAutotileType(m, atBases); }
public static void updateAutotile( UIMapView map, AutoTileTypeField[] atBases, int x, int y, int layer) { AutoTileTypeField myAT = getAutotileType(map, x, y, layer, atBases, null); if (myAT == null) return; int index = 0; int power = 1; for (int i = -1; i < 2; i++) for (int j = -1; j < 2; j++) { if (i == 0) if (j == 0) continue; if (myAT.considersSameAs(getAutotileType(map, x + j, y + i, layer, atBases, myAT))) index |= power; power <<= 1; } int recommendedTile = map.app.autoTiles[myAT.databaseId].inverseMap[index] + myAT.start; map.mapTable.setTiletype(x, y, layer, (short) recommendedTile); map.passModificationNotification(); }
@Override public String toString() { int tab = tabPane.getTabIndex(); if (tab == -1) return "???"; TileEditingTab tabInst = tileTabs[tab]; int selectedLocalTileIndex = tileMaps[tab].getSelected(); if (!tabInst.inActTilesRange(selectedLocalTileIndex)) return "TMFAULT/" + tab + "/" + selectedLocalTileIndex; return "T" + tabInst.actTiles[selectedLocalTileIndex]; }
public void selectTile(int aShort, boolean preferATs) { if (preferATs) { AutoTileTypeField attf = getAutotileType(aShort, atBases); if (attf != null) aShort = attf.start; } for (int pass = 0; pass < 2; pass++) { boolean queryATProcessingValue = preferATs; if (pass != 0) queryATProcessingValue = !queryATProcessingValue; for (int i = 0; i < tileTabs.length; i++) { if (tileTabs[i].atProcessing != queryATProcessingValue) continue; for (int j = 0; j < tileTabs[i].actTiles.length; j++) { if (tileTabs[i].actTiles[j] == aShort) { tabPane.selectTab(tileMaps[i]); tileMaps[i].setSelected(j); return; } } } } System.err.println("Cannot find tile " + aShort); }
@Override @NonNull public String viewState(int mouseXT, int mouseYT) { int ti = tabPane.getTabIndex(); String rest = ""; if (ti != -1) rest = "." + tileMaps[ti].getSelected() + "." + tileMaps[ti].selWidth + "." + tileMaps[ti].selHeight; return "AutoTile." + mouseXT + "." + mouseYT + "." + ti + rest; }
@Override public void run() { actualConfirm(confirmX, confirmY); changeInner(innerLabel, false); confirming = false; }
@Override public void run() { changeInner(innerLabel, false); confirming = false; }
@Override public int shouldDrawAt( MapViewDrawContext.MouseStatus mouse, int tx, int ty, int there, int layer, int currentLayer) { int cx; int cy; if (confirming) { cx = confirmX; cy = confirmY; } else { if (mouse == null) return there; cx = mouse.x; cy = mouse.y; } if (tx < cx) return there; if (ty < cy) return there; if (tx >= cx + table.width) return there; if (ty >= cy + table.height) return there; int px = tx - cx; int py = ty - cy; return table.getTiletype(px, py, layer); }
@Override public void confirmAt( final int x, final int y, int pixx, int pixy, final int layer, boolean first) { if (!first) return; if (app.ui.isMobile && !confirming) { confirmX = x; confirmY = y; changeInner(confirmButton, false); confirming = true; } else { actualConfirm(x, y); } }
private void actualConfirm(int x, int y) { UIMapView map = mapToolContext.getMapView(); for (int l = 0; l < table.planeCount; l++) for (int i = 0; i < table.width; i++) for (int j = 0; j < table.height; j++) if (!map.mapTable.outOfBounds(i + x, j + y)) map.mapTable.setTiletype(i + x, j + y, l, table.getTiletype(i, j, l)); map.passModificationNotification(); }
@Override @NonNull public String viewState(int mouseXT, int mouseYT) { return "PasteRct." + confirming + "." + confirmX + "." + confirmY + "." + mouseXT + "." + mouseYT; }
public boolean containsLine(TOutline.Line tl) { return set.contains(tl); }
public void append(TOutline.Line tl) { set.add(tl); testedValidity.clear(); involvedTiles = null; }
public TOutline.Line removeLast() { if (set.size() > 0) { TOutline.Line l = set.removeLast(); testedValidity.clear(); involvedTiles = null; return l; } return null; }
public boolean validWith(TOutline.Line tl) { if (testedValidity.containsKey(tl)) return testedValidity.get(tl); MOutline mo = new MOutline(); mo.set.addAll(set); mo.set.add(tl); boolean v = mo.valid(); testedValidity.put(tl, v); return v; }
public static boolean addValidityForLine(Set<FillAlgorithm.Point> correlation, TOutline.Line cl) { int tileX = UIElement.sensibleCellDiv(cl.a.x, 2); int tileY = UIElement.sensibleCellDiv(cl.a.y, 2); boolean wouldBeValid = false; for (int i = -1; i <= 1; i++) { for (int j = -1; j <= 1; j++) { if (TOutline.isLineValid(cl.transformFor(i - tileX, j - tileY))) { if (correlation != null) correlation.add(new FillAlgorithm.Point(tileX - i, tileY - j)); wouldBeValid = true; } } } return wouldBeValid; }
@Override public boolean equals(Object o) { if (!(o instanceof Line)) return false; if (((Line) o).a.equals(a)) if (((Line) o).b.equals(b)) return true; return false; }
@Override public int hashCode() { return a.hashCode() ^ b.hashCode(); }
public Line transformFor(int i, int i1) { return new Line(a.offset((i * 2), (i1 * 2)), b.offset((i * 2), (i1 * 2))); }
public static boolean isLineValid(Line cl) { if (!isPointValid(cl.a)) return false; if (!isPointValid(cl.b)) return false; return true; }
private static boolean isPointValid(FillAlgorithm.Point b) { if (b.x < 0) return false; if (b.y < 0) return false; if (b.x > 2) return false; if (b.y > 2) return false; return !((b.x == 1) && (b.y == 1)); }
@Override public String toString() { return T.m.tDeepWater.r(mapToolContext.getMapView().currentLayer); }
@Override public int shouldDrawAt( MapViewDrawContext.MouseStatus mouseAllowed, int tx, int ty, int there, int layer, int currentLayer) { if (layer != currentLayer) return there; TOutline mo = workspace.getOutlineForTile(tx, ty); if (mo != null) return mo.getUsedIdReal(); return there; }
@Override public void performGlobalOverlay(MapViewDrawContext mvdc, boolean minimap) { for (int tx = mvdc.camT.x; tx < mvdc.camT.x + mvdc.camT.width; tx++) { for (int ty = mvdc.camT.y; ty < mvdc.camT.y + mvdc.camT.height; ty++) { int px = tx * mvdc.tileSize; int py = ty * mvdc.tileSize; int ps2 = mapToolContext.getMapView().tileSize / 2; for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { int itx = (tx * 2) + i, ity = (ty * 2) + j; int drawMode = 0; if (!placingPen) { Runnable optval = optValidity(itx, ity); boolean gbi = (itx == lcrX) && (ity == lcrY); if ((optval != null) || gbi) drawMode = gbi ? 2 : 1; } else { if ((i == 1) && (j == 1)) continue; drawMode = 1; } if (drawMode != 0) mvdc.igd.clearRect(0, 0, 0, px + (i * ps2) - 2, py + (j * ps2) - 2, 4, 4); if (drawMode == 1) { mvdc.igd.clearRect(255, 255, 255, px + (i * ps2) - 1, py + (j * ps2) - 1, 2, 2); } else if (drawMode == 2) { mvdc.igd.clearRect(255, 0, 0, px + (i * ps2) - 1, py + (j * ps2) - 1, 2, 2); } } } } } }
@Override public void run() { workspace.append(tl); lcrX = i; lcrY = i1; }
@Override public void confirmAt(int x, int y, int pixx, int pixy, int layer, boolean first) { int ps2 = mapToolContext.getMapView().tileSize / 2; int cpcX = (x * 2 * ps2) + pixx; int cpcY = (y * 2 * ps2) + pixy; cpcX += ps2 / 2; cpcY += ps2 / 2; int hsx = sensibleCellMod(cpcX, ps2); int hsy = sensibleCellMod(cpcY, ps2); int margin = (ps2 / 3); if (hsx < margin) return; if (hsy < margin) return; if (hsx > (ps2 - margin)) return; if (hsy > (ps2 - margin)) return; cpcX = sensibleCellDiv(cpcX, ps2); cpcY = sensibleCellDiv(cpcY, ps2); if (placingPen) { lcrX = cpcX; lcrY = cpcY; placingPen = false; } else { Runnable rr = optValidity(cpcX, cpcY); if (rr != null) rr.run(); } }
@Override @NonNull public String viewState(int mouseXT, int mouseYT) { return "FtrGdt01." + placingPen + "." + lcrX + "." + lcrY + "." + workspace.getLength(); }
public static boolean supports(ImageIOImage img) { if (img.palette != null) return img.palette.size() <= 256; return false; }
@Override public String saveName(ImageIOImage img) { if (supports(img)) return ilg.t.g.img_xyz; return null; }
@Override public byte[] saveFile(ImageIOImage img) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write('X'); baos.write('Y'); baos.write('Z'); baos.write('1'); IntUtils.writeU16(baos, img.width); IntUtils.writeU16(baos, img.height); DeflaterOutputStream d2 = new DeflaterOutputStream(baos); ByteArrayOutputStream baos2 = new ByteArrayOutputStream(); for (int i = 0; i < 256; i++) { int c = 0; if (img.palette.size() > i) c = img.palette.get(i); baos2.write((c >> 16) & 0xFF); baos2.write((c >> 8) & 0xFF); baos2.write(c & 0xFF); } for (int i = 0; i < img.colourData.length; i++) baos2.write(img.colourData[i]); baos2.writeTo(d2); d2.finish(); return baos.toByteArray(); }
@Override public ImageIOImage loadFile(byte[] s, WSIImage gInput) throws IOException { ByteArrayInputStream fis = new ByteArrayInputStream(s); if (fis.read() != 'X') throw new IOException("Bad magic"); if (fis.read() != 'Y') throw new IOException("Bad magic"); if (fis.read() != 'Z') throw new IOException("Bad magic"); if (fis.read() != '1') throw new IOException("Bad magic"); int w = IntUtils.readU16(fis); int h = IntUtils.readU16(fis); InflaterInputStream iis = new InflaterInputStream(fis); LinkedList<Integer> pal = new LinkedList<Integer>(); for (int i = 0; i < 256; i++) { int r = IntUtils.readU8(iis); int g = IntUtils.readU8(iis); int b = IntUtils.readU8(iis); pal.add(0xFF000000 | ((r << 16) | (g << 8) | b)); } int[] img = new int[w * h]; int ind = 0; for (int i = 0; i < w * h; i++) img[ind++] = IntUtils.readU8(iis); return new ImageIOImage(w, h, img, pal); }
@Override public String saveName(ImageIOImage img) { if (PNG8IImageIOFormat.supports(img)) return null; return ilg.t.g.img_png32; }
@Override public byte[] saveFile(ImageIOImage img) throws IOException { return img.rasterizeToWSI().createPNG(); }
@Override public ImageIOImage loadFile(byte[] s, WSIImage iImage) throws IOException { if (iImage == null) throw new IOException("system image loader didn't understand it"); return new ImageIOImage(iImage.width, iImage.height, iImage.getPixels(), null); }
private static byte[] getChunk(String ihdr, DataInputStream dis) throws IOException { int magicWanted = PNGChunk.encodeMagic(ihdr); int end = PNGChunk.encodeMagic("IEND"); while (true) { PNGChunk pc = PNGChunk.getChunk(dis); if (pc.magic == end) return null; if (pc.magic == magicWanted) return pc.data; } }
@Override public String saveName(ImageIOImage img) { if (supports(img)) return ilg.t.g.img_png8; return null; }
private int performCRC(ByteArrayOutputStream baos, DataOutputStream dos, int mark) throws IOException { byte[] fullSet = baos.toByteArray(); int checksum = 0xFFFFFFFF; for (int i = mark; i < fullSet.length; i++) { int xv = performCRCSub((checksum ^ fullSet[i]) & 0xFF); checksum = (checksum >> 8) & 0x00FFFFFF; checksum ^= xv; } checksum = ~checksum; dos.writeInt(checksum); return checksum; }
private int performCRCSub(int i) { for (int j = 0; j < 8; j++) { boolean top = (i & 1) != 0; i = (i >> 1) & 0x7FFFFFFF; if (top) i ^= 0xEDB88320; } return i; }
private byte[] compressPNG8IData(ImageIOImage img) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); DeflaterOutputStream dos = new DeflaterOutputStream(baos); for (int i = 0; i < img.height; i++) { dos.write(0); for (int j = 0; j < img.width; j++) dos.write(img.getRaw(j, i)); } dos.finish(); return baos.toByteArray(); }
private ImageIOImage finallyAssembleTheData( int width, int height, byte[] scanlineData, byte[] plte, byte[] trns) throws IOException { int[] data = new int[width * height]; LinkedList<Integer> pal = new LinkedList<Integer>(); for (int i = 0; i < plte.length; i += 3) { int ti = i / 3; int c = 0xFF000000; c |= (plte[i] & 0xFF) << 16; c |= (plte[i + 1] & 0xFF) << 8; c |= plte[i + 2] & 0xFF; if (trns != null) if (trns.length > ti) { c &= 0x00FFFFFF; c |= (trns[ti] & 0xFF) << 24; } pal.add(c); } int idx = 0; int oidx = 0; for (int i = 0; i < height; i++) { int alg = scanlineData[idx++]; if (alg != 0) throw new IOException("Need support for algs"); for (int j = 0; j < width; j++) { data[oidx++] = scanlineData[idx++] & 0xFF; } } return new ImageIOImage(width, height, data, pal); }
public static PNGChunk getChunk(DataInputStream dis) throws IOException { int len = dis.readInt(); int maj = dis.readInt(); byte[] data = new byte[len]; if (dis.read(data) != len) throw new IOException("did not read all of chunk"); dis.readInt(); return new PNGChunk(maj, data); }
public static int encodeMagic(String m) { try { byte[] d = m.getBytes("UTF-8"); return new DataInputStream(new ByteArrayInputStream(d)).readInt(); } catch (IOException e) { e.printStackTrace(); return -1; } }
public static ImageIOFormat[] initializeFormats(InterlaunchGlobals app) { return new ImageIOFormat[] { new XYZImageIOFormat(app), new PNG8IImageIOFormat(app), new BMP8IImageIOFormat(app, 8), new BMP8IImageIOFormat(app, 4), new BMP8IImageIOFormat(app, 1), new GabienImageIOFormat(app), }; }
public static TryToLoadResult tryToLoad(FSBackend fs, ImageIOFormat[] formats) { ByteArrayOutputStream dataHolder = new ByteArrayOutputStream(); InputStream inp = GaBIEn.getInFile(fs); if (inp != null) { try { byte[] buffer = new byte[2048]; while (inp.available() > 0) { int l = inp.read(buffer); if (l <= 0) break; dataHolder.write(buffer, 0, l); } inp.close(); } catch (IOException ioe) { try { inp.close(); } catch (IOException ioe2) { } } } else { return null; } return tryToLoad(dataHolder.toByteArray(), formats); }
public static TryToLoadResult tryToLoad(byte[] data, ImageIOFormat[] formats) { WSIImage im = GaBIEn.decodeWSIImage(new ByteArrayInputStream(data)); for (ImageIOFormat ief : formats) { ImageIOImage iei = null; try { iei = ief.loadFile(data, im); } catch (Exception ioe) { ioe.printStackTrace(); } if (iei != null) return new TryToLoadResult(ief, iei, ief.knowsColourKey); } return null; }
private int[] colourDataToARGBByRef() { if (palette == null) { return colourData; } else { int[] data = new int[colourData.length]; for (int i = 0; i < data.length; i++) data[i] = translatePalette(colourData[i]); return data; } }
public IImage rasterize() { return GaBIEn.createImage(colourDataToARGBByRef(), width, height); }
public WSIImage rasterizeToWSI() { return GaBIEn.createWSIImage(colourDataToARGBByRef(), width, height); }
private int translatePalette(int c) { if ((c < 0) || (c >= palette.size())) { return 0xFFFF00FF; } else { return palette.get(c); } }
@Override public String saveName(ImageIOImage img) { if (img.palette == null) return null; if (img.palette.size() == 0) return null; if (img.palette.size() > (1 << actuallyBits)) return null; return ilg.t.g.img_bmpX.r(actuallyBits); }
@Override public byte[] saveFile(ImageIOImage img) throws IOException { if (saveName(img) == null) throw new IOException("Not supposed to be here, are we?"); byte[] base = BMPConnection.prepareBMP( img.width, img.height, actuallyBits, img.palette.size(), false, false); BMPConnection bc = new BMPConnection(new ByteArrayMemoryish(base), BMPConnection.CMode.Normal, 0, false); for (int i = 0; i < img.palette.size(); i++) bc.putPalette(i, img.palette.get(i)); for (int i = 0; i < img.width; i++) for (int j = 0; j < img.height; j++) bc.putPixel(i, j, img.getRaw(i, j)); return base; }
@Override public ImageIOImage loadFile(byte[] s, WSIImage gInput) throws IOException { BMPConnection eDreams = new BMPConnection(new ByteArrayMemoryish(s), BMPConnection.CMode.Normal, 0, false); if (eDreams.ignoresPalette) throw new IOException( "Shouldn't load image this way ; it's not paletted. Better to use native methods if" + " possible."); if (actuallyBits != eDreams.bpp) throw new IOException("Not the same amount of bits"); int[] pixels = new int[eDreams.width * eDreams.height]; for (int i = 0; i < pixels.length; i++) pixels[i] = eDreams.getPixel(i % eDreams.width, i / eDreams.width); LinkedList<Integer> pal = new LinkedList<Integer>(); for (int i = 0; i < eDreams.paletteCol; i++) pal.add(eDreams.getPalette(i) | 0xFF000000); return new ImageIOImage(eDreams.width, eDreams.height, pixels, pal); }
public static void save(Config c) { IRIOGeneric prepare = new IRIOGeneric(AdHocSaveLoad.newContext()); prepare.setObject("R48::FontConfig"); for (FontSizeField fsf : c.f.fields) prepare.addIVar("@" + fsf.configID).setFX(fsf.get()); encodeStringList(prepare.addIVar("@secondary_images_list"), c.secondaryImageLoadLocationBackup); encodeStringList(prepare.addIVar("@saved_rootpath_list"), c.rootPathBackup); setString(prepare.addIVar("@lang"), c.language); if (c.fontOverride != null) { setString(prepare.addIVar("@sysfont"), c.fontOverride); prepare.addIVar("@sysfont_ue8").setBool(c.fontOverrideUE8); } prepare.addIVar("@global_volume").setFX(Math.round(c.globalVolume * 65536.0f)); prepare.addIVar("@theme_variant").setFX(c.borderTheme); prepare.addIVar("@windowing_external").setBool(c.windowingExternal); AdHocSaveLoad.save("fonts", prepare); }
private static void encodeStringList(IRIO arr, LinkedList<String> values) { arr.setArray(values.size()); int idx = 0; for (String s : values) { IRIO elm = arr.getAElem(idx++); setString(elm, s); } }
public String trName(TrFontSizes fs) { try { return (String) trPageField.get(fs); } catch (Exception e) { throw new RuntimeException(e); } }
@Override public void accept(Integer integer) { try { intern.setInt(FontSizes.this, integer); } catch (IllegalAccessException e) { throw new RuntimeException(e); } }
@Override public Integer get() { try { return intern.getInt(FontSizes.this); } catch (IllegalAccessException e) { throw new RuntimeException(e); } }
public int scaleGuess(int defaultVal) { return (defaultVal * uiGuessScaleTenths) / 10; }
public int scaleGrid(int defaultVal) { return (defaultVal * uiGridScaleTenths) / 10; }
public void reset() { resetFontSizes(); windowingExternal = false; borderTheme = 0; secondaryImageLoadLocationBackup.clear(); rootPathBackup.clear(); globalVolume = 1.0f; language = LanguageList.defaultLang; if (isMobile) rootPathBackup.add("easyrpg/games/R48 Game"); }
public void resetFontSizes() { try { for (final FontSizeField field : f.fields) field.accept(field.defValue); } catch (Exception e) { throw new RuntimeException(e); } fontOverride = GaBIEn.getDefaultNativeFontName(); fontOverrideUE8 = false; f.uiGuessScaleTenths = autodetectedUIScaleTenths; for (FontSizeField fsf : f.fields) { if (isMobile) if (fsf.get() == 8) fsf.accept(16); if (fsf != f.f_uiGuessScaleTenths) fsf.accept(f.scaleGuess(fsf.get())); } if (isMobile) f.tilesTabTH *= 2; applyUIGlobals(); }
public void applyUIGlobals() { borderTheme %= ThemingCentral.themes.length; Theme base = ThemingCentral.themes[borderTheme]; base = Theme.FM_GLOBAL.with(base, new FontManager(fontOverride, fontOverrideUE8)); GaBIEnUI.sysThemeRoot.setThemeOverride(base); GaBIEn.sysCoreFontSize = f.gSysCoreTH; }
@Override public String toString() { return id + "@" + sourceLoc + "(NLS)"; }
@Override public void visitTree(Object obj, DatumSrcLoc srcLoc) { if (obj instanceof List) { @SuppressWarnings("unchecked") List<Object> lo = (List<Object>) obj; if (lo.size() != 2) throw new RuntimeException( "LangInfo struct needs 2 strings, check upstream terms/index.txt"); String sa = (String) lo.get(0); String sb = (String) lo.get(1); tgt.add(new LangInfo(key, sa, sb)); } }
private static LangInfo[] createLanguageList() { final LinkedList<LangInfo> languageLL = new LinkedList<LangInfo>(); addFn(languageLL, "terms/index.scm"); addFn(languageLL, "terms/index.aux.scm"); return languageLL.toArray(new LangInfo[0]); }
private final Object missingTerm( String name, Type type, Consumer<String> logTrIssues, final String msg) { System.err.println("TrPage: Missing term " + name); if (type == String.class) { return msg; } else if (type == FF0.class) { return (FF0) () -> msg; } else if (type == FF1.class) { return (FF1) (a) -> msg; } else if (type == FF2.class) { return (FF2) (a, b) -> msg; } else if (type == FF3.class) { return (FF3) (a, b, c) -> msg; } else if (type == FF4.class) { return (FF4) (a, b, c, d) -> msg; } else { throw new RuntimeException("TrPage: Unable to handle " + name + " type " + type); } }
default FF0 dTr(DatumSrcLoc srcLoc, String id, String text) { return dynTrBase(srcLoc, id, null, text, false); }
default FF1 dTrFF1(DatumSrcLoc srcLoc, String id, Object text) { return dynTrBase(srcLoc, id, DynTrSlot.DYNTR_FF1, text, false); }
default FF2 dTrFF2(DatumSrcLoc srcLoc, String id, Object text) { return dynTrBase(srcLoc, id, DynTrSlot.DYNTR_FF2, text, false); }
default FF1 dTrName(DatumSrcLoc srcLoc, String id, Object text, boolean isNLS) { return dynTrBase(srcLoc, TrNames.nameRoutine(id), DynTrSlot.DYNTR_FF1, text, isNLS); }
public static String dynLn(String string) { return "TrDynLauncher." + string; }
public static String cmdbCat(String dbId, int cat) { return "TrCMDB_" + dbId + "_cat.c" + cat; }
public static String cmdbName(String dbId, int commandId) { return "TrCMDB_" + dbId + "_c" + commandId + ".n"; }
public static String cmdbDesc(String dbId, int commandId) { return "TrCMDB_" + dbId + "_c" + commandId + ".d"; }
public static String cmdbParam(String dbId, int commandId, int paramIdx) { return "TrCMDB_" + dbId + "_c" + commandId + ".p" + paramIdx; }
public static String cmdbCommandTag(String id) { return "TrCMDBTag." + id; }
public static String sdbAnon(String ovc, String text) { return "TrSDB_" + ovc + ".$" + text; }
public static String sdbEnum(String string, String k) { return "TrSDB_" + string + ".e" + k; }
public static String sdbWindowTitle(String ovc) { return "TrSDB_" + ovc + ".title"; }
public static String sdbLabel(String ovc, String topic) { return "TrSDB_" + ovc + ".label." + topic; }
public static String nameRoutine(String name) { return "TrName." + name; }
public static String sdbSpritesheet(String imgPfx) { return "TrSpritesheet." + imgPfx; }
@Override public String toString() { return id + "@" + sourceLoc; }
public static Object compileValue( @NonNull MVMEnv env, @Nullable DatumSymbol mode, DatumSrcLoc srcLoc, Object v) { if (mode == null) { return env.evalObject(v, srcLoc); } else { return ((MVMFn) env.getSlot(mode).v).clDirect(v); } }
@Override public String r() { return resolve(0, null, null, null, null); }
@Override public String r(Object a0) { return resolve(1, a0, null, null, null); }
@Override public String r(Object a0, Object a1) { return resolve(2, a0, a1, null, null); }
@Override public String r(Object a0, Object a1, Object a2) { return resolve(3, a0, a1, a2, null); }
@Override public String r(Object a0, Object a1, Object a2, Object a3) { return resolve(4, a0, a1, a2, a3); }
@Override public Object callDirect() { return r(); }
@Override public Object callDirect(Object a0) { return r(a0); }
@Override public Object callDirect(Object a0, Object a1) { return r(a0, a1); }
@Override public Object callDirect(Object a0, Object a1, Object a2) { return r(a0, a1, a2); }
@Override public Object callDirect(Object a0, Object a1, Object a2, Object a3) { return r(a0, a1, a2, a3); }
@Override public int layoutGetHForW(int width) { Size bgb1 = subElement.getWantedSize(); Size bgb2 = button.getWantedSize(); if (bgb1.width + bgb2.width <= width) { return Math.max(bgb1.height, bgb2.height); } else { return subElement.layoutGetHForW(width) + button.layoutGetHForW(width); } }
@Override protected void layoutRunImpl() { Size r = getSize(); Size bgb1 = subElement.getWantedSize(); Size bgb2 = button.getWantedSize(); if (bgb1.width + bgb2.width <= r.width) { subElement.setForcedBounds(this, new Rect(0, 0, r.width - bgb2.width, r.height)); button.setForcedBounds(this, new Rect(r.width - bgb2.width, 0, bgb2.width, r.height)); } else { int b1h = button.layoutGetHForW(r.width); subElement.setForcedBounds(this, new Rect(0, 0, r.width, r.height - b1h)); button.setForcedBounds(this, new Rect(0, r.height - b1h, r.width, b1h)); } }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { Size bgb1 = subElement.getWantedSize(); Size bgb2 = button.getWantedSize(); return new Size(bgb1.width + bgb2.width, Math.max(bgb1.height, bgb2.height)); }
public UIAppendButton togglable(boolean gridST) { button.togglable(gridST); return this; }
@Override protected void layoutRunImpl() { Size aWanted = a.getWantedSize(), bWanted = b.getWantedSize(); Size mySize = getSize(); int qWidth = aWanted.width; if (hasOverride) qWidth = overrideValue.get(); int reqWidth = qWidth + bWanted.width; boolean performHorizontal = true; if (mySize.width < reqWidth) { qWidth = aWanted.width; int req2Width = qWidth + bWanted.width; if (mySize.width < req2Width) performHorizontal = false; } if (performHorizontal) { a.setForcedBounds(this, new Rect(0, 0, qWidth, mySize.height)); b.setForcedBounds(this, new Rect(qWidth, 0, mySize.width - qWidth, mySize.height)); } else { int split = a.layoutGetHForW(mySize.width); a.setForcedBounds(this, new Rect(0, 0, mySize.width, split)); b.setForcedBounds(this, new Rect(0, split, mySize.width, mySize.height - split)); } }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { Size aWanted = a.getWantedSize(), bWanted = b.getWantedSize(); int qWidth = aWanted.width; if (hasOverride) qWidth = overrideValue.get(); int reqWidth = qWidth + bWanted.width; int reqHeight = Math.max(aWanted.height, bWanted.height); return new Size(reqWidth, reqHeight); }
@Override public int layoutGetHForW(int width) { Size aWanted = a.getWantedSize(), bWanted = b.getWantedSize(); int qWidth = aWanted.width; if (hasOverride) qWidth = overrideValue.get(); int reqWidth = qWidth + bWanted.width; int reqHeight = Math.max(aWanted.height, bWanted.height); if (width < reqWidth) { qWidth = aWanted.width; int req2Width = qWidth + bWanted.width; if (width < req2Width) return a.layoutGetHForW(width) + b.layoutGetHForW(width); } return reqHeight; }
@Override public void renderContents(boolean drawBlack, IGrDriver igd) { int bw = getBorderWidth(); Size sz = getSize(); UIColourSwatch.doRender(igd, col, bw, bw, sz.width - (bw * 2), sz.height - (bw * 2)); }
public static void drawZoom(IGrDriver igd, boolean b, int x, int y, int size) { int m = size / 12; if (m < 1) m = 1; igd.clearRect(128, 128, 128, x, y, size, size); igd.clearRect(64, 64, 64, x + m, y + m, size - (m * 2), size - (m * 2)); int pa = (((size + 1) / 2) + m) - ((size / 2) - m); if (b) igd.clearRect(255, 255, 255, x + (size / 2) - m, y + (m * 2), pa, size - (m * 4)); igd.clearRect(255, 255, 255, x + (m * 2), y + (size / 2) - m, size - (m * 4), pa); }
public void drawDragControl(IGrDriver igd, boolean select, int x, int y, int size) { int m = size / 12; int a = 64; int b = 128; if (select) { a = 128; b = 255; } igd.clearRect(b, b, b, x, y, size, size); igd.clearRect(a, a, a, x + m, y + m, size - (m * 2), size - (m * 2)); int xd = m; drawSymbol( igd, Art.Symbol.Camera, x + m + xd, y + m + xd, size - ((m + xd) * 2), false, select); }
public void drawSelectionBox(int x, int y, int w, int h, int thickness, IGrDriver igd) { int f = ((int) (GaBIEn.getTime() * (dotLineAni + 1))) % (dotLineAni + 1); while (thickness > 0) { drawDotLineV(x, y, h, f, igd); drawDotLineV(x + (w - 1), y, h, dotLineAni - f, igd); drawDotLineH(x, y, w, dotLineAni - f, igd); drawDotLineH(x, y + (h - 1), w, f, igd); thickness--; x++; y++; w -= 2; h -= 2; } }
private void drawDotLineV(int x, int y, int h, int f, IGrDriver igd) { if (h <= 0) return; while (h > dotLineMetric) { igd.blitImage(32, f, 1, dotLineMetric, x, y, layerTabs); y += dotLineMetric; h -= dotLineMetric; } igd.blitImage(32, f, 1, h, x, y, layerTabs); }
private void drawDotLineH(int x, int y, int w, int f, IGrDriver igd) { if (w <= 0) return; while (w > dotLineMetric) { igd.blitImage(32 + f, 0, dotLineMetric, 1, x, y, layerTabs); x += dotLineMetric; w -= dotLineMetric; } igd.blitImage(32 + f, 0, w, 1, x, y, layerTabs); }
private static IImage genColourPal() { int[] img = new int[256 * 256]; int idx = 0; for (int y = 0; y < 256; y++) { for (int x = 0; x < 256; x++) { int r = 255 - y; int g = ((255 - x) * r) / 255; int v = 0xFF000000 | (r << 16) | (g << 8) | g; img[idx++] = v; } } return GaBIEn.createImage(img, 256, 256); }
private static IImage genRainbow() { int[] img = new int[256]; for (int x = 0; x < 256; x++) img[x] = new HueShiftImageEffect(getRainbowHue(x)).processCol(0xFFFF0000); return GaBIEn.createImage(img, 256, 1); }
public static void tabWindowIcon(IGrDriver igd, int x, int y, int size) { int tabAscender = size / 4; int tabMargin = Math.max(1, size / 8); igd.clearRect(64, 64, 128, x, y, size / 2, size - tabAscender); igd.clearRect( 32, 32, 64, x + tabMargin, y + tabMargin, (size / 2) - (tabMargin * 2), (size - tabAscender) - (tabMargin * 2)); igd.clearRect(64, 64, 128, x, y + tabAscender, size, size - tabAscender); }
public static void windowWindowIcon(IGrDriver igd, int x, int y, int size) { int frameHeight = size / 3; int tMargin = Math.max(1, size / 8); igd.clearRect(128, 128, 128, x, y, size, frameHeight); igd.clearRect( 32, 32, 32, x + tMargin, y + tMargin, size - (tMargin * 2), frameHeight - (tMargin * 2)); igd.clearRect(96, 96, 96, x, y + frameHeight, size, size - frameHeight); }
public void drawSymbol( IGrDriver igd, Symbol symbol, int x, int y, int size, boolean force, boolean background) { drawSymbol(igd, symbol, x, y, size, size, force, background); }
public void drawSymbol( IGrDriver igd, Symbol symbol, int x, int y, int sizeW, int sizeH, boolean force, boolean background) { if (background) igd.clearRect(0, 0, 0, x, y, sizeW, sizeH); int size = Math.min(sizeW, sizeH); if (size <= 8) { drawSymbol8px(igd, symbol.ordinal(), x, y, sizeW, sizeH); } else if (size < 16) { int mX = (sizeW - 8) / 2; int mY = (sizeH - 8) / 2; if (force) { mX = 0; mY = 0; } drawSymbol8px(igd, symbol.ordinal(), x + mX, y + mY, force ? sizeW : 8, force ? sizeH : 8); } else { int ms = 16 * (size / 16); int mX = (sizeW - ms) / 2; int mY = (sizeH - ms) / 2; if (force) { mX = 0; mY = 0; } drawSymbol16px(igd, symbol.ordinal(), x + mX, y + mY, force ? sizeW : ms, force ? sizeH : ms); } }
private void drawSymbol8px(IGrDriver igd, int symbol, int x, int y, int sizeW, int sizeH) { igd.blitScaledImage(24, symbol * 16, 8, 8, x, y, sizeW, sizeH, symbolic16); }
private void drawSymbol16px(IGrDriver igd, int symbol, int x, int y, int sizeW, int sizeH) { igd.blitScaledImage(0, symbol * 16, 16, 16, x, y, sizeW, sizeH, symbolic16); }
public void drawTarget(int px, int py, int tileSize, IGrDriver igd, boolean atOrBelowHalfSize) { if (atOrBelowHalfSize && tileSize == 32) { try (Block b = igd.openTRS(px, py, 2, 2)) { drawSymbol( igd, Art.Symbol.Target, (tileSize / 8), (tileSize / 8), tileSize / 4, false, false); } } else { drawSymbol( igd, Art.Symbol.Target, px + (tileSize / 4), py + (tileSize / 4), tileSize / 2, false, false); } }
public Instance i(Art a) { return new Instance(a); }
public Instance i(App a) { return a.ui.symbolInstances[ordinal()]; }
public Instance instanceDirect(App app) { return i(app.a); }
public Instance i(InterlaunchGlobals a) { return i(a.a); }
@Override public void draw(IGrDriver igd, int x, int y, int size) { a.drawSymbol(igd, Symbol.this, x, y, size, false, false); }
@Override public IIcon apply(Boolean t) { return t ? forLightTheme : this; }
@Override public void run() { setFrameIdx.accept(getFrameIdx.get() - 1); }
@Override public void run() { setFrameIdx.accept(getFrameIdx.get() + 1); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { if (playController.button.state) { playTimer += deltaTime; double frameTime = 1.0d / recommendedFramerate; if (hsController.button.state) frameTime *= 2; if (tsController.button.state) frameTime *= 3; while (playTimer >= frameTime) { playTimer -= frameTime; int oldIdx = getFrameIdx.get(); setFrameIdx.accept(oldIdx + 1); if (getFrameIdx.get() != (oldIdx + 1)) if (!loopController.button.state) { playController.button.state = false; break; } } } else { playTimer = 0; } currentFrame.setText(T.u.frameDisplay.r(getFrameIdx.get(), getFrameCount.get())); super.update(deltaTime, selected, peripherals); }
@Override public void onWindowClose() { super.onWindowClose(); state = false; }
@Override public void optionExecute(int b) { if (continued != null) if (!continued.get()) return; super.optionExecute(b); }
protected void changeInner(UIElement inner, boolean inConstructor) { for (UIElement uie : layoutGetElements()) layoutRemoveElement(uie); if (innerElem != null) if (inConstructor) throw new RuntimeException("Stop it! >.<"); innerElem = inner; if (inner != null) { if (inConstructor) inner.forceToRecommended(); layoutAddElement(inner); if (!inConstructor) { layoutRecalculateMetrics(); } else { forceToRecommended(); } } }
@Override public boolean requestsUnparenting() { return selfClose; }
@Override public int layoutGetHForW(int width) { if (innerElem != null) return innerElem.layoutGetHForW(width); return super.layoutGetHForW(width); }
@Override public int layoutGetWForH(int height) { if (innerElem != null) return innerElem.layoutGetWForH(height); return super.layoutGetWForH(height); }
@Override protected void layoutRunImpl() { if (innerElem != null) innerElem.setForcedBounds(this, new Rect(getSize())); }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { if (innerElem != null) return innerElem.getWantedSize(); return null; }
@Override public void onWindowClose() { hasClosed = true; }
@Override public String toString() { if (titleOverride != null) return titleOverride; if (innerElem != null) return innerElem.toString(); return super.toString(); }
public static UIDynAppPrx wrap(@NonNull App app, @NonNull UIElement svl) { UIDynAppPrx r = new UIDynAppPrx(app); r.changeInner(svl, true); return r; }
@Override public String toString() { return toStringRes; }
@Override protected void drawTile(int t, boolean hover, int x, int y, IGrDriver igd) { t = hover ? viewMapHover[t] : viewMap[t]; renderer.tileRenderer.drawTile( layer, (short) t, x + borderWidth, y + borderWidth, igd, spriteScale); }
protected boolean planeCanZoom(boolean north) { if (!north) if (planeZoomMul == 1) return false; return true; }
protected void planeZoomLogic(boolean north) { if (north) { if (planeZoomDiv > 1) { planeZoomDiv /= 2; } else { planeZoomMul *= 2; } } else { planeZoomMul /= 2; if (planeZoomMul < 1) planeZoomMul = 1; } }
protected double planeMulZoom(double n) { return ((n * planeZoomMul) / planeZoomDiv); }
protected double planeDivZoom(double i) { return (i * planeZoomDiv) / planeZoomMul; }
protected int planeDivZoomFloor(int i) { return sensibleCellDiv(i * planeZoomDiv, planeZoomMul); }
@Override public final void renderLayer(IGrDriver igd, UILayer layer) { if (layer != UILayer.Content) return; render(igd); }
public void render(IGrDriver igd) { Rect plusRect = Art.getZIconRect(app, false, 0); Rect plusRectFull = Art.getZIconRect(app, true, 0); Rect minusRect = Art.getZIconRect(app, false, 1); Rect dragRect = Art.getZIconRect(app, false, 2); int textX = plusRectFull.x + plusRectFull.width; int textW = getSize().width - (textX + ((plusRectFull.width - plusRect.width) / 2)); String statusText = planeGetStatus(); if (statusText != null) planeStatusLine.draw(statusText, app.f.mapPositionTH, igd, textX, plusRect.y, textW); if (planeCanZoom(true)) Art.drawZoom(igd, true, plusRect.x, plusRect.y, plusRect.height); if (planeCanZoom(false)) Art.drawZoom(igd, false, minusRect.x, minusRect.y, minusRect.height); app.a.drawDragControl(igd, planeGetDragLock(), dragRect.x, dragRect.y, minusRect.height); }
@Override public void handlePointerBegin(IPointer state) { pokePointer(state); recalcNexus(); lockZoom(); }
private void pokePointer(IPointer state) { dragPointers.put(state, new Size(state.getX(), state.getY())); }
private void recalcNexus() { dragNexusX = 0; dragNexusY = 0; dragAvgDist = 0; for (Size ip : dragPointers.values()) { dragNexusX += ip.width / dragPointers.size(); dragNexusY += ip.height / dragPointers.size(); } for (Size ip : dragPointers.values()) { double x = ip.width - dragNexusX; double y = ip.height - dragNexusY; dragAvgDist += Math.sqrt((x * x) + (y * y)) / dragPointers.size(); } }
@Override public void handlePointerUpdate(IPointer state) { pokePointer(state); double oldDNX = dragNexusX; double oldDNY = dragNexusY; recalcNexus(); camX += planeDivZoom(oldDNX - dragNexusX); camY += planeDivZoom(oldDNY - dragNexusY); if (dragPointers.size() > 1) { double coreRatio = (dragAvgDist / firstDragDist); double ratioW = firstDragZoom * coreRatio * coreRatio; double ratioF = tryZoom(false); double ratioT = tryZoom(true); if (ratioW <= ratioF) { handleMousewheel((int) dragNexusX, (int) dragNexusY, false); } else if (ratioW >= ratioT) { handleMousewheel((int) dragNexusX, (int) dragNexusY, true); } } }
private double tryZoom(boolean b) { int oldM = planeZoomMul; int oldD = planeZoomDiv; planeZoomLogic(b); double r2 = planeMulZoom(1); planeZoomMul = oldM; planeZoomDiv = oldD; return r2; }
@Override public void handlePointerEnd(IPointer state) { pokePointer(state); dragPointers.remove(state); recalcNexus(); lockZoom(); }
private void lockZoom() { firstDragDist = dragAvgDist; firstDragZoom = planeMulZoom(1); }
@Override public void handleMousewheel(int x, int y, boolean north) { if (!planeCanZoom(north)) return; Size bSize = getSize(); double zx = planeDivZoom(x - (bSize.width / 2.0d)); double zy = planeDivZoom(y - (bSize.height / 2.0d)); planeZoomLogic(north); double z2x = planeDivZoom(x - (bSize.width / 2.0d)); double z2y = planeDivZoom(y - (bSize.height / 2.0d)); camX += zx - z2x; camY += zy - z2y; }
private UIElement genMenu() { final T[] choiceListAtTime = choices; UIPopupMenu.Entry[] entries = new UIPopupMenu.Entry[choiceListAtTime.length]; for (int i = 0; i < entries.length; i++) { final T thisChoice = choiceListAtTime[i]; entries[i] = new UIPopupMenu.Entry( choiceToText(thisChoice), () -> { if (choiceListAtTime == choices) setSelected(thisChoice); }); } return new UIAutoclosingPopupMenu(entries, app.f.menuTH, app.f.menuS, true); }
private void refreshContents() { for (UIIndentThingy utb : setButtons.values()) utb.selected = UIIndentThingy.SELECTED_NOT_THIS; for (Object o : set) setButtons.get(o).selected = UIIndentThingy.SELECTED_HEAD; }
public void updateSet(Set<T> newSet) { set.clear(); set.addAll(newSet); refreshContents(); }
public void refreshButtonText() { for (Map.Entry<T, UILabel> buttons : setLabels.entrySet()) buttons.getValue().setText(buttons.getKey().toString()); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { super.update(deltaTime, selected, peripherals); if (peripherals instanceof IDesktopPeripherals) { mouseEmulator.mouseX = ((IDesktopPeripherals) peripherals).getMouseX(); mouseEmulator.mouseY = ((IDesktopPeripherals) peripherals).getMouseY(); } }
protected void drawTile(int t, boolean hover, int x, int y, IGrDriver igd) { GaBIEn.engineFonts.drawString( igd, x, y + 1, Integer.toHexString(t).toUpperCase(), false, false, app.f.gridTH); }
@Override protected void layoutRunImpl() { int scrollBarW = uivScrollbar.getWantedSize().width; Size r = getSize(); int tiles = (r.width - scrollBarW) / tileSizeW; if (tiles < 2) tiles = 2; int availableRows = r.height / tileSizeH; if (availableRows < 1) availableRows = 1; tmWidth = tiles; if (tileCount > 0) uivScrollbar.wheelScale = (availableRows * tiles) / (tileCount * 2d); uivScrollbar.setForcedBounds( this, new Rect(r.width - scrollBarW, 0, scrollBarW, availableRows * tileSizeH)); }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { return new Size(tileSizeW * 3, tileSizeH * 3); }
@Override public void handleClick(int x, int y, int button) { if (x < tileSizeW * tmWidth) { int tx = UIElement.sensibleCellDiv(x, tileSizeW); int ty = UIElement.sensibleCellDiv(y, tileSizeH); selTile = tx + (ty * tmWidth) + getScrollOffset(); selWidth = 1; selHeight = 1; selectionChanged(); } }
@Override public void handleDrag(int x, int y) { if (tmWidth <= 0) return; if (x < tileSizeW * tmWidth) { if (!canMultiSelect) return; int tx = UIElement.sensibleCellDiv(x, tileSizeW); int ty = UIElement.sensibleCellDiv(y, tileSizeH) + (getScrollOffset() / tmWidth); int ox = selTile % tmWidth; int oy = selTile / tmWidth; selWidth = (tx - ox) + 1; if (selWidth < 1) selWidth = 1; selHeight = (ty - oy) + 1; if (selHeight < 1) selHeight = 1; selectionChanged(); } }
@Override public void handleMousewheel(int x, int y, boolean north) { uivScrollbar.handleMousewheel(x, y, north); }
@Override public IPointerReceiver handleNewPointer(IPointer state) { IPointerReceiver ipr = super.handleNewPointer(state); if (ipr != null) return ipr; return mouseEmulator; }
private void selectionChanged() { if (selTile < 0) selTile = 0; if (selTile >= tileCount) selTile = tileCount - 1; if (onSelectionChange != null) onSelectionChange.run(); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) {}
@Override public void renderLayer(IGrDriver igd, UILayer layer) { if (layer != UILayer.Content) return; Size bounds = getSize(); doRender(igd, col, 0, 0, bounds.width, bounds.height); }
public static void doRender(IGrDriver igd, int col, int x, int y, int width, int height) { final int a = ((col & 0xFF000000) >> 24) & 0xFF; final int r = (col & 0xFF0000) >> 16; final int g = (col & 0xFF00) >> 8; final int b = (col & 0xFF); igd.clearRect(r, g, b, x, y, width / 2, height); igd.clearRect(a, a, a, (width / 2) + x, y, width - (width / 2), height); }
@Override protected void layoutRunImpl() { Size r = getSize(); int y = 0; for (TreeElement te : elements) { if (!te.visible) { layoutSetElementVis(te.innerElement, false); continue; } int x = nodeWidth * (te.indent + 1); int h = te.innerElement.layoutGetHForW(r.width - x); te.innerElement.setForcedBounds(this, new Rect(x, y, r.width - x, h)); y += te.h = h; layoutSetElementVis(te.innerElement, true); } }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { int y = 0; int width = 0; for (TreeElement te : elements) { if (!te.visible) continue; Size wantedSize = te.innerElement.getWantedSize(); width = Math.max(width, wantedSize.width); y += wantedSize.height; } return new Size(width, y); }
@Override public int layoutGetHForW(int width) { int y = 0; for (TreeElement te : elements) { if (!te.visible) continue; int x = nodeWidth * (te.indent + 1); y += te.innerElement.layoutGetHForW(width - x); } return y; }
@Override public void handlePointerBegin(IPointer state) { mouseEmulator.handlePointerBegin(state); ipr.handlePointerBegin(state); }
@Override public void handlePointerUpdate(IPointer state) { mouseEmulator.handlePointerUpdate(state); ipr.handlePointerEnd(state); }
@Override public void handlePointerEnd(IPointer state) { mouseEmulator.handlePointerEnd(state); ipr.handlePointerEnd(state); }
@Override public void handleClick(int x, int y, int button) { if (button == 1) { dragBase = getTarget(x, y); dragBaseX = x; dragBaseY = y; dragCursorEnable = false; } }
@Override public void handleDrag(int x, int y) { if (dragBase != -1) { int ddx = Math.abs(dragBaseX - x); int ddy = Math.abs(dragBaseY - y); if (Math.max(ddx, ddy) > (elements[dragBase].h / 2)) { dragCursorEnable = true; dragCursorSymbol = elements[dragBase].icon; } } }
@Override public void handleRelease(int x, int y) { int targ = getTarget(x, y); if (dragBase != -1) { if (dragCursorEnable) { if (targ != -1) elements[targ].elementDraggedHere.accept(dragBase); } else if (targ == dragBase) { if (x < ((elements[dragBase].indent + 1) * elements[dragBase].h)) elements[dragBase].expandToggle.run(); } } dragBase = -1; dragCursorEnable = false; }
public void show() { app.ui.wm.createWindow(this, "findTranslatables"); }
@Override public String toString() { return T.u.mTranslatablesIn.r(objIdName); }
public void doRefresh() { UIElement[] sites = refresh.get(); layout.panelsSet(sites); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { super.update(deltaTime, selected, peripherals); if (needsRefresh) { needsRefresh = false; doRefresh(); } }
@Override public void onWindowClose() { super.onWindowClose(); for (ObjectRootHandle ilo : roots) ilo.deregisterModificationHandler(consumer); }
@Override public String choiceToText(USFROperationMode choice) { return choice.translate(app); }
@Override public void execCmd(String c, String[] args, Object[] argsObj, DatumSrcLoc sl) throws IOException { if (c.equals(":")) { view = new UICharGenView( args[0], Integer.parseInt(args[1]), Integer.parseInt(args[2]), CharacterGeneratorController.this); modes.addTab(new UITabBar.Tab(view, new UITabBar.TabIcon[0])); views.add(view); } else if (c.equals(".")) { if (args.length == 1) view.text = args[0]; if (args.length == 2) if (app.c.language.equals(args[0])) view.text = args[1]; } else { throw new RuntimeException("Unknown command " + c); } }
@Override public void accept(String s) { try { OutputStream os = GaBIEn.getOutFile(s); os.write(b); os.close(); } catch (Exception e) { e.printStackTrace(); app.ui.launchDialog(e); } }
@Override public String toString() { return T.t.charGen; }
@Override public int compare(LayerImage layerImage, LayerImage t1) { if (layerImage.z < t1.z) return -1; if (layerImage.z > t1.z) return 1; return 0; }
private byte[] createPNG() { WSIImage img = getCurrentModeImage(); ImageEditorImage iei = new ImageEditorImage(img.width, img.height, img.getPixels(), null, false); ImageEditorImage iei2 = new ImageEditorImage(iei, true, true); if (iei2.paletteSize() > 256) { return img.createPNG(); } PNG8IImageIOFormat tempFmt = new PNG8IImageIOFormat(app.ilg); try { return tempFmt.saveFile(iei2); } catch (IOException e) { e.printStackTrace(); return img.createPNG(); } }
@Override public void render(IGrDriver igd) { Size mySize = getSize(); int ew = (int) planeMulZoom(genWidth); int eh = (int) planeMulZoom(genHeight); int ex = ((mySize.width - ew) / 2) - ((int) planeMulZoom(camX)); int ey = ((mySize.height - eh) / 2) - ((int) planeMulZoom(camY)); try (Block b = igd.openTranslate(ex, ey)) { render(igd, ew, eh); } super.render(igd); }
@Override public String toString() { return text + " (" + genWidth + "x" + genHeight + ")"; }
public void render(IGrDriver igd, int w, int h) { for (CharacterGeneratorController.LayerImage li : ctrl.charLay) { if (mode.equals(li.mode)) { CharacterGeneratorController.Layer l = ctrl.charCfg.get(li.layerId); if (l.enabled) { int a = (l.swatch.col >> 24) & 0xFF; int r = (l.swatch.col >> 16) & 0xFF; int g = (l.swatch.col >> 8) & 0xFF; int b = l.swatch.col & 0xFF; IImage im = GaBIEn.getImage(li.img); im = ctrl.app.ui.imageFXCache.process(im, new MultiplyImageEffect(a, r, g, b)); int imw = im.getWidth(); int imh = im.getHeight(); int smw = (imw * w) / genWidth; int smh = (imh * h) / genHeight; igd.blitScaledImage(0, 0, imw, imh, 0, 0, smw, smh, im); } } } }
@Override protected String planeGetStatus() { return null; }
@Override protected boolean planeGetDragLock() { return dragLock; }
@Override protected void planeToggleDragLock() { dragLock = !dragLock; }
@Override protected IPointerReceiver planeHandleDrawPointer(IPointer state) { camX = 0; camY = 0; return null; }
@Override public UIElement createToolPalette(UIImageEditView uiev) { return createToolPalette(uiev, RootImageEditorTool.class); }
@Override public void forceDifferentTool(UIImageEditView uiev) {}
@Override public void apply(int x, int y, UIImageEditView view, boolean major, boolean dragging) { if (!activeSection) { activeSection = true; view.eds.startSection(); } FillAlgorithm.Point p = view.correctPoint(x, y); if (p == null) return; view.image.setPixel(p.x, p.y, view.selPaletteIndex); }
@Override public void endApply(UIImageEditView view) { view.eds.endSection(); activeSection = false; view.newToolCallback.run(); }
@Override public void forceDifferentTool(UIImageEditView uiev) { if (uiev.tiling != null) { uiev.tiling = null; uiev.currentTool = new RootImageEditorTool(app); } }
@Override protected void performOperation(UIImageEditView view, int bW, int bH) { FillAlgorithm.Point p = view.correctPoint(aX, aY); if (p == null) return; view.tiling = new Rect(p.x, p.y, bW, bH); view.currentTool = new RootImageEditorTool(app); view.newToolCallback.run(); }
@Override public UIElement createToolPalette(UIImageEditView uiev) { return RootImageEditorTool.createToolPalette(uiev, TileImageEditorTool.class); }
@Override public void apply(int x, int y, UIImageEditView view, boolean major, boolean dragging) { if (major && (!dragging)) { if (!stage2) { aX = x; aY = y; stage2 = true; } else { int bW = (Math.max(aX, x) + 1) - Math.min(aX, x); int bH = (Math.max(aY, y) + 1) - Math.min(aY, y); aX = Math.min(aX, x); aY = Math.min(aY, y); performOperation(view, bW, bH); stage2 = false; } } }
protected void performOperation(UIImageEditView view, int bW, int bH) { view.eds.startSection(); for (int i = 0; i < bW; i++) { for (int j = 0; j < bH; j++) { FillAlgorithm.Point p = view.correctPoint(aX + i, aY + j); if (p == null) continue; view.image.setPixel(p.x, p.y, view.selPaletteIndex); } } view.eds.endSection(); view.newToolCallback.run(); }
@Override public UIElement createToolPalette(UIImageEditView uiev) { return RootImageEditorTool.createToolPalette(uiev, getClass()); }
@Override public void apply(int x, int y, UIImageEditView view, boolean major, boolean dragging) { FillAlgorithm.Point p = view.correctPoint(x, y); if (p == null) return; result.accept(view.image.getRGB(p.x, p.y)); view.currentTool = new RootImageEditorTool(app); view.newToolCallback.run(); }
@Override public UIElement createToolPalette(UIImageEditView uiev) { return RootImageEditorTool.createToolPalette(uiev, AddColourFromImageEditorTool.class); }
@Override public void run() { while (true) { ImageEditorTool tool = imageEditView.currentTool; imageEditView.currentTool.forceDifferentTool(imageEditView); if (tool == imageEditView.currentTool) break; } initPalette(0); }
@Override public String toString() { if (imageEditView.eds.imageModified()) return T.ie.modified; return T.u.mImgEdit; }
@Override public void onWindowClose() { super.onWindowClose(); app.ui.imgContext.remove(ImageEditorController.this); }
public boolean imageModified() { return imageEditView.eds.imageModified(); }
public void save() { if (!imageEditView.eds.canSimplySave()) { app.ui.launchDialog(T.ie.noSimpleSave); return; } try { imageEditView.eds.simpleSave(); } catch (Exception e) { app.ui.launchDialog(T.ie.saveFail.r(imageEditView.eds.getSimpleSaveTarget()), e); } app.ui.performFullImageFlush(); }
@Override public void accept(Rect rect) { imageEditView.eds.startSection(); int[] newImage = new int[rect.width * rect.height]; for (int i = 0; i < Math.min(rect.width - rect.x, imageEditView.image.width); i++) { for (int j = 0; j < Math.min(rect.height - rect.y, imageEditView.image.height); j++) { if (i + rect.x < 0) continue; if (j + rect.y < 0) continue; newImage[(i + rect.x) + ((j + rect.y) * rect.width)] = imageEditView.image.getRaw(i, j); } } imageEditView.setImage( new ImageEditorImage( rect.width, rect.height, newImage, imageEditView.image.palette, imageEditView.image.t1Lock)); imageEditView.eds.endSection(); initPalette(0); }
@Override public void run() { imageEditView.setImage( new ImageEditorImage(imageEditView.image.width, imageEditView.image.height)); imageEditView.eds.newFile(); initPalette(3); app.ui.launchDialog(T.ie.newOk); }
@Override public void accept(String s) { if (s != null) load(s); }
@Override public void accept(String s) { if (s != null) { try { if (format.saveName(imageEditView.image) == null) throw new Exception("Became unable to save file between dialog launch and confirmation"); byte[] data = format.saveFile(imageEditView.image); OutputStream os = GaBIEn.getOutFile(s); os.write(data); os.close(); imageEditView.eds.didSuccessfulSave(s, format); } catch (Exception e) { app.ui.launchDialog(T.ie.saveFail.r(s), e); } app.ui.performFullImageFlush(); initPalette(0); } }
@Override public void accept(Integer integer) { if (integer == null) return; imageEditView.eds.startSection(); imageEditView.image.appendToPalette(integer); imageEditView.eds.endSection(); initPalette(0); }
@Override public void run() { if (app.system.engineUsesPal0Colourkeys() && imageEditView.image.usesPalette() && !imageEditView.image.t1Lock) { if (!hasWarnedUserAboutRM) { app.ui.createLaunchConfirmation(T.ie.rmWarn, runnable).run(); hasWarnedUserAboutRM = true; return; } } runnable.run(); }
private UIElement pokeOnCause(int cause, int i, UIAppendButton redo) { if (cause == i) redo.button.enableStateForClick(); return redo; }
@Override public String toString() { return title; }
private int colourDistance(int argb, int argb2) { int ad = Math.abs(((argb >> 24) & 0xFF) - ((argb2 >> 24) & 0xFF)); int rd = Math.abs(((argb >> 16) & 0xFF) - ((argb2 >> 16) & 0xFF)); int gd = Math.abs(((argb >> 8) & 0xFF) - ((argb2 >> 8) & 0xFF)); int bd = Math.abs((argb & 0xFF) - (argb2 & 0xFF)); return (ad * 768) + rd + gd + bd; }
@Override public UIElement createToolPalette(UIImageEditView uiev) { UITextButton a = new UITextButton( T.ie.flipX, app.f.schemaFieldTH, () -> { flipX = !flipX; }) .togglable(flipX); UITextButton b = new UITextButton( T.ie.flipY, app.f.schemaFieldTH, () -> { flipY = !flipY; }) .togglable(flipY); UITextButton c = new UITextButton( T.ie.swapXY, app.f.schemaFieldTH, () -> { swapXY = !swapXY; }) .togglable(swapXY); UITextButton d = new UITextButton( T.ie.rawCopy, app.f.schemaFieldTH, () -> { rawCopy = !rawCopy; }) .togglable(rawCopy); UISplitterLayout sl = new UISplitterLayout(a, b, false, 0.5d); UIElement toolPalette = RootImageEditorTool.createToolPalette(uiev, PasteImageEditorTool.class); return new UIScrollLayout( true, app.f.mapToolbarS, toolPalette, new UISplitterLayout(sl, c, false, 0.6666d), d); }
@Override public void apply(int x, int y, UIImageEditView view, boolean major, boolean dragging) { if (dragging) return; if (!major) return; stageXs[stage] = x; stageYs[stage] = y; stage++; if (stage >= stageXs.length) { performOperation(view); stage = 0; } }
@Override public UIElement createToolPalette(UIImageEditView uiev) { return RootImageEditorTool.createToolPalette(uiev, LineImageEditorTool.class); }
@Override public Boolean apply(Boolean aBoolean) { FillAlgorithm.Point p = view.correctPoint(la.ax, la.ay); if (p != null) view.image.setPixel(p.x, p.y, view.selPaletteIndex); return true; }
public FillAlgorithm.Point correctPoint(int x, int y) { if (tiling != null) { int ofsX = tiling.x; int ofsY = tiling.y; int ofsW = tiling.width; int ofsH = tiling.height; x -= ofsX; y -= ofsY; x = UIElement.sensibleCellMod(x, ofsW); y = UIElement.sensibleCellMod(y, ofsH); x += ofsX; y += ofsY; x = UIElement.sensibleCellMod(x, image.width); y = UIElement.sensibleCellMod(y, image.height); } if (x < 0) return null; if (y < 0) return null; if (x >= image.width) return null; if (y >= image.height) return null; return new FillAlgorithm.Point(x, y); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { shift = false; if (peripherals instanceof IDesktopPeripherals) shift = ((IDesktopPeripherals) peripherals).isKeyDown(IGrInDriver.VK_SHIFT); }
@Override public String planeGetStatus() { return currentTool.getLocalizedText(true); }
@Override public boolean planeGetDragLock() { return currentTool.getCamModeLT() != null; }
@Override public void planeToggleDragLock() { ImageEditorTool lt = currentTool.getCamModeLT(); if (lt != null) { currentTool = lt; } else { currentTool = new CamImageEditorTool(currentTool); } newToolCallback.run(); }
@Override public void handlePointerBegin(IPointer state) { dragLastX = state.getX(); dragLastY = state.getY(); handleAct(state.getX(), state.getY(), true); }
@Override public void handlePointerUpdate(IPointer state) { handleAct(state.getX(), state.getY(), false); dragLastX = state.getX(); dragLastY = state.getY(); }
@Override public void handlePointerEnd(IPointer state) { if (currentTool == lockedTool) currentTool.endApply(UIImageEditView.this); }
@Override public Boolean apply(Boolean major) { FillAlgorithm.Point p = correctPoint(lineDraw.ax, lineDraw.ay); if (p != null) lockedTool.apply(p.x, p.y, UIImageEditView.this, major, true); if (currentTool != lockedTool) { lockedTool.endApply(UIImageEditView.this); return false; } return true; }
@Override public ImageEditorImage clone() { LinkedList<Integer> pal = null; if (palette != null) pal = new LinkedList<Integer>(palette); ImageEditorImage iei2 = new ImageEditorImage(width, height, new int[width * height], pal, t1Lock); if (palette == null) { iei2.editorPalette = new int[editorPalette.length]; System.arraycopy(editorPalette, 0, iei2.editorPalette, 0, editorPalette.length); } System.arraycopy(colourData, 0, iei2.colourData, 0, iei2.colourData.length); return iei2; }
public boolean equalToImage(ImageEditorImage iei) { if (iei.palette == null) { if (palette != null) return false; } else { if (palette == null) return false; } if (iei.paletteSize() != paletteSize()) return false; int size = paletteSize(); for (int i = 0; i < size; i++) if (getPaletteRGB(i) != iei.getPaletteRGB(i)) return false; if (iei.width != width) return false; if (iei.height != height) return false; for (int i = 0; i < colourData.length; i++) if (colourData[i] != iei.colourData[i]) return false; return true; }
private void handleT1Import() { if (palette == null) throw new IllegalArgumentException("cannot have null palette & t1lock"); int paletteSize = palette.size(); for (int i = 0; i < paletteSize; i++) palette.set(i, sanitizeColour(palette.get(i), i)); }
public IImage rasterize() { if (cachedD1 != null) return cachedD1; return cachedD1 = super.rasterize(); }
public int rawToPalette(int rawValue) { if (palette != null) { if (rawValue < 0) return 0; if (rawValue >= palette.size()) return palette.size() - 1; return rawValue; } for (int i = 0; i < editorPalette.length; i++) if (editorPalette[i] == rawValue) return i; appendToPalette(rawValue); return editorPalette.length - 1; }
public int paletteSize() { if (palette != null) return palette.size(); return editorPalette.length; }
public void appendToPalette(int rgb) { if (palette == null) { int[] ia = new int[editorPalette.length + 1]; System.arraycopy(editorPalette, 0, ia, 0, editorPalette.length); ia[ia.length - 1] = rgb; editorPalette = ia; } else { int idx = palette.size(); rgb = sanitizeColour(rgb, idx); palette.add(rgb); clearCachedData(); } }
public void removeFromPalette(int fidx, boolean sanity) { if (palette == null) { if (editorPalette.length <= 1) return; int[] ia = new int[editorPalette.length - 1]; System.arraycopy(editorPalette, 0, ia, 0, fidx); System.arraycopy(editorPalette, fidx + 1, ia, fidx, ia.length - fidx); editorPalette = ia; } else { int paletteSize = palette.size(); if (paletteSize <= 1) return; palette.remove(fidx); paletteSize--; for (int i = 0; i < paletteSize; i++) palette.set(i, sanitizeColour(palette.get(i), i)); if (sanity) for (int i = 0; i < colourData.length; i++) if (colourData[i] > fidx) colourData[i]--; clearCachedData(); } }
public void swapInPalette(int selPaletteIndex, int fidx, boolean sanity) { if (palette == null) { int t = editorPalette[selPaletteIndex]; editorPalette[selPaletteIndex] = editorPalette[fidx]; editorPalette[fidx] = t; } else { if (sanity) { int selCol = palette.get(selPaletteIndex); int fidCol = palette.get(fidx); selCol = sanitizeColour(selCol, fidx); fidCol = sanitizeColour(fidCol, selPaletteIndex); palette.set(selPaletteIndex, fidCol); palette.set(fidx, selCol); } for (int i = 0; i < colourData.length; i++) { if (colourData[i] == selPaletteIndex) { colourData[i] = fidx; } else if (colourData[i] == fidx) { colourData[i] = selPaletteIndex; } } clearCachedData(); } }
private int sanitizeColour(int fidCol, int selPaletteIndex) { if (t1Lock) { fidCol |= 0xFF000000; if (selPaletteIndex == 0) fidCol &= 0xFFFFFF; } return fidCol; }
public void changePalette(int fidx, int col) { if (palette == null) { editorPalette[fidx] = col; } else { palette.set(fidx, sanitizeColour(col, fidx)); } clearCachedData(); }
public boolean usesPalette() { return palette != null; }
public boolean run(int nx, int ny, Function<Boolean, Boolean> plotPointContinue) { int absX = Math.abs(ax - nx); int absY = Math.abs(ay - ny); int sub = absX; int subV = sub; int subS = absY; while ((absX > 0) || (absY > 0)) { if (!plotPointContinue.apply(false)) return false; subV -= subS; boolean firstApp = true; while ((subV <= 0) && (absY > 0)) { if (!firstApp) if (!plotPointContinue.apply(false)) return false; firstApp = false; if (ay < ny) { ay++; absY--; } else if (ay > ny) { ay--; absY--; } subV += sub; } if (ax < nx) { ax++; absX--; } else if (ax > nx) { ax--; absX--; } } if ((ax != nx) || (ay != ny)) System.out.println("Warning " + ax + "," + ay + ":" + nx + "," + ny); return plotPointContinue.apply(true); }
public void newFile() { currentFileName = null; currentFileFormat = null; undoBuffers.clear(); redoBuffers.clear(); saveDepth = 0; }
public boolean canSimplySave() { if (currentFileName == null) return false; if (currentFileFormat == null) return false; if (currentFileFormat.saveName(currentImage) == null) return false; return true; }
public void simpleSave() throws IOException { if (currentFileFormat.saveName(currentImage) == null) throw new IOException( "File has become incompatible with the current internal format. Use the Save As option," + " to the right."); byte[] data = currentFileFormat.saveFile(currentImage); OutputStream os = GaBIEn.getOutFile(currentFileName); os.write(data); os.close(); saveDepth = 0; }
public void didSuccessfulLoad(String name, ImageIOFormat format) { newFile(); didSuccessfulSave(name, format); }
public void didSuccessfulSave(String name, ImageIOFormat format) { currentFileName = name; currentFileFormat = format; saveDepth = 0; }
public void startSection() { if (saveDepth < 0) { saveDepth = Integer.MIN_VALUE; } saveDepth++; redoBuffers.clear(); undoBuffers.add(currentImage.clone()); }
public boolean hasUndo() { return undoBuffers.size() > 0; }
public boolean hasRedo() { return redoBuffers.size() > 0; }
public ImageEditorImage performRedo() { saveDepth++; undoBuffers.add(currentImage); return redoBuffers.removeLast(); }
public ImageEditorImage performUndo() { saveDepth--; redoBuffers.add(currentImage); return undoBuffers.removeLast(); }
public boolean imageModified() { return saveDepth != 0; }
@Override public FillAlgorithm.Point apply(FillAlgorithm.Point point) { return view.correctPoint(point.x, point.y); }
@Override public Boolean apply(FillAlgorithm.Point point) { return view.image.getRaw(point.x, point.y) == spi; }
private FillAlgorithm.Point tileAS(UIImageEditView view, FillAlgorithm.Point point) { return view.correctPoint(point.x, point.y); }
@Override public void run() { autoshade = !autoshade; }
@Override public void run() { autoshadeLRX = !autoshadeLRX; }
@Override public void run() { autoshadeUDX = !autoshadeUDX; }
@Override public void apply(int x, int y, UIImageEditView view, boolean major, boolean dragging) {}
@Override public UIElement createToolPalette(UIImageEditView uiev) { return new UIEmpty(); }
@Override public void apply(int x, int y, UIImageEditView view, boolean major, boolean dragging) { if (major && (!dragging)) { view.currentTool = new RootImageEditorTool(app); applyCore(view.correctPoint(x, y), view); } }
public void applyCore(FillAlgorithm.Point correctedPoint, UIImageEditView view) { view.eds.startSection(); int rawValue = view.image.getRaw(correctedPoint.x, correctedPoint.y); view.selPaletteIndex = view.image.rawToPalette(rawValue); view.eds.endSection(); view.newToolCallback.run(); }
@Override public UIElement createToolPalette(UIImageEditView uiev) { return RootImageEditorTool.createToolPalette(uiev, EDImageEditorTool.class); }
public void pass() { HashSet<Point> aps = new HashSet<Point>(availablePointSet); availablePointSet.clear(); for (Point p : aps) { p = inBounds.apply(p); if (p == null) continue; if (executedPointSet.contains(p)) continue; if (matchesFill.apply(p)) { executedPointSet.add(p); availablePointSet.add(p.offset(0, -1)); availablePointSet.add(p.offset(0, 1)); availablePointSet.add(p.offset(-1, 0)); availablePointSet.add(p.offset(1, 0)); } } }
@Override public boolean equals(Object o) { if (o instanceof Point) { if (((Point) o).x != x) return false; if (((Point) o).y != y) return false; return true; } return false; }
public Point offset(int i, int i1) { return new Point(x + i, y + i1); }
@Override protected void drawTile(int t, boolean hover, int x, int y, IGrDriver igd) { provider.drawItem(provider.mapIdxToVal(t), x, y, app.f.getSpriteScale(), igd); }
@Override public boolean requestsUnparenting() { return wantClose; }
@Override public boolean requestsUnparenting() { return wantsSelfClose; }
public int compare(UIEnumChoice.Option o1, UIEnumChoice.Option o2) { return UITest.natStrComp(o1.getTextMerged(), o2.getTextMerged()); }
public void refreshContents() { if (lastSplitter != null) lastSplitter.release(); lastSplitter = new UISplitterLayout(adj, maker.apply(currentSize), true, 0); dynProxySet(lastSplitter); }
public int compare(Replacement o1, Replacement o2) { int l1 = o1.key.length(); int l2 = o2.key.length(); if (l1 < l2) return 1; if (l1 > l2) return -1; return 0; }
public void saveTo(IRIO replacements) { replacements.setArray(); for (Replacement key : settings) { IRIO replacement = replacements.addAElem(replacements.getALen()); replacement.setObject("R48::UniversalStringLocatorReplacement"); replacement.addIVar("@key").setString(key.key); replacement.addIVar("@value").setString(key.value); } }
private void loadFromHash(IRIO irio) { for (DMKey hk : irio.getHashKeys()) settings.add(new Replacement(hk.decString(), irio.getHashVal(hk).decString())); }
private void loadFromList(IRIO irio) { for (IRIO hk : irio.getANewArray()) settings.add( new Replacement(hk.getIVar("@key").decString(), hk.getIVar("@value").decString())); }
private void settingsRemoveByKey(String text) { Replacement res = null; for (Replacement r : settings) if (r.key.equals(text)) res = r; if (res != null) settings.remove(res); }
@Override public void run() { settings.remove(key); refreshContents(); }
@Override public void updateContents(double deltaTime, boolean selected, IPeripherals peripherals) { String fName; if (c.fontOverride != null) { fName = c.fontOverride; } else { fName = T.g.fsc_fontInternal; } setText(T.g.fsc_font.r(fName)); super.updateContents(deltaTime, selected, peripherals); }
@Override public void updateContents(double deltaTime, boolean selected, IPeripherals peripherals) { setText(T.g.fsc_theme.r(c.borderTheme)); super.updateContents(deltaTime, selected, peripherals); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { if (scheduleSetSelectorUpdate) { scheduleSetSelectorUpdate = false; refreshButtonText(); } super.update(deltaTime, selected, peripherals); }
public void write(String string) { System.out.println(string); viewList.add(new UILabel(string, c.f.dialogWindowTH)); view.panelsSet(viewList); }
@Override public String toString() { return T.t.confirm; }
@Override public boolean requestsUnparenting() { return done; }
@Override public void run() { PrintStream ps = null; try { ps = new PrintStream(GaBIEn.getOutFile(app.gameRoot.into("transcript.html")), false, "UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } RMTranscriptDumper dumper = new RMTranscriptDumper(app, ps); Set<TranscriptComponent> comps = setSelector.getSet(); for (TranscriptComponent tc : components) if (comps.contains(tc)) tc.dump(dumper); app.sdb.updateDictionaries(null); app.sdb.kickAllDictionariesForMapChange(); dumper.end(); ps.close(); app.ui.launchDialog(app.t.u.tsc_dumpOk); done = true; }
@Override public void dump(RMTranscriptDumper dumper) { dumper.start(); dumper.startFile("CommonEvents", T.h.tsc_cev); for (IRIO rio : mapSystem.getAllCommonEvents()) dumper.dump(rio.getIVar("@name").decString(), rio.getIVar("@list"), commandsEvent); dumper.endFile(); }
@Override public String toString() { return T.h.tsc_cev; }
@Override public void dump(RMTranscriptDumper dumper) { ObjectRootHandle map = rmd.getILO(false); if (map == null) return; dumper.startFile( RXPRMLikeMapInfoBackend.sNameFromInt(rmd.id), RMTranscriptDumper.escapeHtml(whatDoWeCallThis)); app.sdb.updateDictionaries(map); app.sdb.kickAllDictionariesForMapChange(); LinkedList<Integer> orderedEVN = new LinkedList<Integer>(); for (DMKey i : map.getObject().getIVar("@events").getHashKeys()) orderedEVN.add((int) i.getFX()); Collections.sort(orderedEVN); for (int k : orderedEVN) { IRIO event = map.getObject().getIVar("@events").getHashVal(DMKey.of(k)); int pageId = 1; IRIO pages = event.getIVar("@pages"); int alen = pages.getALen(); for (int i = 0; i < alen; i++) { IRIO page = pages.getAElem(i); if (page.getType() == '0') continue; dumper.dump( T.u.tsc_ev.r(k, pageId, event.getIVar("@name")), page.getIVar("@list"), commandsEvent); pageId++; } } dumper.endFile(); }
@Override public String toString() { return whatDoWeCallThis; }
@Override public void dump(RMTranscriptDumper dumper) { mapSystem.dumpCustomData(dumper); }
@Override public String toString() { return T.u.tsc_ctx; }
@Override public void run() { setColour(null, currentColour.col); }
@Override public void run() { if (!shuttingDown) { shuttingDown = true; iConsumer.accept(currentColour.col); } }
@Override public void run() { if (!shuttingDown) { shuttingDown = true; iConsumer.accept(null); } }
@Override public boolean requestsUnparenting() { return shuttingDown; }
@Override public String toString() { return wTitle; }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { Size size = super.layoutRecalculateMetricsImpl(); if ((size.width < numberBoxMinimumSize.width) || (size.height < numberBoxMinimumSize.height)) return new Size( Math.max(size.width, numberBoxMinimumSize.width), Math.max(size.height, numberBoxMinimumSize.height)); return size; }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { Size size = super.layoutRecalculateMetricsImpl(); return new Size(size.height, size.height); }
public Rect determineInteriorPosition() { return UIThumbnail.getDrawRect(getSize(), baseW, baseH); }
@Override public void renderLayer(IGrDriver igd, UILayer layer) { if (layer != UILayer.Content) return; Rect intPos = determineInteriorPosition(); int bw = baseImage.getWidth(); int bh = baseImage.getHeight(); igd.blitScaledImage(0, 0, bw, bh, intPos.x, intPos.y, intPos.width, intPos.height, baseImage); int tsx = intPos.x + ((targetSize.width * intPos.width) / baseW); int tsy = intPos.y + ((targetSize.height * intPos.height) / baseH); if (bh == 1) tsy = intPos.y + (intPos.height / 2); igd.clearRect(0, 0, 0, intPos.x, tsy - targetScale, intPos.width, targetScale); igd.clearRect(0, 0, 0, intPos.x, tsy + targetScale, intPos.width, targetScale); igd.clearRect(0, 0, 0, tsx - targetScale, intPos.y, targetScale, intPos.height); igd.clearRect(0, 0, 0, tsx + targetScale, intPos.y, targetScale, intPos.height); String text; if (bh == 1) { text = Integer.toString(targetSize.width); } else { text = targetSize.width + "," + targetSize.height; } GaBIEn.engineFonts.drawString(igd, 0, 0, text, false, false, app.f.tonePickerTH); }
@Override public void handlePointerBegin(IPointer state) { handlePointerUpdate(state); }
@Override public void handlePointerEnd(IPointer state) { handlePointerUpdate(state); }
@Override public void handlePointerUpdate(IPointer state) { Rect intPos = determineInteriorPosition(); if (intPos.width == 0) return; if (intPos.height == 0) return; int rx = ((state.getX() - intPos.x) * baseW) / intPos.width; int ry = ((state.getY() - intPos.y) * baseH) / intPos.height; if (rx < 0) rx = 0; if (ry < 0) ry = 0; if (rx >= baseImage.getWidth()) rx = baseImage.getWidth() - 1; if (ry >= baseImage.getHeight()) ry = baseImage.getHeight() - 1; targetSize = new Size(rx, ry); resultConsumer.accept(targetSize); }
@Override public void run() { updateBFromA(); lastKnownBVal = getBColour(); setColour(UIRGBColourView.this, lastKnownBVal); }
private int crChannel(double r) { int round = (int) Math.round(r * 255); if (round < 0) return 0; if (round > 255) return 255; return round; }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { super.update(deltaTime, selected, peripherals); int bCol = getBColour(); if (bCol != lastKnownBVal) { lastKnownBVal = bCol; updateA(bCol); setColour(this, bCol); } }
@Override public void accept(Integer integer) { updateA(integer); lastKnownBVal = integer; updateBFromA(); }
private void updateA(int x) { rA.setNumber((x & 0xFF0000) >> 16); gA.setNumber((x & 0xFF00) >> 8); bA.setNumber((x & 0xFF)); }
private void updateBFromA() { rB.scrollPoint = Math.min(255, Math.max(0, rA.getNumber() / 255.0d)); gB.scrollPoint = Math.min(255, Math.max(0, gA.getNumber() / 255.0d)); bB.scrollPoint = Math.min(255, Math.max(0, bA.getNumber() / 255.0d)); }
@Override public String toString() { return "RGB"; }
private void performSendStuff() { int[] array = svCoordinator.baseImage.getPixels(); int col = array[svCoordinator.targetSize.width + (svCoordinator.targetSize.height * 256)]; col &= 0xFFFFFF; setColour(this, col); }
@Override public String toString() { return "HSV"; }
@Override public int layoutGetHForW(int width) { int leftY = 0; int rightX = width; int rightY = -1; for (HelpElement he : page) { if (leftY >= rightY) { rightY = -1; rightX = width; } Size wantedSize = he.element.getWantedSize(); boolean effectivePosition = he.position; if (wantedSize.width > width) effectivePosition = false; if (!effectivePosition) { leftY += he.element.layoutGetHForW(rightX); } else { if (rightY == -1) rightY = leftY; int gottenWidth = Math.min(width, wantedSize.width); int gottenX = width - gottenWidth; int wantedHeight = he.element.layoutGetHForW(gottenWidth); rightX = Math.min(gottenX, rightX); rightY += wantedHeight; } } return Math.max(leftY, rightY); }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { int leftY = 0; int leftWidth = 0; int rightWidth = 0; int maxWidth = 0; int rightY = -1; for (HelpElement he : page) { if (leftY >= rightY) { rightY = -1; rightWidth = 0; } Size ws = he.element.getWantedSize(); if (!he.position) { leftY += ws.height; leftWidth = ws.width; } else { if (rightY == -1) rightY = leftY; rightY += ws.height; rightWidth = ws.width; } int totalWidth = leftWidth + rightWidth; if (totalWidth > maxWidth) maxWidth = totalWidth; } return new Size(maxWidth, Math.max(leftY, rightY)); }
@Override public void accept(String integer) { onLinkClick.accept(integer); }
@Override public void run() { if (onLinkClick != null) onLinkClick.accept(index); }
public void tightlyCoupledLayoutRecalculateMetrics() { layoutRecalculateMetrics(); }
public void accept(final String link) { if (link.contains(":")) { String[] coms = link.split(":"); helpFile = coms[0]; helpFileData = HelpFile.load(hs.ilg, helpFile); loadPage(Integer.parseInt(coms[1])); } else { loadPage(Integer.parseInt(link)); } }
public void loadPage(final int i) { hs.page.clear(); HelpFile.Page page = helpFileData.pages.get(i); if (page == null) { if (pageName != null) pageName.setText(helpFile + ":" + i); } else { if (pageName != null) pageName.setText(page.name); hs.page.addAll(page.contents); } hs.tightlyCoupledLayoutRecalculateMetrics(); if (onLoad != null) onLoad.run(); }
@Override public void newObj(int objId, String objName, DatumSrcLoc sl) throws IOException { helpPage = new Page(objName); if (!wasLoadedInNativeLanguage) helpPage.contents.add(new UIHelpSystem.HelpElement(ilg, ".", ilg.t.g.helpUnavailable)); hf.pages.put(objId, helpPage); }
@Override public void execCmd(String ch, String[] args, Object[] argsObj, DatumSrcLoc sl) throws IOException { StringBuilder argbuilder = new StringBuilder(); boolean first = true; for (String s : args) { if (first) { first = false; } else { argbuilder.append(' '); } argbuilder.append(s); } if (ch.equals(",")) { UILabel uil = ((UILabel) workingElement.element); uil.setText(uil.getText() + "\n" + argbuilder.toString()); } else { helpPage.contents.add( workingElement = new UIHelpSystem.HelpElement(ilg, ch, argbuilder.toString())); } }
@Override public void run() { setPlaying(playButton.state); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { super.update(deltaTime, selected, peripherals); app.c.globalVolume = (float) (1.0d - scrollPoint); }
@Override public String toString() { return T.t.audioPlayer; }
private boolean ensureSourceHasBeenInitialized() { if (source != null) return true; if (dataSupplier == null) return false; Supplier<AudioIOSource> dsrc = dataSupplier; dataSupplier = null; try { AudioIOSource data = dsrc.get(); if (data instanceof MIDISynthesizerSource) displayWarning(T.u.soundMIDIWarning); source = new StreamingAudioDiscreteSample( data, (data.formatHint == null) ? AudioIOFormat.F_F32 : data.formatHint); audioThreadBuffer = new float[data.crSet.channels]; } catch (Exception ex) { ex.printStackTrace(); changeInner(new UILabel(T.u.soundFail, app.f.schemaFieldTH), false); return false; } updateSeeker(); return true; }
@Override public void pullData(@NonNull short[] interleaved, int ofs, int frames) { int lim = ofs + (frames * 2); for (int i = ofs; i < lim; i += 2) { source.getInterpolatedF32(position, audioThreadBuffer, loopButton.state); int secondChannel = audioThreadBuffer.length > 1 ? 1 : 0; interleaved[i] = (short) (AudioIOFormat.cF64toS32(audioThreadBuffer[0] * app.c.globalVolume) >> 16); interleaved[i + 1] = (short) (AudioIOFormat.cF64toS32(audioThreadBuffer[secondChannel] * app.c.globalVolume) >> 16); position += (source.sampleRate / 22050d) * speed; } if (source.length != 0) if (loopButton.state && position >= source.length) position %= source.length; }
private void updateSeeker() { if (source != null) { int len = source.length; if (len < 1) len = 1; if (seeker.scrollPoint != lastSeekerScrollPoint) { position = seeker.scrollPoint * len; } else { seeker.scrollPoint = position / len; if (seeker.scrollPoint < 0) seeker.scrollPoint = 0; if (seeker.scrollPoint > 1) seeker.scrollPoint = 1; } lastSeekerScrollPoint = seeker.scrollPoint; } }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { super.update(deltaTime, selected, peripherals); updateSeeker(); }
public static UIElement create(App app, String filename, double speed) { InputStream theInputStream = null; for (String mnt : extensionsWeWillTry) { theInputStream = GaBIEn.getInFile(app.gameRoot.intoRelPath(filename + mnt)); if (theInputStream != null) break; } if (theInputStream == null) { for (String mnt : extensionsWeWillTry) { theInputStream = GaBIEn.getInFile(app.gameResources.intoRelPath(filename + mnt)); if (theInputStream != null) break; } } return create(app, theInputStream, speed); }
public static UIElement createAbsoluteName(App app, String filename, double speed) { return create(app, GaBIEn.getInFile(filename), speed); }
public static UIElement create(App app, final InputStream tryWav, double speed) { if (tryWav != null) { try { return new UIAudioPlayer( app, () -> { try { return ReadAnySupportedAudioSource.open(tryWav, true); } catch (Exception e) { throw new RuntimeException(e); } }, speed); } catch (Exception e) { e.printStackTrace(); } } return new UILabel(app.t.u.soundFailFileNotFound, app.f.schemaFieldTH); }
@Override public void renderLayer(IGrDriver igd, UILayer layer) { if (layer != UILayer.Content) return; int bW = Math.max(selectUnit / 6, 1); int height = getSize().height; Theme theme = getTheme(); Theme.Attr<IBorder> ba = (selected > 32) ? Theme.B_BTNP : Theme.B_BTN; UIBorderedElement.drawBorder(theme, igd, ba, bW, 0, 0, selectUnit, height); igd.clearRect( selected / 3, (selected * 2) / 3, selected, bW, bW, selectUnit - (bW * 2), height - (bW * 2)); igd.clearRect( selected / 2, (selected * 5) / 6, selected, bW * 2, bW * 2, selectUnit - (bW * 4), height - (bW * 4)); }
@Override public IPointerReceiver handleNewPointer(IPointer state) { if (state.getType() == IPointer.PointerType.Generic) if (onClick != null) onClick.run(); return super.handleNewPointer(state); }
@Override public int layoutGetHForW(int width) { int wm = width - (bw * 2); if (wm < innerPanel.getWantedSize().width) return innerPanel.layoutGetHForW(width); return innerPanel.layoutGetHForW(wm) + (bw * 2); }
@Override public int layoutGetWForH(int height) { int hm = height - (bw * 2); if (hm < innerPanel.getWantedSize().height) return innerPanel.layoutGetWForH(height); return innerPanel.layoutGetWForH(hm) + (bw * 2); }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { Size s2 = innerPanel.getWantedSize(); return new Size(s2.width + (bw * 2), s2.height + (bw * 2)); }
@Override protected void layoutRunImpl() { enableBorder = true; Size s = getSize(); Size s2 = innerPanel.getWantedSize(); Rect plannedSize = new Rect(bw, bw, s.width - (bw * 2), s.height - (bw * 2)); if ((s2.width > plannedSize.width) || (s2.height > plannedSize.height)) enableBorder = false; if (!enableBorder) { innerPanel.setForcedBounds(this, new Rect(s)); } else { innerPanel.setForcedBounds(this, plannedSize); } }
public void shakeOffDeadWindows() { HashSet<UIElement> ok = new HashSet<UIElement>(); for (UIElement uie : real.runningWindows()) if (aliveWindows.contains(uie)) ok.add(uie); aliveWindows.clear(); aliveWindows.addAll(ok); }
public Iterable<UIElement> runningWindows() { return aliveWindows; }
public void forceRemove(UIElement uie) { real.forceRemove(uie); }
public void accept(UIElement uie, boolean fullscreen) { aliveWindows.add(uie); real.accept(uie, 1, fullscreen); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { if (peripherals instanceof IDesktopPeripherals) coco.accept((IDesktopPeripherals) peripherals); uiTicker.shakeOffDeadWindows(); super.update(deltaTime, selected, peripherals); }
@Override public void onWindowClose() { if (!performingScreenTransfer) super.onWindowClose(); }
@Override public IPointerReceiver handleNewPointer(IPointer state) { IPointerReceiver res = super.handleNewPointer(state); if (selectedTab == null) if (res == null) System.gc(); return res; }
public void pleaseShutdown() { for (UIElement uie : uiTicker.runningWindows()) uiTicker.forceRemove(uie); }
public void finishInitialization() { if (!performingScreenTransfer) throw new RuntimeException("That's not supposed to happen"); uiTicker.accept(rootView, false); performingScreenTransfer = false; }
public void toggleFullscreen() { performingScreenTransfer = true; uiTicker.forceRemove(rootView); if (preFullscreenRect == null) { preFullscreenRect = rootView.getParentRelativeBounds(); uiTicker.accept(rootView, true); } else { rootView.setForcedBounds(null, preFullscreenRect); preFullscreenRect = null; uiTicker.accept(rootView, false); } performingScreenTransfer = false; }
public void selectFirstTab() { LinkedList<UITabBar.Tab> uie = tabPane.getTabs(); if (uie.size() > 0) tabPane.selectTab(uie.getFirst().contents); }
public void adjustWindowSH(final UIElement mtb) { Size rootSize = getRootSize(); Size validSize = new Size((rootSize.width * 3) / 4, (rootSize.height * 3) / 4); int recWidth = mtb.getWantedSize().width; int w = Math.min(recWidth, validSize.width); int recHeight = mtb.layoutGetHForW(w); int h = Math.min(recHeight, validSize.height); mtb.setForcedBounds(null, new Rect(0, 0, w, h)); }
public void createWindowSH(final UIElement mtb) { adjustWindowSH(mtb); createWindow(mtb); }
public void createWindow(final UIElement uie) { createWindow(uie, false, false); }
public void createWindow(final UIElement uie, final @Nullable String disposition) { createWindow(uie, false, false, disposition); }
public void createWindow(final UIElement uie, final boolean tab, final boolean immortal) { createWindow(uie, tab, immortal, uie.getClass().getSimpleName()); }
@Override public void draw(IGrDriver igd, int x, int y, int size) { ilg.a.drawSymbol(igd, Art.Symbol.CloneFrame, x, y, size, false, false); }
@Override public void click(UITabBar.Tab self) { ((IDuplicatableWindow) uie).duplicateThisWindow(); }
@Override public void draw(IGrDriver igd, int x, int y, int size) { Art.windowWindowIcon(igd, x, y, size); }
@Override public void click(UITabBar.Tab self) { tabPane.removeTab(self); Size mainSize = getRootSize(); uie.setForcedBounds(null, new Rect(0, 0, mainSize.width / 2, mainSize.height / 2)); createWindow(uie, false, immortal); }
@Override public void draw(IGrDriver igd, int x, int y, int size) { ilg.a.drawSymbol(igd, Art.Symbol.XRed, x, y, size, false, false); }
@Override public void click(UITabBar.Tab self) { tabPane.removeTab(self); uie.onWindowClose(); }
@Override public void onWindowClose() { allWindowViews.remove(this); createWindow(uie, true, immortal); }
@Override public String toString() { return uie.toString(); }
@Override public void draw(IGrDriver igd, int x, int y, int size) { Art.tabWindowIcon(igd, x, y, size); }
@Override public void click(UITabBar.Tab tab) { rootView.removeTab(tab); createWindow(uie, true, immortal); }
@Override public void click(UITabBar.Tab tab) { rootView.removeTab(tab); uie.onWindowClose(); }
@Override public void windowBoundsCheck() { super.windowBoundsCheck(); if (disposition != null) recordedWindowPositions.put(disposition, contents.getParentRelativeBounds()); }
public void debugDumpUITree(DatumWriter dw) { rootView.debugDumpUITree(dw); }
@Override public String toString() { return T.t.sysTools; }
private UIElement createInitialHelp() { UIHelpSystem uhs = new UIHelpSystem(app.ilg); final HelpSystemController hsc = new HelpSystemController(null, "Help/Tips/Entry", uhs); Date dt = new Date(); @SuppressWarnings("deprecation") int h = dt.getHours(); if (h < 7) { hsc.accept("Help/Tips/Secret:" + (990 + new Random().nextInt(10))); } else { hsc.loadPage(new Random().nextInt(10)); } uhs.onLinkClick = hsc; return uhs; }
private UIElement createODBRMGestalt() { LinkedList<UIPopupMenu.Entry> entries = new LinkedList<>(); app.system.createEngineTools().accept(entries); UIElement button = new UIMenuButton(app, T.u.mEngineTools, app.f.menuTH, null, entries).centred(); return new UISplitterLayout(createODBButton(), button, true, 0.5); }
private static int locateStrings(App app, IRIO rio, Function<IRIO, Integer> string) { int total = 0; int type = rio.getType(); if (type == '"') total += string.apply(rio); if ((type == '{') || (type == '}')) for (DMKey me : rio.getHashKeys()) total += locateStrings(app, rio.getHashVal(me), string); if (type == '[') { int arrLen = rio.getALen(); for (int i = 0; i < arrLen; i++) total += locateStrings(app, rio.getAElem(i), string); } for (String k : rio.getIVars()) total += locateStrings(app, rio.getIVar(k), string); return total; }
@Override public void run() { RORIO clipGet = (app.theClipboard == null) ? DMKey.NULL : app.theClipboard; String clipText = app.format(clipGet); uiStatusLabel.setText(T.u.statusLine.r(app.odb.modifiedObjects.size(), clipText)); app.uiPendingRunnables.add(this); }
@Override public String toString() { return T.t.mDBO; }
@Override public void loadMap(String gum) { System.out.println("Game Unique Map:" + gum); mapBox.loadMap(gum); }
@Override public void freeOsbResources() { if (mapBox.view == null) return; mapBox.view.freeOsbResources(); }
@Override public void performCacheFlush() { UIMapView.performFullCacheFlush(app, mapBox.view); }
@Override public UIElement[] generateTabs() { return tabs; }
@Override public void renderLayer(IGrDriver igd, UILayer layer) { if (layer != UILayer.Content) return; IImage tst = TonePickerSchemaElement.getOneTrueTotem(); for (int j = 0; j < 3; j++) { int angle = j * 22; for (int i = 0; i < blendModes.length; i++) igd.drawRotatedScaled( j * 128, i * 64, tst.getWidth(), tst.getHeight(), angle, tst, blendModes[i], 0); } float ofx = (float) (96 + (GaBIEn.getTime() % 16)); igd.blitScaledImage( ofx, ofx, 16, 16, 512, 0, 128, 128, tst, IGrDriver.BLEND_NORMAL, BadGPU.DrawFlags.MagLinear); igd.drawXYSTRGBA( IGrDriver.BLEND_NORMAL, 0, null, 0, 512, 0, 0, 1, 0, 0, 1, 256, 512, 0, 0, 0, 1, 0, 1, 0, 768, 0, 0, 0, 0, 1, 1); }
private static IRIO putProp(IRIO root, String string) { return root.addHashVal(DMKey.ofStr(string)); }
public RORIO dumpRoot() { putProp(root, "type").setString("dump file for liblcf#245, format version 1"); dumpSDB(putProp(root, "sdbID")); dumpCMDBs(putProp(root, "cmdbs")); return root; }
private void dumpCMDB(CMDB cmdb, IRIO target) { target.setHash(); IRIO categories = putProp(target, "categories").setArray(); for (FF0 ff0 : cmdb.categories) categories.appendAElem().setString(ff0.r()); IRIO knownCommands = putProp(target, "knownCommands").setArray(); for (Integer i : cmdb.knownCommandOrder) { dumpCMDBEntry(cmdb.knownCommands.get(i), knownCommands.appendAElem()); } }
private void dumpCMDBEntry(RPGCommand rc, IRIO target) { target.setHash(); putProp(target, "commandId").setFX(rc.commandId); putProp(target, "srcLoc").setString(rc.srcLoc.toString()); putProp(target, "name").setString(rc.formatName(null)); putProp(target, "nameRawUnlocalized").setString(rc.nameRawUnlocalized.toString()); if (rc.description == null) { putProp(target, "description").setNull(); } else { putProp(target, "description").setString(rc.description.r()); } if (rc.specialSchema != null) { putProp(target, "specialSchema").setFX(dumpSDBNode(rc.specialSchema)); } else { putProp(target, "specialSchema").setNull(); } putProp(target, "specialSchemaEssential").setBool(rc.specialSchemaEssential); IRIO paramT = putProp(target, "params").setArray(); for (Param param : rc.params) dumpCMDBParam(param, paramT.appendAElem()); }
private void dumpCMDBParam(Param param, IRIO target) { if (param instanceof RPGCommand.PStatic) { RPGCommand.PStatic r = (RPGCommand.PStatic) param; target.setHash(); putProp(target, "type").setString("static"); if (r.name != null) { putProp(target, "name").setString(r.name.r()); } else { putProp(target, "name").setNull(); } putProp(target, "se").setFX(dumpSDBNode(r.se)); } else if (param instanceof RPGCommand.PDyn) { RPGCommand.PDyn r = (RPGCommand.PDyn) param; target.setHash(); putProp(target, "type").setString("dynamic"); dumpCMDBParam(r.def, putProp(target, "def")); putProp(target, "arrayDI").setFX(r.arrayDI); IRIO contents = putProp(target, "contents").setHash(); for (Map.Entry<Integer, Param> ent : r.contents.entrySet()) { IRIO ct = putProp(contents, ent.getKey().toString()); dumpCMDBParam(ent.getValue(), ct); } } else { target.setString(param.toString()); } }
private long dumpSDBNode(SchemaElement se) { if (!(se instanceof SDB.DynamicSchemaElement)) se = AggregateSchemaElement.extractField(se, null); Integer present = seGraph.get(se); if (present != null) return (int) present; int alen = sdbNodes.getALen(); IRIO newSDBNode = sdbNodes.addAElem(alen); seGraph.put(se, alen); dumpSDBNodeInner(se, newSDBNode); return alen; }
private void createCBM() { LinkedList<UIPopupMenu.Entry> ll = new LinkedList<>(); for (final IDChangerEntry idc : app.idc) { ll.add( new UIPopupMenu.Entry( idc.text.r(), () -> { entry = idc; fromValue = toValue = entry.extractEnum().defaultVal; updateText(); })); } UIAutoclosingPopupMenu amp = new UIAutoclosingPopupMenu(ll, app.f.menuTH, app.f.menuS, true); app.ui.wm.createMenu(chooseButton, amp); }
private void updateText() { chooseButton.setText(T.u.idc_typeButton.r(entry.text.r())); fromButton.setText( T.u.idc_fromButton.r( app.format(fromValue, entry.userFacing, EnumSchemaElement.Prefix.Prefix))); toButton.setText( T.u.idc_toButton.r(app.format(toValue, entry.userFacing, EnumSchemaElement.Prefix.Prefix))); }
private void fromButton() { app.ui.wm.createMenu( fromButton, entry .extractEnum() .makeEnumChoiceDialog( (res) -> { fromValue = res; updateText(); })); }
private void toButton() { app.ui.wm.createMenu( toButton, entry .extractEnum() .makeEnumChoiceDialog( (res) -> { toValue = res; updateText(); })); }
@Override public String toString() { return fixedPath != null ? T.t.idChangerLocal : T.t.idChanger; }
public void start() { tableOfContents.clear(); tableOfContentsIID.clear(); output.println("<!DOCTYPE html>"); output.println( "<html><head><title>" + T.h.title + "</title></head><body><a href=\"#toc\">" + T.h.tocLink + "</a>"); }
public void end() { output.println("<a name=\"toc\"/><h1>" + T.h.toc + "</h1><ol>"); int hIndex = 0; for (String s : tableOfContents) { if (s != null) { output.println( "<li><a href=\"#p" + tableOfContentsIID.get(hIndex) + "\">" + escapeHtml(s) + "</a><ol>"); } else { output.println("</ol></li>"); } hIndex++; } output.println("</ol></body></html>"); }
private void anchor(String s, String name) { if (s != null) output.println("<a name=\"p" + name + "\"/>"); tableOfContents.add(s); tableOfContentsIID.add(name); }
public void startFile(String name, String desc) { anchor(name + " (" + desc + ")", name); output.println("<h1>" + name + "</h1>"); output.println("<h2>" + desc + "</h2>"); }
public void dump(String name, IRIO code, CMDB database) { output.println("<h3>" + escapeHtml(name) + "</h3>"); output.println("<code><ul>"); int ci = 0; int alen = code.getALen(); for (int i = 0; i < alen; i++) { IRIO cm = code.getAElem(i); int ti = (int) cm.getIVar("@indent").getFX(); while (ci < ti) { output.print("<ul>"); ci++; } while (ci > ti) { output.print("</ul>"); ci--; } output.println("<li>" + escapeHtml(database.buildCodename(cm, false, true)) + "</li>"); } output.println("</ul></code>"); }
public void dumpBasicList(String name, String[] items, int startIndex) { output.println("<h3>" + escapeHtml(name) + "</h3>"); output.print("<ol start=\"" + startIndex + "\">"); for (String it : items) output.println("<li>" + escapeHtml(it) + "</li>"); output.println("</ol>"); }
public static String escapeHtml(String s) { StringBuilder r = new StringBuilder(); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); int cp = s.codePointAt(i); String rb = Character.toString(c); if (c != cp) rb += Character.toString(s.charAt(++i)); boolean special = false; if (c == '<') special = true; if (c == '>') special = true; if (c == '&') special = true; if (special) { r.append("&#"); r.append(cp); r.append(";"); } else { r.append(rb); } } return r.toString(); }
public void dumpSVList(String n, IRIO arrVal, int st) { String[] s = new String[arrVal.getALen()]; for (int i = 0; i < s.length; i++) s[i] = arrVal.getAElem(i).toString(); dumpBasicList(n, s, st); }
public void dumpSVListHash(String n, IRIO arrHashVal) { LinkedList<Long> l = new LinkedList<Long>(); for (DMKey rio : arrHashVal.getHashKeys()) l.add(rio.getFX()); Collections.sort(l); output.println("<h3>" + escapeHtml(n) + "</h3>"); output.print("<ul>"); for (Long ll : l) output.println( "<li>" + escapeHtml(ll + " : " + arrHashVal.getHashVal(DMKey.of(ll))) + "</li>"); output.println("</ul>"); }
public void dumpHTML(String s) { output.println(s); }
public SchemaElement[] resolve() { SchemaElement[] res = new SchemaElement[unresolvedElements.length]; for (int i = 0; i < unresolvedElements.length; i++) res[i] = AggregateSchemaElement.extractField(unresolvedElements[i], null); return res; }
public static boolean match(SchemaElement a, RORIO rio, SchemaElement[] resolved) { SchemaElement b = AggregateSchemaElement.extractField(a, null); SchemaElement c = AggregateSchemaElement.extractField(a, rio); for (SchemaElement se : resolved) if (se == a || se == b || se == c) return true; return false; }
public final EnumSchemaElement extractEnum() { return (EnumSchemaElement) AggregateSchemaElement.extractField(userFacing, null); }
@Override public DynTrBase dynTrBase( DatumSrcLoc srcLoc, String id, @Nullable DatumSymbol mode, Object text, boolean isNLS) { return langVM.dynTrBase(srcLoc, id, mode, text, isNLS); }
public void launcherDynTrDump(String fn) { langVM.dynTrDump(fn); }
public void updateLanguage(Consumer<String> loadProgress) { String lang = c.language; if (LanguageList.getLangInfo(lang) == null) lang = LanguageList.defaultLang; c.language = lang; langVM = new MVMEnvR48(loadProgress, logTrIssues, lang, strict); MVMR48GlobalLibraries.add(langVM); langVM.include("vm/global", false); langVM.include("terms/" + lang + "/init", true); t.fillFromVM(langVM, logTrIssues); reportVMChanges.accept(langVM); GaBIEn.wordLoad = t.g.wordLoad; GaBIEn.wordSave = t.g.wordSave; GaBIEn.wordInvalidFileName = t.g.wordInvalidFileName; }
public DatumVisitor newVisitor() { return new DatumExpectListVisitor( () -> new DatumKVDHVisitor<EngineDef, Object>(map, this, null)); }
private void fileCopier(String[] mkdirs, String[] fileCopies) { for (String s : mkdirs) app.gameRoot.intoPath(s).mkdirs(); for (int i = 0; i < fileCopies.length; i += 2) { String src = fileCopies[i]; String dst = fileCopies[i + 1]; InputStream inp = GaBIEn.getResource(src); if (inp != null) { FSBackend tgt = app.gameRoot.intoPath(dst); if (tgt.exists()) { System.err.println("Didn't write " + dst + " as it is already present as " + tgt + "."); try { inp.close(); } catch (IOException e) { e.printStackTrace(); } continue; } OutputStream oup = GaBIEn.getOutFile(tgt); if (oup != null) { try { byte[] b = new byte[2048]; while (inp.available() > 0) oup.write(b, 0, inp.read(b)); } catch (IOException ioe) { } try { oup.close(); } catch (IOException ioe) { } } try { inp.close(); } catch (IOException ioe) { } } else { System.err.println("Didn't write " + dst + " as " + src + " missing."); } } }
public static void initializeUI( App app, final WindowCreatingUIElementConsumer uiTicker, boolean mobile) { app.np = new AppNewProject(app); app.ui = new AppUI(app, mobile); app.ui.initialize(uiTicker); }
public static void performSystemDump(App app, boolean emergency, String addendumData) { IRIO n = new IRIOGeneric(app.ilg.adhocIOContext); n.setObject("R48::Backup"); n.addIVar("@emergency").setBool(emergency); if (!emergency) { IRIOGeneric n3 = AdHocSaveLoad.load("r48.revert.YOUR_SAVED_DATA"); if (n3 != null) { n3.rmIVar("@last"); n.addIVar("@last").setDeepClone(n3); } } n.addIVar("@description").setString(addendumData); performSystemDumpBodyInto(app, n); if (emergency) System.err.println("emergency dump is now actually occurring. Good luck."); AdHocSaveLoad.save(emergency ? "r48.error.YOUR_SAVED_DATA" : "r48.revert.YOUR_SAVED_DATA", n); if (emergency) System.err.println("emergency dump is complete."); }
private static void performSystemDumpBodyInto(App app, IRIO n) { IRIO h = n.addIVar("@objects"); h.setHash(); for (ODBHandle rio : app.odb.modifiedObjects) { String s = app.odb.getIdByObject(rio); if (s != null) h.addHashVal(DMKey.ofStr(s)).setDeepClone(rio.getObject()); } }
@Override public void accept(IDesktopPeripherals igd) { if (igd.isKeyJustPressed(IGrInDriver.VK_LEFT)) key('L'); if (igd.isKeyJustPressed(IGrInDriver.VK_DOWN)) key('D'); if (igd.isKeyJustPressed(IGrInDriver.VK_RIGHT)) key('R'); if (igd.isKeyJustPressed(IGrInDriver.VK_UP)) key('U'); if (igd.isKeyJustPressed(IGrInDriver.VK_B)) key('B'); if (igd.isKeyJustPressed(IGrInDriver.VK_A)) key('A'); if (igd.isKeyJustPressed(IGrInDriver.VK_I)) key('I'); }
@Override public void pullData(@NonNull short[] interleaved, int ofs, int frames) { for (int i = 0; i < frames; i++) { interleaved[ofs++] = flipper; interleaved[ofs++] = flipper; if (totalFrames < 22050) { if ((totalFrames & 7) == 0) flipper ^= 0x0800; } else { flipper = 0; } totalFrames++; } }
public void launch() { try { InputStream r = GaBIEn.getResource("version.txt"); if (r != null) { BufferedReader br = new BufferedReader(new InputStreamReader(r)); String bb = ""; while (br.ready()) { if (!bb.isEmpty()) bb += "\n"; bb += br.readLine(); } app.ui.launchDialog(bb); br.close(); } else { app.ui.launchDialog(T.u.notRelease); } } catch (Exception e) { throw new RuntimeException(e); } }
public void finishInitialization() { wm.finishInitialization(); }
public void tick(double dT) { saveButtonSym.symbol = (hasModified() ? Art.Symbol.Save : Art.Symbol.SaveDisabled).i(app); undoButtonSym.symbol = (app.timeMachine.canUndo() ? Art.Symbol.Undo : Art.Symbol.UndoDisabled).i(app); redoButtonSym.symbol = (app.timeMachine.canRedo() ? Art.Symbol.Redo : Art.Symbol.RedoDisabled).i(app); if (mapContext != null) { String mapId = mapContext.getCurrentMapObject(); ObjectRootHandle map = null; if (mapId != null) map = app.odb.getObject(mapId); app.sdb.updateDictionaries(map); } else { app.sdb.updateDictionaries(null); } app.odb.runPendingModifications(); LinkedList<Runnable> runs = new LinkedList<>(app.uiPendingRunnables); app.uiPendingRunnables.clear(); for (Runnable r : runs) r.run(); LinkedList<UISchemaHostWindow> newActive = new LinkedList<>(); for (UISchemaHostWindow ac : activeHosts) if (ac.windowOpen) newActive.add(ac); activeHosts = newActive; app.timeMachine.doCycle(); }
private void initializeTabs() { LinkedList<IToolset> toolsets = new LinkedList<IToolset>(); toolsets.add(new BasicToolset(app)); if (app.system.enableMapSubsystem) { app.loadProgress.accept(T.u.initMapScan); MapToolset mapController = new MapToolset(app); mapContext = mapController.getContext(); toolsets.add(mapController); } else { mapContext = null; } UIElement firstTab = null; for (IToolset its : toolsets) { app.loadProgress.accept(T.u.initTab.r(its.toString())); for (UIElement uie : its.generateTabs()) { if (firstTab == null) firstTab = uie; wm.createWindow(uie, true, true); } } wm.selectFirstTab(); }
public void startImgedit() { app.ui.wm.createWindowSH(new ImageEditorController(app).rootView); }
public void confirmDeletion( boolean mobileOnly, IRIO irio, SchemaElement se, final @Nullable UIElement menuBasis, final Runnable runnable) { confirmDeletion(mobileOnly, app.format(irio, se, Prefix.NoPrefix), menuBasis, runnable); }
public void confirmDeletion( boolean mobileOnly, String stuff, final @Nullable UIElement menuBasis, final Runnable runnable) { if (mobileOnly && !app.deletionButtonsNeedConfirmation) { runnable.run(); return; } String text = T.u.confirmDeletion.r(stuff); confirm(text, menuBasis, runnable); }
public void confirm( final String s, final @Nullable UIElement menuBasis, final Runnable runnable) { UITextButton accept = new UITextButton(T.u.confirm_accept, app.f.dialogWindowTH, null).centred(); UITextButton cancel = new UITextButton(T.u.confirm_cancel, app.f.dialogWindowTH, null).centred(); UIElement uie = new UISplitterLayout( new UILabel(s, app.f.dialogWindowTH), new UISplitterLayout(accept, cancel, false, 0.5d), true, 1d); final UIDynAppPrx mtb = UIDynAppPrx.wrap(app, uie); mtb.titleOverride = T.t.confirm; accept.onClick = () -> { runnable.run(); mtb.selfClose = true; }; cancel.onClick = () -> { mtb.selfClose = true; }; app.ui.wm.adjustWindowSH(mtb); if (menuBasis != null) { app.ui.wm.createMenu(menuBasis, mtb); } else { app.ui.wm.createWindow(mtb); } }
public Runnable createLaunchConfirmation(final String s, final Runnable runnable) { return () -> { UITextButton accept = new UITextButton(T.u.confirm_accept, app.f.dialogWindowTH, null).centred(); UITextButton cancel = new UITextButton(T.u.confirm_cancel, app.f.dialogWindowTH, null).centred(); UIElement uie = new UISplitterLayout( new UILabel(s, app.f.dialogWindowTH), new UISplitterLayout(accept, cancel, false, 0.5d), true, 1d); final UIDynAppPrx mtb = UIDynAppPrx.wrap(app, uie); mtb.titleOverride = T.t.confirm; accept.onClick = () -> { runnable.run(); mtb.selfClose = true; }; cancel.onClick = () -> { mtb.selfClose = true; }; app.ui.wm.createWindowSH(mtb); }; }
public boolean currentlyOpenInEditor(IRIO r) { for (ISchemaHost ish : activeHosts) { SchemaPath sp = ish.getCurrentObject(); while (sp != null) { if (sp.targetElement == r) return true; sp = sp.parent; } } return false; }
@Override public String toString() { return T.g.bCredits; }
@Override public String toString() { return T.u.helpTitle; }
public void schemaHostImplRegister(UISchemaHostWindow shi) { activeHosts.add(shi); }
public void saveAllModified() { app.odb.ensureAllSaved(); for (ImageEditorController iec : imgContext) if (iec.imageModified()) iec.save(); }
public boolean hasModified() { if (app.odb.modifiedObjects.size() > 0) return true; for (ImageEditorController iec : imgContext) if (iec.imageModified()) return true; return false; }
public void performFullImageFlush() { if (mapContext != null) mapContext.performCacheFlush(); }
public void launchDialog(String s, Throwable e) { StringWriter sw = new StringWriter(); e.printStackTrace(new PrintWriter(sw)); launchDialog(T.u.contextError.r(s, sw.toString()), T.t.error); }
public void launchDialog(String s) { launchDialog(s, T.t.info); }
public void launchDialog(Throwable e) { launchDialog(T.t.error, e); }
public void launchDoneDialog() { launchDialog(T.u.done); }
public void launchPrompt(String text, Consumer<String> consumer) { wm.createWindow(new UITextPrompt(app, text, consumer)); }
public ISchemaHost launchSchema(@NonNull ObjectRootHandle rio, @Nullable UIMapView context) { return launchSchema(rio.rootSchema, rio, context); }
public ISchemaHost launchSchema( SchemaElement s, @NonNull ObjectRootHandle rio, @Nullable UIMapView context) { UISchemaHostWindow watcher = new UISchemaHostWindow(app, context); watcher.pushObject(new SchemaPath(s, rio)); return watcher; }
public ISchemaHost launchDisconnectedSchema( @NonNull ObjectRootHandle root, DMKey arrayIndex, IRIO element, SchemaElement elementSchema, String indexText, UIMapView context) { ISchemaHost shi = launchSchema(root, context); SchemaPath sp = new SchemaPath(root); sp = sp.arrayHashIndex(arrayIndex, indexText); shi.pushObject(sp.newWindow(elementSchema, element)); return shi; }
public @Nullable ISchemaHost launchSchemaTrace( @NonNull ObjectRootHandle root, @Nullable UIMapView context, @NonNull DMPath goal) { SchemaPath pathRoot = new SchemaPath(root); SchemaPath res = pathRoot.tracePathRoute(goal); if (res == null) { launchDialog(T.u.schemaTraceFailure); return null; } UISchemaHostWindow watcher = new UISchemaHostWindow(app, context); watcher.pushPathTree(res); return watcher; }
public void copyUITree() { StringWriter sw = new StringWriter(); DatumWriter dw = new DatumWriter(sw); app.ui.wm.debugDumpUITree(dw); GaBIEn.clipboard.copyText(sw.toString()); }
public void record(IDM3Data data, TimeMachineChangeSource src) { hasRecordBeenCalledThisCycle = true; if (!recording.data.containsKey(data)) recording.data.put(data, data.saveState()); recording.sources.add(src); }
public void recordFresh(IDM3Data irioData) { fresh.add(irioData); }
public boolean canUndo() { return !undoStack.isEmpty(); }
public int undoSnapshots() { return undoStack.size(); }
public boolean canRedo() { return !redoStack.isEmpty(); }
public int redoSnapshots() { return redoStack.size(); }
private void markFreshObjectsClean() { for (IDM3Data f : fresh) f.trackingMarkClean(); fresh.clear(); }
public void doCycle() { recording.cleanAll(); markFreshObjectsClean(); if (!hasRecordBeenCalledThisCycle) { if (!recording.isEmpty()) { System.err.println("TimeMachine: COMMIT"); undoStack.addFirst(recording); while (undoStack.size() > MAX_STEPS) undoStack.removeLast(); recording = new Recording(); redoStack.clear(); } } hasRecordBeenCalledThisCycle = false; }
private void revertToRecording(HashSet<TimeMachineChangeSource> sourceTrack) { markFreshObjectsClean(); Recording tmp = recording; recording = new Recording(); tmp.invoke(sourceTrack); if (!recording.isEmpty()) throw new RuntimeException("State reversion caused recordings"); }
public void undo() { System.err.println("TimeMachine: UNDO"); HashSet<TimeMachineChangeSource> sourceTrack = new HashSet<TimeMachineChangeSource>(); revertToRecording(sourceTrack); recording = undoStack.removeFirst(); redoStack.addFirst(recording.createCounterRecording()); while (redoStack.size() > MAX_STEPS) redoStack.removeLast(); revertToRecording(sourceTrack); updateRestOfWorld(sourceTrack); }
public void redo() { System.err.println("TimeMachine: REDO"); HashSet<TimeMachineChangeSource> sourceTrack = new HashSet<TimeMachineChangeSource>(); revertToRecording(sourceTrack); recording = redoStack.removeFirst(); undoStack.addFirst(recording.createCounterRecording()); revertToRecording(sourceTrack); updateRestOfWorld(sourceTrack); }
public void clearUndoRedo() { undoStack.clear(); redoStack.clear(); }
private void updateRestOfWorld(HashSet<TimeMachineChangeSource> sources) { for (TimeMachineChangeSource tmcs : sources) tmcs.onTimeTravel(); app.sdb.kickAllDictionariesForMapChange(); }
void invoke(HashSet<TimeMachineChangeSource> sourceTrack) { sourceTrack.addAll(sources); for (Map.Entry<IDM3Data, Runnable> r : data.entrySet()) { r.getValue().run(); r.getKey().trackingMarkClean(); } }
Recording createCounterRecording() { Recording r = new Recording(); r.sources.addAll(sources); for (Map.Entry<IDM3Data, Runnable> e : data.entrySet()) r.data.put(e.getKey(), e.getKey().saveState()); return r; }
void cleanAll() { for (IDM3Data k : data.keySet()) k.trackingMarkClean(); }
@Override public void modifying(IDM3Data modifiedData) { tm.record(modifiedData, this); }
@Override public DatumVisitor handle(String key, DatumSrcLoc loc) { EngineDef ed = new EngineDef(); hm.put(key, ed); return ed.newVisitor(); }
public static MVMType irioOrRORIOForAccessor(MVMType input, Object context) { if (input.canImplicitlyCastTo(IRIO_TYPE)) return IRIO_TYPE; input.assertCanImplicitlyCastTo(RORIO_TYPE, context); return RORIO_TYPE; }
public void include(String filename, boolean opt) { boolean attempt = DatumLoader.read(filename, loadProgress, this::evalObject); if ((!opt) && !attempt) throw new RuntimeException("Expected " + filename + ".scm to exist"); DatumLoader.read(filename + ".aux", loadProgress, this::evalObject); }
@Override public DynTrBase dynTrBase( DatumSrcLoc srcLoc, String id, @Nullable DatumSymbol mode, Object base, boolean isNLS) { DynTrSlot res = dynMap.get(id); if (res == null) { MVMSlot slot = ensureSlot(new DatumSymbol(id)).help(null); if (slot.v != null) throw new RuntimeException("DynTr can't overwrite unrelated (NLS?) value " + id + "."); if (isNLS) { NLSTr nls = new NLSTr(this, srcLoc, id, mode, base); slot.v = nls; return nls; } res = new DynTrSlot(this, srcLoc, id, mode, base); slot.v = res; dynMap.put(id, res); dynList.add(id); } else { if (isNLS) throw new RuntimeException("Can't overwrite " + id + " with an NLS slot."); String srcOld = res.sourceDump(); res.setValue(base); if (!srcOld.equals(res.sourceDump())) logTrIssues.accept( "dynTr ID " + id + " changed value between two dynTrBase calls. DON'T do this."); } return res; }
private LinkedList<TrDumpSection> dynTrDumpSections() { LinkedList<TrDumpSection> sections = new LinkedList<>(); TrDumpSection currentSection = null; for (String s : dynList) { String estPfx = ""; if (s.contains(".")) estPfx = s.substring(0, s.indexOf('.') + 1); if (currentSection == null || !currentSection.prefix.equals(estPfx)) { currentSection = new TrDumpSection(estPfx); sections.add(currentSection); } currentSection.sectionContent.add(s); } return sections; }
public static void add(MVMEnvR48 ctx) { ctx.defLib( "include", MVMType.ANY, MVMType.STR, (a0) -> { ctx.include((String) a0, false); return null; }, "(include FILE) : Includes the given file. The code within magically counts as top-level" + " even if it shouldn't. The filename has \".scm\" appended, and a second file is" + " checked for with \".aux.scm\" appended for user additions."); ctx.defineSlot(new DatumSymbol("log"), new Log()).help("(log V...) : Logs the given values."); ctx.defineSlot(new DatumSymbol("help-html"), new HelpHTML(ctx)) .help("(help-html) : Creates r48-repl-help.html in the R48 launch directory."); }
@Override public Object callIndirect(Object[] args) { for (Object arg : args) System.out.println("MVM Log: " + MVMU.userStr(arg)); return null; }
public String textToHTML(String txt) { StringBuilder sb = new StringBuilder(); for (char c : txt.toCharArray()) { if (c == '\n') { sb.append("<br/>"); } else { sb.append("&"); sb.append("#"); sb.append((int) c); sb.append(";"); } } return sb.toString(); }
public String encodeAnchor(String txt) { StringBuilder a = new StringBuilder(); for (char c : txt.toCharArray()) { a.append('_'); a.append((int) c); } return a.toString(); }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length < 1) throw new RuntimeException("define-name needs at least the name of the name"); LinkedList<Object> l = new LinkedList<>(); for (int i = 1; i < call.length; i++) l.add(call[i]); FF1 res = ((MVMEnvR48) cs.context).dTrName(cs.topLevelSrcLoc, ((DatumSymbol) call[0]).id, l, isNLS); return new MVMCExpr.Const(res, MVMType.typeOfClass(FF1.class)); }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length != 2) throw new RuntimeException("define-tr has a name and a value"); DynTrBase res = ((MVMEnvR48) cs.context) .dynTrBase(cs.topLevelSrcLoc, ((DatumSymbol) call[0]).id, mode, call[1], isNLS); return new MVMCExpr.Const(res, MVMType.typeOfClass(DynTrBase.class)); }
@Defun(n = "atdb-load", r = 1) @Help("Loads an ATDB. A0: Primary rule file A1: Inverse rule file (or \"$WallATs$\")") public ATDB loadATDB(String filename, String inverseRules) { ATDB atdb = new ATDB(app, filename); if (inverseRules != null) atdb.calculateInverseMap(inverseRules); return atdb; }
@Defun(n = "atdb-bind", r = 1) @Help("Binds ATDBs.") public void loadATDB(List<ATDB> atdbs) { app.autoTiles = atdbs.toArray(new ATDB[0]); }
public static SchemaElement coerceToElement(App app, Object elm) { if (elm instanceof SchemaElement) return (SchemaElement) elm; return app.sdb.getSDBEntry(MVMU.coerceToString(elm)); }
public static void add(MVMEnvR48 ctx) { MVMCoreLibraries.add(ctx); MVMIntegrationLibrary.add(ctx); MVMDMLibrary.add(ctx, ctx.strict); MVMTrLibrary.add(ctx); }
@Defun(n = "se-new-button", r = 2) @Help( "Creates a button. A0: a 1-parameter name routine for the button's text, A1: a 3-parameter" + " lambda (target launcher path).") public SchemaElement newButton(FF1 text, MVMFn fn) { return new TenthRuleSchemaElement(app, text, fn); }
@Defun(n = "se-new-subwindow", r = 1) @Help( "Creates a subwindow element. A0: interior schema element A1: optional: a 1-parameter name" + " routine for the button's text") public SchemaElement newSubwindow(Object se, FF1 fn) { if (fn == null) return new SubwindowSchemaElement(coerceToElement(app, se)); return new SubwindowSchemaElement(coerceToElement(app, se), (irio) -> fn.r(irio)); }
@Defun(n = "se-new-with-default", r = 2) @Help("Creates a with-default element. A0: interior schema element A1: default") public SchemaElement newWithDefault(Object se, Object fn) { return new WithDefaultSchemaElement(coerceToElement(app, se), MVMDMLibrary.dmKeyify(fn)); }
@Defun(n = "se-new-ui-override", r = 2) @Help("Creates a UI override element. A0: interior schema element A1: ui schema element") public SchemaElement newUIO(Object se1, Object se2) { return new UIOverrideSchemaElement(coerceToElement(app, se1), coerceToElement(app, se2)); }
@Defun(n = "se-new-label", r = 1) @Help("Creates a label element. A0: text") @Example("(ui-test-schema (se-new-label (define-tr test \"HI\")))") public SchemaElement newUILabel(FF0 se1) { return new LabelSchemaElement(app, se1); }
@Defun(n = "se-new-aggregate", r = 0) @Help("Creates a new aggregate from the given list of elements.") @Example( "(ui-test-schema (se-new-aggregate (list (se-new-label (define-tr test1 \"A\")) (se-new-label" + " (define-tr test2 \"B\")) )))") public SchemaElement newAggregate(List<SchemaElement> elements) { return new AggregateSchemaElement(app, elements.toArray(new SchemaElement[0])); }
public static @Nullable ObjectRootHandle assertObjectRoot(App app, Object input, boolean create) { if (input instanceof ObjectRootHandle) return (ObjectRootHandle) input; return assertObjectInfo(app, input).getILO(create); }
public static @NonNull ObjectInfo assertObjectInfo(App app, Object text) { ObjectInfo oi = app.getObjectInfo((String) text); if (oi == null) throw new RuntimeException("MVM is not allowed to access undefined object info: " + text); return oi; }
@Override public Object callDirect(Object a0) { if (a0 == null) return ""; return app.format((RORIO) a0, (String) null, EnumSchemaElement.Prefix.Default); }
@Override public Object callDirect(Object a0, Object a1) { if (a0 == null) return ""; return app.format((RORIO) a0, (String) a1, EnumSchemaElement.Prefix.Default); }
@Override public Object callDirect(Object a0, Object a1, Object a2) { if (a0 == null) return ""; EnumSchemaElement.Prefix pfx = EnumSchemaElement.Prefix.Default; if (a2 != null) pfx = MVMU.isTruthy(a2) ? EnumSchemaElement.Prefix.Prefix : EnumSchemaElement.Prefix.NoPrefix; return app.format((RORIO) a0, (String) a1, pfx); }
public static DMKey dmKeyify(Object v) { if (v == null) { return DMKey.NULL; } else if (v instanceof DMKey) { return (DMKey) v; } else if (v instanceof Boolean) { return DMKey.of((Boolean) v); } else if (v instanceof String) { return DMKey.ofStr((String) v); } else if (v instanceof DatumSymbol) { return DMKey.ofSym(((DatumSymbol) v).id); } else if (v instanceof Long) { return DMKey.of((Long) v); } else if (v instanceof RORIO) { return ((RORIO) v).asKey(); } else { throw new RuntimeException("Cannot convert " + v + " to DMKey"); } }
private static String tName(int mode) { String name = "dm-at"; if (mode == 1) name = "dm-add-at!"; if (mode == 2) name = "dm-del-at!"; return name; }
@Override public Object execute( MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { Object bval = base.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); if (mode == 1) return ps.add((IRIO) bval); else if (mode == 2) return ps.del((IRIO) bval); else return ps.getRO((RORIO) bval); }
@Override public Object disasm() { return DatumTreeUtils.sym("dm-at-invoker"); }
public static void add(MVMEnvR48 ctx, App app) { MVMR48GlobalLibraries.add(ctx); MVMDMAppLibrary.add(ctx, app); ctx.install(new MVMSDBLibrary(app)); ctx.install(new MVMSDBElementsLibrary(app)); MVMAppUILibrary.add(ctx, app); }
@Override public void run() { launcher.launchOther(new UITest(launcher.getApp(), target, path.root)); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { if (setDefault) path.changeOccurred(true); }
@Override public void objectRootModifiedPass(SchemaPath path) { super.objectRootModifiedPass(path); keyWorkspaceSlot.value = new IRIOGeneric(app.ctxWorkspaceAppEncoding).setDeepClone(keyWorkspace); }
@Override public String apply(RORIO rubyIO) { return getKeyText(rubyIO); }
private boolean findAndAddIVars(SchemaElement ise, IRIO target, LinkedList<String> iVars) { ise = AggregateSchemaElement.extractField(ise, target); if (ise instanceof PathSchemaElement) { String n = PathSyntax.getAbsoluteIVar(((PathSchemaElement) ise).pStr); if (n != null) iVars.add(n); return true; } if (ise instanceof BaseRubyTableSchemaElement) { String n = PathSyntax.getAbsoluteIVar(((BaseRubyTableSchemaElement) ise).iVar); if (n != null) iVars.add(n); return true; } if (ise instanceof HalfsplitSchemaElement) return findAndAddIVars(((HalfsplitSchemaElement) ise).a, target, iVars) || findAndAddIVars(((HalfsplitSchemaElement) ise).b, target, iVars); if (ise instanceof AggregateSchemaElement) { boolean r = false; for (SchemaElement se : ((AggregateSchemaElement) ise).aggregate) { if (findAndAddIVars(se, target, iVars)) r = true; } return r; } return false; }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { setDefault = SchemaElement.checkType(target, type, symbol, setDefault); if (setDefault) target.setObject(symbol); backing.modifyVal(target, path, setDefault); if (setDefault) path.changeOccurred(true); }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { backing.visit(target, path, v, detailedPaths); }
@Override public String windowTitleSuffix(SchemaPath path) { return backing.windowTitleSuffix(path); }
@Override public boolean determineTruth(IRIO rubyIO) { return rubyIO.getFX() != 0; }
@Override public boolean truthInvalid(IRIO target) { return target.getType() != 'i'; }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { return new UIEmpty(); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { if (checkType(target, '{', null, setDefault && (!inner))) { target.setHash(); path.changeOccurred(true); } else { LinkedList<DMKey> keys = new LinkedList<DMKey>(); for (DMKey key : target.getHashKeys()) if (!allowedKeys.contains(key)) keys.add(key); for (DMKey k : keys) target.removeHashVal(k); if (keys.size() > 0) path.changeOccurred(true); } }
@Override public UIElement buildHoldingEditorImpl( final IRIO target, final ISchemaHost launcher, final SchemaPath path2) { final SchemaPath path = path2.tagSEMonitor(target, this, true); String iv = getDisambigIndex(target); SchemaElement ise = getSchemaElement(iv); return ise.buildHoldingEditor(target, launcher, path); }
@Override public void modifyVal(IRIO target, SchemaPath path2, boolean setDefault) { final SchemaPath path = path2.tagSEMonitor(target, this, true); String iv = getDisambigIndex(target); if (!setDefault) if (iv.equals("")) System.out.println( "Warning: Disambiguator working off of nothing here, this CANNOT GO WELL"); try { SchemaElement ise = getSchemaElement(iv); ise.modifyVal(target, path, setDefault); } catch (RuntimeException e) { e.printStackTrace(System.out); System.out.println("ArrayDisambiguator Debug: " + iv); throw e; } }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { String iv = getDisambigIndex(target); SchemaElement ise = getSchemaElement(iv); ise.visit(target, path, v, detailedPaths); }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { return new UISplitterLayout( a.buildHoldingEditor(target, launcher, path), b.buildHoldingEditor(target, launcher, path), false, weight); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { a.modifyVal(target, path, setDefault); b.modifyVal(target, path, setDefault); }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { a.visit(target, path, v, detailedPaths); b.visit(target, path, v, detailedPaths); }
@Override public UIElement buildHoldingEditorImpl( final IRIO target, final ISchemaHost launcher, final SchemaPath path) { UILabel uil = null; if (alias != null) uil = new UILabel(alias.r() + " ", app.f.schemaFieldTH); IRIO tgo = pStr.getRW(target); UIElement e2; if (tgo == null) { if (!optional) throw new RuntimeException( "Error: Made it to PathSchemaElement.buildHoldingEditor when target wasn't there: " + pStr); e2 = new UITextButton( T.s.bOptAdd, app.f.schemaFieldTH, () -> { IRIO rio = pStr.add(target); createIVar(rio, path, false); }); } else { e2 = subElem.buildHoldingEditor(tgo, launcher, path.otherIndex(alias.r())); if (optional) e2 = new UIAppendButton( "-", e2, () -> { if (pStr.del(target) != null) path.changeOccurred(false); }, app.f.schemaFieldTH); } if (uil != null) { UIFieldLayout usl = new UIFieldLayout(uil, e2, fieldWidth, fieldWidthOverride); fieldWidthOverride = false; return usl; } return e2; }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { IRIO r = pStr.getRW(target); if (r != null) { subElem.modifyVal(r, path.otherIndex(alias.r()), setDefault); } else { if (!optional) { IRIO rio = pStr.add(target); if (rio == null) throw new RuntimeException("failed create during modifyVal, " + pStr); createIVar(rio, path, true); } } }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { IRIO r = pStr.getRW(target); if (r != null) subElem.visit(r, detailedPaths ? path.otherIndex(alias.r()) : path, v, detailedPaths); }
private void createIVar(IRIO r, SchemaPath targetPath, boolean mv) { subElem.modifyVal(r, targetPath.otherIndex(alias.r()), mv); targetPath.changeOccurred(mv); }
@Override public UIElement buildHoldingEditorImpl( final IRIO target, ISchemaHost launcher, final SchemaPath path) { final UITextButton utb = new UITextButton( determineTruth(target) ? T.s.booleanTrue : T.s.booleanFalse, app.f.schemaFieldTH, null) .togglable(determineTruth(target)); utb.onClick = () -> { modifyValueTruth(target, utb.state); path.changeOccurred(false); }; return utb; }
public boolean determineTruth(IRIO rubyIO) { return rubyIO.getType() == 'T'; }
public boolean modifyValueTruth(IRIO target, boolean truth) { int lastType = target.getType(); target.setBool(truth); return lastType != target.getType(); }
public boolean truthInvalid(IRIO target) { int t = target.getType(); if (t == 'T') return false; if (t == 'F') return false; return true; }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { boolean modified = false; if (setDefault) { modified = modifyValueTruth(target, defaultVal); } else if (truthInvalid(target)) { modified = modifyValueTruth(target, defaultVal); } if (modified) path.changeOccurred(true); }
public void convertLookupToView() { viewOptions.clear(); viewOptions.addAll(lookupOptions.values()); Collections.sort(viewOptions, UIEnumChoice.COMPARATOR_OPTION); }
public void convertViewToLookup() { lookupOptions.clear(); for (UIEnumChoice.Option o : viewOptions) lookupOptions.put(ValueSyntax.encode(o.value), o); }
@Override public UIElement buildHoldingEditorImpl( final IRIO target, final ISchemaHost launcher, final SchemaPath path) { final UIEnumChoice.Option opt = findOption(target); UITextButton button = new UITextButton( viewValue(target, Prefix.Prefix, opt), app.f.schemaFieldTH, () -> { liveUpdate(); TempDialogSchemaChoice temp = new TempDialogSchemaChoice(app, null, path); temp.heldDialog = makeEnumChoiceDialog( (integer) -> { target.setDeepClone(integer); path.changeOccurred(false); temp.pleasePopObject(); }); launcher.pushObject(path.newWindow(temp, target)); }); if (opt != null) { if (opt.furtherDataButton != null) return new UIAppendButton( Art.Symbol.CloneFrame.i(app), button, () -> { launcher.newBlank().pushObject(opt.furtherDataButton); }, app.f.schemaFieldTH); } return button; }
public UIEnumChoice makeEnumChoiceDialog(Consumer<DMKey> result) { return new UIEnumChoice(app, result, viewOptions, buttonText.r(), entryMode); }
public static UIEnumChoice.Option makeStandardOption( DMKey val, FF0 text, @Nullable Consumer<String> edit, @Nullable SchemaPath fdb) { return new UIEnumChoice.Option(val.toString() + " : ", text, val, edit, fdb); }
public @Nullable UIEnumChoice.Option findOption(RORIO val) { String v2 = ValueSyntax.encode(val); UIEnumChoice.Option st = null; if (v2 != null) st = lookupOptions.get(v2); return st; }
public String viewValue(RORIO val, Prefix prefix) { return viewValue(val, prefix, findOption(val)); }
public String viewValue(RORIO val, Prefix prefix, @Nullable UIEnumChoice.Option option) { if (option != null) { boolean shouldPrefix = false; if (prefix == Prefix.Prefix) shouldPrefix = true; else if (prefix == Prefix.Default) shouldPrefix = displayPrefixDefault; if (!shouldPrefix) return option.textSuffix.r(); return option.getTextMerged(); } return val.toString(); }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { if (show.apply(target)) return content.buildHoldingEditor(target, launcher, path); return new UIEmpty(); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { content.modifyVal(target, path, setDefault); }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { content.visit(target, path, v, detailedPaths); }
@Override public void run() { targetValue.setNull(); targets[fi].modifyVal(targetValue, path, true); path.changeOccurred(false); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { int rei = -1; if (!setDefault) rei = getRelevantElementId(target); if (rei == -1) { rei = targets.length - 1; setDefault = true; } SchemaElement targetS = targets[rei]; targetS.modifyVal(target, path, setDefault); }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { int rei = getRelevantElementId(target); if (rei == -1) return; targets[rei].visit(target, path, v, detailedPaths); }
@Override public UIElement buildHoldingEditorImpl( IRIO target, final ISchemaHost launcher, final SchemaPath path) { if (!overrideSet) overrideFW = getDefaultFieldWidth(target); LinkedList<UIElement> uiSVLList = new LinkedList<>(); for (SchemaElement ise : aggregate) { SchemaElement possibleField = extractField(ise, target); if (possibleField instanceof IFieldSchemaElement) ((IFieldSchemaElement) possibleField).setFieldWidthOverride(overrideFW); uiSVLList.add(ise.buildHoldingEditor(target, launcher, path)); } overrideSet = false; return AggregateSchemaElement.createScrollSavingSVL( launcher, scrollPointKey, target, uiSVLList); }
public static SchemaElement extractField(SchemaElement ise, @Nullable RORIO rio) { boolean continuing = true; while (continuing) { continuing = false; if (ise instanceof IProxySchemaElement) { ise = ((IProxySchemaElement) ise).getEntry(); continuing = true; } if (rio != null) { if (ise instanceof DisambiguatorSchemaElement) { ise = ((DisambiguatorSchemaElement) ise).getDisambiguation(rio); continuing = true; } } } return ise; }
@Override public void modifyVal(IRIO target, SchemaPath i, boolean setDefault) { for (SchemaElement ise : aggregate) ise.modifyVal(target, i, setDefault); }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { for (SchemaElement ise : aggregate) ise.visit(target, path, v, detailedPaths); }
@Override public void handleMousewheel(int x, int y, boolean north) { super.handleMousewheel(x, y, north); savedPoint.accept(scrollbar.scrollPoint); }
@Override public void handlePointerBegin(IPointer state) { ipr.handlePointerBegin(state); }
@Override public void handlePointerUpdate(IPointer state) { ipr.handlePointerUpdate(state); }
@Override public void handlePointerEnd(IPointer state) { ipr.handlePointerEnd(state); savedPoint.accept(scrollbar.scrollPoint); }
public static UIScrollLayout createScrollSavingSVL( final ISchemaHost host, final EmbedDataKey<Double> key, final IRIO target, UIElement... contents) { UIScrollLayout usl = createScrollSavingSVL(host, key, target); usl.panelsSet(contents); usl.forceToRecommended(); return usl; }
public static UIScrollLayout createScrollSavingSVL( final ISchemaHost host, final EmbedDataKey<Double> key, final IRIO target, Iterable<UIElement> contents) { UIScrollLayout usl = createScrollSavingSVL(host, key, target); usl.panelsSet(contents); usl.forceToRecommended(); return usl; }
public static void hookButtonForPressPreserve( final ISchemaHost host, final IRIO target, final UITextButton utb, final EmbedDataKey<Boolean> id) { IGetSet<Boolean> wasPressed = host.embedSlot(target, id, false); final Runnable next = utb.onClick; utb.onClick = () -> { wasPressed.accept(true); if (next != null) next.run(); }; if (wasPressed.get()) utb.enableStateForClick(); wasPressed.accept(false); }
@Override public @Nullable String windowTitleSuffix(SchemaPath path) { for (SchemaElement ise : aggregate) { String res = ise.windowTitleSuffix(path); if (res != null) return res; } return null; }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { return content.buildHoldingEditor(target, launcher, path); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { if (setDefault) { target.setDeepClone(def); content.modifyVal(target, path, false); path.changeOccurred(true); } else { content.modifyVal(target, path, setDefault); } }
@Override public UIElement buildHoldingEditorImpl( final IRIO target, ISchemaHost launcher, final SchemaPath path) { UITextButton utb = new UITextButton( text.r(), app.f.schemaFieldTH, () -> { target.setDeepClone(value); path.changeOccurred(false); }) .togglable(RORIO.rubyEquals(target, value)); return utb; }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) {}
@Override public UIElement buildHoldingEditorImpl( final IRIO target, final ISchemaHost launcher, final SchemaPath path) { String text = nameGetter.apply(target); String[] lines = text.split("\n"); UIElement[] elms = new UIElement[lines.length]; elms[0] = new UITextButton( lines[0], app.f.schemaFieldTH, () -> { launcher.pushObject(path.newWindow(heldElement, target)); }); for (int i = 1; i < lines.length; i++) elms[i] = new UILabel(lines[i], app.f.schemaFieldTH); return new UIListLayout(true, elms); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { heldElement.modifyVal(target, path, setDefault); }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { heldElement.visit( target, detailedPaths ? path.newWindow(heldElement, target) : path, v, detailedPaths); }
@Override public void run() { reinitializer.modifyVal(target, path, asDefault); path.changeOccurred(false); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { if (defaulting && setDefault) reinitializer.modifyVal(target, path, true); }
public static boolean checkType(RORIO tgt, int t, String objType, boolean setDefault) { if (tgt.getType() != t) return true; if (objType != null) if (!tgt.getSymbol().equals(objType)) return true; return setDefault; }
public final UIElement objectHasBecomeInvalidScreen(SchemaPath sp) { return new UIScrollLayout( true, app.f.generalS, new UILabel(T.s.objectHasBecomeInvalid.r(sp, this), app.f.schemaFieldTH)); }
public final UIElement buildHoldingEditor(IRIO target, ISchemaHost launcher, SchemaPath path) { try { return buildHoldingEditorImpl(target, launcher, path); } catch (Exception ex) { if (app.ilg.strict) throw ex; ex.printStackTrace(); StringWriter sw = new StringWriter(); ex.printStackTrace(new PrintWriter(sw)); return new UIScrollLayout( true, app.f.generalS, new UILabel(T.s.seInternalError + sw.toString(), app.f.schemaFieldTH)); } }
public @Nullable String windowTitleSuffix(SchemaPath path) { return null; }
public boolean declaresSelfEditorOf(RORIO target, RORIO check) { return target == check; }
public final void visit(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { if (v.visit(this, target, path)) visitChildren(target, path, v, detailedPaths); }
@Override public final void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) {}
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { return ui.buildHoldingEditor(target, launcher, path); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { data.modifyVal(target, path, setDefault); }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { data.visitChildren(target, path, v, detailedPaths); }
@Override public UIElement buildHoldingEditorImpl( final IRIO target, final ISchemaHost launcher, final SchemaPath path) { if (target.getType() != '"') return objectHasBecomeInvalidScreen(path); final UITextBox tb = new UITextBox(target.decString(), app.f.schemaFieldTH); tb.onEdit = () -> { String text = tb.getText(); if (verifier(text)) { encodeVal(text, target); path.changeOccurred(false); } else { tb.setText(target.decString()); } }; return tb; }
protected void encodeVal(String text, IRIO target) { target.setString(text); }
protected boolean verifier(String text) { return true; }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { if (SchemaElement.checkType(target, type, null, setDefault)) { encodeVal(defaultStr.r(), target); path.changeOccurred(true); } }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { if (path.lastArrayIndex == null) return; if (checkType(target, 'i', null, setDefault || !IRIO.rubyEquals(target, path.lastArrayIndex))) { target.setDeepClone(path.lastArrayIndex); path.changeOccurred(true); } }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { boolean ok = false; int typ = target.getType(); if (jsonCoerce) if (typ == 'i') ok = true; if (typ == 'f') ok = true; if (setDefault) ok = false; if (!ok) { if (!IntUtils.encodeRbFloat(target, def, jsonCoerce)) throw new RuntimeException("Float default must be valid"); path.changeOccurred(true); } }
public StandardArrayInterface withoutIndexLabels() { hasIndexLabels = false; return this; }
private void copyRange(int fixedStart, int fixedEnd) { IRIOGeneric rio = new IRIOGeneric(app.ctxClipboardAppEncoding); rio.setArray(); for (int j = fixedStart; j <= fixedEnd; j++) if (positions[j].elements != null) for (IRIO rio2 : positions[j].elements) rio.addAElem(rio.getALen()).setDeepClone(rio2); app.theClipboard = rio; }
private void deleteRange(int fixedStart, int fixedEnd) { ArrayPosition[] effectivePositions = positions; Runnable term = null; HashSet<IRIO> allowedDelete = new HashSet<IRIO>(); for (int j = fixedStart; j <= fixedEnd; j++) if (effectivePositions[j].elements != null) Collections.addAll(allowedDelete, effectivePositions[j].elements); for (int j = fixedStart; j <= fixedEnd; j++) { if (fixedStart >= effectivePositions.length) { break; } if (effectivePositions[fixedStart].execDelete == null) { break; } if (effectivePositions[fixedStart].elements == null) { break; } boolean aok = true; for (IRIO rio : effectivePositions[fixedStart].elements) { if (!allowedDelete.contains(rio)) { aok = false; break; } } if (!aok) { break; } term = effectivePositions[fixedStart].execDelete.get(); effectivePositions = getPositions.get(); } if (term != null) term.run(); }
private int tracePositionEnd(ArrayPosition[] positions, int mi) { int idt = positions[mi].coreIndent; for (int i = mi + 1; i < positions.length; i++) if (positions[i].coreIndent <= idt) return i; return positions.length - 1; }
private UIMenuButton genAdditionButton( boolean clarifyEmpty, final Runnable runnable, final Runnable runnable2) { if (runnable == null) return null; LinkedList<String> optText = new LinkedList<String>(); LinkedList<Runnable> optRuns = new LinkedList<Runnable>(); optText.add(clarifyEmpty ? T.s.array_bInsert : T.s.array_bAddNext); optRuns.add(runnable); if (runnable2 != null) { optText.add(T.s.array_bPasteArr); optRuns.add(runnable2); } return new UIMenuButton( uiSVL.getApp(), T.s.array_bAdd, app.f.schemaArrayAddTH, valid, optText.toArray(new String[0]), optRuns.toArray(new Runnable[0])); }
private UIElement addAdditionButton( UIElement uie, boolean clarifyEmpty, final Runnable runnable, final Runnable runnable2) { UIMenuButton umb = genAdditionButton(clarifyEmpty, runnable, runnable2); if (umb == null) return uie; return new UIAppendButton(umb, uie); }
@Override public void panelsClear() { svl.panelsClear(); svl.panelsAdd(swapModeButton); }
@Override public void panelsAdd(UIElement element) { svl.panelsAdd(element); }
@Override public void panelsFinished() { svl.panelsFinished(); }
@Override public void selectTab(UIElement i) { super.selectTab(i); prop2.value = getTabIndex(); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { super.update(deltaTime, selected, peripherals); scrollProp.value = getScrollPoint(); }
@Override public void panelsClear() { uie.clear(); uiSVL.panelsSet(); }
@Override public void panelsAdd(UIElement element) { uie.add(element); }
@Override public void panelsFinished() { uiSVL.panelsSet(uie); }
@Override public void run() { path.changeOccurred(false); }
@Override public void visitChildren(IRIO target, SchemaPath path2, Visitor v, boolean detailedPaths) { final SchemaPath path = monitorsSubelements() ? path2.tagSEMonitor(target, this, false) : path2; HashMap<Integer, Integer> indentAnchors = new HashMap<Integer, Integer>(); int alen = target.getALen(); for (int j = 0; j < alen; j++) { IRIO rio = target.getAElem(j); getElementSchema(j) .visit(rio, path.arrayHashIndex(DMKey.of(j), "[" + j + "]"), v, detailedPaths); } int groupStep; for (int j = 0; j < alen; j += groupStep) { groupStep = getGroupLength(target, j); if (groupStep == 0) { groupStep = 1; continue; } getElementContextualSchema(target, j, groupStep, indentAnchors) .element .visit(target, path, v, detailedPaths); } }
public boolean monitorsSubelements() { return false; }
protected void elementOnCreateMagic( IRIO target, int i, ISchemaHost launcher, SchemaPath ind, SchemaPath path) {}
protected ElementContextual getElementContextualSchema( IRIO arr, int start, int length, final HashMap<Integer, Integer> indentAnchors) { throw new RuntimeException( "Group length was used, but no contextual schema was defined for it."); }
protected int elementPermissionsLevel(int i, IRIO target) { boolean canDelete = (sizeFixed == -1) && (!(target.getALen() <= atLeast)); return canDelete ? 2 : 1; }
@Override protected boolean autoCorrectArray(IRIO array, SchemaPath path) { return false; }
@Override protected int elementPermissionsLevel(int i, IRIO target) { if (i < indexOffset) return 0; return super.elementPermissionsLevel(i, target); }
@Override public void accept(T arg0) { value = arg0; }
private static @NonNull SchemaElement verifyRootHasSchema(@NonNull ObjectRootHandle root) { SchemaElement se = root.rootSchema; if (se == null) throw new NullPointerException( "Gah! Creating SchemaPath to " + root + " ; but it has no schema!"); return se; }
private static @NonNull SchemaElement weDoNotTrustOurCallers( @Nullable SchemaElement he, @NonNull ObjectRootHandle root) { if (he == null) { System.err.println("Gah! Creating SchemaPath to " + root + " with null SchemaElement."); return verifyRootHasSchema(root); } return he; }
public static void setDefaultValue( @NonNull IRIO target, @NonNull SchemaElement ise, @Nullable DMKey arrayIndex) { ObjectRootHandle dvRoot = new ObjectRootHandle.Isolated(ise, target, "setDefaultValue"); ise.modifyVal( target, new SchemaPath(ise, dvRoot).arrayHashIndex(arrayIndex, "AnonObject"), true); }
public String toString() { SchemaPath measuring = this; LinkedList<SchemaPath> pathOrder = new LinkedList<>(); while (measuring != null) { pathOrder.addFirst(measuring); measuring = measuring.parent; } String str = ""; for (SchemaPath sp : pathOrder) if (sp.hrIndex != null) str += sp.hrIndex; return str; }
public String toStringMissingRoot() { SchemaPath measuring = this; LinkedList<SchemaPath> pathOrder = new LinkedList<>(); while (measuring != null) { pathOrder.addFirst(measuring); measuring = measuring.parent; } pathOrder.removeFirst(); String str = ""; for (SchemaPath sp : pathOrder) if (sp.hrIndex != null) str += sp.hrIndex; return str; }
public SchemaPath findRoot() { SchemaPath root = this; while (root.parent != null) root = root.parent; return root; }
public @Nullable SchemaPath findFirstEditable() { if (editor != null) return this; if (parent == null) return null; return parent.findFirstEditable(); }
public SchemaPath findHighestSubwatcher() { SchemaPath mod = this; SchemaPath root = this; while (root.parent != null) { root = root.parent; if (root.monitorsSubelements) mod = root; } return mod; }
public SchemaPath arrayHashIndex(DMKey index, String indexS) { return new SchemaPath(this, null, null, index, indexS); }
public SchemaPath newWindow(SchemaElement heldElement, IRIO target) { return new SchemaPath(this, heldElement, target, lastArrayIndex, null); }
public SchemaPath otherIndex(String index) { return new SchemaPath(this, null, null, lastArrayIndex, index); }
public SchemaPath tagSEMonitor(IRIO target, SchemaElement ise, boolean upwards) { if (upwards) { SchemaPath spp = this; SchemaPath sppLast = this; while ((target == spp.targetElement) || (target == null)) { sppLast = spp; spp = spp.parent; if (spp == null) break; } if (sppLast != spp) sppLast.monitorsSubelements = true; } SchemaPath sp = new SchemaPath(this, ise, target, lastArrayIndex, null); sp.monitorsSubelements = true; return sp; }
public void changeOccurred(boolean modifyVal) { if (!modifyVal) pokeHighestSubwatcherEditor(); root.objectRootModified(this); }
public void pokeHighestSubwatcherEditor() { SchemaPath sw = findHighestSubwatcher(); if (sw.editor != null) sw.editor.modifyVal(sw.targetElement, sw, false); }
public boolean hasTempDialog() { if (editor instanceof TempDialogSchemaChoice) return true; if (parent != null) return parent.hasTempDialog(); return false; }
public SchemaPath contextSchema(String contextName, SchemaElement enumSchemaElement) { SchemaPath sp = new SchemaPath(this, null, null, lastArrayIndex, null); sp.contextualSchemas.put(contextName, enumSchemaElement); return sp; }
public @NonNull String windowTitleSuffix() { String parentSuffix = ""; if (parent != null) parentSuffix = parent.windowTitleSuffix(); if (editor != null) { String attemptedEditorSuffix = editor.windowTitleSuffix(this); if (attemptedEditorSuffix != null) return parentSuffix + ":" + attemptedEditorSuffix; } return parentSuffix; }
public @Nullable SchemaPath tracePathRoute(@NonNull DMPath path) { SchemaPath sp = findFirstEditable(); if (sp == null) { System.err.println("tracePathRoute failed: findFirstEditable failed"); return null; } RORIO res = path.getRO(sp.targetElement); if (res == null) { System.err.println("tracePathRoute failed: path failed"); return null; } HashSet<RORIO> mainSet = new PathSyntax(path).traceRO(sp.targetElement); mainSet.add(sp.targetElement); mainSet.add(res); return sp.traceRoute(res, mainSet); }
@Override public void pushObject(SchemaPath nextObject) { if (innerElem != null) backStack.push(innerElem); switchObject(nextObject); }
@Override public void popObject(boolean canClose) { if (backStack.size() > 0) { switchObject(backStack.pop()); } else if (canClose) { shutdown(); } }
@Override protected void refreshDisplay() { boolean doLaunch = false; if (!(windowOpen || stayClosed)) doLaunch = true; innerElemEditor = innerElem.editor.buildHoldingEditor(innerElem.targetElement, this, innerElem); for (UIElement uie : layoutGetElements()) layoutRemoveElement(uie); layoutAddElement(toolbarRoot); layoutAddElement(innerElemEditor); innerElemEditor.setForcedBounds(this, new Rect(getSize())); pathLabel.setText(innerElem.toStringMissingRoot()); layoutRecalculateMetrics(); if (doLaunch) { windowOpen = true; app.ui.wm.createWindow(this); app.ui.schemaHostImplRegister(this); } }
@Override public int layoutGetHForW(int width) { if (innerElemEditor == null) return toolbarRoot.layoutGetHForW(width); return toolbarRoot.layoutGetHForW(width) + innerElemEditor.layoutGetHForW(width); }
@Override protected void layoutRunImpl() { Size r = getSize(); int tbHeight = toolbarRoot.layoutGetHForW(r.width); toolbarRoot.setForcedBounds(this, new Rect(0, 0, r.width, tbHeight)); if (innerElemEditor != null) innerElemEditor.setForcedBounds(this, new Rect(0, tbHeight, r.width, r.height - tbHeight)); }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { Size tb = toolbarRoot.getWantedSize(); Size iee = tb; if (innerElemEditor != null) iee = innerElemEditor.getWantedSize(); return new Size(Math.max(tb.width, iee.width), tb.height + iee.height); }
@Override public void duplicateThisWindow() { if (innerElem.hasTempDialog()) { app.ui.launchDialog(T.u.shNoCloneTmp); return; } UISchemaHostWindow next = (UISchemaHostWindow) newBlank(); next.backStack.addAll(backStack); next.backStack.push(innerElem); next.embedData = new EmbedDataTracker(next.backStack, embedData); next.popObject(false); }
@Override public void onWindowClose() { windowOpen = false; stayClosed = true; if (innerElem != null) { innerElem.findRoot().root.deregisterModificationHandler(nudgeRunnable); replaceValidity(); innerElem = null; innerElemEditor = null; } for (UIElement uie : layoutGetElements()) layoutRemoveElement(uie); }
@Override public boolean requestsUnparenting() { return stayClosed; }
@Override public void accept(SchemaPath sp) { nudged = true; }
@Override public Boolean get() { return validitySupplier == this; }
@Override public <T> EmbedDataSlot<T> embedSlot( SchemaPath locale, IRIO target, EmbedDataKey<T> prop, T def) { return embedData.createSlot(locale, target, prop, def); }
@Override public ISchemaHost newBlank() { return new UISchemaHostWindow(app, contextView); }
@Override public void launchOther(UIElement uiTest) { app.ui.wm.createWindow(uiTest); }
@Override public String toString() { if (innerElem == null) return "(how'd you manage this then?)"; String name = innerElem.root.toString(); name += innerElem.windowTitleSuffix(); if (app.odb.modifiedObjects.contains(innerElem.root)) name += "*"; return name; }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { super.update(deltaTime, selected, peripherals); if (nudged) { replaceValidity(); refreshDisplay(); nudged = false; } }
protected final void switchObject(SchemaPath nextObject) { if (innerElem != null) innerElem.root.deregisterModificationHandler(nudgeRunnable); while (nextObject.editor == null) nextObject = nextObject.parent; nextObject.root.registerModificationHandler(nudgeRunnable); replaceValidity(); innerElem = nextObject; refreshDisplay(); }
@SuppressWarnings("unchecked") public @NonNull <T> EmbedDataSlot<T> createSlot( SchemaPath current, IRIO target, EmbedDataKey<T> prop, T defVal) { LinkedList<EmbedDataSlot<?>> localEDKs = mapTree.get(current); if (localEDKs == null) { localEDKs = new LinkedList<EmbedDataSlot<?>>(); mapTree.put(current, localEDKs); } for (EmbedDataSlot<?> edk : localEDKs) if (edk.target.equals(target)) if (edk.prop.equals(prop)) return (EmbedDataSlot<T>) edk; EmbedDataSlot<T> newEDK = new EmbedDataSlot<T>(target, prop); newEDK.value = defVal; localEDKs.add(newEDK); return newEDK; }
@Override public void pushObject(SchemaPath nextObject) { if (innerElem == null) { switchObject(nextObject); } else { newBlank().pushObject(nextObject); } }
@Override public void popObject(boolean canClose) { }
@Override protected void refreshDisplay() { for (UIElement uie : layoutGetElements()) layoutRemoveElement(uie); innerElemEditor = innerElem.editor.buildHoldingEditor(innerElem.targetElement, this, innerElem); layoutAddElement(innerElemEditor); layoutRecalculateMetrics(); }
@Override protected Size layoutRecalculateMetricsImpl() { if (innerElemEditor == null) return null; return innerElemEditor.getWantedSize(); }
@Override public int layoutGetHForW(int width) { if (innerElemEditor == null) return 0; return innerElemEditor.layoutGetHForW(width); }
@Override public int layoutGetWForH(int height) { if (innerElemEditor == null) return 0; return innerElemEditor.layoutGetWForH(height); }
@Override protected void layoutRunImpl() { if (innerElemEditor != null) innerElemEditor.setForcedBounds(this, new Rect(getSize())); }
default void pushPathTree(SchemaPath nextObject) { LinkedList<SchemaPath> rv = new LinkedList<>(); while (nextObject != null) { if (nextObject.editor != null) rv.addFirst(nextObject); nextObject = nextObject.parent; } for (SchemaPath sp : rv) pushObject(sp); }
default <T> EmbedDataSlot<T> embedSlot(IRIO target, EmbedDataKey<T> prop, T def) { return embedSlot(getCurrentObject(), target, prop, def); }
default IEmbedDataContext embedContext(IRIO target) { return embedContext(getCurrentObject(), target); }
@Override public <T> EmbedDataSlot<T> embedSlot(EmbedDataKey<T> prop, T def) { return ISchemaHost.this.embedSlot(locale, target, prop, def); }
private String stripExt(String s) { int idx = s.lastIndexOf('.'); if (idx != -1) return s.substring(0, idx); return s; }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { }
public StuffRenderer baseInitializeHelper(IRIO target) { return app.system.rendererFromTso(target); }
public StuffRenderer baseTileDraw( IRIO target, int t, int x, int y, IGrDriver igd, StuffRenderer osr) { int ts = osr.tileRenderer.tileSize * app.f.getSpriteScale(); Size sz = getGridSize(osr); int xx = (sz.width - ts) / 2; int xy = (sz.height - ts) / 2; osr.tileRenderer.drawTile(0, (short) t, x + xx, y + xy, igd, app.f.getSpriteScale()); return osr; }
@Override public Integer apply(IRIO rubyIO) { return 192; }
@Override public String apply(IRIO rubyIO) { return "Animations/"; }
@Override public IRIO get() { return anim.getFrame(); }
@Override public Boolean get() { if (app.stuffRendererIndependent.imageLoader.getImage( "Battle2/" + target.getIVar("@animation_name").decString(), false) == GaBIEn.getErrorImage()) return false; return target.getIVar("@battle2_2k3").getType() == 'T'; }
@Override public Integer apply(IRIO rubyIO) { if (actuallyBattle2.get()) return 128; return 96; }
@Override public String apply(IRIO rubyIO) { if (actuallyBattle2.get()) return "Battle2/"; return "Battle/"; }
private void launchFrame( ISchemaHost launcher, SchemaPath path, IGenposFrame gpf, TempDialogSchemaChoice boot) { final GenposFramePanelController rmarp = new GenposFramePanelController(gpf, null, launcher); rmarp.frameChanged(); safetyWrap( rmarp.rootLayout, launcher, () -> { if (!gpf.isStillValid()) return false; rmarp.frameChanged(); return true; }, boot, path); }
private void safetyWrap( UIElement rmarp, ISchemaHost shi, Supplier<Boolean> update, TempDialogSchemaChoice sc, final SchemaPath path) { sc.heldDialog = rmarp; sc.update = update; shi.pushObject(path); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { }
@Override protected void drawTile(int t, boolean hover, int x, int y, IGrDriver igd) { int tX = t % targ.width; int tY = t / targ.width; if (!targ.coordAccessible(tX, tY)) return; tileHelper = baseTileDraw(target, t, x, y, igd, tileHelper); if (allowTextdraw) { igd.clearRect(0, 0, 0, x, y, tileSizeW, app.f.gridTH); for (int i = 0; i < targ.planeCount; i++) GaBIEn.engineFonts.drawString( igd, x, y + (i * app.f.gridTH), Integer.toHexString(targ.getTiletype(t % targ.width, t / targ.width, i) & 0xFFFF), false, false, app.f.gridTH); } }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { gridScrollSlot.value = uivScrollbar.scrollPoint; gridSelectionSlot.value = getSelected(); super.update(deltaTime, selected, peripherals); }
@Override public void run() { int sel = uig.getSelected(); int oldSel = selectionOnLastCall; selectionOnLastCall = sel; int tX = sel % targ.width; int tY = sel / targ.width; for (int i = 0; i < planeValues.length; i++) planeValues[i] = targ.getTiletype(tX, tY, i); editorOnSelChange.run(); if (oldSel == sel) { int p = targ.getTiletype(tX, tY, 0); int p2 = baseFlipBits(p); if (p != p2) { targ.setTiletype(tX, tY, 0, p2); path.changeOccurred(false); } } }
public TileHelper baseTileDraw(IRIO target, int t, int x, int y, IGrDriver igd, TileHelper th) { return null; }
public TileHelper baseInitializeHelper(IRIO target) { return null; }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { MemoryishRW rct = target.editUser(); UIElement[] uiSVLContents = { addField(T.s.toneR, 0, rct, path), addField(T.s.toneG, 8, rct, path), addField(T.s.toneB, 16, rct, path), addField(T.s.toneAL, 24, rct, path) }; return AggregateSchemaElement.createScrollSavingSVL( launcher, scrollPointKey, target, uiSVLContents); }
private UIElement addField(String r, final int i, final MemoryishRW targ, final SchemaPath sp) { final UINumberBox uinb = new UINumberBox((long) targ.getF64LE(i), app.f.schemaFieldTH); uinb.onEdit = () -> { if (cls.equals("Tone")) { if (uinb.getNumber() < -255) uinb.setNumber(-255); } else { if (uinb.getNumber() < 0) uinb.setNumber(0); } if (uinb.getNumber() > 255) uinb.setNumber(255); ; targ.setF64LE(i, uinb.getNumber()); sp.changeOccurred(false); }; return new UISplitterLayout(new UILabel(r, app.f.schemaFieldTH), uinb, false, 1, 3); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { if (checkType(target, 'u', cls, setDefault)) { ByteArrayMemoryish bam = new ByteArrayMemoryish(new byte[32]); bam.setF64LE(0, 0); bam.setF64LE(8, 0); bam.setF64LE(16, 0); bam.setF64LE(24, 255); target.setUser(cls, bam.data); path.changeOccurred(true); } }
@Override public void run() { try { target.setFX(hashString(utb.getText().getBytes("UTF-8"))); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } path.changeOccurred(false); }
public static void tryInitOSSHESEDB(App app) { InputStream inp = null; try { inp = GaBIEn.getInFile(app.gameRoot.into("locmaps.txt")); if (inp == null) return; HashMap<Integer, String> bigMap = new HashMap<Integer, String>(); while (true) { int start = inp.read(); if (start == ';') break; if (start == -1) break; if (start <= 32) continue; byte[] data = IMIUtils.readIMIStringBody(inp); String dataStr = new String(data, "UTF-8"); bigMap.put(hashString(data), dataStr); } inp.close(); app.osSHESEDB = bigMap; } catch (Exception e) { e.printStackTrace(); try { if (inp != null) inp.close(); } catch (Exception e2) { } } }
private static int hashString(byte[] dataStr) { int v = 0xFFFFFFFF; for (byte b : dataStr) { int zc = (b & 0xFF) ^ (v & 0xFF); for (int bit = 0; bit < 8; bit++) zc = ((zc >> 1) & 0x7FFFFFFF) ^ (0xedb88320 * (zc & 1)); v = ((v >> 8) & 0xFFFFFF) ^ zc; } return ~v; }
public static String decode(App app, RORIO v) { if (app.osSHESEDB == null) tryInitOSSHESEDB(app); int type = v.getType(); if (type == 'i') return mainDecode(app, (int) v.getFX()); if (type == 'l') { int p = 0; byte[] buf = v.getBufferCopy(); for (int i = buf.length - 1; i > 0; i--) { p <<= 8; p |= buf[i] & 0xFF; } return mainDecode(app, p); } return v.toString(); }
private static String mainDecode(App app, int fixnumVal) { final TrRoot T = app.t; if (app.osSHESEDB == null) return T.s.oslocErrNoDB; String r = app.osSHESEDB.get(fixnumVal); if (r == null) return T.s.oslocErrStrUnknown; return r; }
public static byte[] readStream(InputStream dis) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] block = new byte[512]; while (true) { int r = dis.read(block); if (r <= 0) break; baos.write(block, 0, r); } return baos.toByteArray(); }
public static void copyStream(InputStream dis, OutputStream os) throws IOException { byte[] block = new byte[512]; while (true) { int r = dis.read(block); if (r <= 0) break; os.write(block, 0, r); } }
private String readContentString(IRIO target) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); copyStream(getDecompressionInputStream(target.getBufferCopy()), baos); return new String(baos.toByteArray(), app.encoding); }
private void writeContentString(IRIO target, String text) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); copyStream( getCompressionInputStream(new ByteArrayInputStream(text.getBytes(app.encoding))), baos); target.putBuffer(baos.toByteArray()); }
protected byte[] createDefaultByteArray() { return new byte[0]; }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { if (SchemaElement.checkType(target, '\"', null, setDefault)) { target.putBuffer(createDefaultByteArray()); path.changeOccurred(true); } }
public IRIO extractTarget(IRIO target) { return iVar == null ? target : iVar.getRW(target); }
@Override public UIElement buildHoldingEditorImpl( final IRIO target, final ISchemaHost launcher, final SchemaPath path) { final UITextButton importer = new UITextButton( text.r(target), app.f.schemaFieldTH, () -> { try { executeFn.clDirect(target, launcher, path); } catch (Exception ioe) { app.ui.launchDialog(ioe); } }); AggregateSchemaElement.hookButtonForPressPreserve(launcher, target, importer, buttonEDKey); return importer; }
@Override public UIElement buildHoldingEditorImpl( final IRIO target, final ISchemaHost launcher, final SchemaPath path) { final UITileGrid r = new UITileGrid( app, launcher.getContextRenderer(), layer, displayMap.mapping, app.f.getSpriteScale()); if (charName.getRO(target).decString().length() == 0) r.setSelected((int) charIdx.getRO(target).getFX()); r.onSelectionChange = () -> { charName.getRW(target).setString(""); charIdx.getRW(target).setFX(r.getSelected()); path.changeOccurred(false); launcher.popObject(true); }; return r; }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { }
@Override public void run() { tabSlot.value = tabPane.getTabIndex(); tabCopySlot.value = tileGrid; int base = tileGrid.getSelected(); int stride = tileGrid.getSelectStride(); for (int selY = 0; selY < tileGrid.selHeight; selY++) { for (int selX = 0; selX < tileGrid.selWidth; selX++) { int originalTileGridIndex = base + (stride * selY) + selX; if ((originalTileGridIndex < 0) || (originalTileGridIndex >= tab.actTiles.length)) continue; int originalTile = tab.actTiles[originalTileGridIndex]; writeData(originalTile); if (tab.atProcessing) for (AutoTileTypeField attf : atFields) if (attf.contains(originalTile)) for (int st = 0; st < attf.length; st++) writeData(attf.start + st); } } path.changeOccurred(false); }
public void writeData(int tile) { if ((tile < 0) || (tile >= targ.width)) return; for (int p = 0; p < targ.planeCount; p++) targ.setTiletype(tile, 0, p, (short) values[p]); }
@Override public String toString() { return tileGrid.toString(); }
public final void pleasePopObject() { if (pleasePopObject != null) pleasePopObject.run(); }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { pleasePopObject = () -> { launcher.popObject(true); }; if (update != null) if (!update.get()) return objectHasBecomeInvalidScreen(path); return heldDialog; }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { if (hPar.editor != null) hPar.editor.modifyVal(hPar.targetElement, hPar, setDefault); if (update != null) update.get(); }
@Override public UIElement buildHoldingEditorImpl( final IRIO target, final ISchemaHost launcher, final SchemaPath path) { final ISpritesheetProvider localProvider = provider.apply(target); final IRIO actTarg = numberProvider.apply(target); return new UITextButton( text.apply(actTarg), app.f.schemaFieldTH, () -> { TempDialogSchemaChoice temp = new TempDialogSchemaChoice(app, null, path); final SchemaPath innerPath = path.newWindow(temp, target); temp.heldDialog = new UISpritesheetChoice( app, actTarg.getFX(), localProvider, (integer) -> { actTarg.setFX(integer); innerPath.changeOccurred(false); temp.pleasePopObject(); }); launcher.pushObject(innerPath); }); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { IRIO actTarg = numberProvider.apply(target); if (checkType(actTarg, 'i', null, setDefault)) { actTarg.setFX(defaultVal); path.changeOccurred(true); } }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { return interior.buildHoldingEditor(new CellMask(target), launcher, path); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { interior.modifyVal(new CellMask(target), path, setDefault); }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { interior.visit(new CellMask(target), path, v, detailedPaths); }
private void mapIdMagic(IRIO target, SchemaPath root) { String str = app.odb.getIdByObject(root.root); if (str == null) return; if (str.startsWith("Map")) if (str.endsWith(".lmu")) { try { target.setFX(Integer.parseInt(str.substring(3, str.length() - 4))); } catch (Exception e) { } } if (str.startsWith("Save")) if (str.endsWith(".lsd")) target.setDeepClone(root.targetElement.getIVar("@party_pos").getIVar("@map")); }
private void saveFileSetup(IRIO target) { setupSaveCharacter(target.getIVar("@party_pos"), "@player_map", "@player_x", "@player_y"); setupSaveCharacter(target.getIVar("@boat_pos"), "@boat_map", "@boat_x", "@boat_y"); setupSaveCharacter(target.getIVar("@ship_pos"), "@ship_map", "@ship_x", "@ship_y"); setupSaveCharacter(target.getIVar("@airship_pos"), "@airship_map", "@airship_x", "@airship_y"); IRIO savSys = target.getIVar("@system"); IRIO ldb = app.odb.getObject("RPG_RT.ldb").getObject(); IRIO ldbSys = ldb.getIVar("@system"); target.getIVar("@party").getIVar("@party").setDeepClone(ldbSys.getIVar("@party")); savSys.getIVar("@font_id").setDeepClone(ldbSys.getIVar("@font_id")); initializeArrayWithClones(savSys.getIVar("@switches"), ldb.getIVar("@switches"), DMKey.FALSE); initializeArrayWithClones(savSys.getIVar("@variables"), ldb.getIVar("@variables"), DMKey.of(0)); for (String iv : savSys.getIVars()) if (iv.endsWith("_se") || iv.endsWith("_music") || iv.endsWith("_fadein") || iv.endsWith("_fadeout")) savSys.getIVar(iv).setDeepClone(ldbSys.getIVar(iv)); initTable(target.getIVar("@map_info").getIVar("@lower_tile_remap")); initTable(target.getIVar("@map_info").getIVar("@upper_tile_remap")); }
private void initTable(IRIO instVarBySymbol) { RubyTable rt = new RubyTable(instVarBySymbol.editUser()); for (int i = 0; i < 0x90; i++) rt.setTiletype(i, 0, 0, (short) i); }
private void initializeArrayWithClones(IRIO instVarBySymbol, IRIO length, RORIO rubyIO) { int maxVal = 0; for (DMKey rio : length.getHashKeys()) maxVal = Math.max((int) rio.getFX(), maxVal); for (int i = 0; i < maxVal; i++) instVarBySymbol.addAElem(i).setDeepClone(rubyIO); }
private void setupSaveCharacter(IRIO chr, String s, String s1, String s2) { IRIO lmt = app.odb.getObject("RPG_RT.lmt").getObject().getIVar("@start"); IRIO a = lmt.getIVar(s); IRIO b = lmt.getIVar(s1); IRIO c = lmt.getIVar(s2); if (a != null) chr.getIVar("@map").setDeepClone(a); if (b != null) chr.getIVar("@x").setDeepClone(b); if (c != null) chr.getIVar("@y").setDeepClone(c); }
@Override public void run() { try { IRIO scripts = importScripts(); if (scripts != null) { target.setDeepClone(scripts); path.changeOccurred(true); } } catch (Exception ioe) { app.ui.launchDialog(ioe); } }
private boolean tryWrite(String name, byte[] inflated, HashSet<String> used, PrintStream ps) throws IOException { String oldName = name; int counter = 2; while (used.contains(name.toLowerCase())) name = oldName + " (" + (counter++) + ")"; OutputStream os2 = GaBIEn.getOutFile(app.gameRoot.intoPath("scripts/" + name + ".rb")); if (os2 == null) return false; os2.write(inflated); os2.close(); used.add(name.toLowerCase()); ps.println(name); return true; }
@Override public void run() { StringBuilder results = new StringBuilder(); results.append(T.s.searchResults); results.append("\n"); String searchFor = searchText.getText(); int alen = target.getALen(); for (int i = 0; i < alen; i++) { String name = target.getAElem(i).getAElem(1).decString(); byte[] inflated = null; try { inflated = StringBlobSchemaElement.readStream( new InflaterInputStream( new ByteArrayInputStream(target.getAElem(i).getAElem(2).getBufferCopy()))); } catch (IOException e) { e.printStackTrace(); } if (inflated == null) continue; String res = new String(inflated, StandardCharsets.UTF_8); if (res.contains(searchFor)) { results.append(i); results.append(": "); results.append(name); results.append("\n"); } } app.ui.launchDialog(results.toString()); }
private byte[] loadScript(String s) throws IOException { InputStream inp = GaBIEn.getInFile(app.gameResources.intoPath("scripts/" + s + ".rb").parentMkdirs()); if (inp == null) return null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); DeflaterOutputStream def = new DeflaterOutputStream(baos); StringBlobSchemaElement.copyStream(inp, def); def.close(); return baos.toByteArray(); }
@Override public StuffRenderer baseInitializeHelper(IRIO target) { return app.system.rendererFromTso(target); }
@Override public StuffRenderer baseTileDraw( IRIO target, int t, int x, int y, IGrDriver igd, StuffRenderer osr) { if (allocSource.mapping != null) if (t > allocSource.mapping.length) return osr; final IRIO targV = iVar == null ? target : iVar.getRW(target); final RubyTableR targ = new RubyTableR(targV.getBuffer()); int sprScale = app.f.getSpriteScale(); int ts = osr.tileRenderer.tileSize * sprScale; Size sz = getGridSize(osr); int xx = (sz.width - ts) / 2; int xy = (sz.height - ts) / 2; int mapped = allocSource.mapping != null ? allocSource.mapping[t] : t; osr.tileRenderer.drawTile(0, (short) mapped, x + xx, y + xy, igd, sprScale); allocSource.draw(x, y, t, targ.getTiletype(t % targ.width, t / targ.width, 0), sprScale, igd); return osr; }
@Override public int baseFlipBits(int p) { int i = p & 0xFFFF; i ^= allocSource.xorDoubleclick; return i; }
@Override protected byte[] createDefaultByteArray() { try { DeflaterInputStream dis = new DeflaterInputStream(new ByteArrayInputStream(new byte[0])); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] block = new byte[512]; while (true) { int r = dis.read(block); if (r <= 0) break; baos.write(block, 0, r); } dis.close(); return baos.toByteArray(); } catch (IOException ie) { ie.printStackTrace(); return new byte[0]; } }
@Override public int shouldDrawAt( MapViewDrawContext.MouseStatus mouse, int tx, int ty, int there, int layer, int currentLayer) { return there; }
@Override public void performGlobalOverlay(MapViewDrawContext mvdc, boolean minimap) { mvdc.drawIndicator((int) x, (int) y, MapViewDrawContext.IndicatorStyle.Target); }
@Override public void confirmAt(int x, int y, int pixx, int pixy, int layer, boolean first) { if (!first) return; abc[1].setFX(x); abc[2].setFX(y); path.changeOccurred(false); }
@Override public @NonNull String viewState(int mouseXT, int mouseYT) { return "MPH," + x + "," + y + "," + mouseXT + "," + mouseYT; }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { }
@Override public void updateContents(double deltaTime, boolean selected, IPeripherals peripherals) { super.updateContents(deltaTime, selected, peripherals); int l1 = textRules.countCells(utb.getText()); setText(Integer.toString(getLen() - l1)); }
@Override public boolean requestsUnparenting() { return didAnything; }
private void editSimple(Function<String, String> editDetail) { didAnything = true; String[] res = getter.get(); for (int i = 0; i < res.length; i++) res[i] = editDetail.apply(res[i]); editor.accept(res); }
private void alignLeft() { didAnything = true; editSimple((s) -> s.trim()); }
private void alignCentre() { didAnything = true; editSimple( (s) -> { s = s.trim(); int startWidth = textRules.countCells(s); int expectWidth = ((fieldWidth - startWidth) / 2) + startWidth; for (int i = 0; i < fieldWidth; i++) { if (textRules.countCells(s) >= expectWidth) break; s = " " + s; } return s; }); }
private void alignRight() { didAnything = true; editSimple( (s) -> { s = s.trim(); for (int i = 0; i < fieldWidth; i++) { if (textRules.countCells(s) >= fieldWidth) break; s = " " + s; } return s; }); }
private boolean isRange(int i, int i1, int c) { return (c >= i) && (c <= i1); }
public int countCellsRaw(String s) { int i = 0; int p = 0; while (i < s.length()) { int codepoint = s.codePointAt(i); i += Character.charCount(codepoint); p += isWide(codepoint) ? 2 : 1; } return p; }
@Override public void run() { planes[index] = (int) box.getNumber(); changeOccurred.run(); }
@Override public void run() { for (int i = 0; i < planes.length; i++) numbers[i].setNumber(planes[i]); }
@Override public Runnable createEditor( final LinkedList<UIElement> base, final int[] planes, final Runnable changeOccurred) { final Consumer<Integer> editor1 = installEditor( app, flags, (element) -> { base.add(element); }, new AtomicReference<Consumer<Integer>>( (t) -> { planes[0] = t; changeOccurred.run(); })); editor1.accept(planes[0]); base.add(new UILabel(T.s.manualEdit, app.f.tableElementTH)); final Runnable editor2 = new DefaultTableCellEditor(app).createEditor(base, planes, changeOccurred); return () -> { editor1.accept(planes[0]); editor2.run(); }; }
@Override public void update(long n) { n = finalIse.filter(n); int r = currentState.get(); r &= ~(thisBit * (pwr - 1)); r |= thisBit * (n & (pwr - 1)); currentState.set(r); set.get().accept(r); }
@Override public UIScrollLayout newSVL() { return new UIScrollLayout(true, app.f.generalS); }
@Override public void run() { int v = currentState.get() ^ thisBit; currentState.set(v); set.get().accept(v); }
@Override public boolean monitorsSubelements() { return true; }
@Override public String apply(IRIO rubyIO) { return "This text should not be visible. Grouping is used for all commands."; }
@Override protected ElementContextual getElementContextualSchema( IRIO arr, final int start, final int length, final HashMap<Integer, Integer> indentAnchors) { final IRIO tracker = arr.getAElem(start); int indent = 0; final IRIO trackerIndent = tracker.getIVar("@indent"); if (trackerIndent != null) indent = (int) trackerIndent.getFX(); RPGCommand cmd = database.entryOf(tracker); boolean anchor = false; boolean shouldShowAnchor = false; if (cmd != null) { IRIO param = tracker.getIVar("@parameters"); anchor = cmd.isAnchor(param); shouldShowAnchor = cmd.isAnchorVis(param); } String st = ""; if (shouldShowAnchor) { if (anchor) { st = "@" + start + " "; indentAnchors.put(indent, start); } else { Integer lai = indentAnchors.get(indent); if (lai != null) st = "@" + lai + " "; } } return new ElementContextual(indent, getElementContextualSubwindowSchema(tracker, start, st)); }
@Override public String apply(IRIO rubyIO) { return displayPrefix + database.buildGroupCodename(rubyIO, start, false); }
public static int findActualStart(IRIO target, IRIO tracker) { if (target.getType() != '[') return -1; int alen = target.getALen(); for (int i = 0; i < alen; i++) if (target.getAElem(i) == tracker) return i; return -1; }
@Override public boolean declaresSelfEditorOf(RORIO target, RORIO check) { return check == tracker; }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { int actualStart = findActualStart(target, tracker); if (actualStart == -1) return new UILabel(T.s.cmdOutOfList, app.f.schemaFieldTH); return getGroupElement(target, actualStart, ecwsKey).buildHoldingEditor(target, launcher, path); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { int actualStart = findActualStart(target, tracker); if (actualStart == -1) return; getGroupElement(target, actualStart, ecwsKey).modifyVal(target, path, setDefault); }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { int actualStart = findActualStart(target, tracker); if (actualStart == -1) return; getGroupElement(target, actualStart, ecwsKey).visit(target, path, v, detailedPaths); }
@Override public void accept(int[] i) { for (int j = 0; j < i.length; j++) { IRIO ne = target.addAElem(idx + j + 1); SchemaPath.setDefaultValue(ne, baseElement, null); ne.getIVar("@code").setFX(i[j]); } sp.changeOccurred(false); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { path = path.tagSEMonitor(target, this, false); actualSchema.modifyVal(target, path, setDefault); RPGCommand rc = getRPGCommand(target); if (rc != null) { if (rc.specialSchema != null) { rc.specialSchema.modifyVal(target, path, setDefault); } else { IRIO param = target.getIVar("@parameters"); SchemaElement parametersSanitySchema = new StandardArraySchemaElement( app, new OpaqueSchemaElement(app), rc.params.size(), false, 0, new StandardArrayInterface()); parametersSanitySchema.modifyVal(param, path, setDefault); int alen = param.getALen(); for (int i = 0; i < alen; i++) { SchemaElement ise = rc.getParameterSchema(param, i); ise.modifyVal( param.getAElem(i), path.arrayHashIndex(DMKey.of(i), "[" + i + "]"), setDefault); } } } }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { path = path.tagSEMonitor(target, this, false); actualSchema.visit(target, path, v, detailedPaths); RPGCommand rc = getRPGCommand(target); if (rc != null) { if (rc.specialSchema != null) { rc.specialSchema.visit(target, path, v, detailedPaths); } else { IRIO param = target.getIVar("@parameters"); SchemaElement parametersSanitySchema = new StandardArraySchemaElement( app, new OpaqueSchemaElement(app), rc.params.size(), false, 0, new StandardArrayInterface()); parametersSanitySchema.visit(param, path, v, detailedPaths); int alen = param.getALen(); for (int i = 0; i < alen; i++) { SchemaElement ise = rc.getParameterSchema(param, i); ise.visit( param.getAElem(i), path.arrayHashIndex(DMKey.of(i), "[" + i + "]"), v, detailedPaths); } } } }
public RPGCommandSchemaElement hideHeaderVer() { if (hiddenHeadVer != null) return hiddenHeadVer; RPGCommandSchemaElement rcse = new RPGCommandSchemaElement( app, actualSchema, mostOfSchema, database, allowControlOfIndent, false); hiddenHeadVer = rcse; return rcse; }
public void frameChanged() { cellSelection.frameChanged(); editingPanel.somethingChanged(); }
public void frameChanged() { if (cellNumber >= root.getCellCount()) cellNumber = -1; if (cellNumber < -1) cellNumber = -1; cellChangeNotificationNumber++; rebuildSelectionPanel(); }
@Override public KeyTrack propertyKeytrack(int prop) { String k = prop + "@" + framePanelController.cellSelection.cellNumber; KeyTrack kt = propTracks.get(k); if (kt != null) return kt; kt = tweening.getTrack(framePanelController.cellSelection.cellNumber, prop); propTracks.put(k, kt); return kt; }
@Override public boolean propertyKeyed(int prop, KeyTrack track) { return track.track[target.getFrameIdx()]; }
@Override public void disablePropertyKey(int prop, KeyTrack track) { tweening.disablePropertyKey( target.getFrameIdx(), framePanelController.cellSelection.cellNumber, prop, track); }
@Override public String toString() { return T.s.animEdit; }
public void frameChanged() { target.setFrameIdx(target.getFrameIdx()); framePanelController.frameChanged(); }
public void incomingModification() { propTracks.clear(); frameChanged(); }
private double[] tween(double[] inputs, boolean[] results, boolean shouldFloor) { double[] ip = new double[inputs.length]; int encountered = -1; for (int i = 0; i < inputs.length; i++) { if (results[i]) { ip[i] = inputs[i]; if (encountered == -1) { for (int j = 0; j < i; j++) ip[j] = inputs[i]; } else { interpolate(ip, encountered, i, shouldFloor); } encountered = i; } } if (encountered != -1) for (int i = encountered + 1; i < inputs.length; i++) ip[i] = inputs[encountered]; return ip; }
private void interpolate(double[] inputs, int a, int b, boolean shouldFloor) { double vA = inputs[a]; double vB = inputs[b]; double vS = (vB - vA) / (b - a); for (int i = a + 1; i < b; i++) { int sf = i - a; inputs[i] = vA + (vS * sf); if (shouldFloor) inputs[i] = Math.floor(inputs[i]); } }
@Override public void handleClick(int x, int y, int button) { dragging = button; lastMX = x; lastMY = y; lossX = 0; lossY = 0; }
@Override public Integer apply(Integer integer) { int r = offset(integer, ofsX); int ao = r - integer; lossX = ofsX - ao; return r; }
@Override public Integer apply(Integer integer) { int r = offset(integer, ofsY); int ao = r - integer; lossY = ofsY - ao; return r; }
@Override public IPointerReceiver handleNewPointer(IPointer state) { return mouseEmulator; }
private int offset(int integer, int ofs) { integer += ofs; if (basePanelAccess.gridToggleButton.state) integer &= ~7; return integer; }
private void recreateHalfSplits() { for (UIElement uie : layoutGetElements()) layoutRemoveElement(uie); String[] properties = root.frame.getCellProps(); for (int i = 0; i < halfsplits.length; i++) { UIElement ed = createPropertyEditor(i); UIElement leftSide = new UILabel(properties[i], app.f.schemaFieldTH); halfsplits[i] = new UISplitterLayout(leftSide, ed, false, 1); layoutAddElement(halfsplits[i]); } }
public void somethingChanged() { recreateHalfSplits(); layoutRecalculateMetrics(); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { int n = cellSelectionPanel.cellChangeNotificationNumber; if (lastCCN != n) { lastCCN = n; somethingChanged(); } super.update(deltaTime, selected, peripherals); }
@Override public int layoutGetHForW(int width) { int h = 0; for (int i = 0; i < halfsplits.length; i++) h += halfsplits[i].layoutGetHForW(width); return h; }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { int w = 0; int h = 0; for (int i = 0; i < halfsplits.length; i++) { Size ws = halfsplits[i].getWantedSize(); w = Math.max(w, ws.width); h += ws.height; } return new Size(w, h); }
@Override protected void layoutRunImpl() { int h = 0; Size r = getSize(); for (int i = 0; i < halfsplits.length; i++) { Size ws = halfsplits[i].getWantedSize(); halfsplits[i].setForcedBounds(this, new Rect(0, h, r.width, ws.height)); h += ws.height; } }
@Override public boolean isStillValid() { return troop.getType() == 'o'; }
private IImage readEnemy(IRIO value, IImageLoader img) { if (SchemaElement.checkType(value, 'o', "RPG::Enemy", false)) return null; IImage im = img.getImage("Battlers/" + value.getIVar("@battler_name").decString(), false); return app.ui.imageFXCache.process( im, new HueShiftImageEffect((int) value.getIVar("@battler_hue").getFX())); }
public void prepareFramesetCache() { spriteSize = spsDeterminant.apply(target); framesetCacheA = GaBIEn.getErrorImage(); if (framesetALoc != null) { String nameA = target.getIVar(framesetALoc).decString(); if (nameA.length() != 0) framesetCacheA = app.stuffRendererIndependent.imageLoader.getImage( pfxDeterminant.apply(target) + nameA, false); if (framesetAHue != null) framesetCacheA = app.ui.imageFXCache.process( framesetCacheA, new HueShiftImageEffect((int) target.getIVar(framesetAHue).getFX())); } framesetCacheB = GaBIEn.getErrorImage(); if (framesetBLoc != null) { String nameB = target.getIVar(framesetBLoc).decString(); if (nameB.length() != 0) framesetCacheB = app.stuffRendererIndependent.imageLoader.getImage( pfxDeterminant.apply(target) + nameB, false); if (framesetBHue != null) framesetCacheB = app.ui.imageFXCache.process( framesetCacheB, new HueShiftImageEffect((int) target.getIVar(framesetBHue).getFX())); } }
@Override public boolean canAddRemoveCells() { return true; }
@Override public void addCell(int i2) { IRIO rio = troop.getIVar("@members").addAElem(i2 + 1); SchemaPath.setDefaultValue(rio, app.sdb.getSDBEntry("RPG::Troop::Member"), DMKey.of(i2 + 1)); changed.run(); }
@Override public void deleteCell(int i2) { troop.getIVar("@members").rmAElem(i2 + 1); changed.run(); }
@Override public void moveCell(int ct, Function<Integer, Integer> x, Function<Integer, Integer> y) { SchemaPath memberPath = troopPath.otherIndex("@members").arrayHashIndex(DMKey.of(ct + 1), "[" + (ct + 1) + "]"); IRIO member = troop.getIVar("@members").getAElem(ct + 1); member.getIVar("@x").setFX(x.apply((int) member.getIVar("@x").getFX())); member.getIVar("@y").setFX(y.apply((int) member.getIVar("@y").getFX())); memberPath.changeOccurred(false); }
@Override public void drawCell(int i, int opx, int opy, IGrDriver igd) { int enemy = (int) getCellProp(i, 0).targetElement.getFX(); opx += getCellProp(i, 1).targetElement.getFX(); opy += getCellProp(i, 2).targetElement.getFX(); if (enemy < 0) return; if (enemy >= enemies.length) return; IImage enemyImg = enemies[enemy]; if (enemyImg != null) igd.blitImage(opx - (enemyImg.getWidth() / 2), opy - (enemyImg.getHeight() / 2), enemyImg); }
@Override public boolean isStillValid() { return target.getType() == '['; }
@Override public void insertFrame(RORIO source) { target.addAElem(frameIdx + 1).setDeepClone(source); updateNotify.run(); frameIdx++; }
@Override public void deleteFrame() { target.rmAElem(frameIdx); updateNotify.run(); frameIdx--; getFrame(); }
@Override public boolean acceptableForPaste(RORIO theClipboard) { return !SchemaElement.checkType(theClipboard, 'o', "RPG::Animation::Frame", false); }
@Override public void modifiedFrames() { updateNotify.run(); }
private IImage readEnemy(IRIO value, IImageLoader img) { IImage im = img.getImage("Monster/" + value.getIVar("@battler_name").decString(), false); return app.ui.imageFXCache.process( im, new HueShiftImageEffect((int) value.getIVar("@battler_hue").getFX())); }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { RORIO nameObj = namePath.getRO(target); RORIO tempoObj = tempoPath == null ? null : tempoPath.getRO(target); double tempo = 1; if (tempoObj != null) tempo = tempoObj.getFX() / 100d; return UIAudioPlayer.create(app, prefix + nameObj.decString(), tempo); }
@Override public void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { }
@Override public void accept(Long aLong) { uie.baseImage = TonePickerSchemaElement.compositeTotem(app, totem, new HueShiftImageEffect((int) oldVal)); ai2.onValueChange.accept(aLong); }
@Override public long filter(long i) { return i % 360; }
@Override public void accept(String integer) { launcher.getApp().ui.startHelp(file, integer); }
@Override public @Nullable String windowTitleSuffix(SchemaPath path) { return suffixRoutine.r(path.targetElement, path.lastArrayIndex); }
@Override public UIElement buildHoldingEditorImpl( final IRIO target, final ISchemaHost launcher, SchemaPath path) { StuffRenderer r = launcher.getContextRenderer(); return buildEditorFromObject(app, r, target); }
@Override public void renderLayer(IGrDriver igd, UILayer layer) { if (layer != UILayer.Content) return; Size bounds = getSize(); igd.clearRect(255, 0, 255, 0, 0, bounds.width, bounds.height); int ofs = r.tileRenderer.tileSize / 2; r.eventRenderer.drawEventGraphic( target, (bounds.width / 2) - (ofs * sprScale), (bounds.height / 2) - (ofs * sprScale), igd, sprScale, null); }
@Override public void modifyVal(IRIO target, SchemaPath index, boolean setDefault) {}
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { return new UILabel(text.r(), app.f.helpTH); }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { int nr = (int) rP.getRO(target).getFX(); int ng = (int) gP.getRO(target).getFX(); int nb = (int) bP.getRO(target).getFX(); int ns = (int) sP.getRO(target).getFX(); return createTotem(target, new ToneImageEffect(nr, ng, nb, ns, base)); }
public static IImage compositeTotem(App app, IImage totem, IImageEffect cfg) { int imageUnit = (app.f.tonePickerTH * 64) / 6; if (imageUnit < 1) imageUnit = 1; IGrDriver finalComposite = GaBIEn.makeOffscreenBuffer(imageUnit * 2, imageUnit); finalComposite.blitScaledImage(0, 0, 256, 256, 0, 0, imageUnit, imageUnit, totem); finalComposite.blitImage( 0, 0, imageUnit, imageUnit, imageUnit, 0, app.ui.imageFXCache.process(finalComposite, cfg)); final TrRoot T = app.t; GaBIEn.engineFonts.drawString( finalComposite, 0, (imageUnit + 1) - app.f.tonePickerTH, T.s.totemSrc, false, false, app.f.tonePickerTH); GaBIEn.engineFonts.drawString( finalComposite, imageUnit, (imageUnit + 1) - app.f.tonePickerTH, T.s.totemCmp, false, false, app.f.tonePickerTH); return finalComposite.convertToImmutable(null); }
public static UIPublicPanel createTotemStandard(App app, IImage totem, IImageEffect cfg) { IImage img = compositeTotem(app, totem, cfg); UIPublicPanel panel = new UIPublicPanel(img.getWidth(), img.getHeight()); panel.baseImage = img; return panel; }
public UIElement createTotem(IRIO target, IImageEffect cfg) { return createTotemStandard(app, getOneTrueTotem(), cfg); }
@Override public UIElement createTotem(IRIO target, IImageEffect cfg) { String imagePath = iPrefix + iPath.getRO(target).decString(); IImage totem = app.stuffRendererIndependent.imageLoader.getImage(imagePath, false); IImage img = compositeTotem(app, totem, cfg); UIThumbnail panel = new UIThumbnail(img); return panel; }
@Override protected void drawTile(int t, boolean hover, int x, int y, IGrDriver igd) { super.drawTile(t, hover, x, y, igd); y += app.f.gridTH + 1; igd.blitScaledImage( t * tileSize, 0, tileSize, tileSize, x, y, tileSize * sprScale, tileSize * sprScale, tsdb); }
@Override public Size layoutRecalculateMetricsImpl() { Size res = super.layoutRecalculateMetricsImpl(); if (uivScrollbar != null) { return new Size((16 * 16 * sprScale) + uivScrollbar.getWantedSize().width, res.height); } else { return res; } }
@Override public void update(long n) { target.setFX(filter(n)); path.changeOccurred(false); }
@Override public UIScrollLayout newSVL() { return AggregateSchemaElement.createScrollSavingSVL(launcher, scrollPointKey, target); }
public ActiveInteger buildIntegerEditor( long oldVal, final IntegerSchemaElement.IIntegerContext context) { final UINumberBox unb = new UINumberBox(oldVal, app.f.schemaFieldTH); unb.readOnly = isReadOnly(); unb.onEdit = () -> { context.update(unb.getNumber()); }; return new ActiveInteger( unb, (aLong) -> { unb.setNumber(aLong); }); }
@Override public final void modifyVal(IRIO target, SchemaPath path, boolean setDefault) { if (checkType(target, 'i', null, setDefault)) { target.setFX(defaultInt); path.changeOccurred(true); } }
@Override public ActiveInteger buildIntegerEditor(long oldVal, final IIntegerContext context) { LinkedList<UIElement> elms = new LinkedList<>(); final Consumer<Integer> refresh = BitfieldTableCellEditor.installEditor( app, flags, (element) -> { elms.add(element); }, new AtomicReference<Consumer<Integer>>( (integer) -> { context.update((long) (int) integer); })); refresh.accept((int) oldVal); elms.add(new UILabel(T.s.manualEdit, app.f.tableElementTH)); final ActiveInteger ai = super.buildIntegerEditor(oldVal, context); elms.add(ai.uie); final UIScrollLayout uiSVL = context.newSVL(); uiSVL.panelsSet(elms); return new ActiveInteger( uiSVL, (aLong) -> { refresh.accept((int) (long) aLong); ai.onValueChange.accept(aLong); }); }
public @Nullable Namespace namespaceOf(long v) { for (Namespace n : namespaces) if (n.contains(v)) return n; throw new RuntimeException("It sure is important that you have an Unknown namespace, huh!"); }
@Override public UIElement buildHoldingEditorImpl(IRIO target, ISchemaHost launcher, SchemaPath path) { Namespace ns = namespaceOf(target.getFX()); LinkedList<UIPopupMenu.Entry> mapped = new LinkedList<>(); for (final Namespace ns2 : namespaces) { mapped.add( new UIPopupMenu.Entry( ns2.name.r(), () -> { ns2.editor.modifyVal(new NamespacingMask(target, ns2.base), path, true); path.changeOccurred(false); })); } UIElement nsPanel = new UIMenuButton(app, ns.name.r(), app.f.schemaFieldTH, launcher.getValidity(), mapped); UIElement valuePanel = ns.editor.buildHoldingEditor(new NamespacingMask(target, ns.base), launcher, path); if (ns.explain != null) { UIElement explainPanel = new UILabel(ns.explain.r(), app.f.schemaFieldTH); return new UISplitterLayout( new UISplitterLayout(nsPanel, valuePanel, false, 0), explainPanel, true, 0); } else { return new UISplitterLayout(nsPanel, valuePanel, false, 0); } }
@Override public void visitChildren(IRIO target, SchemaPath path, Visitor v, boolean detailedPaths) { Namespace ns = namespaceOf(target.getFX()); ns.editor.visit(new NamespacingMask(target, ns.base), path, v, detailedPaths); }
public boolean contains(long v) { return v >= firstValue && v <= lastValue; }
@Override public boolean isReadOnly() { return true; }
@Override public long filter(long i) { if (i < lowerBound) i = lowerBound; return i; }
public void draw(IGrDriver igd, double deltaTime, int sw, int sh) { int stage = ((int) (moveTime / 8)) % 6; int type = 0; int mul = 1; int switchMul = 64; int darkMul = 4; int lightMul = 2; switch (stage) { case 0: type = 0; mul = lightMul; break; case 1: type = 1; mul = switchMul; break; case 2: type = 2; mul = darkMul; break; case 3: type = 2; doJump(sw, sh); mul = darkMul; break; case 4: type = 1; mul = switchMul; break; case 5: type = 0; mul = lightMul; break; } moveTime += deltaTime * mul; if (type != 2) { igd.fillRect(0, 0, 0, 255, iconPlanX, iconPlanY, iconSize, iconSize); igd.blitScaledImage(0, 0, 64, 64, iconPlanX, iconPlanY, iconSize, iconSize, app.a.noMap); igd.fillRect(0, 0, 0, type * 127, iconPlanX, iconPlanY, iconSize, iconSize); } }
private void doJump(int w, int h) { iconPlanX = -iconSize; iconPlanY = -iconSize; if (w < iconSize) return; if (h < iconSize) return; iconPlanX = madness.nextInt(w - iconSize); iconPlanY = madness.nextInt(h - iconSize); }
@Override public String toString() { return T.t.map; }
@Override protected void layoutRunImpl() { if (viewToolbarSplit != null) viewToolbarSplit.setForcedBounds(this, new Rect(getSize())); }
@Override protected @Nullable Size layoutRecalculateMetricsImpl() { if (viewToolbarSplit != null) return viewToolbarSplit.getWantedSize(); return super.layoutRecalculateMetricsImpl(); }
@Override public int layoutGetHForW(int width) { if (viewToolbarSplit != null) return viewToolbarSplit.layoutGetHForW(width); return super.layoutGetHForW(width); }
@Override public int layoutGetWForH(int height) { if (viewToolbarSplit != null) return viewToolbarSplit.layoutGetWForH(height); return super.layoutGetWForH(height); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { super.update(deltaTime, selected, peripherals); deltaTimeAccum += deltaTime; }
@Override public void createWindow(UIElement window) { app.ui.wm.createWindow(window); }
@Override public void accept(UIMTBase nextTool) { nextMapTool = nextTool; }
@Override public UIMTAutotile showATField() { if (mapTool instanceof UIMTAutotile) { ((UIMTAutotile) mapTool).refresh(); return (UIMTAutotile) mapTool; } else { return (UIMTAutotile) (nextMapTool = new UIMTAutotile(this)); } }
default int shouldDrawAt( MapViewDrawContext.MouseStatus mouse, int tx, int ty, int there, int layer, int currentLayer) { return there; }
@Override public void noTool() { mapToolContext.accept(new UIMTAreaTool()); }
@Override public boolean allowPickTile() { return false; }
@Override public void performGlobalOverlay(MapViewDrawContext mvdc, boolean minimap) { if (definingPoint2) mvdc.drawIndicator(firstPointX, firstPointY, MapViewDrawContext.IndicatorStyle.Target); if (subFrame() == 0) { Rect r = getViewedRect(); app.a.drawSelectionBox( (r.x * tileSize) - 1, (r.y * tileSize) - 1, (r.width * mvdc.tileSize) + 2, (r.height * mvdc.tileSize) + 2, 1, mvdc.igd); } }
@Override public void confirmAt(int x, int y, int pixx, int pixy, int layer, boolean first) { if (!first) return; if (!definingPoint2) { firstPointX = x; firstPointY = y; definingPoint2 = true; label.setText(textB); } else { IRIO rect = areaInfo.getIVar("@area_rect"); IRIO l = rect.getIVar("@left"); IRIO u = rect.getIVar("@up"); IRIO r = rect.getIVar("@right"); IRIO d = rect.getIVar("@down"); l.setFX(Math.min(firstPointX, x)); u.setFX(Math.min(firstPointY, y)); r.setFX(Math.max(firstPointX, x) + 1); d.setFX(Math.max(firstPointY, y) + 1); App app = mapToolContext.getMapView().app; mapInfosRoot.objectRootModified( new SchemaPath(app.sdb.getSDBEntry("RPG::MapTree"), mapInfosRoot)); label.setText(textA); definingPoint2 = false; } }
@Override public @NonNull String viewState(int mouseXT, int mouseYT) { return "R2kArea." + definingPoint2 + "." + firstPointX + "." + firstPointY + "." + subFrame() + "." + mouseXT + "." + mouseYT; }
public void updateMapId(int m) { if (lastMapId != m) lastTileset = null; lastMapId = m; }
public IRIO receivedChanged(String changed, long currentTsId) { if (lastTsId != currentTsId) lastTileset = null; if (changed == null) { lastTileset = null; } else if (changed.equals(tilesetStorage)) { lastTileset = null; } return lastTileset; }
public void insertTileset(long id, IRIO ts) { if (lastTileset == null) { lastTileset = ts; lastTsId = id; } }
private void performRefresh() { for (String s : listenAdditionals) if (!map.objectId.equals(s)) app.odb.deregisterModificationHandler(s, listener); mapTable = map.rebuild(); listenAdditionals = mapTable.refreshOnObjectChange; for (String s : listenAdditionals) if (!map.objectId.equals(s)) app.odb.registerModificationHandler(s, listener); reinitLayerVis(); scheduler.forceNextUpdate(); }
private void recalcXYT(int x, int y) { Size wSize = getSize(); int xi = (int) Math.floor(camX + planeDivZoom(x - (wSize.width / 2.0d))); int yi = (int) Math.floor(camY + planeDivZoom(y - (wSize.height / 2.0d))); mouseXT = UIElement.sensibleCellDiv(xi, tileSize); mouseXTP = UIElement.sensibleCellMod(xi, tileSize); mouseYT = UIElement.sensibleCellDiv(yi, tileSize); mouseYTP = UIElement.sensibleCellMod(yi, tileSize); }
private int internalScalingReversePad(int i) { int m = (i * planeZoomDiv); return (m / planeZoomMul) + (((m % planeZoomMul) != 0) ? 1 : 0); }
public void reinitLayerVis() { if (layerVis != null) if (layerVis.length == mapTable.layers.length) return; layerVis = new boolean[mapTable.layers.length]; System.arraycopy(mapTable.activeDef, 0, layerVis, 0, mapTable.activeDef.length); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { if (scheduledRefresh) { scheduledRefresh = false; performRefresh(); } shiftDown = false; ctrlDown = false; if (peripherals instanceof IDesktopPeripherals) { recalcXYT( ((IDesktopPeripherals) peripherals).getMouseX(), ((IDesktopPeripherals) peripherals).getMouseY()); shiftDown = ((IDesktopPeripherals) peripherals).isKeyDown(IGrInDriver.VK_SHIFT); ctrlDown = ((IDesktopPeripherals) peripherals).isKeyDown(IGrInDriver.VK_CONTROL); } }
@Override protected String planeGetStatus() { String shortcuts; if (camDragSwitch) { shortcuts = T.m.stCamera; } else if (callbacks == null) { if ((pickTileHelper != null) && (!app.ui.isMobile)) { shortcuts = T.m.stPicker; } else { shortcuts = T.m.stDragToPan; } } else { shortcuts = T.m.stUseTool; } return mapGUM + ";" + mouseXT + ", " + mouseYT + " Z" + planeZoomDiv + ":" + planeZoomMul + "; " + shortcuts; }
@Override protected boolean planeGetDragLock() { return camDragSwitch || ((callbacks == null) && (!shiftDown)); }
@Override protected void planeToggleDragLock() { if (planeGetDragLock()) { camDragSwitch = false; } else { camDragSwitch = true; } }
@Override protected void planeZoomLogic(boolean north) { int zwd = tuningZoomWorkingDiv; if (shiftDown || ctrlDown) zwd = tuningZoomWorkingDivCtrl; planeZoomMul = (planeZoomMul * zwd) / planeZoomDiv; if (planeZoomMul < 1) planeZoomMul = 1; planeZoomDiv = zwd; if (north) { planeZoomMul++; } else { planeZoomMul--; if (planeZoomMul < 1) planeZoomMul = 1; } for (int i = planeZoomDiv; i > 1; i--) { if ((planeZoomMul % i) == 0) { if ((planeZoomDiv % i) == 0) { planeZoomMul /= i; planeZoomDiv /= i; break; } } } }
@Override protected boolean planeCanZoom(boolean north) { return true; }
@Override public IPointerReceiver handleNewPointer(IPointer state) { recalcXYT(state.getX(), state.getY()); return super.handleNewPointer(state); }
@Override public void handlePointerBegin(IPointer state) { visCurrentlyDrawing = true; recalcXYT(state.getX(), state.getY()); if (shiftDown) { if (mapTable.tileAccess.coordAccessible(mouseXT, mouseYT)) if (pickTileHelper != null) pickTileHelper.accept(mapTable.tileAccess.getTiletype(mouseXT, mouseYT, currentLayer)); } else if (callbacks != null) { callbacks.confirmAt(mouseXT, mouseYT, mouseXTP, mouseYTP, currentLayer, true); } }
@Override public void handlePointerUpdate(IPointer state) { recalcXYT(state.getX(), state.getY()); if (!shiftDown) if (callbacks != null) callbacks.confirmAt(mouseXT, mouseYT, mouseXTP, mouseYTP, currentLayer, false); }
@Override public void handlePointerEnd(IPointer state) { visCurrentlyDrawing = false; }
public void passModificationNotification() { map.object.objectRootModified(new SchemaPath(map.objectSchema, map.object)); }
@Override protected void finalize() throws Throwable { super.finalize(); if (offscreenBuf != null) offscreenBuf.shutdown(); }
public void freeOsbResources() { if (offscreenBuf != null) { offscreenBuf.shutdown(); offscreenBuf = null; } }
public void showTile(int x, int y) { camX = (x * tileSize) + (tileSize / 2.0); camY = (y * tileSize) + (tileSize / 2.0); }
public static void performFullCacheFlush(@NonNull App app, @Nullable UIMapView view) { app.stuffRendererIndependent.imageLoader.flushCache(); if (view != null) { view.mapTable.renderer.imageLoader.flushCache(); view.performRefresh(); view.mapTable.renderer.imageLoader.flushCache(); view.reinitLayerVis(); } }
@Override public void run() { clearTools(thisButton); view.currentLayer = thisButton; viewGiver.showATField(); }
@Override public void run() { clearTools(thisButton); viewGiver.accept(toolFuncs[toolId].apply(viewGiver)); }
@Override public void run() { clearTools(thisButton); viewGiver.accept(new UIMTEventPicker(viewGiver)); }
@Override public void run() { view.layerVis[fi] = !view.layerVis[fi]; }
@Override public void run() { clearTools(view.currentLayer); viewGiver.accept(new UIMTPickTile(viewGiver)); }
@Override public void run() { clearTools(thisButton); viewGiver.accept(new UIMTCopyRectangle(viewGiver)); }
@Override public void run() { clearTools(thisButton); viewGiver.accept(new UIMTPopupButtons(viewGiver, readonlyTiles, addendum)); }
public void clearTools(int t) { for (UITextButton utb : tools) utb.state = false; if (t != -1) tools.get(t).state = true; }
@Override public void noTool() { clearTools(-1); }
@Override public boolean allowPickTile() { return !readonlyTiles; }
public void drawMouseIndicator() { if (mouseStatus != null) drawIndicator(mouseStatus.x, mouseStatus.y, IndicatorStyle.Selection); }
public void drawIndicator(int tx, int ty, IndicatorStyle solid) { int px = tx * tileSize; int py = ty * tileSize; if (solid == IndicatorStyle.SolidBlue) { igd.clearRect(0, 0, 255, px, py, tileSize, tileSize); } else if (solid == IndicatorStyle.Target) { app.a.drawTarget(px, py, tileSize, igd, atOrBelowHalfSize); } else { app.a.drawSelectionBox(px, py, tileSize, tileSize, 1, igd); } }
private boolean merge(int f0id, int f0, int f1, int flag, int flagInv, int oX, int oY) { if (!mapTable.coordAccessible(oX, oY)) return false; int b0id = mapTable.getTiletype(oX, oY, 0); int b0 = R2kTileMapViewDrawLayer.getTileFlags(b0id, tsLow, tsHigh); int b1 = R2kTileMapViewDrawLayer.getTileFlags(mapTable.getTiletype(oX, oY, 1), tsLow, tsHigh); return mergeCore(f0id, f0, f1, flag) & mergeCore(b0id, b0, b1, flagInv); }
private boolean mergeCore(int f0id, int f0, int f1, int flag) { if ((f1 & flag) == 0) return false; if ((f1 & 0x10) == 0) return true; if ((f0 & 0x30) == 0x30) { int n = f0id % 50; if ((n >= 20) && (n < 24)) { return true; } else if ((n >= 33) && (n < 38)) { return true; } else if ((n == 42) || (n == 43) || (n == 45) || (n == 46)) { return true; } } return (f0 & flag) != 0; }
@Override public void drawTile(int layer, int tidx, int px, int py, IGrDriver igd) { int tx = (tidx & 0xFFFF) % tileStride; int ty = (tidx & 0xFFFF) / tileStride; igd.blitScaledImage( tileSize * tx, tileSize * ty, tileSize, tileSize, px, py, tileSize, tileSize, img); }
@Override public AutoTileTypeField[] indicateATs() { return new AutoTileTypeField[0]; }
public void checkReload() { Object[] deps = new Object[16]; for (int i = 0; i < blockTypes.length; i++) if (blockTypes[i] != null) deps[i] = imageLoader.getImage("Prt" + blockTypes[i], false); if (tilesDeps.shouldUpdate(deps)) { SimpleAtlasBuilder sab = new SimpleAtlasBuilder(256, 256, BinaryTreeAtlasStrategy.INSTANCE); for (int i = 0; i < blockTypes.length; i++) { final int fi = i; if (deps[fi] != null) sab.add((res) -> tileSheets[fi] = res, new ImageAtlasDrawable((ITexRegion) deps[fi])); } lastAtlasSet = sab.compile(); } }
@Override public void drawTile(int layer, int tidx, int px, int py, IGrDriver igd) { int plane = (tidx & ~0xF) >> 4; int block = tidx & 0xF; if (plane < 0) return; if (plane > 15) return; ITexRegion i = tileSheets[plane]; if (i == null) return; if (plane != 6) { igd.blitImage(tileSize * block, 0, tileSize, tileSize, px, py, i); } else { int frame = getFrame(); if (block == 0) igd.blitImage(frame, 0, tileSize, tileSize, px, py, i); if (block == 1) igd.blitImage(tileSize - frame, 0, tileSize, tileSize, px, py, i); if (block == 2) igd.blitImage(0, frame, tileSize, tileSize, px, py, i); if (block == 3) igd.blitImage(0, tileSize - frame, tileSize, tileSize, px, py, i); } }
@Override public AutoTileTypeField[] indicateATs() { return new AutoTileTypeField[0]; }
@Override public void checkReloadTSO(@Nullable IRIO tso) { if (tso != null) { IImage chipsetSrc = imageLoader.getImage("ChipSet/" + tso.getIVar("@tileset_name").decString(), false); checkReloadImg(chipsetSrc); } else { checkReloadImg(null); } }
private void handleWATField( int tSubfield, int px, int py, IGrDriver igd, int aniX, int baseY, int diamondY, int ovlX) { int innerSubfield = tSubfield % 50; int outerSubfield = tSubfield / 50; char[] charTbl = {' ', '+', 'O', '|', '-'}; ATDB adb = app.autoTiles[1]; char ul = charTbl[adb.entries[innerSubfield].corners[0]]; char ur = charTbl[adb.entries[innerSubfield].corners[1]]; char ll = charTbl[adb.entries[innerSubfield].corners[2]]; char lr = charTbl[adb.entries[innerSubfield].corners[3]]; int etc = tileSize / 2; handleWATCorner( 0, 0, ((outerSubfield & 1) != 0) ? 'D' : ul, px, py, igd, aniX, baseY, diamondY, ovlX, etc); if ((etc * 2) == tileSize) { handleWATCorner( etc, 0, ((outerSubfield & 2) != 0) ? 'D' : ur, px, py, igd, aniX, baseY, diamondY, ovlX, etc); handleWATCorner( 0, etc, ((outerSubfield & 4) != 0) ? 'D' : ll, px, py, igd, aniX, baseY, diamondY, ovlX, etc); handleWATCorner( etc, etc, ((outerSubfield & 8) != 0) ? 'D' : lr, px, py, igd, aniX, baseY, diamondY, ovlX, etc); } }
private void handleWATCorner( int cx, int cy, char c, int px, int py, IGrDriver igd, int aniX, int baseY, int diamondY, int ovlX, int etc) { int tox = 0; int toy = 0; switch (c) { case ' ': tox = aniX; toy = baseY; break; case 'D': tox = aniX; toy = diamondY; break; case 'O': tox = ovlX; toy = 0; break; case '|': tox = ovlX; toy = tileSize; break; case '-': tox = ovlX; toy = tileSize * 2; break; case '+': tox = ovlX; toy = tileSize * 3; break; } igd.blitScaledImage(tox + cx, toy + cy, etc, etc, px + cx, py + cy, etc, etc, chipsetLeft); }
private void handleCommonPage(int base, int ofsPage, int tidx, int px, int py, IGrDriver igd) { int ti = tidx - base; ti += ofsPage * 144; int tx = (ti % 6) + ((ti / 96) * 6); int ty = ((ti / 6) % 16); igd.blitScaledImage( tx * tileSize, ty * tileSize, tileSize, tileSize, px, py, tileSize, tileSize, chipsetRight); }
@Override public AutoTileTypeField[] indicateATs() { LinkedList<AutoTileTypeField> attf = new LinkedList<AutoTileTypeField>(); int[] waterIndexes = new int[60]; for (int i = 0; i < waterIndexes.length; i++) { waterIndexes[i] = i * 50; int subgroup = i % 20; int rep = 0; if ((subgroup == 0) && (i != 40)) rep = 46; attf.add(new AutoTileTypeField(i * 50, 50, 1, rep, waterIndexes)); } for (int i = 4000; i < 4600; i += 50) attf.add(new AutoTileTypeField(i, 50, 0, 49)); return attf.toArray(new AutoTileTypeField[0]); }
@Override public void drawTile(int layer, int tidx, int px, int py, IGrDriver igd) {}
@Override public void checkReloadTSO(@Nullable IRIO tso) { this.tileset = tso; if (tileset != null) { flags = new RubyTableR(tileset.getIVar("@flags").getBuffer()); IRIO amNames = tileset.getIVar("@tileset_names"); IImage[] tilesetMaps = new IImage[9]; for (int i = 0; i < tilesetMaps.length; i++) { IRIO rio = amNames.getAElem(i); String expectedAT = rio.decString(); if (expectedAT.length() != 0) tilesetMaps[i] = imageLoader.getImage("Tilesets/" + expectedAT, false); } checkReloadImg(tilesetMaps); } else { flags = new RubyTable(2, 0, 0, 0, new int[0]); tilesetReg = null; atlasSet = null; } }
private void checkReloadImg(IImage[] tilesetMaps) { if (!depsLocker.shouldUpdate((Object) tilesetMaps)) return; tilesetReg = new ITexRegion[tilesetMaps.length]; SimpleAtlasBuilder sab = new SimpleAtlasBuilder(1024, 1024, BinaryTreeAtlasStrategy.INSTANCE); for (int i = 0; i < tilesetMaps.length; i++) { final int fi = i; if (tilesetMaps[i] != null) sab.add((res) -> tilesetReg[fi] = res, new ImageAtlasDrawable(tilesetMaps[i])); } atlasSet = sab.compile(); }
private void drawShadowTileFlag(int tidx, int i, int i1, int i2, IGrDriver igd, int st) { if ((tidx & i) != 0) igd.fillRect(0, 0, 0, 128, i1, i2, st, st); }
private boolean handleMTLayer(int tidx, int ets, int px, int py, int tm, IGrDriver igd) { int t = tidx & 0xFF; ITexRegion planeImage = tilesetReg[tm]; if (planeImage != null) { int tgtX = t % 8; int tgtY = t / 8; if (tgtY >= 16) { tgtY -= 16; tgtX += 8; } igd.blitScaledImage(tgtX * tileSize, tgtY * tileSize, ets, ets, px, py, ets, ets, planeImage); return true; } return false; }
@Override public AutoTileTypeField[] indicateATs() { AutoTileTypeField[] r = new AutoTileTypeField[preparedATTF.length]; for (int i = 0; i < r.length; i++) r[i] = preparedATTF[i]; return r; }
public static ExpandedATTF vxGeneral(int base, int tsi, int x, int y, int[] a) { return new ExpandedATTF(base, 0, 47, tsi, new Rect(x, y, 2, 3), a); }
public static ExpandedATTF vxWall(int base, int tsi, int x, int y, int[] a) { return new ExpandedATTF(base, 1, 15, tsi, new Rect(x, y, 2, 2), a); }
public static ExpandedATTF vxWaterfall(int base, int tsi, int x, int y, int[] a) { return new ExpandedATTF(base, 2, 0, tsi, new Rect(x, y, 2, 1), a); }
public static ITileAccess.Bounded of(RubyTableR tbl, boolean tileLoopX, boolean tileLoopY) { if (tileLoopX || tileLoopY) return new LoopTileAccess(tbl, tileLoopX, tileLoopY); return tbl; }
public static ITileAccess.RWBounded of(RubyTable tbl, boolean tileLoopX, boolean tileLoopY) { if (tileLoopX || tileLoopY) return new LoopTileAccess.RW(tbl, tileLoopX, tileLoopY); return tbl; }
public static ITexRegion[] addToSimpleAtlasBuilder( int tileSize, ATDB db, SimpleAtlasBuilder sab, ITexRegion src, boolean vxa) { ITexRegion[] out = new ITexRegion[db.entries.length]; for (int i = 0; i < db.entries.length; i++) { final int fi = i; ATDB.Autotile entry = db.entries[i]; if (entry != null) sab.add((res) -> out[fi] = res, new ATFieldAtlasDrawable(tileSize, src, entry, vxa)); } return out; }
@Override public void drawTo(IGrDriver ap, int px, int py) { int cSize = tileSize / 2; for (int sA = 0; sA < 2; sA++) for (int sB = 0; sB < 2; sB++) { int ti = details.corners[sA + (sB * 2)]; int tx = ti % 3; int ty = ti / 3; if (vxaAdjust) { if (ti == 2) { tx = tileSize; } else if (ti > 2) { ty -= tileSize; tx /= 2; ty /= 2; ty += tileSize; } } int sX = (sA * cSize); int sY = (sB * cSize); ap.blitImage( (tx * tileSize) + sX, (ty * tileSize) + sY, cSize, cSize, px + sX, py + sY, source, IGrDriver.BLEND_NONE, 0); } }
@Override public void checkReloadTSO(@Nullable IRIO tileset) { if (tileset != null) { priorities = new RubyTableR(tileset.getIVar("@priorities").getBuffer()); IRIO tn = tileset.getIVar("@tileset_name"); IImage[] tilesetMaps = new IImage[8]; if (tn != null) { String expectedTS = tn.decString(); if (expectedTS.length() != 0) tilesetMaps[0] = imageLoader.getImage("Tilesets/" + expectedTS, false); } IRIO amNames = tileset.getIVar("@autotile_names"); if (amNames != null) { for (int i = 0; i < 7; i++) { IRIO rio = amNames.getAElem(i); String expectedAT = rio.decString(); if (expectedAT.length() > 0) tilesetMaps[i + 1] = imageLoader.getImage("Autotiles/" + expectedAT, false); } } doReloadImg(tilesetMaps); } else { priorities = null; depsLocker.shouldUpdate(); commonTiles = null; atFields = null; atlasSet = null; } }
private void doReloadImg(IImage[] tilesetMaps) { if (!depsLocker.shouldUpdate((Object) tilesetMaps)) return; SimpleAtlasBuilder sab = new SimpleAtlasBuilder(1024, 1024, BinaryTreeAtlasStrategy.INSTANCE); if (tilesetMaps[0] != null) { commonTilesHeight = tilesetMaps[0].height; sab.add((res) -> commonTiles = res, new ImageAtlasDrawable(tilesetMaps[0])); } atFields = new ITexRegion[7][][]; for (int i = 0; i < 7; i++) { IImage atf = tilesetMaps[i + 1]; if (atf == null) continue; int count = atf.getWidth() / 96; if (count < 1) count = 1; ITexRegion[][] ts = new ITexRegion[count][]; for (int j = 0; j < ts.length; j++) { ITexRegion atfSrc = atf.subRegion(j * 96, 0, 96, 128); ITexRegion[] compiledATF = ATFieldAtlasDrawable.addToSimpleAtlasBuilder( tileSize, app.autoTiles[0], sab, atfSrc, false); ts[j] = compiledATF; } atFields[i] = ts; } atlasSet = sab.compile(); }
@Override public void drawTile(int layer, int tidx, int px, int py, IGrDriver igd) { if (tidx < (48 * 8)) { int atMap = tidx / 48; if (atMap == 0) return; atMap--; tidx %= 48; ITexRegion[][] animatedATF = atFields[atMap]; if (animatedATF != null) { int animControl = 0; int animSets = animatedATF.length; if (animSets > 0) animControl = getFrame() % animSets; ITexRegion[] atfFrame = animatedATF[animControl]; ITexRegion atfTile = atfFrame[tidx]; if (atfTile != null) igd.blitImage(px, py, atfTile); } return; } tidx -= 48 * 8; int tsh = 8; int tx = tidx % tsh; int ty = tidx / tsh; if (commonTiles != null) { if (ty * tileSize >= commonTilesHeight) return; igd.blitImage(tx * tileSize, ty * tileSize, tileSize, tileSize, px, py, commonTiles); } }
@Override public AutoTileTypeField[] indicateATs() { return new AutoTileTypeField[] { new AutoTileTypeField(0, 48, 0, 47), new AutoTileTypeField(48, 48, 0, 47), new AutoTileTypeField(48 * 2, 48, 0, 47), new AutoTileTypeField(48 * 3, 48, 0, 47), new AutoTileTypeField(48 * 4, 48, 0, 47), new AutoTileTypeField(48 * 5, 48, 0, 47), new AutoTileTypeField(48 * 6, 48, 0, 47), new AutoTileTypeField(48 * 7, 48, 0, 47), }; }
public final void drawTile(int layer, int tidx, int px, int py, IGrDriver igd, int spriteScale) { if (spriteScale != 1) { try (Block b = igd.openTRS(px, py, spriteScale, spriteScale)) { drawTile(layer, tidx, 0, 0, igd); } } else { drawTile(layer, tidx, px, py, igd); } }
public static int lookupDirection(int dir) { if (dir == 2) return 0; if (dir == 4) return 1; if (dir == 6) return 2; if (dir == 8) return 3; return 0; }
@Override public int determineEventLayer(RORIO event) { if (useVXAExtensionScheme) return (int) event.getIVar("@pages").getAElem(0).getIVar("@priority_type").getFX(); return (event.getIVar("@pages").getAElem(0).getIVar("@always_on_top").getType() == 'T') ? 1 : 0; }
@Override public RORIO extractEventGraphic(RORIO evI) { return evI.getIVar("@pages").getAElem(0).getIVar("@graphic"); }
@Override public int determineEventLayer(RORIO event) { return 0; }
@Override public RORIO extractEventGraphic(RORIO event) { return event; }
@Override public void drawEventGraphic( RORIO target, int ox, int oy, IGrDriver igd, int ss, @Nullable RORIO originalEvent) {}
@Override public void delEvent(DMKey key) { IRIO mapEvents = getMapEvents(); mapEvents.removeHashVal(key); pokeHive(); }
@Override public String[] eventTypes() { return new String[] {eventName}; }
@Override public @Nullable DMKey addEvent(@Nullable RORIO eve, int type) { DMKey key = getFreeIndex(); IRIO mapEvents = getMapEvents(); IRIO eveTarget = mapEvents.addHashVal(key); if (eve == null) { SchemaPath.setDefaultValue(eveTarget, eventSchema, key); pokeHive(); } else { IRIOGeneric ig = new IRIOGeneric(app.ctxDisposableAppEncoding); ig.setDeepClone(eve); new SchemaPath( eventSchema, new ObjectRootHandle.Isolated(eventSchema, ig, "TraditionalEventAccess")) .changeOccurred(false); eveTarget.setDeepClone(ig); makeEventSchemaPath(key).changeOccurred(false); } return key; }
@Override public Runnable hasSync(DMKey evK) { return null; }
@Override public String customEventsName() { return eventsName; }
protected DMKey convIndex(long unusedIndex) { return DMKey.of(unusedIndex); }
private SchemaPath makeMapRootSchemaPath() { return new SchemaPath(mapRootSchema, mapRoot); }
private SchemaPath makeEventSchemaPath(DMKey key) { SchemaPath base = makeMapRootSchemaPath(); base = base.arrayHashIndex(key, "E" + key); IRIO res = getEvent(key); return base.newWindow(eventSchema, res); }
private void pokeHive() { mapRoot.objectRootModified(makeMapRootSchemaPath()); }
@Override public int determineEventLayer(RORIO event) { RORIO eventCore = extractEventGraphic(event); if (eventCore == null) return -1; RORIO active = eventCore.getIVar("@active"); if (active != null) if (active.getType() == 'F') return -1; int ld = (int) eventCore.getIVar("@layer").getFX(); if (ld == 0) return 0; if (ld == 1) return 1; if (ld == 2) return 2; return 1; }
@Override public RORIO extractEventGraphic(RORIO event) { if (event.getSymbol() == null) return null; if (event.getSymbol().equals("RPG::SavePartyLocation")) return event; if (event.getSymbol().equals("RPG::SaveVehicleLocation")) return event; if (event.getSymbol().equals("RPG::SaveMapEvent")) return event; if (event.getIVar("@pages").getALen() <= 1) return null; return event.getIVar("@pages").getAElem(1); }
private int scaleLocalToRemote(int i) { return (i * remoteTileSize) / localTileSize; }
private DMKey convertEventKey(int i, DMKey key) { return DMKey.ofStr(((char) ('0' + i)) + ValueSyntax.encode(key)); }
@Override public void delEvent(DMKey key) { String ks = key.decString(); int in = ks.charAt(0) - '0'; accesses[in].delEvent(ValueSyntax.decode(ks.substring(1))); }
@Override public String[] eventTypes() { return eventTypes; }
@Override public @Nullable DMKey addEvent(@Nullable RORIO eve, int type) { int accessId = eventTypesToAccess[type]; IEventAccess iea = accesses[accessId]; type -= accessEVTBases[accessId]; DMKey res = iea.addEvent(eve, type); if (res == null) return null; return convertEventKey(accessId, res); }
@Override public Runnable hasSync(DMKey key) { String ks = key.decString(); int in = ks.charAt(0) - '0'; return accesses[in].hasSync(ValueSyntax.decode(ks.substring(1))); }
@Override public String customEventsName() { return tabName; }
private void sfveInjectEvent(String s, int mapId, IRIO instVarBySymbol) { if (instVarBySymbol.getIVar("@map").getFX() != mapId) return; eventsHash.put(DMKey.ofStr(s), instVarBySymbol); }
@Override public String[] eventTypes() { return new String[] {}; }
@Override public @Nullable DMKey addEvent(@Nullable RORIO eve, int type) { app.ui.launchDialog(T.m.r2kSavefile_cantAddEvents); return null; }
public static void eventAsSaveEvent(App app, IRIO rMap, long mapId, DMKey key, IRIO event) { IRIO rio = rMap.addHashVal(key); SchemaPath.setDefaultValue(rio, app.sdb.getSDBEntry("RPG::SaveMapEvent"), key); rio.getIVar("@map").setFX(mapId); rio.getIVar("@x").setDeepClone(event.getIVar("@x")); rio.getIVar("@y").setDeepClone(event.getIVar("@y")); IRIO pages = event.getIVar("@pages"); IRIO eventPage = null; if (pages.getALen() >= 2) eventPage = pages.getAElem(1); if (eventPage != null) { rio.getIVar("@character_name").setDeepClone(eventPage.getIVar("@character_name")); rio.getIVar("@character_index").setDeepClone(eventPage.getIVar("@character_index")); rio.getIVar("@character_direction").setDeepClone(eventPage.getIVar("@character_direction")); rio.getIVar("@dir").setDeepClone(eventPage.getIVar("@character_direction")); rio.getIVar("@transparency") .setFX((eventPage.getIVar("@character_blend_mode").getType() == 'T') ? 3 : 0); rio.getIVar("@move_freq").setDeepClone(eventPage.getIVar("@move_freq")); rio.getIVar("@move_speed").setDeepClone(eventPage.getIVar("@move_speed")); rio.getIVar("@layer").setDeepClone(eventPage.getIVar("@layer")); rio.getIVar("@block_other_events").setDeepClone(eventPage.getIVar("@block_other_events")); } }
@Override public Runnable hasSync(final DMKey evK) { if (eventsHash.get(evK) == null) return () -> { if (eventsHash.get(evK) != null) { app.ui.launchDialog(T.m.r2kSavefile_evAppearedInCB); } else { IRIO map = getMap(); if (map == null) { app.ui.launchDialog(T.m.r2kSavefile_noEvMap); return; } IRIO ev = map.getIVar("@events").getHashVal(evK); if (ev == null) { app.ui.launchDialog(T.m.r2kSavefile_errUserIsAToaster); return; } eventAsSaveEvent(app, getSaveEvents(), getMapId(), evK, ev); pokeHive(); } }; return null; }
@Override public String customEventsName() { return T.m.r2kSavefile_name; }
public void pokeHive() { saveFileRoot.objectRootModified(new SchemaPath(saveFileRootSchema, saveFileRoot)); }
@Override public int compare(DMKey a, DMKey b) { int yA = (int) eventList.getEventY(a); int yB = (int) eventList.getEventY(b); if (yA < yB) return -1; if (yA > yB) return 1; return 0; }
@Override public void draw(MapViewDrawContext mvdc) { int x = (int) evI.getIVar("@x").getFX(); int y = (int) evI.getIVar("@y").getFX(); if (!mvdc.camTMargin.contains(x, y)) return; int px = x * mvdc.tileSize; int py = y * mvdc.tileSize; RORIO g = renderer.extractEventGraphic(evI); if (g != null) renderer.drawEventGraphic(g, px, py, mvdc.igd, 1, evI); }
@Override public void draw(MapViewDrawContext mvdc) { int half = mvdc.tileSize / 2; try (Block blk = mvdc.igd.openScissor( mapBoundsPx.x - half, mapBoundsPx.y - half, mapBoundsPx.width + mvdc.tileSize, mapBoundsPx.height + mvdc.tileSize)) { for (int i = Math.max(mvdc.cam.x, mapBoundsPx.x); i < Math.min(mvdc.cam.right, mapBoundsPx.right); i += mvdc.tileSize) { app.a.drawSymbol( mvdc.igd, Art.Symbol.Stripes, i, mapBoundsPx.y - mvdc.tileSize, mvdc.tileSize, false, false); app.a.drawSymbol( mvdc.igd, Art.Symbol.Stripes, i, mapBoundsPx.bottom, mvdc.tileSize, false, false); } for (int j = Math.max(mvdc.cam.y, mapBoundsPx.y - mvdc.tileSize); j < Math.min(mvdc.cam.bottom, mapBoundsPx.right + mvdc.tileSize); j += mvdc.tileSize) { app.a.drawSymbol( mvdc.igd, Art.Symbol.Stripes, mapBoundsPx.x - mvdc.tileSize, j, mvdc.tileSize, false, false); app.a.drawSymbol( mvdc.igd, Art.Symbol.Stripes, mapBoundsPx.right, j, mvdc.tileSize, false, false); } } }
@Override public void draw(MapViewDrawContext mvdc) { for (int i = mvdc.camT.x; i < mvdc.camT.x + mvdc.camT.width; i++) { int a = (i * mvdc.tileSize) + (mvdc.tileSize - 1); mvdc.igd.clearRect(0, 0, 0, a, mvdc.cam.y, 1, mvdc.igd.getHeight()); } for (int i = mvdc.camT.y; i < mvdc.camT.y + mvdc.camT.height; i++) { int a = (i * mvdc.tileSize) + (mvdc.tileSize - 1); mvdc.igd.clearRect(0, 0, 0, mvdc.cam.x, a, mvdc.igd.getWidth(), 1); } }
public boolean shouldDraw(int x, int y, int layer, int value) { return true; }
public boolean shouldDrawRow(int y, int layer) { return true; }
@Override public void draw(MapViewDrawContext mvdc) { for (int j = mvdc.camT.y; j < mvdc.camT.y + mvdc.camT.height; j++) { int yBase = targetTable.getYBase(j); if (yBase == -1) continue; if (!shouldDrawRow(j, mvdc.currentLayer)) continue; for (int i = mvdc.camT.x; i < mvdc.camT.x + mvdc.camT.width; i++) { int xBase = targetTable.getXBase(i); if (xBase == -1) continue; xBase += yBase; int px = i * mvdc.tileSize; int py = j * mvdc.tileSize; for (int pi = 0; pi < tileLayers.length; pi++) { int pBase = tileLayersBases[pi]; if (pBase == -1) continue; int tidx = targetTable.getTiletypeRaw(tileLayersBases[pi] + xBase); tileDrawIntern( tileLayers[pi], mvdc.mouseStatus, mvdc.currentLayer, mvdc.callbacks, mvdc.debugToggle, mvdc.igd, tidx, i, j, px, py); } } } }
private void tileDrawIntern( int tdi, MapViewDrawContext.MouseStatus mouseAllowed, int currentLayer, IMapViewCallbacks callbacks, boolean debug, IGrDriver igd, int tidx, int i, int j, int px, int py) { if (callbacks != null) tidx = callbacks.shouldDrawAt(mouseAllowed, i, j, tidx, tdi, currentLayer); if (shouldDraw(i, j, tdi, tidx)) { if (debug) { String t = Integer.toString(tidx, 16); GaBIEn.engineFonts.f6.drawLAB(igd, px, py + (tdi * 6), t, false); } else { tr.drawTile(tdi, tidx, px, py, igd); } } }
@Override public int compare(IZSortedObject t0, IZSortedObject t1) { long zA = t0.getZ(); long zB = t1.getZ(); if (zA < zB) return -1; if (zA > zB) return 1; return 0; }
@Override public void draw(MapViewDrawContext mvdc) { for (IZSortedObject obj : zSorting) { SignalMapViewLayer controlSignal = obj.getControlSignal(); if ((controlSignal == null) || controlSignal.active) obj.draw(mvdc); } for (SignalMapViewLayer signal : signals) signal.active = false; }
@Override public void draw(MapViewDrawContext mvdc) { active = true; }
@Override public boolean shouldDrawRow(int y, int layer) { if (pIndex < y) return false; if (pIndex > (y + 5)) return false; return true; }
@Override public boolean shouldDraw(int x, int y, int layer, int value) { if (!tileSignalLayers[layer].active) return false; int pri = getTIDPriority(value); if (pIndex == -1) if (pri == 0) return true; int targPIndex = y + pri; return targPIndex == pIndex; }
@Override public boolean shouldDraw(int x, int y, int layer, int tidx) { int val = getTileFlags(tidx, lowpass, highpass); boolean r = (val & ((layer == 0) ? 0x30 : 0x10)) != 0; return r == upper; }
private static int checkUpperRange( int tidx, RubyTableR tileset, int rangeS, int rangeE, int group) { if (tidx >= rangeS) if (tidx < rangeE) return tileset.getTiletype(group, 0, 0) & 0xFFFF; return 0; }
@Override public boolean shouldDrawRow(int y, int layer) { if (pIndex < y) return false; if (pIndex > (y + 4)) return false; return true; }
@Override public boolean shouldDraw(int x, int y, int layer, int value) { if (!tileSignalLayers[layer].active) return false; int targPIndex = y; if (layer != 3) { int pri = 0; if (tiles.flags.coordAccessible(value, 0)) { int flags = tiles.flags.getTiletype(value, 0, 0); if ((flags & 16) != 0) pri += 4; } else { System.err.println( "WARNING: Corrupt/malsized VXA priority table (what are you playing at?)"); } targPIndex += pri; } else { } return targPIndex == pIndex; }
@Override public void draw(MapViewDrawContext mvdc) { if (mvdc.tileSize != tileSize) return; for (int i = mvdc.camT.x; i < mvdc.camT.x + mvdc.camT.width; i++) { for (int j = mvdc.camT.y; j < mvdc.camT.y + mvdc.camT.height; j++) { int px = i * tileSize; int py = j * tileSize; int flags = src.getPassability(i, j); if (flags == -1) continue; int tsEnd = tileSize - 8; int tsMid = (tileSize / 2) - 4; if ((flags & IPassabilitySource.PASS_DOWN) == 0) mvdc.igd.blitImage(16, 0, 8, 8, px + tsMid, py + tsEnd, app.a.layerTabs); if ((flags & IPassabilitySource.PASS_RIGHT) == 0) mvdc.igd.blitImage(8, 0, 8, 8, px + tsEnd, py + tsMid, app.a.layerTabs); if ((flags & IPassabilitySource.PASS_LEFT) == 0) mvdc.igd.blitImage(24, 0, 8, 8, px, py + tsMid, app.a.layerTabs); if ((flags & IPassabilitySource.PASS_UP) == 0) mvdc.igd.blitImage(0, 0, 8, 8, px + tsMid, py, app.a.layerTabs); } } }
public static String sNameFromInt(long key) { String mapStr = Long.toString(key); while (mapStr.length() < 3) mapStr = "0" + mapStr; return "Map" + mapStr; }
@Override public void registerModificationHandler(Consumer<SchemaPath> onMapInfoChange) { modHandler = onMapInfoChange; mapInfos.registerModificationHandler(onMapInfoChange); }
@Override public boolean wouldRelocatingInOrderFail(int orderFrom, int orderTo) { return MapInfoReparentUtil.wouldRelocatingInOrderFail(orderFrom, orderTo, this); }
@Override public int relocateInOrder(int orderFrom, int orderTo) { return MapInfoReparentUtil.relocateInOrder(orderFrom, orderTo, this); }
@Override public void triggerEditInfoOf(long k) { app.ui.launchSchemaTrace(mapInfos, null, new DMPath.Hash(DMKey.of(k), false)); }
@Override public void swapOrders(int orderA, int orderB) { long a = getMapOfOrder(orderA); long b = getMapOfOrder(orderB); IRIO ao = getHashBID(a).getIVar("@order"); IRIO bo = getHashBID(b).getIVar("@order"); long t = bo.getFX(); bo.setFX(ao.getFX()); ao.setFX(t); }
@Override public void removeMap(long k) { MapInfoReparentUtil.removeMapHelperSALT(k, this); mapInfos.getObject().removeHashVal(DMKey.of(k)); }
@Override public int createNewMap(long k) { int targetOrder = getLastOrder(); long l = getMapOfOrder(targetOrder); if (l == -1) l = 0; IRIO mi = mapInfos.getObject().addHashVal(DMKey.of(k)); SchemaPath.setDefaultValue(mi, app.sdb.getSDBEntry("RPG::MapInfo"), DMKey.of(k)); mi.getIVar("@parent_id").setFX(l); mi.getIVar("@order").setFX(targetOrder + 1); return targetOrder; }
@Override public void complete() { SchemaPath fakePath = new SchemaPath(app.sdb.getSDBEntry("File.MapInfos"), mapInfos); mapInfos.objectRootModified(fakePath); modHandler.accept(fakePath); }
@Override public String translateToGUM(long k) { return sNameFromInt(k); }
@Override public String calculateIndentsAndGetErrors(HashMap<Long, Integer> id) { StringBuilder errors = new StringBuilder(); standardCalculateIndentsAndGetErrors(app, this, id, errors, 0); return errorsToStringOrNull(app, errors); }
@Override public int compare(Long aLong, Long t1) { int a = backend.getOrderOfMap(aLong); int b = backend.getOrderOfMap(t1); if (a < b) return -1; if (a > b) return 1; return 0; }
public static String errorsToStringOrNull(App app, StringBuilder errors) { if (errors.length() == 0) return null; errors.append(app.t.m.resolveManually); return errors.toString(); }
public void reload() { LinkedList<UIElement> elms = new LinkedList<>(); for (int i = first; i <= last; i++) { final int fi = i; try { ObjectRootHandle rio = app.odb.getObject(objectMapping.apply(i), false); final String gum = gumMapping.apply(i); if (rio != null) { String obj = app.format(rio.getObject()); elms.add( new UITextButton( T.m.dSaveColon.r(gum, obj), app.f.mapInfosTH, () -> { context.loadMap(gum); })); } else { elms.add( new UIAppendButton( T.m.bNew, new UILabel(T.m.unavailable.r(gum), app.f.mapInfosTH), () -> { context.loadMap(gum); reload(); }, app.f.mapInfosTH)); } } catch (Exception ex) { ex.printStackTrace(); UILabel warning = new UILabel(T.m.internalErr, app.f.mapInfosTH); elms.add( new UIAppendButton( T.m.bAttemptLoadAnyway, warning, () -> { context.loadMap(gumMapping.apply(fi)); }, app.f.mapInfosTH)); } } mainLayout.panelsSet(elms); }
public static boolean wouldRelocatingInOrderFail( int orderA, int orderB, IRMLikeMapInfoBackendWPriv operators) { long map = operators.getMapOfOrder(orderA); if (map == -1) return true; int lastOrder = findChildrenLastOrder(map, operators); if (orderB > orderA) if (orderB <= (lastOrder + 1)) return true; return false; }
public static void removeMapHelperSALT(long k, IRMLikeMapInfoBackendWPriv operators) { int glo = operators.getLastOrder(); for (int i = operators.getOrderOfMap(k); i < glo; i++) operators.swapOrders(i, i + 1); }
@Override public void swapOrders(int orderA, int orderB) { IRIO mapTreeOrders = getMapOrders(); IRIO a = mapTreeOrders.getAElem(orderA); IRIO b = mapTreeOrders.getAElem(orderB); long ai = a.getFX(); a.setFX(b.getFX()); b.setFX(ai); }
public static String sNameFromInt(int i) { String m = Integer.toString(i); while (m.length() < 4) m = "0" + m; return "Map" + m + ".lmu"; }
public static String sTranslateToGUM(App app, long k) { final IRIO map = app.odb.getObject("RPG_RT.lmt").getObject().getIVar("@map_infos").getHashVal(DMKey.of(k)); if (map == null) return null; String pfx = map.getIVar("@type").getFX() == 2 ? "Area." : "Map."; return pfx + k; }
@Override public void registerModificationHandler(Consumer<SchemaPath> onMapInfoChange) { modHandler = onMapInfoChange; mapTree.registerModificationHandler(onMapInfoChange); }
@Override public void triggerEditInfoOf(long k) { app.ui.launchSchemaTrace( mapTree, null, new DMPath.IVar("@map_infos", false).withHash(DMKey.of(k))); }
@Override public void removeMap(long k) { IRIO mapTreeOrders = getMapOrders(); IRIO mapTreeHash = getMapHash(); MapInfoReparentUtil.removeMapHelperSALT(k, this); mapTreeOrders.rmAElem(mapTreeOrders.getALen() - 1); mapTreeHash.removeHashVal(DMKey.of(k)); }
@Override public int createNewMap(long k) { IRIO mapTreeOrders = getMapOrders(); IRIO mapTreeHash = getMapHash(); int targetOrder = mapTreeOrders.getALen() - 1; long l = getMapOfOrder(targetOrder); if (l == -1) l = 0; mapTreeOrders.addAElem(mapTreeOrders.getALen()).setFX(k); DMKey key = DMKey.of(k); IRIO mi = mapTreeHash.addHashVal(key); SchemaPath.setDefaultValue(mi, app.sdb.getSDBEntry("RPG::MapInfo"), key); mi.getIVar("@parent_id").setFX(l); return (int) k - 1; }
@Override public int compare(Long p0, Long p1) { int t0 = getOrderOfMap(p0); int t1 = getOrderOfMap(p1); if (t0 > t1) return 1; if (t0 < t1) return -1; return 0; }
@Override public String translateToGUM(long k) { return sTranslateToGUM(app, k); }
@Override public void flushCache() { loader.flushCache(); }
@Override public void flushCache() { for (IImageLoader iil : subLoaders) iil.flushCache(); }
@Override public void flushCache() { loadedImages.clear(); root.flushCache(); }
@Override public void flushCache() { GaBIEn.hintFlushAllTheCaches(); }
public static int[] range(int low, int count) { int[] res = new int[count]; for (int i = 0; i < count; i++) res[i] = low + i; return res; }
public boolean compatibleWith(TileEditingTab lTM) { if (lTM.actTiles.length != actTiles.length) return false; for (int i = 0; i < actTiles.length; i++) if (actTiles[i] != lTM.actTiles[i]) return false; return true; }
public boolean inActTilesRange(int i) { return (i >= 0) && (i < actTiles.length); }
public boolean considersSameAs(AutoTileTypeField autotileType) { if (autotileType == null) return false; for (int i = 0; i < considerSameAs.length; i++) if (considerSameAs[i] == autotileType.start) return true; return false; }
public boolean contains(int tile) { return ((tile >= start) && (tile < (start + length))); }
@Override public TSOAwareTileRenderer createTileRenderer() { return new VXATileRenderer(app, imageLoader); }
@Override public StuffRenderer rendererFromMapAndTso( IRIO map, IRIO tso, IEventAccess events, ITileRenderer tileRenderer) { RMEventGraphicRenderer eventRenderer = new RMEventGraphicRenderer(app, imageLoader, tileRenderer, true); return new StuffRenderer(app, imageLoader, tileRenderer, eventRenderer); }
@Override public IMapViewDrawLayer[] createLayersForMap( StuffRenderer renderer, IRIO map, IRIO tileset, IEventAccess events) { String vxaPano = map.getIVar("@parallax_name").decString(); if (map.getIVar("@parallax_show").getType() != 'T') vxaPano = ""; IImage panoImg = null; if (!vxaPano.equals("")) panoImg = imageLoader.getImage("Parallaxes/" + vxaPano, true); RubyTableR rt = new RubyTableR(map.getIVar("@data").getBuffer()); RVXAAccurateDrawLayer accurate = new RVXAAccurateDrawLayer( rt, events, (VXATileRenderer) renderer.tileRenderer, (RMEventGraphicRenderer) renderer.eventRenderer); return new IMapViewDrawLayer[] { new PanoramaMapViewDrawLayer( app, panoImg, true, true, 0, 0, rt.width, rt.height, -1, -1, 2, 1, 0), accurate.tileSignalLayers[0], accurate.tileSignalLayers[1], accurate.tileSignalLayers[2], accurate.tileSignalLayers[3], accurate.signalLayerEvA, accurate, new EventMapViewDrawLayer(app, 0x7FFFFFFF, events, renderer.eventRenderer, ""), new GridMapViewDrawLayer(app), new BorderMapViewDrawLayer(app, rt.getBounds().multiplied(renderer.tileRenderer.tileSize)) }; }
@Override public StuffRenderer rendererFromTso(IRIO tso) { TSOAwareTileRenderer tileRenderer = createTileRenderer(); tileRenderer.checkReloadTSO(tso); IEventGraphicRenderer eventRenderer = new RMEventGraphicRenderer(app, imageLoader, tileRenderer, true); return new StuffRenderer(app, imageLoader, tileRenderer, eventRenderer); }
@Override public boolean engineUsesPal0Colourkeys() { return true; }
public StuffRenderer rendererGeneral() { tileRenderer.checkReload(); IEventGraphicRenderer eventRenderer = new IkaEventGraphicRenderer(app, imageLoader); return new StuffRenderer(app, imageLoader, tileRenderer, eventRenderer); }
@Override public StuffRenderer rendererFromTso(IRIO target) { return rendererGeneral(); }
@Override public MapViewState rebuild() { StuffRenderer sr = rendererGeneral(); return MapViewState.fromRT( sr, StuffRenderer.prepareTraditional( app, sr, new int[] {0}, map.getObject(), events, "Back", true, true, 0, 0, -1, -1, 1), null, gum, new String[] {}, map.getObject(), "@data", false, events, false, false); }
@Override public IEditingToolbarController makeToolbar(IMapToolContext context) { return new MapEditingToolbarController(context, false); }
@Override protected String mapObjectIDToSchemaID(String objectID) { if (objectID.startsWith("Map")) return "RPG::Map"; return super.mapObjectIDToSchemaID(objectID); }
protected static IRIO tsoById(App app, long id) { IRIO tileset = null; int tid = (int) id; IRIO tilesets = app.odb.getObject("Tilesets").getObject(); if ((tid >= 0) && (tid < tilesets.getALen())) tileset = tilesets.getAElem(tid); if (tileset != null) if (tileset.getType() == '0') tileset = null; return tileset; }
@Override public UIElement createMapExplorer(IMapContext mapBox, String mapInfos) { return new UIGRMMapInfos(new RXPRMLikeMapInfoBackend(app), mapBox, mapInfos); }
@Override public Consumer<LinkedList<Entry>> createEngineTools() { return new RMTools(app); }
public TSOAwareTileRenderer createTileRenderer() { return new XPTileRenderer(app, imageLoader); }
public StuffRenderer rendererFromMapAndTso( IRIO map, IRIO tileset, IEventAccess events, ITileRenderer tileRenderer) { RMEventGraphicRenderer eventRenderer = new RMEventGraphicRenderer(app, imageLoader, tileRenderer, false); return new StuffRenderer(app, imageLoader, tileRenderer, eventRenderer); }
@Override public StuffRenderer rendererFromTso(IRIO tso) { TSOAwareTileRenderer tileRenderer = createTileRenderer(); tileRenderer.checkReloadTSO(tso); IEventGraphicRenderer eventRenderer = new RMEventGraphicRenderer(app, imageLoader, tileRenderer, false); return new StuffRenderer(app, imageLoader, tileRenderer, eventRenderer); }
@Override public MapViewState rebuild() { long currentTsId = map.getObject().getIVar("@tileset_id").getFX(); IRIO lastTileset = tsoById(app, currentTsId); tileRenderer.checkReloadTSO(lastTileset); StuffRenderer renderer = rendererFromMapAndTso(map.getObject(), lastTileset, events, tileRenderer); return MapViewState.fromRT( renderer, createLayersForMap(renderer, map.getObject(), lastTileset, events), null, gum, new String[] {"Tilesets"}, map.getObject(), "@data", false, events, false, false); }
@Override public IEditingToolbarController makeToolbar(IMapToolContext context) { return mapEditingToolbar(context); }
protected IEditingToolbarController mapEditingToolbar(IMapToolContext iMapToolContext) { return new MapEditingToolbarController(iMapToolContext, false); }
@Override public String mapReferentToGUM(IRIO mapReferent) { return RXPRMLikeMapInfoBackend.sNameFromInt((int) mapReferent.getFX()); }
@Override public StuffRenderer rendererFromTso(IRIO target) { ITileRenderer tileRenderer = new NullTileRenderer(app); IEventGraphicRenderer eventRenderer = new NullEventGraphicRenderer(); return new StuffRenderer(app, imageLoader, tileRenderer, eventRenderer); }
@Override public MapViewDetails mapViewRequest(String gum, boolean allowCreate) { throw new RuntimeException("There's no map system, how can you bring up a map?"); }
public String toString() { return idName + ": " + getName(); }
@Override public UIElement createMapExplorer(IMapContext context, String mapInfos) { return new UIGRMMapInfos(new R2kRMLikeMapInfoBackend(app), context, mapInfos); }
@Override public UIElement createSaveExplorer(IMapContext mapBox, String saves) { return new UISaveScanMapInfos( this::getSaveName, (integer) -> "Save." + integer, 1, 99, mapBox, saves); }
@Override public Consumer<LinkedList<Entry>> createEngineTools() { return new RMTools(app).andThen(new R2kTools(app)); }
@Override protected String mapObjectIDToSchemaID(String objectID) { if (objectID.endsWith(".lmt")) return "RPG::MapTree"; if (objectID.endsWith(".lmu")) return "RPG::Map"; if (objectID.endsWith(".ldb")) return "RPG::Database"; if (objectID.endsWith(".lsd")) return "RPG::Save"; return super.mapObjectIDToSchemaID(objectID); }
private @Nullable IRIO tsoById(long id) { return app.odb .getObject("RPG_RT.ldb") .getObject() .getIVar("@tilesets") .getHashVal(DMKey.of(id)); }
private StuffRenderer rendererFromMapAndTso( IRIO map, IRIO tileset, IEventAccess events, LcfTileRenderer tileRenderer) { IEventGraphicRenderer eventRenderer = new R2kEventGraphicRenderer(app, imageLoader, tileRenderer); return new StuffRenderer(app, imageLoader, tileRenderer, eventRenderer); }
@Override public StuffRenderer rendererFromTso(IRIO tso) { LcfTileRenderer tileRenderer = new LcfTileRenderer(app, imageLoader); tileRenderer.checkReloadTSO(tso); IEventGraphicRenderer eventRenderer = new R2kEventGraphicRenderer(app, imageLoader, tileRenderer); return new StuffRenderer(app, imageLoader, tileRenderer, eventRenderer); }
@Override public void dumpCustomData(RMTranscriptDumper dumper) { dumper.startFile("RPG_RT.ldb", T.h.systemDsc); IRIO sys = app.odb.getObject("RPG_RT.ldb").getObject(); dumper.dumpSVListHash("@switches", sys.getIVar("@switches")); dumper.dumpSVListHash("@variables", sys.getIVar("@variables")); dumper.endFile(); }
@Override public String mapReferentToGUM(IRIO mapReferent) { return R2kRMLikeMapInfoBackend.sTranslateToGUM(app, (int) mapReferent.getFX()); }
@Override public MapViewState rebuild() { int mapId = (int) root.getObject().getIVar("@party_pos").getIVar("@map").getFX(); final String objn = R2kRMLikeMapInfoBackend.sNameFromInt(mapId); ObjectRootHandle map = app.odb.getObject(objn); final IEventAccess events = new R2kSavefileEventAccess(app, obj, root, "RPG::Save"); if (map == null) return MapViewState.getBlank(app, null, new String[] {objn}, events); long currentTsId = map.getObject().getIVar("@tileset_id").getFX(); IRIO lastTileset = tsoById(currentTsId); tileRenderer.checkReloadTSO(lastTileset); long scrollFlags = map.getObject().getIVar("@scroll_type").getFX(); boolean tileLoopX = (scrollFlags & 2) != 0; boolean tileLoopY = (scrollFlags & 1) != 0; StuffRenderer renderer = rendererFromMapAndTso(map.getObject(), lastTileset, events, tileRenderer); IMapViewDrawLayer[] layers = createLayersForMap(renderer, map.getObject(), lastTileset, events); return MapViewState.fromRT( renderer, layers, null, objn, new String[] {objn, "RPG_RT.ldb"}, map.getObject(), "@data", true, events, tileLoopX, tileLoopY); }
@Override public IEditingToolbarController makeToolbar(IMapToolContext context) { return new MapEditingToolbarController(context, true); }
@Override public MapViewState rebuild() { return mvd.rebuild(); }
@Override public IEditingToolbarController makeToolbar(IMapToolContext context) { return new R2kAreaEditingToolbarController(context, root, mapInfo); }
@Override public MapViewState rebuild() { long currentTsId = map.getObject().getIVar("@tileset_id").getFX(); IRIO lastTileset = tsoById(currentTsId); tileRenderer.checkReloadTSO(lastTileset); long scrollFlags = map.getObject().getIVar("@scroll_type").getFX(); boolean tileLoopX = (scrollFlags & 2) != 0; boolean tileLoopY = (scrollFlags & 1) != 0; StuffRenderer renderer = rendererFromMapAndTso(map.getObject(), lastTileset, iea, tileRenderer); IMapViewDrawLayer[] layers = createLayersForMap(renderer, map.getObject(), lastTileset, iea); return MapViewState.fromRT( renderer, layers, null, objn, new String[] {"RPG_RT.ldb"}, map.getObject(), "@data", false, iea, tileLoopX, tileLoopY); }
@Override public String toString() { return tr.bConfigV; }
@Override public String toString() { return tr.bSelectEngine; }
@Override public String toString() { return tr.bCredits; }
@Override public Long apply(Long aLong) { int gms = (int) (long) aLong; if (gms < 1) gms = 1; lun.globalMS = gms; return (long) gms; }
@Override public void modified() { super.modified(); ConfigIO.save(c); }
@Override public boolean requestsUnparenting() { return gamepaksRequestClose; }
public void requestClose() { gamepaksRequestClose = true; }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { super.update(deltaTime, selected, peripherals); if (peripherals instanceof IDesktopPeripherals) { IDesktopPeripherals dph = (IDesktopPeripherals) peripherals; if (dph.isKeyDown(IGrInDriver.VK_CONTROL) && dph.isKeyJustPressed(IGrInDriver.VK_I)) { counterForTree++; if (counterForTree == 3) { counterForTree = 0; StringWriter sw = new StringWriter(); DatumWriter dw = new DatumWriter(sw); debugDumpUITree(dw); GaBIEn.clipboard.copyText(sw.toString()); } } } }
private static void checkFailBrutally(String locale) { String checkme = System.getenv("R48_DEBUG_PLEASE_FAIL_BRUTALLY"); if (checkme != null) if (checkme.equals(locale)) throw new RuntimeException("told to fail at " + locale); }
public static void checkFailBrutallyAtSplash() { checkFailBrutally("splash"); }
public static void checkFailBrutallyAtLoader() { checkFailBrutally("loader"); }
public static void checkFailBrutallyAtAppInit() { checkFailBrutally("appinit"); }
public void refresh() { LinkedList<UIElement> uie = new LinkedList<>(); for (final String v : values) { UITextButton mainButton = new UITextButton( v, c.f.launcherTH, () -> { text.setText(v); values.remove(v); values.add(v); modified(); }); uie.add( new UIAppendButton( " - ", mainButton, () -> { values.remove(v); modified(); }, c.f.launcherTH)); } uie.add(appendButton); layout.panelsSet(uie); }
public static void gabienmain() { if (!GaBIEn.hasStoragePermission()) Android23.run(); Launcher lun = new Launcher(false); lun.run(); }
@Override public String toString() { return "Error..."; }
@Override public void accept(String t) { ConcurrentLinkedQueue<String> get = consoletronDataInput; if (get != null) get.add(t); }
@Override public void update(double deltaTime, boolean selected, IPeripherals peripherals) { if (ackDoneInjector == 0) if (doneInjector.get() != null) ackDoneInjector = 1; ConcurrentLinkedQueue<String> get = consoletronDataInput; if (get != null) { String didThing = null; while (true) { String st = get.poll(); if (st != null) { didThing = st; } else { break; } } if (didThing != null) layout.setText(didThing); } super.update(deltaTime, selected, peripherals); }
@Override public void renderLayer(IGrDriver igd, UILayer layer) { super.renderLayer(igd, layer); if (layer == UILayer.Content) if (ackDoneInjector >= 1) ackDoneInjector++; }
@Override public boolean requestsUnparenting() { return ackDoneInjector == 10; }
@Override public void onWindowClose() { consoletronDataInput = null; while (true) { try { Runnable r = doneInjector.get(); if (r != null) { r.run(); return; } Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }
public void run() { while (currentState != null) { double dTTarg = (globalMS / 1000d) - compensationDT; double dT = GaBIEn.endFrame(dTTarg); compensationDT = Math.min(dTTarg, dT - dTTarg); currentState.tick(dT); } GaBIEn.ensureQuit(); }
void shutdownAllAppMainWindows() { for (UIElement uie : uiTicker.runningWindows()) uiTicker.forceRemove(uie); }
@Override public DynTrBase dynTrBase( DatumSrcLoc srcLoc, String id, @Nullable DatumSymbol mode, Object text, boolean isNLS) { return lun.ilg.dynTrBase(srcLoc, id, mode, text, isNLS); }
@Override public void tick(double dT) { if (lun.uiTicker.runningWindows().size() == 0) { if (app != null) app.shutdown(); lun.currentState = null; if (errorHandler.failed != null) return; lun.currentState = new LSMain(lun); return; } try { if (!disableAppTicker) if (app != null) app.tick(dT); lun.uiTicker.runTick(dT); } catch (Exception e) { if (errorHandler.handle(app, e, lun.uiTicker)) { for (UIElement uie : lun.uiTicker.runningWindows()) { if (uie != errorHandler.failed) { try { lun.uiTicker.forceRemove(uie); } catch (Exception e3) { } } } disableAppTicker = true; try { if (app != null) app.shutdown(); } catch (Exception e4) { } } } }
@Override public void tick(double dT) { if (lun.uiTicker.runningWindows().size() == 0) { lun.currentState = null; return; } try { lun.uiTicker.runTick(dT); } catch (Exception e) { if (errorHandler.handle(null, e, lun.uiTicker)) { for (UIElement uie : lun.uiTicker.runningWindows()) { if (uie != errorHandler.failed) { try { lun.uiTicker.forceRemove(uie); } catch (Exception e3) { } } } } } }
@Test public void testNumbers() { testAlways(MVMU::eqQ); testAlways(MVMU::eqvQ); testAlways(MVMU::equalQ); assertFalse(MVMU.eqQ(MVMU.l(1L, 2L, 3L), MVMU.l(1L, 2L, 3L))); assertFalse(MVMU.eqvQ(MVMU.l(1L, 2L, 3L), MVMU.l(1L, 2L, 3L))); assertTrue(MVMU.equalQ(MVMU.l(1L, 2L, 3L), MVMU.l(1L, 2L, 3L))); assertTrue(MVMU.equalQ(MVMU.l(1L, 2L, 3L), MVMU.l(1L, 2L, 3L))); }
public void testAlways(EqPredicate eqp) { assertTrue(eqp.test(1L, 1L)); assertFalse(eqp.test(2L, 1L)); assertFalse(eqp.test(1L, 2L)); assertTrue(eqp.test(1d, 1d)); assertFalse(eqp.test(2d, 1d)); assertFalse(eqp.test(1d, 2d)); assertFalse(eqp.test("A", "B")); assertTrue(eqp.test('A', 'A')); assertFalse(eqp.test('A', 'B')); }
@Test public void testObvious() { assertTrue(MVMType.OBJ.canImplicitlyCastFrom(MVMType.LIST)); assertTrue(MVMType.OBJ.canImplicitlyCastFrom(MVMType.ANY)); assertFalse(MVMType.LIST.canImplicitlyCastFrom(MVMType.OBJ)); assertTrue(MVMType.LIST.canImplicitlyCastFrom(MVMType.ANY)); assertTrue(MVMType.ANY.canImplicitlyCastFrom(MVMType.OBJ)); assertTrue(MVMType.ANY.canImplicitlyCastFrom(MVMType.LIST)); assertTrue(new MVMType.TypedList(MVMType.I64).canImplicitlyCastTo(MVMType.LIST)); }
public static MVMEnv prepEnv() { MVMEnv env = new MVMEnv(); MVMCoreLibraries.add(env); return env; }
public static void disasm(MVMEnv env, String p, String sym) { System.out.println(p + ": " + MVMU.userStr(env.evalString("(mvm-disasm " + sym + ")"))); }
@Test public void testConstants() { MVMEnv env = prepEnv(); assertEquals(1L, env.evalString("1")); }
@Test public void testQuote() { MVMEnv env = prepEnv(); assertEquals(Arrays.asList(sym("example"), 1L), env.evalString("(quote (example 1))")); }
@Test public void testTopLevelDefines() { MVMEnv env = prepEnv(); assertEquals( Arrays.asList(sym("example"), 1L), env.evalString("(define testsym (quote (example 1)))")); assertEquals(Arrays.asList(sym("example"), 1L), env.evalString("testsym")); }
@Test public void testTopLevelDefinedFunctions() { MVMEnv env = prepEnv(); env.evalString("(define (testsym a) a)"); disasm(env, "testTopLevelDefinedFunctions", "testsym"); assertEquals( Arrays.asList(sym("example"), 1L), env.evalString("(testsym (quote (example 1)))")); }
@Test public void testLambdas() { MVMEnv env = prepEnv(); env.evalString("(define (testsym) (lambda () (define test 123) (lambda () test)))"); disasm(env, "testLambdas", "testsym"); assertEquals(123L, env.evalString("(((testsym)))")); }
@Test public void testLambdasVA() { MVMEnv env = prepEnv(); env.evalString("(define (list . v) v)"); env.evalString("(define (va0 . a0) (list a0))"); env.evalString("(define (va1 a0 . a1) (list a0 a1))"); env.evalString("(define (va2 a0 a1 . a2) (list a0 a1 a2))"); env.evalString("(define (va3 a0 a1 a2 . a3) (list a0 a1 a2 a3))"); env.evalString("(define (va4 a0 a1 a2 a3 . a4) (list a0 a1 a2 a3 a4))"); env.evalString("(define (va5 a0 a1 a2 a3 a4 . a5) (list a0 a1 a2 a3 a4 a5))"); assertEquals(MVMU.l(MVMU.l(0L)), env.evalString("(va0 0)")); assertEquals(MVMU.l(0L, MVMU.l(1L)), env.evalString("(va1 0 1)")); assertEquals(MVMU.l(0L, 1L, MVMU.l(2L)), env.evalString("(va2 0 1 2)")); assertEquals(MVMU.l(0L, 1L, 2L, MVMU.l(3L)), env.evalString("(va3 0 1 2 3)")); assertEquals(MVMU.l(0L, 1L, 2L, 3L, MVMU.l(4L)), env.evalString("(va4 0 1 2 3 4)")); assertEquals(MVMU.l(0L, 1L, 2L, 3L, 4L, MVMU.l(5L)), env.evalString("(va5 0 1 2 3 4 5)")); }
@Test public void testMacros() { MVMEnv env = prepEnv(); env.evalString("(define (list . v) v)"); env.evalString("(define-syntax (teu c b a) (list a b c))"); env.evalString("(define (test-teu) (teu 6 5 +))"); assertEquals(11L, env.evalString("(test-teu)")); disasm(env, "testMacros", "test-teu"); }
@Test public void testRoundtrip() { MVMEnv env = MVMTests.prepEnv(); assertEquals("Test string", env.evalString("(list->string (string->list \"Test string\"))")); }
@Test public void testSubstring() { MVMEnv env = MVMTests.prepEnv(); assertEquals("strin", env.evalString("(substring \"Test string\" 5 10)")); }
public Object get(int f, int i) { Object[] base = slots[f]; return base[i]; }
public void set(int f, int i, Object v) { Object[] base = slots[f]; base[i] = v; }
public final DatumSymbol gensym() { return new DatumSymbol(" g" + (gensymCounter.getAndIncrement())); }
public Object evalString(String str) { return evalString(str, "REPL"); }
public Object evalString(String str, String src) { AtomicReference<Object> ar = new AtomicReference<>(); new DatumReaderTokenSource(src, str) .visit( decVisitor( (obj, srcLoc) -> { ar.set(evalObject(obj, srcLoc)); })); return ar.get(); }
public Object evalObject(Object obj, DatumSrcLoc srcLoc) { try { MVMCompileScope mcs = new MVMToplevelScope(this, srcLoc); MVMCExpr exp = mcs.compile(obj); return exp.exc(MVMScope.ROOT); } catch (Exception ex) { throw new RuntimeException("at " + srcLoc, ex); } }
public void defineType(DatumSymbol d, MVMType type) { types.put(d, type); }
public @NonNull MVMSlot ensureSlot(DatumSymbol d) { MVMSlot res = getSlot(d); if (res != null) return res; return defineSlot(d); }
public @NonNull MVMSlot defineSlot(DatumSymbol d) { return defineSlot(d, null, MVMType.ANY); }
public @NonNull MVMSlot defineSlot(DatumSymbol d, Object v) { return defineSlot(d, v, MVMType.typeOf(v)); }
public @NonNull MVMSlot defineSlot(DatumSymbol d, Object v, MVMType t) { if (values.containsKey(d)) throw new RuntimeException("Cannot redefine: " + d); MVMSlot s = new MVMSlot(d, t); s.v = v; values.put(d, s); return s; }
public Collection<MVMSlot> listSlots() { return values.values(); }
public MVMFn defLib(String s, MVMType rt, Supplier<Object> fn, String help) { MVMFn f2 = MVMJLambdaConv.c(s, rt, fn); defineSlot(new DatumSymbol(s), f2).help(help); return f2; }
public MVMFn defLib(String s, MVMType rt, MVMType t0, Function<Object, Object> fn, String help) { MVMFn f2 = MVMJLambdaConv.c(s, rt, t0, fn); defineSlot(new DatumSymbol(s), f2).help(help); return f2; }
public MVMFn defLib( String s, MVMType rt, MVMType t0, MVMType t1, MVMJLambdaConv.F2 fn, String help) { MVMFn f2 = MVMJLambdaConv.c(s, rt, t0, t1, fn); defineSlot(new DatumSymbol(s), f2).help(help); return f2; }
public MVMFn defLib( String s, MVMType rt, MVMType t0, MVMType t1, MVMType t2, MVMJLambdaConv.F3 fn, String help) { MVMFn f2 = MVMJLambdaConv.c(s, rt, t0, t1, t2, fn); defineSlot(new DatumSymbol(s), f2).help(help); return f2; }
public MVMFn defLib( String s, MVMType rt, MVMType t0, MVMType t1, MVMType t2, MVMType t3, MVMJLambdaConv.F4 fn, String help) { MVMFn f2 = MVMJLambdaConv.c(s, rt, t0, t1, t2, t3, fn); defineSlot(new DatumSymbol(s), f2).help(help); return f2; }
public void install(Object lib) { Harvester.harvest(this, lib); }
public static long cLong(Object v) { return (Long) v; }
public static int cInt(Object v) { return (int) (long) (Long) v; }
@SuppressWarnings("unchecked") public static List<Object> cList(Object o) { return (List<Object>) o; }
public static String userStr(Object v) { try { return DatumWriter.objectToString(v); } catch (Exception ex) { if (v == null) { return "?congratulations, it broke"; } else { try { return "?" + v.toString(); } catch (Exception ex2) { return "?toString error in " + v.getClass(); } } } }
public static String coerceToString(Object object) { if (object instanceof String) return (String) object; if (object instanceof DatumSymbol) return ((DatumSymbol) object).id; return object.toString(); }
public static LinkedList<Object> l() { return new LinkedList<>(); }
public static LinkedList<Object> l(Object a) { LinkedList<Object> ll = new LinkedList<>(); ll.add(a); return ll; }
public static LinkedList<Object> l(Object a, Object b) { LinkedList<Object> ll = new LinkedList<>(); ll.add(a); ll.add(b); return ll; }
public static LinkedList<Object> l(Object a, Object b, Object c) { LinkedList<Object> ll = new LinkedList<>(); ll.add(a); ll.add(b); ll.add(c); return ll; }
public static LinkedList<Object> l(Object a, Object b, Object c, Object d) { LinkedList<Object> ll = new LinkedList<>(); ll.add(a); ll.add(b); ll.add(c); ll.add(d); return ll; }
public static LinkedList<Object> l(Object a, Object b, Object c, Object d, Object... e) { LinkedList<Object> ll = new LinkedList<>(); ll.add(a); ll.add(b); ll.add(c); ll.add(d); for (Object obj : e) ll.add(obj); return ll; }
public static LinkedList<Object> lArr(Object[] args) { LinkedList<Object> ll = new LinkedList<>(); for (Object o : args) ll.add(o); return ll; }
public static LinkedList<Object> lArr(Object[] args, int base, int length) { LinkedList<Object> ll = new LinkedList<>(); for (int i = 0; i < length; i++) ll.add(args[base + i]); return ll; }
public static LinkedList<Object> lArr(Object a, Object[] args) { LinkedList<Object> ll = new LinkedList<>(); ll.add(a); for (Object o : args) ll.add(o); return ll; }
public static LinkedList<Object> lArr(Object a, Object b, Object[] args) { LinkedList<Object> ll = new LinkedList<>(); ll.add(a); ll.add(b); for (Object o : args) ll.add(o); return ll; }
public static LinkedList<Object> lArr(Object a, Object b, Object c, Object[] args) { LinkedList<Object> ll = new LinkedList<>(); ll.add(a); ll.add(b); ll.add(c); for (Object o : args) ll.add(o); return ll; }
public static LinkedList<Object> lArr(Object a, Object b, Object c, Object d, Object[] args) { LinkedList<Object> ll = new LinkedList<>(); ll.add(a); ll.add(b); ll.add(c); ll.add(d); for (Object o : args) ll.add(o); return ll; }
public static boolean isTruthy(Object v) { return !((v instanceof Boolean) && (false == (Boolean) v)); }
public static boolean isFalsy(Object v) { return (v instanceof Boolean) && (false == (Boolean) v); }
public static boolean eqQ(Object a, Object b) { if (a instanceof Long || a instanceof Double || a instanceof Boolean || a instanceof Character || a instanceof DatumSymbol) { return a.equals(b); } return a == b; }
public static boolean eqvQ(Object a, Object b) { if (a instanceof Long || a instanceof Double || a instanceof Boolean || a instanceof Character || a instanceof DatumSymbol || a instanceof String) { return a.equals(b); } return a == b; }
public static boolean equalQ(Object a, Object b) { if (a instanceof List && b instanceof List) { @SuppressWarnings("unchecked") List<Object> la = ((List<Object>) a); @SuppressWarnings("unchecked") List<Object> lb = ((List<Object>) b); if (la.size() != lb.size()) return false; Iterator<Object> ia = la.iterator(); Iterator<Object> ib = lb.iterator(); while (ia.hasNext()) if (!equalQ(ia.next(), ib.next())) return false; return true; } if (a == null) return a == b; return a.equals(b); }
@Override protected boolean canImplicitlyCastFromImpl(MVMType other) { return true; }
@Override protected boolean canImplicitlyCastToImpl(MVMType other) { return true; }
@Override public String toString() { return "type.any"; }
public static MVMType typeOf(@Nullable Object v) { if (v == null) return ANY; if (v instanceof IMVMTypable) return ((IMVMTypable) v).getMVMType(); return typeOfClass(v.getClass()); }
public static MVMType typeOfClass(@NonNull Class<?> cls) { if (cls == boolean.class) return BOOL; if (cls == long.class) return I64; if (cls == double.class) return F64; if (cls == char.class) return CHAR; MVMType typeA = classMap.get(cls); if (typeA != null) return typeA; synchronized (classMap) { typeA = classMap.get(cls); if (typeA != null) return typeA; typeA = new Clazz(cls); classMap.put(cls, typeA); return typeA; } }
public final void assertCanImplicitlyCastTo(@NonNull MVMType type, Object context) { if (!canImplicitlyCastTo(type)) throw new RuntimeException( "Cannot implicitly cast " + this + " to " + type + " at " + context); }
public final void assertCanImplicitlyCastFrom(@NonNull MVMType type, Object context) { if (!canImplicitlyCastFrom(type)) throw new RuntimeException( "Cannot implicitly cast " + type + " to " + this + " at " + context); }
public final boolean canImplicitlyCastFrom(@NonNull MVMType other) { if (other == this) return true; return canImplicitlyCastFromImpl(other) || other.canImplicitlyCastToImpl(this); }
public final boolean canImplicitlyCastTo(@NonNull MVMType other) { if (other == this) return true; return canImplicitlyCastToImpl(other) || other.canImplicitlyCastFromImpl(this); }
@Override public int hashCode() { return cls.hashCode(); }
@Override protected boolean canImplicitlyCastFromImpl(MVMType other) { if (other instanceof Clazz) return cls.isAssignableFrom(((Clazz) other).cls); return false; }
@Override protected boolean canImplicitlyCastToImpl(MVMType other) { if (other instanceof Clazz) return ((Clazz) other).cls.isAssignableFrom(cls); return false; }
@Override public String toString() { return "type." + cls.getSimpleName(); }
@Override public int hashCode() { return content.hashCode(); }
@Override public boolean equals(Object obj) { if (obj == this) return true; if (obj instanceof TypedList) { TypedList lt = (TypedList) obj; return lt.content.equals(content); } return false; }
@Override protected boolean canImplicitlyCastFromImpl(MVMType other) { if (other instanceof TypedList) return content.canImplicitlyCastFrom(((TypedList) other).content); return false; }
@Override protected boolean canImplicitlyCastToImpl(MVMType other) { if (other instanceof TypedList) return content.canImplicitlyCastTo(((TypedList) other).content); return false; }
@Override public String toString() { return "list." + content; }
public static MVMType of(MVMType a, MVMType b, boolean forgiving) { if (!forgiving) { if (a.canImplicitlyCastFrom(b)) return a; if (b.canImplicitlyCastFrom(a)) return b; } else if (a.canImplicitlyCastFrom(b) && b.canImplicitlyCastFrom(a)) return a; return new Union(a, b, forgiving); }
@Override public boolean equals(Object obj) { if (obj instanceof Union) if (canImplicitlyCastFrom((MVMType) a) && canImplicitlyCastTo((MVMType) a)) return true; return false; }
@Override protected boolean canImplicitlyCastFromImpl(MVMType other) { return a.canImplicitlyCastFrom(other) || b.canImplicitlyCastFrom(other); }
@Override protected boolean canImplicitlyCastToImpl(MVMType other) { if (forgiving) return a.canImplicitlyCastTo(other) || b.canImplicitlyCastTo(other); return a.canImplicitlyCastTo(other) && b.canImplicitlyCastTo(other); }
@Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(a); sb.append("|"); sb.append(b); return sb.toString(); }
public static Fn simple(MVMType res, MVMType... args) { return new Fn(res, args.length, args, null); }
@Override public boolean equals(Object obj) { return this == obj; }
@Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append("fn["); for (MVMType t : args) { sb.append(t); sb.append(","); } if (vaType != null) { sb.append(vaType); sb.append("..."); } sb.append("]->"); sb.append(returnType); return sb.toString(); }
public @Nullable MVMType argAt(int idx) { if (idx < args.length) return args[idx]; return vaType; }
@Override protected boolean canImplicitlyCastFromImpl(MVMType other) { if (other instanceof Fn) { Fn o = (Fn) other; if (!returnType.canImplicitlyCastFrom(o.returnType)) return false; if (((Fn) other).minArgs > minArgs) return false; int relevantArgCount = args.length; if (o.args.length > relevantArgCount) relevantArgCount = o.args.length; relevantArgCount++; for (int i = 0; i < relevantArgCount; i++) { MVMType us = argAt(i); MVMType them = o.argAt(i); if (us == null) break; if (them == null) return false; if (!them.canImplicitlyCastFrom(us)) return false; } return true; } return false; }
@Override protected boolean canImplicitlyCastToImpl(MVMType other) { if (other instanceof Fn) return other.canImplicitlyCastFromImpl(this); return false; }
@Override protected boolean canImplicitlyCastFromImpl(MVMType other) { return false; }
@Override protected boolean canImplicitlyCastToImpl(MVMType other) { return other.canImplicitlyCastFrom(baseType); }
public MVMSlot help(@Nullable String text) { help = text; return this; }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { return v; }
@Override public Object disasm() { return MVMU.l(sym("slot"), s, sym(type.toString())); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { MVMFn mvmFn = asFn(call.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7)); return mvmFn.clDirect(); }
@Override public Object disasm() { return makeDisassembly(call, exprs); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { MVMFn mvmFn = asFn(call.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7)); Object v0 = exprs[0].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); return mvmFn.clDirect(v0); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { MVMFn mvmFn = asFn(call.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7)); Object v0 = exprs[0].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); Object v1 = exprs[1].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); return mvmFn.clDirect(v0, v1); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { MVMFn mvmFn = asFn(call.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7)); Object v0 = exprs[0].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); Object v1 = exprs[1].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); Object v2 = exprs[2].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); return mvmFn.clDirect(v0, v1, v2); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { MVMFn mvmFn = asFn(call.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7)); Object v0 = exprs[0].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); Object v1 = exprs[1].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); Object v2 = exprs[2].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); Object v3 = exprs[3].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); return mvmFn.clDirect(v0, v1, v2, v3); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { MVMFn mvmFn = asFn(call.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7)); Object[] v = new Object[exprs.length]; for (int i = 0; i < v.length; i++) v[i] = exprs[i].execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); return mvmFn.clIndirect(v); }
public static Object makeDisassembly(MVMCExpr call, MVMCExpr[] exprs) { LinkedList<Object> obj = new LinkedList<>(); obj.add(sym("call")); obj.add(call.disasm()); for (MVMCExpr ex : exprs) obj.add(ex.disasm()); return obj; }
public static MVMFn asFn(Object execute) { return (MVMFn) execute; }
@Override public MVMCExpr compileDefine(DatumSymbol sym, Supplier<MVMCExpr> value) { MVMSlot slot = context.ensureSlot(sym); try { MVMCExpr expr = value.get(); slot.type = expr.returnType; return new MVMCSetSlot(slot, expr); } catch (Exception ex) { throw new RuntimeException("during " + sym + " definition", ex); } }
@Override public MVMCExpr compileDefine(DatumSymbol sym, MVMType type, Supplier<MVMCExpr> value) { MVMSlot slot = context.ensureSlot(sym); slot.type.assertCanImplicitlyCastFrom(type, "compileDefine of " + sym); slot.type.assertCanImplicitlyCastTo(type, "compileDefine of " + sym); slot.type = type; try { return new MVMCSetSlot(slot, value.get()); } catch (Exception ex) { throw new RuntimeException("during " + sym + " definition", ex); } }
@Override public MVMSubScope extendWithFrame() { return new MVMSubScope(this); }
@Override public MVMSubScope extendMayFrame() { return new MVMSubScope(this); }
public MVMCLocal newLocal(@NonNull DatumSymbol aSym, @NonNull MVMType type) { LocalRoot lr = new LocalRoot(type); locals.put(aSym, lr); return lr.local; }
@Override public MVMCExpr readLookup(DatumSymbol ds) { Local lcl = locals.get(ds); if (lcl != null) return lcl.getter(false); return super.readLookup(ds); }
@Override public MVMCExpr writeLookup(DatumSymbol ds, MVMCExpr compile) { Local lcl = locals.get(ds); if (lcl != null) return lcl.setter(compile); return super.writeLookup(ds, compile); }
@Override public MVMCExpr compileDefine(DatumSymbol sym, Supplier<MVMCExpr> value) { LocalRoot local = new LocalRoot(MVMType.ANY); locals.put(sym, local); MVMCExpr res = value.get(); local.local.type = res.returnType; return local.setter(res); }
@Override public MVMCExpr compileDefine(DatumSymbol sym, MVMType type, Supplier<MVMCExpr> value) { LocalRoot local = new LocalRoot(type); locals.put(sym, local); return local.setter(value.get()); }
@Override public MVMSubScope extendWithFrame() { return new MVMSubScope(this, true); }
@Override public MVMSubScope extendMayFrame() { return new MVMSubScope(this, false); }
@Override public int occupiesLocalFVSlot() { return local.getFastSlot(); }
@Override public Local wrapFVBarrier() { return new LocalFVBarrier(this); }
public void deoptimize() { if (local.getFastSlot() != -1) frame.allocateLocal(local); }
@Override public MVMCExpr getter(boolean isPastFVBarrier) { if (isPastFVBarrier) deoptimize(); return local.read(); }
@Override public MVMCExpr setter(MVMCExpr val) { deoptimize(); return local.write(val); }
@Override public int occupiesLocalFVSlot() { return -1; }
@Override public Local wrapFVBarrier() { return this; }
public MVMCExpr getter(boolean isPastFVBarrier) { return base.getter(true); }
@Override public MVMCExpr setter(MVMCExpr val) { return base.setter(val); }
public void allocateLocal(MVMCLocal local) { markExpectedToExist(); local.deoptimizeInto(frameID, allocatedLocals++); }
public MVMCLocal allocateLocal(@NonNull MVMType type) { markExpectedToExist(); return new MVMCLocal(frameID, allocatedLocals++, type); }
public static MVMScope wrapRuntimeScope(@Nullable MVMCompileFrame frame, MVMScope scope) { if (frame == null) return scope; return frame.expectedToExist ? new MVMScope(scope, frame.frameID, frame.allocatedLocals) : scope; }
public void markExpectedToExist() { expectedToExist = true; }
public boolean isExpectedToExist() { return expectedToExist; }
public MVMCExpr readLookup(DatumSymbol ds) { MVMSlot s = context.getSlot(ds); if (s != null) return s; throw new RuntimeException("Undefined symbol: " + ds); }
public MVMCExpr writeLookup(DatumSymbol ds, MVMCExpr compile) { MVMSlot s = context.getSlot(ds); if (s != null) return new MVMCSetSlot(s, compile); throw new RuntimeException("Undefined symbol: " + ds); }
@Override protected Object callDirect() { return ""; }
@Override protected Object callDirect(Object a0) { return (String) a0; }
@Override protected Object callDirect(Object a0, Object a1) { String x0 = (String) a0; int l0 = x0.length(); String x1 = (String) a1; int l1 = x1.length(); char[] total = new char[l0 + l1]; int ptr = 0; x0.getChars(0, l0, total, 0); ptr += l0; x1.getChars(0, l1, total, ptr); return new String(total); }
@Override protected Object callDirect(Object a0, Object a1, Object a2) { String x0 = (String) a0; int l0 = x0.length(); String x1 = (String) a1; int l1 = x1.length(); String x2 = (String) a2; int l2 = x2.length(); char[] total = new char[l0 + l1 + l2]; int ptr = 0; x0.getChars(0, l0, total, 0); ptr += l0; x1.getChars(0, l1, total, ptr); ptr += l1; x2.getChars(0, l2, total, ptr); return new String(total); }
@Override protected Object callDirect(Object a0, Object a1, Object a2, Object a3) { String x0 = (String) a0; int l0 = x0.length(); String x1 = (String) a1; int l1 = x1.length(); String x2 = (String) a2; int l2 = x2.length(); String x3 = (String) a3; int l3 = x3.length(); char[] total = new char[l0 + l1 + l2 + l3]; int ptr = 0; x0.getChars(0, l0, total, 0); ptr += l0; x1.getChars(0, l1, total, ptr); ptr += l1; x2.getChars(0, l2, total, ptr); ptr += l2; x3.getChars(0, l3, total, ptr); return new String(total); }
@Override protected Object callIndirect(Object[] args) { int len = 0; for (Object obj : args) len += ((String) obj).length(); char[] total = new char[len]; int ptr = 0; for (Object obj : args) { String s = (String) obj; s.getChars(0, s.length(), total, ptr); ptr += s.length(); } return new String(total); }
@Override public Object callDirect(Object a0) { return core((Number) a0, 10); }
@Override public Object callDirect(Object a0, Object a1) { return core((Number) a0, MVMU.cInt(a1)); }
public String core(Number a0, int radix) { if (a0 instanceof Double) { if (radix != 10) throw new RuntimeException("can't convert float/double to non-decimal"); return Double.toString(a0.doubleValue()); } return Long.toString((Long) a0, radix); }
@Override public Object callDirect(Object a0) { return core((String) a0, 10); }
@Override public Object callDirect(Object a0, Object a1) { return core((String) a0, MVMU.cInt(a1)); }
public Object core(String s, int radix) { try { return Long.parseLong(s, radix); } catch (Exception ex) { } if (radix != 10) { try { return Double.parseDouble(s); } catch (Exception ex) { } } return false; }
@Override public Object callDirect(Object a0, Object a1, Object a2) { return ((String) a0).substring(MVMU.cInt(a1), MVMU.cInt(a2)); }
@Override public Number checkParticipant(Object v) { return (Number) v; }
@Override public Object loneOp(Number a) { return a; }
@Override public Number twoOp(Number a, Number b) { if (a instanceof Double || b instanceof Double) return a.doubleValue() + b.doubleValue(); return a.longValue() + b.longValue(); }
@Override protected Object callDirect() { return 0L; }
@Override public Object loneOp(Number a) { if (a instanceof Double) return -a.doubleValue(); return -a.longValue(); }
@Override public Number twoOp(Number a, Number b) { if (a instanceof Double || b instanceof Double) return a.doubleValue() - b.doubleValue(); return a.longValue() - b.longValue(); }
public static void add(MVMEnv ctx) { ctx.defineSlot(sym("define"), new Define()) .help( "(define K [TYPE] V) | function define: (define (K ARG... [. VA]) STMT...) : Defines" + " mutable variables or functions. See lambda."); ctx.defineSlot(sym("let"), new Let()) .help( "(let ((K V)...) CODE...) : Creates variables. For constants, more efficient than" + " define."); ctx.defineSlot(sym("lambda"), new Lambda()) .help( "(lambda (ARG... [. VA]) STMT...) : Creates first-class functions. The symbol . splits" + " main args from a var-arg list arg. Args can be symbols or (SYM TYPE) for" + " type-checking."); ctx.defineSlot(sym("set!"), new Set()).help("(set! VAR V) : Sets a variable."); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { return new MVMLambdaVAFn(new MVMLambdaFn(hint, ctx, compiledLambda, roots, rootFrame)); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { return new MVMLambdaFn(hint, ctx, compiledLambda, roots, rootFrame); }
public static MVMCExpr compileFnDefine( MVMCompileScope cs, Object[] call, IFnDefineConverter val) { if (call.length < 1) throw new RuntimeException("define entered function decl handling but wasn't long enough"); if (!(call[0] instanceof List)) throw new RuntimeException( "define entered function decl handling but wasn't a function decl"); @SuppressWarnings("unchecked") List<Object> lo = (List<Object>) call[0]; if (lo.size() == 0) throw new RuntimeException("define with what looked like a function decl but an empty list!"); final Object head = lo.get(0); final Object[] args = new Object[lo.size() - 1]; for (int i = 0; i < args.length; i++) args[i] = lo.get(i + 1); return compileIndividualDefine(cs, head, () -> val.convert(head, args)); }
public static MVMCExpr compileIndividualDefine( MVMCompileScope cs, Object k, Supplier<MVMCExpr> v) { if (!(k instanceof DatumSymbol)) throw new RuntimeException(MVMU.userStr(k) + " expected to be sym"); DatumSymbol k2 = (DatumSymbol) k; try { return cs.compileDefine(k2, v); } catch (Exception ex) { throw new RuntimeException("during '" + k + "' definition", ex); } }
public static MVMCExpr compileIndividualDefine( MVMCompileScope cs, Object k, Object t, Supplier<MVMCExpr> v) { if (!(k instanceof DatumSymbol)) throw new RuntimeException(MVMU.userStr(k) + " expected to be sym"); DatumSymbol k2 = (DatumSymbol) k; try { return cs.compileDefine(k2, cs.context.getType(t, "typeof-" + k2.id), v); } catch (Exception ex) { throw new RuntimeException("during '" + k + "' definition", ex); } }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length >= 1) { if (call[0] instanceof List) { return compileFnDefine( cs, call, (head, args) -> lambda(head.toString(), cs, args, call, 1)); } } if (call.length == 0) throw new RuntimeException("can't have empty global define"); if (call.length == 1) throw new RuntimeException("can't have global define with only one arg"); if (call.length == 2) return compileIndividualDefine(cs, call[0], () -> cs.compile(call[1])); if (call.length == 3) return compileIndividualDefine(cs, call[0], call[1], () -> cs.compile(call[2])); throw new RuntimeException("invalid define format"); }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length < 1) throw new RuntimeException("let needs at least the list of bindings"); List<Object> bindings = MVMU.cList(call[0]); LinkedList<MVMCExpr> letExprs = new LinkedList<>(); LinkedList<MVMCLocal> letLocals = new LinkedList<>(); MVMSubScope innerScope = cs.extendMayFrame(); for (Object binding : bindings) { List<Object> b = MVMU.cList(binding); if (b.size() != 2) throw new RuntimeException("let binding must be of 2 elements, name and expression"); Object name = b.get(0); Object expr = b.get(1); MVMCExpr exprC = cs.compile(expr); letLocals.add(innerScope.newLocal((DatumSymbol) name, exprC.returnType)); letExprs.add(exprC); } MVMCExpr inner = MVMCBegin.of(innerScope, call, 1, call.length - 1); return new MVMCLet( letExprs.toArray(new MVMCExpr[0]), letLocals.toArray(new MVMCLocal[0]), innerScope.getFrameIfOwned(), inner); }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length < 1) throw new RuntimeException("Lambda needs at least the args list"); if (!(call[0] instanceof List)) throw new RuntimeException("Lambda args list needs to actually be an args list"); @SuppressWarnings("unchecked") List<Object> args = (List<Object>) call[0]; return lambda(MVMU.userStr(call), cs, args.toArray(), call, 1); }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length != 2) throw new RuntimeException("Set needs variable name and value, no more or less"); return cs.writeLookup((DatumSymbol) call[0], cs.compile(call[1])); }
@Override public Object callDirect() { return fn.get(); }
@Override public Object callDirect(Object a0) { return fn.apply(a0); }
@Override public Object callDirect(Object a0, Object a1) { return fn.apply(a0, a1); }
@Override public Object callDirect(Object a0, Object a1, Object a2) { return fn.apply(a0, a1, a2); }
@Override public Object callDirect(Object a0, Object a1, Object a2, Object a3) { return fn.apply(a0, a1, a2, a3); }
@Override public String toString() { return "lambda-" + fixedArgs + "VA: " + nameHint; }
@Override protected Object callDirect() { if (fixedArgs > 0) throw new RuntimeException("Not enough args to " + this + ", got 0"); else return underlying.callDirect(MVMU.l()); }
@Override protected Object callDirect(Object a0) { if (fixedArgs > 1) throw new RuntimeException("Not enough args to " + this + ", got 1"); else if (fixedArgs == 1) return underlying.callDirect(a0, MVMU.l()); else return underlying.callDirect(MVMU.l(a0)); }
@Override protected Object callDirect(Object a0, Object a1) { if (fixedArgs > 2) throw new RuntimeException("Not enough args to " + this + ", got 2"); else if (fixedArgs == 2) return underlying.callDirect(a0, a1, MVMU.l()); else if (fixedArgs == 1) return underlying.callDirect(a0, MVMU.l(a1)); else return underlying.callDirect(MVMU.l(a0, a1)); }
@Override protected Object callDirect(Object a0, Object a1, Object a2) { if (fixedArgs > 3) throw new RuntimeException("Not enough args to " + this + ", got 3"); else if (fixedArgs == 3) return underlying.callDirect(a0, a1, a2, MVMU.l()); else if (fixedArgs == 2) return underlying.callDirect(a0, a1, MVMU.l(a2)); else if (fixedArgs == 1) return underlying.callDirect(a0, MVMU.l(a1, a2)); else return underlying.callDirect(MVMU.l(a0, a1, a2)); }
@Override protected Object callDirect(Object a0, Object a1, Object a2, Object a3) { if (fixedArgs > 4) throw new RuntimeException("Not enough args to " + this + ", got 4"); else if (fixedArgs == 4) return underlying.callL5(a0, a1, a2, a3, MVMU.l()); else if (fixedArgs == 3) return underlying.callDirect(a0, a1, a2, MVMU.l(a3)); else if (fixedArgs == 2) return underlying.callDirect(a0, a1, MVMU.l(a2, a3)); else if (fixedArgs == 1) return underlying.callDirect(a0, MVMU.l(a1, a2, a3)); else return underlying.callDirect(MVMU.l(a0, a1, a2, a3)); }
@Override protected Object callIndirect(Object[] args) { if (args.length < fixedArgs) throw new RuntimeException("Not enough args to " + this + ", got " + fixedArgs); if (fixedArgs > 4) { List<Object> p2 = MVMU.lArr(args, fixedArgs, args.length - fixedArgs); Object[] argv = new Object[fixedArgs + 1]; System.arraycopy(args, 0, argv, 0, fixedArgs); argv[fixedArgs] = p2; return underlying.callIndirect(argv); } else if (fixedArgs == 4) return underlying.callL5( args[0], args[1], args[2], args[3], MVMU.lArr(args, 4, args.length - 4)); else if (fixedArgs == 3) return underlying.callDirect(args[0], args[1], args[2], MVMU.lArr(args, 3, args.length - 3)); else if (fixedArgs == 2) return underlying.callDirect(args[0], args[1], MVMU.lArr(args, 2, args.length - 2)); else if (fixedArgs == 1) return underlying.callDirect(args[0], MVMU.lArr(args, 1, args.length - 1)); else return underlying.callDirect(MVMU.lArr(args)); }
protected RuntimeException cError(Exception ex2) { RuntimeException ex = new RuntimeException("@" + nameHint, ex2); ex.setStackTrace(new StackTraceElement[0]); return ex; }
public final Object clDirect() { try { return callDirect(); } catch (Exception ex) { throw cError(ex); } }
public final Object clDirect(Object a0) { try { return callDirect(a0); } catch (Exception ex) { throw cError(ex); } }
public final Object clDirect(Object a0, Object a1) { try { return callDirect(a0, a1); } catch (Exception ex) { throw cError(ex); } }
public final Object clDirect(Object a0, Object a1, Object a2) { try { return callDirect(a0, a1, a2); } catch (Exception ex) { throw cError(ex); } }
public final Object clDirect(Object a0, Object a1, Object a2, Object a3) { try { return callDirect(a0, a1, a2, a3); } catch (Exception ex) { throw cError(ex); } }
public final Object clIndirect(Object[] args) { try { return callIndirect(args); } catch (Exception ex) { throw cError(ex); } }
@Override public String toString() { return "function: " + nameHint; }
public final Object callDirect() { return callIndirect(new Object[] {}); }
public final Object callDirect(Object a0) { return callIndirect(new Object[] {a0}); }
public final Object callDirect(Object a0, Object a1) { return callIndirect(new Object[] {a0, a1}); }
public final Object callDirect(Object a0, Object a1, Object a2) { return callIndirect(new Object[] {a0, a1, a2}); }
public final Object callDirect(Object a0, Object a1, Object a2, Object a3) { return callIndirect(new Object[] {a0, a1, a2, a3}); }
public Object callDirect() { throw new RuntimeException(this + " supplied no args"); }
public Object callDirect(Object a0) { throw new RuntimeException(this + " supplied 1 arg"); }
public Object callDirect(Object a0, Object a1) { throw new RuntimeException(this + " supplied 2 args"); }
public Object callDirect(Object a0, Object a1, Object a2) { throw new RuntimeException(this + " supplied 3 args"); }
public Object callDirect(Object a0, Object a1, Object a2, Object a3) { throw new RuntimeException(this + " supplied 4 args"); }
@Override public final Object callIndirect(Object[] args) { switch (args.length) { case 0: return callDirect(); case 1: return callDirect(args[0]); case 2: return callDirect(args[0], args[1]); case 3: return callDirect(args[0], args[1], args[2]); case 4: return callDirect(args[0], args[1], args[2], args[3]); } throw new RuntimeException(this + " supplied " + args.length + " args"); }
public final Object callDirect(Object a0) { V v0 = checkParticipant(a0); return loneOp(v0); }
public final Object callDirect(Object a0, Object a1) { V v0 = checkParticipant(a0); V v1 = checkParticipant(a1); return twoOp(v0, v1); }
public final Object callDirect(Object a0, Object a1, Object a2) { V v0 = checkParticipant(a0); V v1 = checkParticipant(a1); V v2 = checkParticipant(a2); return twoOp(twoOp(v0, v1), v2); }
public final Object callDirect(Object a0, Object a1, Object a2, Object a3) { V v0 = checkParticipant(a0); V v1 = checkParticipant(a1); V v2 = checkParticipant(a2); V v3 = checkParticipant(a3); return twoOp(twoOp(twoOp(v0, v1), v2), v3); }
@Override public final Object callIndirect(Object[] args) { if (args.length == 0) return callDirect(); V ongoing = checkParticipant(args[0]); if (args.length == 1) return loneOp(ongoing); for (int i = 1; i < args.length; i++) ongoing = twoOp(ongoing, checkParticipant(args[i])); return ongoing; }
public static void add(MVMEnv ctx) { MVMScopingLibrary.add(ctx); MVMBasicsLibrary.add(ctx); MVMExtensionsLibrary.add(ctx); MVMMathsLibrary.add(ctx); MVMStringLibrary.add(ctx); MVMListsLibrary.add(ctx); }
@Override public String toString() { return "macro " + nameHint; }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length != 1) throw new RuntimeException("quote expects exactly 1 arg"); return new MVMCExpr.Const(call[0], MVMType.typeOf(call[0])); }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length != 1) throw new RuntimeException("quasiquote expects exactly 1 arg"); if (call[0] instanceof List<?>) { List<?> callContents = (List<?>) call[0]; if (callContents.isEmpty()) return new MVMCExpr.Const(call[0], MVMType.typeOf(call[0])); Object first = callContents.get(0); if (DatumTreeUtils.isSym(first, "unquote") || DatumTreeUtils.isSym(first, ",")) { if (callContents.size() != 2) throw new RuntimeException("unquote expects exactly 1 arg"); return cs.compile(callContents.get(1)); } MVMCExpr[] elements = new MVMCExpr[callContents.size()]; int i = 0; for (Object o : callContents) elements[i++] = compile(cs, new Object[] {o}); return new MVMCList(elements); } else { return new MVMCExpr.Const(call[0], MVMType.typeOf(call[0])); } }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { return MVMCBegin.of(cs, call, 0, call.length); }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length < 2) throw new RuntimeException("If needs at least the condition and true branch"); else if (call.length > 3) throw new RuntimeException("If cannot have too many parameters"); else if (call.length == 2) { if (invert) return new MVMCIf(cs.compile(call[0]), null, cs.compile(call[1])); return new MVMCIf(cs.compile(call[0]), cs.compile(call[1]), null); } if (invert) return new MVMCIf(cs.compile(call[0]), cs.compile(call[2]), cs.compile(call[1])); return new MVMCIf(cs.compile(call[0]), cs.compile(call[1]), cs.compile(call[2])); }
@Override protected Object callDirect() { throw new RuntimeException("error needs at least a message"); }
@Override protected Object callDirect(Object a0) { throw new MVMUserException((String) a0); }
@Override protected Object callDirect(Object a0, Object a1) { throw new MVMUserException((String) a0, a1); }
@Override protected Object callDirect(Object a0, Object a1, Object a2) { throw new MVMUserException((String) a0, a1, a2); }
@Override protected Object callDirect(Object a0, Object a1, Object a2, Object a3) { throw new MVMUserException((String) a0, a1, a2, a3); }
@Override protected Object callIndirect(Object[] args) { Object[] reduced = new Object[args.length - 1]; System.arraycopy(args, 1, reduced, 0, reduced.length); throw new MVMUserException((String) args[0], reduced); }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length < 1) throw new RuntimeException("While needs at least the expression"); return new MVMCWhile(cs.compile(call[0]), MVMCBegin.of(cs, call, 1, call.length - 1)); }
public static void add(MVMEnv ctx) { ctx.defineSlot(new DatumSymbol("for-each"), new ForEach()) .help( "(for-each F L...) : Given a group of lists, iterates over all of them simultaneously," + " calling F with each set of results."); ctx.defineSlot(new DatumSymbol("append"), new Append()) .help("(append L...) : Creates a new list from a set of appended lists."); ctx.defineSlot(new DatumSymbol("append!"), new AppendM()) .help("(append! T L...) : Modifies an existing list to append a set of lists."); ctx.defineSlot(new DatumSymbol("sublist"), new Sublist()) .help("(sublist L START END) : Substring, but on lists!"); ctx.defLib( "list-length", MVMType.I64, MVMType.LIST, (a0) -> (long) MVMU.cList(a0).size(), "(list-length L) : List length"); ctx.defLib( "list-ref", MVMType.ANY, MVMType.LIST, MVMType.I64, (a0, a1) -> MVMU.cList(a0).get(MVMU.cInt(a1)), "(list-ref L I) : List get"); ctx.defLib( "list-set!", MVMType.ANY, MVMType.LIST, MVMType.I64, MVMType.ANY, (a0, a1, a2) -> { MVMU.cList(a0).set(MVMU.cInt(a1), a2); return a2; }, "(list-set! L I V) : List set"); }
@Override protected Object callDirect() { throw new RuntimeException("for-each requires at least a procedure"); }
@Override protected Object callDirect(Object a0) { MVMFnCallCompiler.asFn(a0); return null; }
@Override protected Object callDirect(Object a0, Object a1) { MVMFn fn = MVMFnCallCompiler.asFn(a0); @SuppressWarnings("unchecked") List<Object> l1 = (List<Object>) a1; for (Object o : l1) fn.clDirect(o); return null; }
@Override protected Object callDirect(Object a0, Object a1, Object a2) { MVMFn fn = MVMFnCallCompiler.asFn(a0); @SuppressWarnings("unchecked") List<Object> l1 = (List<Object>) a1; @SuppressWarnings("unchecked") List<Object> l2 = (List<Object>) a2; Iterator<Object> i1 = l1.iterator(); Iterator<Object> i2 = l2.iterator(); while (i1.hasNext()) fn.clDirect(i1.next(), i2.next()); return null; }
@Override protected Object callDirect(Object a0, Object a1, Object a2, Object a3) { MVMFn fn = MVMFnCallCompiler.asFn(a0); @SuppressWarnings("unchecked") List<Object> l1 = (List<Object>) a1; @SuppressWarnings("unchecked") List<Object> l2 = (List<Object>) a2; @SuppressWarnings("unchecked") List<Object> l3 = (List<Object>) a3; Iterator<Object> i1 = l1.iterator(); Iterator<Object> i2 = l2.iterator(); Iterator<Object> i3 = l3.iterator(); while (i1.hasNext()) fn.clDirect(i1.next(), i2.next(), i3.next()); return null; }
@SuppressWarnings("unchecked") @Override protected Object callIndirect(Object[] args) { if (args.length == 4) return callDirect(args[0], args[1], args[2], args[3]); else if (args.length == 3) return callDirect(args[0], args[1], args[2]); else if (args.length == 2) return callDirect(args[0], args[1]); else if (args.length == 1) return callDirect(args[0]); else if (args.length == 0) return callDirect(); MVMFn fn = MVMFnCallCompiler.asFn(args[0]); Object[] temp = new Object[args.length - 1]; Iterator<Object>[] it = new Iterator[temp.length]; for (int i = 0; i < it.length; i++) it[i] = ((List<Object>) args[i + 1]).iterator(); while (it[0].hasNext()) { for (int i = 0; i < it.length; i++) temp[i] = it[i].next(); fn.callIndirect(temp); } return null; }
@Override protected Object callDirect() { return MVMU.l(); }
@SuppressWarnings("unchecked") @Override protected Object callDirect(Object a0) { List<Object> target = MVMU.l(); target.addAll((List<Object>) a0); return target; }
@SuppressWarnings("unchecked") @Override protected Object callDirect(Object a0, Object a1) { List<Object> target = MVMU.l(); target.addAll((List<Object>) a0); target.addAll((List<Object>) a1); return target; }
@SuppressWarnings("unchecked") @Override protected Object callDirect(Object a0, Object a1, Object a2) { List<Object> target = MVMU.l(); target.addAll((List<Object>) a0); target.addAll((List<Object>) a1); target.addAll((List<Object>) a2); return target; }
@SuppressWarnings("unchecked") @Override protected Object callDirect(Object a0, Object a1, Object a2, Object a3) { List<Object> target = MVMU.l(); target.addAll((List<Object>) a0); target.addAll((List<Object>) a1); target.addAll((List<Object>) a2); target.addAll((List<Object>) a3); return target; }
@SuppressWarnings("unchecked") @Override protected Object callIndirect(Object[] args) { List<Object> target = MVMU.l(); for (Object obj : args) target.addAll((List<Object>) obj); return target; }
@Override protected Object callDirect() { throw new RuntimeException("append! must have a target list"); }
@Override protected Object callDirect(Object a0) { return a0; }
@SuppressWarnings("unchecked") @Override protected Object callDirect(Object a0, Object a1) { List<Object> target = (List<Object>) a0; target.addAll((List<Object>) a1); return target; }
@SuppressWarnings("unchecked") @Override protected Object callDirect(Object a0, Object a1, Object a2) { List<Object> target = (List<Object>) a0; target.addAll((List<Object>) a1); target.addAll((List<Object>) a2); return target; }
@SuppressWarnings("unchecked") @Override protected Object callDirect(Object a0, Object a1, Object a2, Object a3) { List<Object> target = (List<Object>) a0; target.addAll((List<Object>) a1); target.addAll((List<Object>) a2); target.addAll((List<Object>) a3); return target; }
@SuppressWarnings("unchecked") @Override protected Object callIndirect(Object[] args) { List<Object> target = MVMU.cList(args[0]); for (int i = 1; i < args.length; i++) target.addAll((List<Object>) args[i]); return target; }
@Override public Object callDirect(Object a0, Object a1, Object a2) { List<Object> lo = MVMU.cList(a0); int s = MVMU.cInt(a1); int e = MVMU.cInt(a2); int c = e - s; if (c <= 0) return new LinkedList<Object>(); ArrayList<Object> copy = new ArrayList<>(c); ListIterator<Object> li = lo.listIterator(s); for (int i = s; i < e; i++) copy.add(li.next()); return copy; }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { return MVMScopingLibrary.compileFnDefine( cs, call, (head, args) -> { final MVMCExpr fnx = MVMScopingLibrary.lambda(head.toString(), cs, args, call, 1); return new MVMCMacroify(fnx); }); }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length == 0) { LinkedList<DatumSymbol> ds = new LinkedList<>(); for (MVMSlot s : cs.context.listSlots()) if (s.help != null) ds.add(s.s); return new MVMCExpr.Const(ds, new MVMType.TypedList(MVMType.SYM)); } else if (call.length == 1) { MVMSlot ds = cs.context.getSlot(new DatumSymbol(MVMU.coerceToString(call[1]))); if (ds != null) return new MVMCExpr.Const(ds.help, MVMType.STR); return new MVMCExpr.Const(null, MVMType.STR); } else { throw new RuntimeException("(help) must be (help) or (help symbol)"); } }
@Override public Object execute( MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { String res = (String) helpInfo.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); ensuredSlot.help = res; return res; }
@Override public Object disasm() { return sym("help-set"); }
@Override public Object execute( MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { return res.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); }
@Override public Object disasm() { return MVMU.l(sym("cast"), type.toString(), res.disasm()); }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { if (call.length != 2) throw new RuntimeException("define-type NAME TYPE"); DatumSymbol name = (DatumSymbol) call[0]; cs.context.defineType(name, cs.context.getType(call[1], name.id)); return null; }
@Override public String toString() { return getMessage(); }
@Override public String toString() { return "lambda " + nameHint; }
@Override public Object callDirect() { if (argL.length != 0) throw new RuntimeException(this + " expects " + argL.length + " args, not 0"); MVMScope sc = MVMCompileFrame.wrapRuntimeScope(rootFrame, scope); return content.execute(sc, null, null, null, null, null, null, null, null); }
public final Object callL5(Object a0, Object a1, Object a2, Object a3, Object a4) { return execSmall(5, a0, a1, a2, a3, a4); }
@Override public Object callDirect(Object a0) { return execSmall(1, a0, null, null, null, null); }
@Override public Object callDirect(Object a0, Object a1) { return execSmall(2, a0, a1, null, null, null); }
@Override public Object callDirect(Object a0, Object a1, Object a2) { return execSmall(3, a0, a1, a2, null, null); }
@Override public Object callDirect(Object a0, Object a1, Object a2, Object a3) { return execSmall(4, a0, a1, a2, a3, null); }
private static MVMType figureOutReturnType( @NonNull MVMCExpr c, @Nullable MVMCExpr a, @Nullable MVMCExpr b) { MVMType aPath = a != null ? a.returnType : c.returnType; MVMType bPath = b != null ? b.returnType : c.returnType; return MVMType.Union.of(aPath, bPath, false); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { Object res = c.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); MVMCExpr x = MVMU.isTruthy(res) ? a : b; return x != null ? x.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7) : res; }
@Override public Object disasm() { return MVMU.l( sym("if"), c.disasm(), a != null ? a.disasm() : null, b != null ? b.disasm() : null); }
public void deoptimizeInto(int fID, int lID) { if (frameID != -1) throw new RuntimeException("Can't deoptimize twice!"); if (fID == -1) throw new RuntimeException("Can't deoptimize into fast-local!"); frameID = fID; localID = lID; }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { if (frameID == -1) { switch (localID) { case 0: return l0; case 1: return l1; case 2: return l2; case 3: return l3; case 4: return l4; case 5: return l5; case 6: return l6; case 7: return l7; default: throw new RuntimeException("Invalid fast-local ID"); } } else { return ctx.get(frameID, localID); } }
@Override public Object disasm() { return MVMU.l(sym("localRead"), frameID, localID); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { Object v = val.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); ctx.set(fID, lID, v); return v; }
@Override public Object disasm() { return Arrays.asList(sym("localWrite"), frameID, localID, val.disasm()); }
public void directWrite(MVMScope scope, Object aV) { if (frameID == -1) throw new RuntimeException( "A local being directly written cannot be fast, check your caller."); scope.set(frameID, localID, aV); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { return slot.v = value.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); }
@Override public Object disasm() { return MVMU.l(sym("setSlot"), slot.s, value.disasm()); }
private static MVMCExpr[] compileAll(MVMCompileScope cs, Object[] obj, int base, int len) { MVMCExpr[] exprs = new MVMCExpr[len]; for (int i = 0; i < len; i++) exprs[i] = cs.compile(obj[base + i]); return exprs; }
public static MVMCExpr of(MVMCExpr... content) { if (content.length == 1) return content[0]; return new MVMCBegin(content); }
public static MVMCExpr of(MVMCompileScope cs, Object[] obj, int base, int len) { if (len == 1) return cs.compile(obj[base]); return new MVMCBegin(cs, obj, base, len); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { Object val = null; for (MVMCExpr ex : exprs) val = ex.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); return val; }
@Override public Object disasm() { LinkedList<Object> obj = new LinkedList<>(); obj.add(sym("begin")); for (MVMCExpr ex : exprs) obj.add(ex.disasm()); return obj; }
@Override public MVMCExpr compile(MVMCompileScope cs, Object[] call) { return cs.compile(fn.clIndirect(call)); }
@Override public Object disasm() { return MVMU.l(sym("macroify"), expr.disasm()); }
public final Object exc(@NonNull MVMScope ctx) { return execute(ctx, null, null, null, null, null, null, null, null); }
public final Object exc(@NonNull MVMScope ctx, Object l0) { return execute(ctx, l0, null, null, null, null, null, null, null); }
@Override public String toString() { return DatumWriter.objectToString(disasm()); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { return value; }
@Override public Object disasm() { return MVMU.userStr(value); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { return l0; }
@Override public Object disasm() { return sym("getL0"); }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { l0 = value.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); return ret.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); }
@Override public Object disasm() { return MVMU.l(sym("setL0"), value.disasm(), ret.disasm()); }
@Override public Object disasm() { LinkedList<Object> res = new LinkedList<>(); res.add(new DatumSymbol("let")); for (MVMCExpr ex : expressions) res.add(ex.disasm()); res.add(inner.disasm()); return res; }
@Override public Object execute( @NonNull MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { Object res = Boolean.FALSE; while (MVMU.isTruthy(c.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7))) res = v.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7); return res; }
@Override public Object disasm() { return MVMU.l(sym("while"), c.disasm(), v.disasm()); }
@Override public Object execute( MVMScope ctx, Object l0, Object l1, Object l2, Object l3, Object l4, Object l5, Object l6, Object l7) { LinkedList<Object> da = new LinkedList<>(); for (MVMCExpr me : exprs) da.add(me.execute(ctx, l0, l1, l2, l3, l4, l5, l6, l7)); return da; }
@Override public Object disasm() { LinkedList<Object> da = new LinkedList<>(); da.add(DatumTreeUtils.sym("list")); for (MVMCExpr me : exprs) da.add(me.disasm()); return da; }
@Override protected Object callIndirect(Object[] args) { if (args.length < def.r()) throw new RuntimeException("under required arg count @ " + this); if (args.length > paramsV.length) { throw new RuntimeException("too many args @ " + this); } else if (args.length < paramsV.length) { Object[] argsPadded = new Object[paramsV.length]; System.arraycopy(args, 0, argsPadded, 0, args.length); try { return m.invoke(library, argsPadded); } catch (Exception ex) { throw new RuntimeException(ex); } } else { try { return m.invoke(library, args); } catch (Exception ex) { throw new RuntimeException(ex); } } }
public static Item.Properties defaultItemProperties() { return new Item.Properties().tab(SakuraMod.GROUP); }
private void setup(final FMLCommonSetupEvent event) { event.enqueueWork( () -> { ComposterRegistry.registerCompost(); }); }
private static ConfiguredFeature<?, ?> wildPlantFeature( Supplier<Block> wildCrop, TagKey<Block> blockTag) { return new ConfiguredFeature<>( Feature.RANDOM_PATCH, getWildCropConfiguration( wildCrop.get(), 64, 1, BlockPredicate.matchesTag(blockTag, BLOCK_BELOW))); }
private static PlacedFeature wildPlantPatch( RegistryObject<ConfiguredFeature<?, ?>> feature, PlacementModifier... modifiers) { return new PlacedFeature(feature.getHolder().get(), Lists.newArrayList(modifiers)); }
private static RandomPatchConfiguration getWildCropConfiguration( Block block, int tries, int xzSpread, BlockPredicate plantedOn) { return new RandomPatchConfiguration( tries, xzSpread, 3, PlacementUtils.filtered( Feature.SIMPLE_BLOCK, new SimpleBlockConfiguration(BlockStateProvider.simple(block)), BlockPredicate.allOf(BlockPredicate.ONLY_IN_AIR_PREDICATE, plantedOn))); }
@Override protected Holder<? extends ConfiguredFeature<?, ?>> getConfiguredFeature( Random random, boolean hasBees) { if (random.nextInt(10) == 0) { return this.fancy_tree.getHolder().get(); } else { return this.tree.getHolder().get(); } }
@Override public boolean growTree( ServerLevel p_60006_, ChunkGenerator p_60007_, BlockPos p_60008_, BlockState p_60009_, Random p_60010_) { return super.growTree(p_60006_, p_60007_, p_60008_, p_60009_, p_60010_); }
private static ConfiguredFeature<?, ?> registryTree( TreeConfiguration.TreeConfigurationBuilder tree) { return new ConfiguredFeature<>(Feature.TREE, tree.build()); }
private static TreeConfiguration.TreeConfigurationBuilder createSimpleBlobTree( Block log, Block leaves) { return createStraightBlobTree(log, leaves, 4, 2, 0, 2); }
private static TreeConfiguration.TreeConfigurationBuilder createStraightBlobTree( Block log, Block leaves, int baseHeight, int heightRandA, int heightRandB, int leaves_radius) { return new TreeConfiguration.TreeConfigurationBuilder( BlockStateProvider.simple(log), new StraightTrunkPlacer(baseHeight, heightRandA, heightRandB), BlockStateProvider.simple(leaves), new BlobFoliagePlacer(ConstantInt.of(leaves_radius), ConstantInt.of(0), 3), new TwoLayersFeatureSize(1, 0, 1)); }
private static TreeConfiguration.TreeConfigurationBuilder createFancyTree( Block log, Block leaves) { return (new TreeConfiguration.TreeConfigurationBuilder( BlockStateProvider.simple(log), new FancyTrunkPlacer(3, 11, 0), BlockStateProvider.simple(leaves), new FancyFoliagePlacer(ConstantInt.of(2), ConstantInt.of(4), 4), new TwoLayersFeatureSize(0, 0, 0, OptionalInt.of(4)))) .ignoreVines(); }
@Override protected Holder<? extends ConfiguredFeature<?, ?>> getConfiguredFeature( Random random, boolean hasBees) { if (random.nextInt(10) == 0) { return SakuraTreeFeatures.FANCY_SAKURA.getHolder().get(); } else { return SakuraTreeFeatures.SAKURA.getHolder().get(); } }
@Override public boolean mayPlace(ItemStack stack) { return false; }
@Override @Nonnull public ItemStack remove(int amount) { if (this.hasItem()) { this.removeCount += Math.min(amount, this.getItem().getCount()); } return super.remove(amount); }
@Override public void onTake(Player thePlayer, ItemStack stack) { this.checkTakeAchievements(stack); super.onTake(thePlayer, stack); }
@Override protected void onQuickCraft(ItemStack stack, int amount) { this.removeCount += amount; this.checkTakeAchievements(stack); }
@Override protected void checkTakeAchievements(ItemStack stack) { stack.onCraftedBy(this.player.level, this.player, this.removeCount); if (!this.player.level.isClientSide) { tileEntity.clearUsedRecipes(this.player); } this.removeCount = 0; }
private static FermenterBlockEntity getTileEntity( final Inventory playerInventory, final FriendlyByteBuf data) { Objects.requireNonNull(playerInventory, "playerInventory cannot be null"); Objects.requireNonNull(data, "data cannot be null"); final BlockEntity tileAtPos = playerInventory.player.level.getBlockEntity(data.readBlockPos()); if (tileAtPos instanceof FermenterBlockEntity) { return (FermenterBlockEntity) tileAtPos; } throw new IllegalStateException("Tile entity is not correct! " + tileAtPos); }
@Override public boolean stillValid(Player playerIn) { return stillValid(canInteractWithCallable, playerIn, BlockRegistry.FERMENTER.get()); }
private static StoneMortarBlockEntity getTileEntity( final Inventory playerInventory, final FriendlyByteBuf data) { Objects.requireNonNull(playerInventory, "playerInventory cannot be null"); Objects.requireNonNull(data, "data cannot be null"); final BlockEntity tileAtPos = playerInventory.player.level.getBlockEntity(data.readBlockPos()); if (tileAtPos instanceof StoneMortarBlockEntity) { return (StoneMortarBlockEntity) tileAtPos; } throw new IllegalStateException("Tile entity is not correct! " + tileAtPos); }
@Override public boolean stillValid(Player playerIn) { return stillValid(canInteractWithCallable, playerIn, BlockRegistry.STONE_MORTAR.get()); }
private static CookingPotBlockEntity getTileEntity( final Inventory playerInventory, final FriendlyByteBuf data) { Objects.requireNonNull(playerInventory, "playerInventory cannot be null"); Objects.requireNonNull(data, "data cannot be null"); final BlockEntity tileAtPos = playerInventory.player.level.getBlockEntity(data.readBlockPos()); if (tileAtPos instanceof CookingPotBlockEntity) { return (CookingPotBlockEntity) tileAtPos; } throw new IllegalStateException("Tile entity is not correct! " + tileAtPos); }
@Override public boolean stillValid(Player playerIn) { return stillValid(canInteractWithCallable, playerIn, BlockRegistry.COOKING_POT.get()); }
@OnlyIn(Dist.CLIENT) public boolean isHeated() { return this.tileEntity.isHeated(); }
private static DistillerBlockEntity getTileEntity( final Inventory playerInventory, final FriendlyByteBuf data) { Objects.requireNonNull(playerInventory, "playerInventory cannot be null"); Objects.requireNonNull(data, "data cannot be null"); final BlockEntity tileAtPos = playerInventory.player.level.getBlockEntity(data.readBlockPos()); if (tileAtPos instanceof DistillerBlockEntity) { return (DistillerBlockEntity) tileAtPos; } throw new IllegalStateException("Tile entity is not correct! " + tileAtPos); }
@Override public boolean stillValid(Player playerIn) { return stillValid(canInteractWithCallable, playerIn, BlockRegistry.DISTILLER.get()); }
@Override public InteractionResult use( BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hitresult) { ItemStack itemstack = player.getItemInHand(hand); if (itemstack.canPerformAction(net.minecraftforge.common.ToolActions.SHEARS_CARVE)) { if (!level.isClientSide) { level.playSound((Player) null, pos, SoundEvents.WOOD_PLACE, SoundSource.BLOCKS, 1.0F, 1.0F); level.setBlock( pos, BlockRegistry.MAPLE_SAP_LOG .get() .withPropertiesOf(state) .setValue(MapleTreeSapLogBlock.EXHAUSTION, false), 11); itemstack.hurtAndBreak( 1, player, tool -> { tool.broadcastBreakEvent(hand); }); level.gameEvent(player, GameEvent.SHEAR, pos); player.awardStat(Stats.ITEM_USED.get(Items.SHEARS)); } return InteractionResult.sidedSuccess(level.isClientSide); } else { return super.use(state, level, pos, player, hand, hitresult); } }
@Override public boolean isCollisionShapeFullBlock(BlockState state, BlockGetter level, BlockPos pos) { return false; }
@Override public BlockEntity newBlockEntity(BlockPos pos, BlockState state) { return BlockEntityRegistry.OBON.get().create(pos, state); }
@Override public VoxelShape getShape( BlockState state, BlockGetter worldIn, BlockPos pos, CollisionContext context) { return SHAPE; }
@Override protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) { super.createBlockStateDefinition(builder); builder.add(FACING); }
@SuppressWarnings("deprecation") @Override public void randomTick(BlockState state, ServerLevel worldIn, BlockPos pos, Random rand) { super.randomTick(state, worldIn, pos, rand); if (worldIn.isDay() && worldIn.canSeeSky(pos)) { worldIn.setBlockAndUpdate( pos, BlockRegistry.TATAMI_SLAB_SUNBURNT.get().withPropertiesOf(state)); } }
@Override public VoxelShape getShape( BlockState state, BlockGetter levelIn, BlockPos pos, CollisionContext context) { return SHAPE; }
@Override public boolean canSurvive(BlockState state, LevelReader worldIn, BlockPos pos) { BlockState ground = worldIn.getBlockState(pos.below()); return ground.is(BlockTags.BAMBOO_PLANTABLE_ON) && !(ground.is(Blocks.BAMBOO)) && !(ground.is(Blocks.BAMBOO_SAPLING)) && !(ground.is(BlockRegistry.BAMBOO_PLANT.get())) && !(ground.is(this)); }
@Override public boolean isValidBonemealTarget( BlockGetter p_50897_, BlockPos p_50898_, BlockState p_50899_, boolean p_50900_) { return true; }
@Override public boolean isBonemealSuccess( Level p_50901_, Random p_50902_, BlockPos p_50903_, BlockState p_50904_) { return true; }
@Override public void performBonemeal(ServerLevel worldIn, Random rand, BlockPos pos, BlockState state) { growBamboo(worldIn, pos); }
private void growBamboo(ServerLevel worldIn, BlockPos pos) { if (!worldIn.isEmptyBlock(pos.above())) { return; } if (worldIn.isEmptyBlock(pos.above(2))) { worldIn.setBlockAndUpdate( pos.above(2), BlockRegistry.BAMBOO_PLANT .get() .defaultBlockState() .setValue(BambooBlock.LEAVES, BambooLeaves.LARGE)); } worldIn.setBlockAndUpdate( pos.above(), BlockRegistry.BAMBOO_PLANT .get() .defaultBlockState() .setValue(BambooBlock.LEAVES, BambooLeaves.SMALL)); worldIn.setBlockAndUpdate(pos, BlockRegistry.BAMBOO_PLANT.get().defaultBlockState()); }
@Override protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> p_48928_) { p_48928_.add(LEAVES); }
@Override public boolean propagatesSkylightDown( BlockState p_48941_, BlockGetter p_48942_, BlockPos p_48943_) { return true; }
@Override public VoxelShape getShape( BlockState p_48945_, BlockGetter p_48946_, BlockPos p_48947_, CollisionContext p_48948_) { return SHAPE; }
@Override public boolean isPathfindable( BlockState p_48906_, BlockGetter p_48907_, BlockPos p_48908_, PathComputationType p_48909_) { return false; }
@Override public boolean isCollisionShapeFullBlock( BlockState p_181159_, BlockGetter p_181160_, BlockPos p_181161_) { return false; }
@Override public void tick(BlockState p_48896_, ServerLevel p_48897_, BlockPos p_48898_, Random p_48899_) { if (!p_48896_.canSurvive(p_48897_, p_48898_)) { p_48897_.destroyBlock(p_48898_, true); } }
@Override public boolean isRandomlyTicking(BlockState state) { return true; }
public void spreadingTick(ServerLevel levelIn, BlockPos pos, Random random) { int j = this.getHeightAboveUpToMax(levelIn, pos) + 1; if (j >= 16) { if (levelIn.isRaining() || random.nextFloat() < 0.15) { growBambooShoot(levelIn, pos, random); } } }
public void growingTick(BlockState state, ServerLevel levelIn, BlockPos pos, Random random) { int i = this.getHeightBelowUpToMax(levelIn, pos) + 1; if (i < 16 && levelIn.isEmptyBlock(pos.above())) { this.growBamboo(state, levelIn, pos, random, i); } }
@Override public boolean canSurvive(BlockState state, LevelReader worldIn, BlockPos pos) { BlockState ground = worldIn.getBlockState(pos.below()); return (ground.is(BlockTags.BAMBOO_PLANTABLE_ON) || ground.is(this)) && !(ground.is(Blocks.BAMBOO)) && !(ground.is(Blocks.BAMBOO_SAPLING)); }
@Override public BlockState updateShape( BlockState p_48921_, Direction p_48922_, BlockState p_48923_, LevelAccessor p_48924_, BlockPos p_48925_, BlockPos p_48926_) { if (!p_48921_.canSurvive(p_48924_, p_48925_)) { p_48924_.scheduleTick(p_48925_, this, 1); } return super.updateShape(p_48921_, p_48922_, p_48923_, p_48924_, p_48925_, p_48926_); }
@Override public boolean isValidBonemealTarget( BlockGetter p_48886_, BlockPos p_48887_, BlockState p_48888_, boolean p_48889_) { return true; }
@Override public boolean isBonemealSuccess( Level p_48891_, Random p_48892_, BlockPos p_48893_, BlockState p_48894_) { return true; }
@Override public void performBonemeal( ServerLevel p_48876_, Random p_48877_, BlockPos p_48878_, BlockState p_48879_) { int i = this.getHeightAboveUpToMax(p_48876_, p_48878_); int j = this.getHeightBelowUpToMax(p_48876_, p_48878_); int k = i + j + 1; int l = 1 + p_48877_.nextInt(2); for (int i1 = 0; i1 < l; ++i1) { BlockPos blockpos = p_48878_.above(i); BlockState blockstate = p_48876_.getBlockState(blockpos); if (k >= 16 || !p_48876_.isEmptyBlock(blockpos.above())) { this.growBambooShoot(p_48876_, p_48878_, p_48877_); return; } this.growBamboo(blockstate, p_48876_, blockpos, p_48877_, k); ++i; ++k; } }
@Override public float getDestroyProgress( BlockState p_48901_, Player p_48902_, BlockGetter p_48903_, BlockPos p_48904_) { return p_48902_.getMainHandItem().canPerformAction(ToolActions.AXE_DIG) ? 1.0F : super.getDestroyProgress(p_48901_, p_48902_, p_48903_, p_48904_); }
public void growBambooShoot(ServerLevel levelIn, BlockPos pos, Random random) { BlockPos blockpos1 = pos.offset( random.nextInt(3) - 1, random.nextInt(2) - random.nextInt(2), random.nextInt(3) - 1); if (BlockRegistry.BAMBOOSHOOT.get().defaultBlockState().canSurvive(levelIn, blockpos1) && levelIn.isEmptyBlock(blockpos1.above()) && levelIn.isEmptyBlock(blockpos1)) { levelIn.setBlockAndUpdate(blockpos1, BlockRegistry.BAMBOOSHOOT.get().defaultBlockState()); } }
@Override protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) { builder.add(AXIS, EXHAUSTION); }
@SuppressWarnings("deprecation") @Override public void randomTick(BlockState state, ServerLevel worldIn, BlockPos pos, Random rand) { super.randomTick(state, worldIn, pos, rand); if (worldIn.isDay() && worldIn.canSeeSky(pos)) { worldIn.setBlockAndUpdate(pos, BlockRegistry.TATAMI_SUNBURNT.get().withPropertiesOf(state)); } }
@Override @OnlyIn(Dist.CLIENT) public void animateTick(BlockState stateIn, Level worldIn, BlockPos pos, Random rand) { super.animateTick(stateIn, worldIn, pos, rand); if (rand.nextInt(40) == 0) { int j = rand.nextInt(2) * 2 - 1; int k = rand.nextInt(2) * 2 - 1; double d0 = pos.getX() + 0.5D + 0.25D * j; double d1 = pos.getY() - 0.15D; double d2 = pos.getZ() + 0.5D + 0.25D * k; double d3 = rand.nextFloat() * j * 0.1D; double d4 = (rand.nextFloat() * 0.055D) + 0.015D; double d5 = rand.nextFloat() * k * 0.1D; worldIn.addParticle(this.leaf_particle.get(), d0, d1, d2, d3, -d4, d5); } }
private static RotatedPillarBlock log(MaterialColor top, MaterialColor bark) { return new RotatedPillarBlock( BlockBehaviour.Properties.of( Material.WOOD, state -> (state.getValue(RotatedPillarBlock.AXIS) == Direction.Axis.Y ? top : bark)) .strength(2.0F) .sound(SoundType.WOOD)); }
private static SaplingBlock sapling(AbstractTreeGrower tree) { return new SaplingBlock( tree, BlockBehaviour.Properties.of(Material.PLANT) .noCollission() .randomTicks() .instabreak() .sound(SoundType.GRASS)); }
private static RotatedPillarBlock simplebambooBlock(MaterialColor top, MaterialColor bark) { return new RotatedPillarBlock( BlockBehaviour.Properties.of( Material.BAMBOO, state -> (state.getValue(RotatedPillarBlock.AXIS) == Direction.Axis.Y ? top : bark)) .strength(2.0F) .sound(SoundType.BAMBOO)); }
private static Block plank(MaterialColor material_color) { return new Block( BlockBehaviour.Properties.of(Material.WOOD, material_color) .strength(2.0F, 3.0F) .sound(SoundType.WOOD)); }
@Override public VoxelShape getShape( BlockState state, BlockGetter worldIn, BlockPos pos, CollisionContext context) { return SHAPE_BY_AGE[state.getValue(this.getAgeProperty())]; }
@Override protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) { builder.add(RICE_AGE); }
@Override public boolean canSurvive(BlockState state, LevelReader worldIn, BlockPos pos) { return (worldIn.getRawBrightness(pos, 0) >= 8 || worldIn.canSeeSky(pos)) && worldIn.getBlockState(pos.below()).is(BlockRegistry.RICE_CROP_ROOT.get()); }
@Override protected boolean mayPlaceOn(BlockState state, BlockGetter worldIn, BlockPos pos) { return state.is(BlockRegistry.RICE_CROP_ROOT.get()); }
@Override protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) { builder.add(AGE, SUPPORTING); }
@Override protected boolean mayPlaceOn(BlockState state, BlockGetter worldIn, BlockPos pos) { return super.mayPlaceOn(state, worldIn, pos) || state.is(BlockTags.DIRT); }
@Override public boolean canSurvive(BlockState state, LevelReader worldIn, BlockPos pos) { FluidState fluid = worldIn.getFluidState(pos); return super.canSurvive(state, worldIn, pos) && fluid.is(FluidTags.WATER) && fluid.getAmount() == 8; }
@Override public boolean isValidBonemealTarget( BlockGetter worldIn, BlockPos pos, BlockState state, boolean isClient) { BlockState upperState = worldIn.getBlockState(pos.above()); if (upperState.is(BlockRegistry.RICE_CROP.get())) { return !((RiceCrop) upperState.getBlock()).isMaxAge(upperState); } return true; }
@Override public boolean isBonemealSuccess(Level worldIn, Random rand, BlockPos pos, BlockState state) { return true; }
public BlockState withAge(int age) { return this.defaultBlockState().setValue(this.getAgeProperty(), age); }
public boolean isMaxAge(BlockState state) { return state.getValue(this.getAgeProperty()) >= this.getMaxAge(); }
@Override public boolean canPlaceLiquid( BlockGetter worldIn, BlockPos pos, BlockState state, Fluid fluidIn) { return false; }
@Override public boolean placeLiquid( LevelAccessor worldIn, BlockPos pos, BlockState state, FluidState fluidStateIn) { return false; }
@Override public BlockState updateShape( BlockState stateIn, Direction facing, BlockState facingState, LevelAccessor worldIn, BlockPos currentPos, BlockPos facingPos) { BlockState state = super.updateShape(stateIn, facing, facingState, worldIn, currentPos, facingPos); if (!state.isAir()) { worldIn.scheduleTick(currentPos, Fluids.WATER, Fluids.WATER.getTickDelay(worldIn)); if (facing == Direction.UP) { return state.setValue(SUPPORTING, isSupportingRiceUpper(facingState)); } } return state; }
public boolean isSupportingRiceUpper(BlockState topState) { return topState.getBlock() instanceof RiceCrop; }
@Override public InteractionResult use( BlockState state, Level worldIn, BlockPos pos, Player player, InteractionHand handIn, BlockHitResult hit) { if (worldIn.isClientSide) { if (this.takePlates(worldIn, pos, state, player, handIn).consumesAction()) { return InteractionResult.SUCCESS; } } return this.takePlates(worldIn, pos, state, player, handIn); }
private InteractionResult takePlates( Level worldIn, BlockPos pos, BlockState state, Player player, InteractionHand handIn) { worldIn.playSound(null, pos, SoundEvents.WOOD_BREAK, SoundSource.PLAYERS, 0.8F, 0.8F); worldIn.destroyBlock(pos, true); return InteractionResult.SUCCESS; }
@Override protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) { super.createBlockStateDefinition(builder); builder.add(FACING, BITES); }
@Override public InteractionResult use( BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hitResult) { ItemStack itemstack = player.getItemInHand(hand); if (level.isClientSide) { if (eat(level, pos, state, player).consumesAction()) { return InteractionResult.SUCCESS; } if (itemstack.isEmpty()) { return InteractionResult.CONSUME; } } return eat(level, pos, state, player); }
protected InteractionResult eat( LevelAccessor level, BlockPos pos, BlockState state, Player player) { if (!player.canEat(false)) { return InteractionResult.PASS; } else { player.getFoodData().eat(this.getFoodInfo().getAmount(), this.getFoodInfo().getCalories()); int i = state.getValue(BITES); level.gameEvent(player, GameEvent.EAT, pos); if (i < 3) { level.setBlock(pos, state.setValue(BITES, Integer.valueOf(i + 1)), 3); } else { level.setBlock( pos, BlockRegistry.TEISHOUKU_FINISHED .get() .defaultBlockState() .setValue(FACING, state.getValue(FACING)), 3); } return InteractionResult.SUCCESS; } }
@Override public boolean isRandomlyTicking(BlockState state) { return !state.getValue(IS_COOKED); }
@Override public void randomTick(BlockState state, ServerLevel level, BlockPos pos, Random rand) { if (state.getValue(IS_COOKED)) return; if (this.isHeated(level, pos) && rand.nextInt(10) == 0) { level.playSound(null, pos, SoundEvents.FIRE_EXTINGUISH, SoundSource.BLOCKS, 1F, 0.8F); level.setBlock(pos, state.setValue(IS_COOKED, true), UPDATE_ALL); } }
@Override public void animateTick(BlockState state, Level level, BlockPos pos, Random rand) { if (state.getValue(IS_COOKED)) return; if (this.isHeated(level, pos) && rand.nextInt(4) == 0) { double x = (double) pos.getX() + 0.5D + (rand.nextDouble() * 0.6D - 0.3D); double y = (double) pos.getY() + 0.75D; double z = (double) pos.getZ() + 0.5D + (rand.nextDouble() * 0.6D - 0.3D); level.addParticle(ParticleTypes.SMOKE, x, y, z, 0.0D, 0.0D, 0.0D); } }
@Override protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) { super.createBlockStateDefinition(builder); builder.add(IS_COOKED, FACING, BITES); }
public static void workingTick( Level level, BlockPos pos, BlockState state, CookingPotBlockEntity blockEntity) { boolean didInventoryChange = false; if (blockEntity.isHeated(level, pos) && blockEntity.hasInput()) { Optional<CookingPotRecipe> recipe = blockEntity.getMatchingRecipe(new RecipeWrapper(blockEntity.inventory)); if (recipe.isPresent() && blockEntity.canWork(recipe.get())) { didInventoryChange = blockEntity.processRecipe(recipe.get()); } else { blockEntity.recipeTime = 0; } } else if (blockEntity.recipeTime > 0) { if (state.is(BlockRegistry.COOKING_POT.get())) state.setValue(CookingPotBlock.OPEN, true); blockEntity.recipeTime = 0; } if (didInventoryChange) { blockEntity.inventoryChanged(); } }
private boolean processRecipe(CookingPotRecipe recipe) { if (level == null) { return false; } ++recipeTime; recipeTimeTotal = recipe.getRecipeTime(); if (recipeTime < recipeTimeTotal) { return false; } recipeTime = 0; ItemStack resultStack = recipe.getResultItem(); ItemStack outStack = inventory.getStackInSlot(9); if (outStack.isEmpty()) { inventory.setStackInSlot(9, resultStack.copy()); } else if (outStack.sameItem(resultStack)) { outStack.grow(resultStack.getCount()); } if (recipe.getRequiredFluid() != FluidIngredient.EMPTY) this.fluidTank .orElse(new FluidTank(0)) .drain(recipe.getRequiredFluid().getRequiredAmount(), FluidAction.EXECUTE); trackRecipeExperience(recipe); for (int i = 0; i < 9; ++i) { ItemStack slotStack = inventory.getStackInSlot(i); if (slotStack.hasContainerItem()) { double x = worldPosition.getX() + 0.5; double y = worldPosition.getY() + 0.7; double z = worldPosition.getZ() + 0.5; LevelUtils.spawnItemEntity( level, inventory.getStackInSlot(i).getContainerItem(), x, y, z, 0F, 0.25F, 0F); } if (!slotStack.isEmpty()) { slotStack.shrink(1); } } return true; }
public void trackRecipeExperience(@Nullable Recipe<?> recipe) { if (recipe != null) { ResourceLocation recipeID = recipe.getId(); experienceTracker.addTo(recipeID, 1); } }
public void clearUsedRecipes(Player player) { grantStoredRecipeExperience(player.level, player.position()); experienceTracker.clear(); }
public void grantStoredRecipeExperience(Level world, Vec3 pos) { for (Object2IntMap.Entry<ResourceLocation> entry : experienceTracker.object2IntEntrySet()) { world .getRecipeManager() .byKey(entry.getKey()) .ifPresent( recipe -> LevelUtils.splitAndSpawnExperience( world, pos, entry.getIntValue(), ((CookingPotRecipe) recipe).getExperience())); } }
@Override public void saveAdditional(CompoundTag compound) { super.saveAdditional(compound); CompoundTag nbt = new CompoundTag(); compound.putInt("RecipeTime", recipeTime); compound.putInt("RecipeTimeTotal", recipeTimeTotal); compound.put("Inventory", inventory.serializeNBT()); fluidTank.ifPresent(fluid -> compound.put("FluidTank", fluid.writeToNBT(nbt))); CompoundTag compoundRecipes = new CompoundTag(); experienceTracker.forEach( (recipeId, craftedAmount) -> compoundRecipes.putInt(recipeId.toString(), craftedAmount)); compound.put("RecipesUsed", compoundRecipes); }
@Override protected void onContentsChanged(int slot) { if (slot >= 0 && slot < 9) { checkNewRecipe = true; } inventoryChanged(); }
@Override public void onContentsChanged() { checkNewRecipe = true; inventoryChanged(); super.onContentsChanged(); }
@Override public boolean isFluidValid(FluidStack stack) { return !stack.getFluid().getAttributes().isLighterThanAir(); }
@Override public int get(int index) { switch (index) { case 0: return CookingPotBlockEntity.this.recipeTime; case 1: return CookingPotBlockEntity.this.recipeTimeTotal; default: return 0; } }
@Override public void set(int index, int value) { switch (index) { case 0: CookingPotBlockEntity.this.recipeTime = value; break; case 1: CookingPotBlockEntity.this.recipeTimeTotal = value; break; } }
@Override public AbstractContainerMenu createMenu(int id, Inventory player, Player entity) { return new CookingPotContainer(id, player, this, this.tileData); }
public boolean isHeated() { if (level == null) { return false; } return this.isHeated(level, worldPosition); }
@Override public void inventoryChanged() { super.inventoryChanged(); }
@Override public void invalidateCaps() { super.invalidateCaps(); inputHandler.invalidate(); outputHandler.invalidate(); fluidTank.invalidate(); }
@Override public void reviveCaps() { super.reviveCaps(); inputHandler = LazyOptional.of(() -> new CookingPotItemHandler(inventory, Direction.UP)); outputHandler = LazyOptional.of(() -> new CookingPotItemHandler(inventory, Direction.DOWN)); fluidTank = LazyOptional.of(this::createFluidHandler); }
public static void workingTick( Level level, BlockPos pos, BlockState state, DistillerBlockEntity blockEntity) { boolean didInventoryChange = false; if (blockEntity.isHeated(level, pos) && blockEntity.hasInput()) { Optional<DistillerRecipe> recipe = blockEntity.getMatchingRecipe(new RecipeWrapper(blockEntity.inventory)); if (recipe.isPresent() && blockEntity.canWork(recipe.get())) { didInventoryChange = blockEntity.processRecipe(recipe.get()); } else { blockEntity.recipeTime = 0; } } else if (blockEntity.recipeTime > 0) { blockEntity.recipeTime = 0; } if (didInventoryChange) { blockEntity.inventoryChanged(); } }
public void grantStoredRecipeExperience(Level world, Vec3 pos) { for (Object2IntMap.Entry<ResourceLocation> entry : experienceTracker.object2IntEntrySet()) { world .getRecipeManager() .byKey(entry.getKey()) .ifPresent( recipe -> LevelUtils.splitAndSpawnExperience( world, pos, entry.getIntValue(), ((DistillerRecipe) recipe).getExperience())); } }
@Override public void saveAdditional(CompoundTag compound) { super.saveAdditional(compound); CompoundTag nbt = new CompoundTag(); compound.putInt("RecipeTime", recipeTime); compound.putInt("RecipeTimeTotal", recipeTimeTotal); compound.put("Inventory", inventory.serializeNBT()); inputfluidTank.ifPresent(fluid -> compound.put("InputFluidTank", fluid.writeToNBT(nbt))); CompoundTag nbt2 = new CompoundTag(); outputfluidTank.ifPresent(fluid -> compound.put("OutputFluidTank", fluid.writeToNBT(nbt2))); CompoundTag compoundRecipes = new CompoundTag(); experienceTracker.forEach( (recipeId, craftedAmount) -> compoundRecipes.putInt(recipeId.toString(), craftedAmount)); compound.put("RecipesUsed", compoundRecipes); }
@Override protected void onContentsChanged(int slot) { if (slot >= 0 && slot < 3) { checkNewRecipe = true; } inventoryChanged(); }
@Override protected void onContentsChanged() { inventoryChanged(); checkNewRecipe = true; super.onContentsChanged(); }
@Override protected void onContentsChanged() { inventoryChanged(); super.onContentsChanged(); }
@Override public int get(int index) { switch (index) { case 0: return DistillerBlockEntity.this.recipeTime; case 1: return DistillerBlockEntity.this.recipeTimeTotal; default: return 0; } }
@Override public void set(int index, int value) { switch (index) { case 0: DistillerBlockEntity.this.recipeTime = value; break; case 1: DistillerBlockEntity.this.recipeTimeTotal = value; break; } }
@Override public AbstractContainerMenu createMenu(int id, Inventory player, Player entity) { return new DistillerContainer(id, player, this, this.tileData); }
@Override public void invalidateCaps() { super.invalidateCaps(); inputHandler.invalidate(); outputHandler.invalidate(); inputfluidTank.invalidate(); outputfluidTank.invalidate(); }
@Override public void reviveCaps() { super.reviveCaps(); inputHandler = LazyOptional.of(() -> new FermenterItemHandler(inventory, Direction.UP)); outputHandler = LazyOptional.of(() -> new FermenterItemHandler(inventory, Direction.DOWN)); inputfluidTank = LazyOptional.of(this::createInputFluidHandler); outputfluidTank = LazyOptional.of(this::createFluidHandler); }
public static void workingTick( Level level, BlockPos pos, BlockState state, FermenterBlockEntity blockEntity) { boolean didInventoryChange = false; if (blockEntity.hasInput()) { Optional<FermenterRecipe> recipe = blockEntity.getMatchingRecipe(new RecipeWrapper(blockEntity.inventory)); if (recipe.isPresent() && blockEntity.canWork(recipe.get())) { didInventoryChange = blockEntity.processRecipe(recipe.get()); } else { blockEntity.recipeTime = 0; } } else if (blockEntity.recipeTime > 0) { blockEntity.recipeTime = 0; } if (didInventoryChange) { blockEntity.inventoryChanged(); } }
public void grantStoredRecipeExperience(Level world, Vec3 pos) { for (Object2IntMap.Entry<ResourceLocation> entry : experienceTracker.object2IntEntrySet()) { world .getRecipeManager() .byKey(entry.getKey()) .ifPresent( recipe -> LevelUtils.splitAndSpawnExperience( world, pos, entry.getIntValue(), ((FermenterRecipe) recipe).getExperience())); } }
@Override public int get(int index) { switch (index) { case 0: return FermenterBlockEntity.this.recipeTime; case 1: return FermenterBlockEntity.this.recipeTimeTotal; default: return 0; } }
@Override public void set(int index, int value) { switch (index) { case 0: FermenterBlockEntity.this.recipeTime = value; break; case 1: FermenterBlockEntity.this.recipeTimeTotal = value; break; } }
@Override public AbstractContainerMenu createMenu(int id, Inventory player, Player entity) { return new FermenterContainer(id, player, this, this.tileData); }
@Override public void load(CompoundTag compound) { super.load(compound); inventory.deserializeNBT(compound.getCompound("Inventory")); recipeTime = compound.getInt("RecipeTime"); recipeTimeTotal = compound.getInt("RecipeTimeTotal"); }
@Override public void saveAdditional(CompoundTag compound) { super.saveAdditional(compound); compound.put("Inventory", inventory.serializeNBT()); compound.putInt("RecipeTime", this.recipeTime); compound.putInt("RecipeTimeTotal", this.recipeTimeTotal); }
public void playSound(SoundEvent sound, float volume, float pitch) { if (level != null) level.playSound( null, worldPosition.getX() + 0.5F, worldPosition.getY() + 0.5F, worldPosition.getZ() + 0.5F, sound, SoundSource.BLOCKS, volume, pitch); }
public boolean addItem(ItemStack itemStack) { if (isEmpty() && !itemStack.isEmpty()) { inventory.setStackInSlot(0, itemStack.split(1)); inventoryChanged(); return true; } return false; }
public ItemStack removeItem() { if (!isEmpty()) { ItemStack item = getStoredItem().split(1); inventoryChanged(); return item; } return ItemStack.EMPTY; }
public boolean isEmpty() { return inventory.getStackInSlot(0).isEmpty(); }
@Override protected void inventoryChanged() { this.recipeTime = 0; super.inventoryChanged(); }
@Override protected void onContentsChanged(int slot) { inventoryChanged(); }
@Override public void load(CompoundTag compound) { super.load(compound); inventory.deserializeNBT(compound.getCompound("Inventory")); }
@Override public void saveAdditional(CompoundTag compound) { super.saveAdditional(compound); compound.put("Inventory", inventory.serializeNBT()); }
public static void workingTick( Level level, BlockPos pos, BlockState state, StoneMortarBlockEntity blockEntity) { boolean didInventoryChange = false; if (blockEntity.hasInput()) { Optional<StoneMortarRecipe> recipe = blockEntity.getMatchingRecipe(new RecipeWrapper(blockEntity.inventory)); if (recipe.isPresent() && blockEntity.canWork(recipe.get())) { didInventoryChange = blockEntity.processRecipe(recipe.get()); } else { blockEntity.recipeTime = 0; } } else if (blockEntity.recipeTime > 0) { blockEntity.recipeTime = 0; } if (didInventoryChange) { blockEntity.inventoryChanged(); } }
protected boolean canWork(StoneMortarRecipe recipe) { if (hasInput()) { boolean check_extra = false; ItemStack resultStack = recipe.getResultItem(); if (resultStack.isEmpty()) { return false; } else { ItemStack outStack = inventory.getStackInSlot(4); if (outStack.isEmpty()) { check_extra = true; } else if (!outStack.sameItem(resultStack)) { return false; } else { check_extra = outStack.getCount() + resultStack.getCount() <= resultStack.getMaxStackSize(); } ItemStack resultExtraStack = recipe.getResultItemList().size() > 1 ? recipe.getResultItemList().get(1) : ItemStack.EMPTY; if (resultExtraStack.isEmpty()) { return check_extra; } else if (check_extra) { ItemStack extraStack = inventory.getStackInSlot(5); if (extraStack.isEmpty()) { return true; } else if (!extraStack.sameItem(resultExtraStack)) { return false; } else { return extraStack.getCount() + resultExtraStack.getCount() <= resultExtraStack.getMaxStackSize(); } } else { return false; } } } else { return false; } }
public void grantStoredRecipeExperience(Level world, Vec3 pos) { for (Object2IntMap.Entry<ResourceLocation> entry : experienceTracker.object2IntEntrySet()) { world .getRecipeManager() .byKey(entry.getKey()) .ifPresent( recipe -> LevelUtils.splitAndSpawnExperience( world, pos, entry.getIntValue(), ((StoneMortarRecipe) recipe).getExperience())); } }
@Override public void saveAdditional(CompoundTag compound) { super.saveAdditional(compound); compound.putInt("RecipeTime", recipeTime); compound.putInt("RecipeTimeTotal", recipeTimeTotal); compound.put("Inventory", inventory.serializeNBT()); CompoundTag compoundRecipes = new CompoundTag(); experienceTracker.forEach( (recipeId, craftedAmount) -> compoundRecipes.putInt(recipeId.toString(), craftedAmount)); compound.put("RecipesUsed", compoundRecipes); }
private CompoundTag writeItems(CompoundTag compound) { super.saveAdditional(compound); compound.put("Inventory", inventory.serializeNBT()); return compound; }
@Override protected void onContentsChanged(int slot) { if (slot >= 0 && slot < 4) { checkNewRecipe = true; } inventoryChanged(); }
@Override public int get(int index) { switch (index) { case 0: return StoneMortarBlockEntity.this.recipeTime; case 1: return StoneMortarBlockEntity.this.recipeTimeTotal; default: return 0; } }
@Override public void set(int index, int value) { switch (index) { case 0: StoneMortarBlockEntity.this.recipeTime = value; break; case 1: StoneMortarBlockEntity.this.recipeTimeTotal = value; break; } }
@Override public AbstractContainerMenu createMenu(int id, Inventory player, Player entity) { return new StoneMortarContainer(id, player, this, tileData); }
@Override public BlockEntity newBlockEntity(BlockPos pos, BlockState state) { return BlockEntityRegistry.STONE_MORTAR.get().create(pos, state); }
@Override public InteractionResult use( BlockState state, Level world, BlockPos pos, Player player, InteractionHand handIn, BlockHitResult result) { if (!world.isClientSide) { BlockEntity tileEntity = world.getBlockEntity(pos); if (tileEntity instanceof StoneMortarBlockEntity blockEntity) { NetworkHooks.openGui((ServerPlayer) player, blockEntity, pos); } } return InteractionResult.SUCCESS; }
@Override @Nullable public <T extends BlockEntity> BlockEntityTicker<T> getTicker( Level level, BlockState state, BlockEntityType<T> blockEntity) { return createTickerHelper( blockEntity, BlockEntityRegistry.STONE_MORTAR.get(), StoneMortarBlockEntity::workingTick); }
@Override public BlockEntity newBlockEntity(BlockPos pos, BlockState state) { return BlockEntityRegistry.COOKING_POT.get().create(pos, state); }
@Override public VoxelShape getCollisionShape( BlockState state, BlockGetter worldIn, BlockPos pos, CollisionContext context) { return state.getValue(TRAY_SUPPORT) ? SHAPE_WITH_TRAY : SHAPE; }
@Override public InteractionResult use( BlockState state, Level level, BlockPos pos, Player player, InteractionHand handIn, BlockHitResult result) { ItemStack stack = player.getItemInHand(handIn); BlockEntity blockentity = level.getBlockEntity(pos); if (!(blockentity instanceof CookingPotBlockEntity cookingPot)) { return InteractionResult.FAIL; } IFluidHandlerItem handler = FluidUtil.getFluidHandler(ItemHandlerHelper.copyStackWithSize(stack, 1)).orElse(null); if (handler != null && handler instanceof FluidBucketWrapper) { FluidUtil.interactWithFluidHandler(player, handIn, cookingPot.getFluidTank().orElse(null)); cookingPot.inventoryChanged(); return InteractionResult.SUCCESS; } ItemStack heldStack = player.getItemInHand(handIn); if (heldStack.isEmpty() && player.isShiftKeyDown()) { level.setBlockAndUpdate(pos, state.setValue(OPEN, state.getValue(OPEN) ? false : true)); level.playSound(null, pos, SoundEvents.WOOD_PLACE, SoundSource.BLOCKS, 0.7F, 1.0F); } else if (!level.isClientSide) { NetworkHooks.openGui((ServerPlayer) player, cookingPot, pos); } return InteractionResult.SUCCESS; }
@Override protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) { super.createBlockStateDefinition(builder); builder.add(FACING, TRAY_SUPPORT, OPEN); }
@Override public BlockState updateShape( BlockState state, Direction facing, BlockState facingState, LevelAccessor world, BlockPos currentPos, BlockPos facingPos) { BlockState belowBlock = world.getBlockState(currentPos.below()); return state.setValue(TRAY_SUPPORT, belowBlock.is(SakuraBlockTags.TRAY_HEAT_SOURCES)); }
@Override @Nullable public <T extends BlockEntity> BlockEntityTicker<T> getTicker( Level level, BlockState state, BlockEntityType<T> blockEntity) { return createTickerHelper( blockEntity, BlockEntityRegistry.COOKING_POT.get(), CookingPotBlockEntity::workingTick); }
@Override public BlockEntity newBlockEntity(BlockPos pos, BlockState state) { return BlockEntityRegistry.DISTILLER.get().create(pos, state); }
@Override public VoxelShape getCollisionShape( BlockState state, BlockGetter worldIn, BlockPos pos, CollisionContext context) { return state.getValue(TRAY_SUPPORT) ? SHAPE_WITH_TRAY : Shapes.block(); }
public static boolean interactWithFluidHandler( @Nonnull Player player, @Nonnull InteractionHand hand, @Nonnull IFluidHandler handler) { Preconditions.checkNotNull(player); Preconditions.checkNotNull(hand); Preconditions.checkNotNull(handler); ItemStack heldItem = player.getItemInHand(hand); if (!heldItem.isEmpty()) { return player .getCapability(CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) .map( playerInventory -> { FluidActionResult fluidActionResult = FluidUtil.tryFillContainerAndStow( heldItem, handler, playerInventory, Integer.MAX_VALUE, player, true); if (fluidActionResult.isSuccess()) { player.setItemInHand(hand, fluidActionResult.getResult()); return true; } return false; }) .orElse(false); } return false; }
@Override protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) { super.createBlockStateDefinition(builder); builder.add(FACING, TRAY_SUPPORT); }
@Override @Nullable public <T extends BlockEntity> BlockEntityTicker<T> getTicker( Level level, BlockState state, BlockEntityType<T> blockEntity) { return createTickerHelper( blockEntity, BlockEntityRegistry.DISTILLER.get(), DistillerBlockEntity::workingTick); }
public static void spawnCuttingParticles( Level worldIn, BlockPos pos, ItemStack stack, int count) { for (int i = 0; i < count; ++i) { Vec3 vec3d = new Vec3( ((double) worldIn.random.nextFloat() - 0.5D) * 0.1D, Math.random() * 0.1D + 0.1D, ((double) worldIn.random.nextFloat() - 0.5D) * 0.1D); if (worldIn instanceof ServerLevel serverlevel) { serverlevel.sendParticles( new ItemParticleOption(ParticleTypes.ITEM, stack), pos.getX() + 0.5F, pos.getY() + 0.1F, pos.getZ() + 0.5F, 1, vec3d.x, vec3d.y + 0.05D, vec3d.z, 0.0D); } else { worldIn.addParticle( new ItemParticleOption(ParticleTypes.ITEM, stack), pos.getX() + 0.5F, pos.getY() + 0.1F, pos.getZ() + 0.5F, vec3d.x, vec3d.y + 0.05D, vec3d.z); } } }
@Override public BlockEntity newBlockEntity(BlockPos pos, BlockState state) { return BlockEntityRegistry.CHOPPING_BOARD.get().create(pos, state); }
@Override public VoxelShape getShape( BlockState state, BlockGetter worldIn, BlockPos pos, CollisionContext context) { Direction facing = state.getValue(FACING); return facing == Direction.NORTH || facing == Direction.SOUTH ? SHAPE_NS : SHAPE_WE; }
@Override public BlockEntity newBlockEntity(BlockPos pos, BlockState state) { return BlockEntityRegistry.FERMENTER.get().create(pos, state); }
@Override @Nullable public <T extends BlockEntity> BlockEntityTicker<T> getTicker( Level level, BlockState state, BlockEntityType<T> blockEntity) { return createTickerHelper( blockEntity, BlockEntityRegistry.FERMENTER.get(), FermenterBlockEntity::workingTick); }
@Nonnull @Override protected List<ItemStack> doApply(List<ItemStack> generatedLoot, LootContext context) { List<Item> seeds = Lists.newArrayList( ItemRegistry.CABBAGE_SEEDS.get(), ItemRegistry.EGGPLANT_SEEDS.get(), ItemRegistry.ONION_SEEDS.get(), ItemRegistry.RADISH_SEEDS.get(), ItemRegistry.TOMATO_SEEDS.get(), ItemRegistry.RICE_SEEDS.get(), ItemRegistry.RAPESEEDS.get(), ItemRegistry.TARO.get(), ItemRegistry.BUCKWHEAT.get(), ItemRegistry.SOYBEAN.get(), ItemRegistry.RED_BEAN.get()); generatedLoot.add(new ItemStack(seeds.get((int) (Math.random() * seeds.size())))); return generatedLoot; }
@Override public SeedDropModifier read( ResourceLocation location, JsonObject object, LootItemCondition[] ailootcondition) { return new SeedDropModifier(ailootcondition); }
@Override public JsonObject write(SeedDropModifier instance) { return new JsonObject(); }
@Override protected List<ItemStack> doApply(List<ItemStack> generatedLoot, LootContext context) { generatedLoot.add(new ItemStack(FoodRegistry.FOODSET.get(SakuraFoodSet.SHRIMP).get())); return generatedLoot; }
@Override public FishingModifiter read( ResourceLocation location, JsonObject object, LootItemCondition[] ailootcondition) { return new FishingModifiter(ailootcondition); }
@Override public JsonObject write(FishingModifiter instance) { return new JsonObject(); }
@SuppressWarnings("resource") @SubscribeEvent public static void onParticleFactoryRegistration(ParticleFactoryRegisterEvent event) { Minecraft.getInstance() .particleEngine .register(ParticleRegistry.SAKURA_LEAF.get(), FallenLeafParticle.Factory::new); Minecraft.getInstance() .particleEngine .register(ParticleRegistry.RED_MAPLE_LEAF.get(), FallenLeafParticle.Factory::new); Minecraft.getInstance() .particleEngine .register(ParticleRegistry.YELLOW_MAPLE_LEAF.get(), FallenLeafParticle.Factory::new); Minecraft.getInstance() .particleEngine .register(ParticleRegistry.GREEN_MAPLE_LEAF.get(), FallenLeafParticle.Factory::new); Minecraft.getInstance() .particleEngine .register(ParticleRegistry.ORANGE_MAPLE_LEAF.get(), FallenLeafParticle.Factory::new); }
@Override public void tick() { this.xo = this.x; this.yo = this.y; this.zo = this.z; if (age++ >= lifetime) { this.remove(); } this.move(this.xd, this.yd, this.zd); this.yd -= 0.003000000026077032D; this.yd = Math.max(this.yd, -0.14000000059604645D); if (onGround) { xd *= 0.0D; zd *= 0.0D; } }
@Override public Particle createParticle( SimpleParticleType typeIn, ClientLevel world, double xIn, double yIn, double zIn, double motionXIn, double motionYIn, double motionZIn) { FallenLeafParticle particle = new FallenLeafParticle(world, xIn, yIn, zIn, motionXIn, motionYIn, motionZIn); particle.pickSprite(this.sprite); return particle; }
@SubscribeEvent public static void registerLayers(EntityRenderersEvent.RegisterLayerDefinitions event) { event.registerLayerDefinition(STONE_MORTAR, StoneMortarRenderer::createLayer); }
private static ModelLayerLocation register(String path) { return register(path, "main"); }
private static ModelLayerLocation register(String path, String part) { return new ModelLayerLocation(new ResourceLocation(SakuraMod.MODID, path), part); }
@Override public void render(PoseStack ms, final int mouseX, final int mouseY, float partialTicks) { this.renderBackground(ms); super.render(ms, mouseX, mouseY, partialTicks); this.renderTooltip(ms, mouseX, mouseY); }
@Override protected void renderLabels(PoseStack ms, int mouseX, int mouseY) { super.renderLabels(ms, mouseX, mouseY); this.font.draw(ms, this.playerInventoryTitle, 8.0f, this.imageHeight - 96 + 2, 4210752); }
@Override protected void renderBg(PoseStack ms, float partialTicks, int mouseX, int mouseY) { if (this.minecraft == null) { return; } RenderUtils.setup(BACKGROUND_TEXTURE); this.blit(ms, this.leftPos, this.topPos, 0, 0, this.imageWidth, this.imageHeight); int n = this.menu.getRolling(); this.blit(ms, this.leftPos + 81, this.topPos + 33, 176, n * 16, 14, 16); int l = this.menu.getProgressionRoll(); this.blit(ms, this.leftPos + 80, this.topPos + 49, 190, l * 6, 16, 6); }
@Override protected void renderBg(PoseStack ms, float partialTicks, int mouseX, int mouseY) { if (this.minecraft == null) { return; } RenderUtils.setup(BACKGROUND_TEXTURE); this.blit(ms, this.leftPos, this.topPos, 0, 0, this.imageWidth, this.imageHeight); if (this.menu.isHeated()) { this.blit(ms, this.leftPos + 101, this.topPos + 52, 176, 0, 18, 18); } int l = this.menu.getCookProgressionScaled(); this.blit(ms, this.leftPos + 98, this.topPos + 34, 176, 18, l + 1, 17); this.menu .tileEntity .getFluidTank() .ifPresent( fluidTank -> { int heightInd = (int) (52.0F * ((float) fluidTank.getFluidAmount() / (float) fluidTank.getCapacity())); if (heightInd > 0) { ClientUtil.renderFluidStack( this.leftPos + 17, this.topPos + 69 - heightInd, 16, heightInd, 0.0F, fluidTank.getFluid()); } }); }
@SubscribeEvent public static void screenRegistry(final FMLClientSetupEvent event) { event.enqueueWork( () -> { MenuScreens.register(ContainerRegistry.STONE_MORTAR.get(), StoneMortarScreen::new); MenuScreens.register(ContainerRegistry.COOKING_POT.get(), CookingPotScreen::new); MenuScreens.register(ContainerRegistry.FERMENTER.get(), FermenterScreen::new); MenuScreens.register(ContainerRegistry.DISTILLER.get(), DistillerScreen::new); }); }
@Override public void render( ChoppingBoardBlockEntity blockEntity, float partialTicks, PoseStack poseStack, MultiBufferSource buffer, int combinedLight, int combinedOverlay) { Direction direction = blockEntity.getBlockState().getValue(ChoppingBoardBlock.FACING).getOpposite(); ItemStack boardStack = blockEntity.getStoredItem(); int posLong = (int) blockEntity.getBlockPos().asLong(); if (!boardStack.isEmpty()) { poseStack.pushPose(); ItemRenderer itemRenderer = Minecraft.getInstance().getItemRenderer(); boolean isBlockItem = itemRenderer.getModel(boardStack, blockEntity.getLevel(), null, 0).isGui3d(); if (isBlockItem) { renderBlock(poseStack, direction); } else { renderItemLayingDown(poseStack, direction); } Minecraft.getInstance() .getItemRenderer() .renderStatic( boardStack, ItemTransforms.TransformType.FIXED, combinedLight, combinedOverlay, poseStack, buffer, posLong); poseStack.popPose(); } }
public void renderItemLayingDown(PoseStack matrixStackIn, Direction direction) { matrixStackIn.translate(0.5D, 0.16D, 0.5D); float f = -direction.toYRot(); matrixStackIn.mulPose(Vector3f.YP.rotationDegrees(f)); matrixStackIn.mulPose(Vector3f.XP.rotationDegrees(90.0F)); matrixStackIn.scale(0.6F, 0.6F, 0.6F); }
public void renderBlock(PoseStack matrixStackIn, Direction direction) { matrixStackIn.translate(0.5D, 0.27D, 0.5D); float f = -direction.toYRot(); matrixStackIn.mulPose(Vector3f.YP.rotationDegrees(f)); matrixStackIn.scale(0.8F, 0.8F, 0.8F); }
@Override public void render( ObonBlockEntity blockEntity, float partialTicks, PoseStack poseStack, MultiBufferSource buffer, int combinedLight, int combinedOverlay) { Direction direction = blockEntity.getBlockState().getValue(ObonBlock.FACING).getOpposite(); ItemStack boardStack = blockEntity.getStoredItem(); int posLong = (int) blockEntity.getBlockPos().asLong(); if (!boardStack.isEmpty()) { poseStack.pushPose(); ItemRenderer itemRenderer = Minecraft.getInstance().getItemRenderer(); boolean isBlockItem = itemRenderer.getModel(boardStack, blockEntity.getLevel(), null, 0).isGui3d(); if (isBlockItem) { renderBlock(poseStack, direction); } else { renderItemLayingDown(poseStack, direction); } Minecraft.getInstance() .getItemRenderer() .renderStatic( boardStack, ItemTransforms.TransformType.FIXED, combinedLight, combinedOverlay, poseStack, buffer, posLong); poseStack.popPose(); } }
public static LayerDefinition createLayer() { MeshDefinition meshdefinition = new MeshDefinition(); PartDefinition partdefinition = meshdefinition.getRoot(); partdefinition.addOrReplaceChild( "top", CubeListBuilder.create() .texOffs(0, 24) .addBox(-8.0F, -16.0F, -8.0F, 16.0F, 8.0F, 16.0F, new CubeDeformation(0.0F)) .texOffs(0, 0) .addBox(-6.0F, -22.0F, 4.0F, 2.0F, 6.0F, 2.0F, new CubeDeformation(0.0F)), PartPose.offset(0.0F, 24.0F, 0.0F)); partdefinition.addOrReplaceChild( "bb_main", CubeListBuilder.create() .texOffs(0, 0) .addBox(-8.0F, -8.0F, -8.0F, 16.0F, 8.0F, 16.0F, new CubeDeformation(0.0F)), PartPose.offset(0.0F, 24.0F, 0.0F)); return LayerDefinition.create(meshdefinition, 128, 64); }
public void renderToBuffer( PoseStack poseStack, VertexConsumer buffer, int packedLight, int packedOverlay) { top.render(poseStack, buffer, packedLight, packedOverlay); bb_main.render(poseStack, buffer, packedLight, packedOverlay); }
@Override public void renderByItem( @Nonnull ItemStack stack, @Nonnull ItemTransforms.TransformType transformType, @Nonnull PoseStack matrix, @Nonnull MultiBufferSource buffer, int x, int y) { if (blockEntity == null) { blockEntity = BlockEntityRegistry.STONE_MORTAR .get() .create(BlockPos.ZERO, BlockRegistry.STONE_MORTAR.get().defaultBlockState()); } Minecraft.getInstance() .getBlockEntityRenderDispatcher() .renderItem(blockEntity, matrix, buffer, x, y); }
private static Item normalItem() { return new Item(SakuraMod.defaultItemProperties()); }
private static ItemNameBlockItem seed(Block block) { return new ItemNameBlockItem(block, SakuraMod.defaultItemProperties()); }
private static ItemFoodSeeds seed(Block block, FoodInfo info) { return new ItemFoodSeeds(block, SakuraMod.defaultItemProperties(), info); }
private static <V extends Item> RegistryObject<V> register(String name, Supplier<V> item) { return ITEMS.register(name, item); }
private static ItemFoodBase normalFood(FoodInfo info) { return new ItemFoodBase(SakuraMod.defaultItemProperties(), info); }
private static ItemFoodBase normalFood(FoodInfo info, Item container) { if (container == null) return normalFood(info); return new ItemFoodBase(SakuraMod.defaultItemProperties().craftRemainder(container), info); }
@Override public boolean canAttackBlock(BlockState state, Level worldIn, BlockPos pos, Player player) { return !player.isCreative(); }
@Override public boolean hurtEnemy(ItemStack stack, LivingEntity target, LivingEntity attacker) { stack.hurtAndBreak(1, attacker, (user) -> user.broadcastBreakEvent(EquipmentSlot.MAINHAND)); return true; }
public static void registerCompost() { FoodRegistry.ITEMS .getEntries() .forEach( item -> { register(item.get()); }); register(ItemRegistry.CABBAGE_SEEDS.get(), 0.3F); register(ItemRegistry.BUCKWHEAT.get(), 0.3F); register(ItemRegistry.RED_BEAN.get(), 0.3F); register(ItemRegistry.SOYBEAN.get(), 0.3F); register(ItemRegistry.RADISH_SEEDS.get(), 0.3F); register(ItemRegistry.ONION_SEEDS.get(), 0.3F); register(ItemRegistry.RICE_SEEDS.get(), 0.3F); register(ItemRegistry.TOMATO_SEEDS.get(), 0.3F); register(ItemRegistry.TARO.get(), 0.3F); register(ItemRegistry.EGGPLANT_SEEDS.get(), 0.3F); }
private static void register(Item item) { if (item instanceof IFoodLike food) { if (food.getFoodInfo().getCompostChance() > 0) register(item, food.getFoodInfo().getCompostChance()); } }
private static void register(Item item, float chance) { ComposterBlock.COMPOSTABLES.put(item, chance); }
private static ForgeFlowingFluid.Properties createProp( Supplier<? extends Fluid> still, Supplier<? extends Fluid> flowing, int color, Supplier<? extends Item> bucket, Supplier<? extends LiquidBlock> block) { return new ForgeFlowingFluid.Properties( still, flowing, FluidAttributes.builder( new ResourceLocation("block/water_still"), new ResourceLocation("block/water_flow")) .sound(SoundEvents.BUCKET_FILL, SoundEvents.BUCKET_EMPTY) .color(color) .density(3000) .viscosity(1000)) .block(block) .bucket(bucket) .slopeFindDistance(3) .explosionResistance(100F); }
public String toString() { return new ResourceLocation(SakuraMod.MODID, name).toString(); }
@Override public boolean isSpecial() { return true; }
@Override public boolean matches(RecipeWrapper inv, Level worldIn) { List<ItemStack> inputs = Lists.newArrayList(); int i = 0; for (int j = 0; j < 4; ++j) { ItemStack itemstack = inv.getItem(j); if (!itemstack.isEmpty()) { ++i; inputs.add(itemstack); } } return i == this.getIngredients().size() && RecipeMatcher.findMatches(inputs, this.getIngredients()) != null; }
@Override public ItemStack assemble(RecipeWrapper inv) { return this.output.get(0).copy(); }
@Override public boolean canCraftInDimensions(int width, int height) { return width * height >= this.getIngredients().size(); }
public boolean matchesWithFluid(FluidStack fluid, RecipeWrapper inv, Level worldIn) { if (this.getRequiredFluid() == FluidIngredient.EMPTY) return fluid.isEmpty() && matches(inv, worldIn); return this.getRequiredFluid().test(fluid) && matches(inv, worldIn); }
@Override public boolean matches(RecipeWrapper inv, Level worldIn) { List<ItemStack> inputs = Lists.newArrayList(); int i = 0; for (int j = 0; j < 3; ++j) { ItemStack itemstack = inv.getItem(j); if (!itemstack.isEmpty()) { ++i; inputs.add(itemstack); } } return i == this.getIngredients().size() && RecipeMatcher.findMatches(inputs, this.getIngredients()) != null; }
@Override public ItemStack assemble(RecipeWrapper inv) { if (this.outputItems.size() > 0) return this.outputItems.get(0).copy(); return ItemStack.EMPTY; }
@Override public boolean matches(RecipeWrapper inv, Level worldIn) { if (inv.isEmpty()) return false; return input.test(inv.getItem(0)); }
public List<ItemStack> rollByproducts(Random rand, int fortuneLevel) { List<ItemStack> results = Lists.newArrayList(); NonNullList<ChanceResult> rollableResults = getByproducts(); for (ChanceResult output : rollableResults) { ItemStack stack = output.rollOutput(rand, fortuneLevel); if (!stack.isEmpty()) results.add(stack); } return results; }
@Override public ItemStack assemble(RecipeWrapper inv) { return this.output; }
@Override public boolean matches(RecipeWrapper inv, Level worldIn) { List<ItemStack> inputs = Lists.newArrayList(); int i = 0; for (int j = 0; j < 9; ++j) { ItemStack itemstack = inv.getItem(j); if (!itemstack.isEmpty()) { ++i; inputs.add(itemstack); } } return i == this.getIngredients().size() && RecipeMatcher.findMatches(inputs, this.getIngredients()) != null; }
@Override public ItemStack assemble(RecipeWrapper inv) { return this.output.copy(); }
public boolean matchesWithFluid(FluidStack fluid, RecipeWrapper inv, Level worldIn) { if (this.getRequiredFluid() == FluidIngredient.EMPTY) return matches(inv, worldIn); return this.getRequiredFluid().test(fluid) && matches(inv, worldIn); }
@Override protected void buildCraftingRecipes(Consumer<FinishedRecipe> consumer) { registerCraftingRecipe(consumer); registerMortarRecipe(consumer); registerCookingRecipe(consumer); registerFermenterRecipe(consumer); registerDistillerRecipe(consumer); registerChoppingRecipes(consumer); }
private void registerChoppingRecipes(Consumer<FinishedRecipe> consumer) { ChoppingBoardRecipeBuilder.chop(FoodRegistry.FOODSET.get(SakuraFoodSet.MACHINED_FISH).get()) .requires( Ingredient.fromValues( Stream.of( new Ingredient.ItemValue(new ItemStack(Items.COD)), new Ingredient.ItemValue(new ItemStack(Items.SALMON)), new Ingredient.ItemValue(new ItemStack(Items.TROPICAL_FISH))))) .requiresTool(SakuraItemTags.TOOLS_KNIVES_FISH) .addByproduce(FoodRegistry.FOODSET.get(SakuraFoodSet.MACHINED_FISH).get()) .addByproduceWithChance(Items.BONE_MEAL, 0.5F) .save(consumer, new ResourceLocation(SakuraMod.MODID, "machined_fish_chopping")); ChoppingBoardRecipeBuilder.chop(FoodRegistry.FOODSET.get(SakuraFoodSet.SLICED_CABBAGE).get()) .requires(SakuraItemTags.CROPS_CABBAGE) .requiresTool(SakuraItemTags.TOOLS_KNIVES_FISH) .addByproduce(FoodRegistry.FOODSET.get(SakuraFoodSet.SLICED_CABBAGE).get()) .addByproduceWithChance(FoodRegistry.FOODSET.get(SakuraFoodSet.SLICED_CABBAGE).get(), 0.5F) .save(consumer, new ResourceLocation(SakuraMod.MODID, "sliced_cabbage_chopping")); }
private void foodSmeltingRecipes( String name, ItemLike ingredient, ItemLike result, float experience, Consumer<FinishedRecipe> consumer) { String namePrefix = new ResourceLocation(SakuraMod.MODID, name).toString(); smeltingRecipe(result, ingredient, experience).save(consumer); campfireRecipe(result, ingredient, experience) .save(consumer, namePrefix + "_from_campfire_cooking"); smokingRecipe(result, ingredient, experience).save(consumer, namePrefix + "_from_smoking"); }
public ShapedRecipeBuilder makeLumberToPlank( Supplier<? extends Block> blockOut, Ingredient ingreIn) { return ShapedRecipeBuilder.shaped(blockOut.get()) .pattern("##") .pattern("##") .define('#', ingreIn); }
public ShapelessRecipeBuilder makeLumber(Supplier<? extends Item> ingotOut, Ingredient ingreIn) { return ShapelessRecipeBuilder.shapeless(ingotOut.get(), 8).requires(ingreIn); }
public ShapelessRecipeBuilder makeItemToBucket( Supplier<? extends Item> ingotOut, Ingredient ingreIn) { return ShapelessRecipeBuilder.shapeless(ingotOut.get()) .requires(ingreIn) .requires(ingreIn) .requires(ingreIn) .requires(ingreIn) .requires(ingreIn) .requires(ingreIn) .requires(ingreIn) .requires(ingreIn) .requires(Items.BUCKET); }
public ConditionalRecipe.Builder whenModLoaded( CookingPotRecipeBuilder recipe, String modid, String path) { return ConditionalRecipe.builder() .addCondition(new ModLoadedCondition(modid)) .addRecipe(consumer -> recipe.save(consumer, new ResourceLocation(SakuraMod.MODID, path))); }
public ConditionalRecipe.Builder whenModLoaded( StoneMortarRecipeBuilder recipe, String modid, String path) { return ConditionalRecipe.builder() .addCondition(new ModLoadedCondition(modid)) .addRecipe(consumer -> recipe.save(consumer, new ResourceLocation(SakuraMod.MODID, path))); }
@SubscribeEvent public static void dataGen(GatherDataEvent event) { DataGenerator dataGenerator = event.getGenerator(); ExistingFileHelper existingFileHelper = event.getExistingFileHelper(); dataGenerator.addProvider( new SakuraBlockStateProvider(dataGenerator, SakuraMod.MODID, existingFileHelper)); dataGenerator.addProvider( new SakuraItemModelProvider(dataGenerator, SakuraMod.MODID, existingFileHelper)); SakuraBlockTagsProvider block_tag = new SakuraBlockTagsProvider(dataGenerator, SakuraMod.MODID, existingFileHelper); dataGenerator.addProvider(block_tag); dataGenerator.addProvider( new SakuraItemTagsProvider(dataGenerator, block_tag, SakuraMod.MODID, existingFileHelper)); dataGenerator.addProvider( new SakuraFluidTagsProvider(dataGenerator, SakuraMod.MODID, existingFileHelper)); dataGenerator.addProvider(new SakuraRecipeProvider(dataGenerator)); dataGenerator.addProvider(new SakuraLootTableProvider(dataGenerator)); }
@Override protected void registerModels() { BlockItemRegistry.ITEMS .getEntries() .forEach( item -> { if (item.get() instanceof BlockItem) { BlockItem blockItem = (BlockItem) item.get(); if (blockItem.getBlock() instanceof StoneMortarBlock) return; if (blockItem.getBlock() instanceof BushBlock) bushItem(item); else itemBlock(blockItem::getBlock); } else { normalItem(item); } }); BucketItemRegistry.ITEMS .getEntries() .forEach( (item) -> { normalItem(item); }); }
public static ChoppingBoardRecipeBuilder chop(ItemLike resultItem) { return new ChoppingBoardRecipeBuilder(resultItem, 1, 1F, 1); }
public static ChoppingBoardRecipeBuilder chop(ItemLike resultItem, int count) { return new ChoppingBoardRecipeBuilder(resultItem, count, 1F, 1); }
public static ChoppingBoardRecipeBuilder chop(ItemLike resultItem, float exp, int time) { return new ChoppingBoardRecipeBuilder(resultItem, 1, exp, time); }
public static ChoppingBoardRecipeBuilder chop( ItemLike resultItem, int count, float exp, int time) { return new ChoppingBoardRecipeBuilder(resultItem, count, exp, time); }
public ChoppingBoardRecipeBuilder requires(TagKey<Item> tag) { return this.requires(Ingredient.of(tag)); }
public ChoppingBoardRecipeBuilder requires(ItemLike item) { return this.requires(Ingredient.of(item)); }
public ChoppingBoardRecipeBuilder requires(Ingredient ingre) { if (this.item.isEmpty()) this.item = ingre; return this; }
public ChoppingBoardRecipeBuilder requiresTool(TagKey<Item> tag) { return this.requiresTool(Ingredient.of(tag)); }
public ChoppingBoardRecipeBuilder requiresTool(ItemLike item) { return this.requiresTool(Ingredient.of(item)); }
public ChoppingBoardRecipeBuilder requiresTool(Ingredient ingre) { if (this.tool.isEmpty()) this.tool = ingre; return this; }
public ChoppingBoardRecipeBuilder addByproduce(ItemLike result) { return this.addByproduce(result, 1); }
public ChoppingBoardRecipeBuilder addByproduce(ItemLike result, int count) { this.byproduces.add(new ChanceResult(new ItemStack(result.asItem(), count), 1)); return this; }
public ChoppingBoardRecipeBuilder addByproduceWithChance(ItemLike result, float chance) { return this.addByproduce(result, 1, chance); }
public ChoppingBoardRecipeBuilder addByproduce(ItemLike result, int count, float chance) { this.byproduces.add(new ChanceResult(new ItemStack(result.asItem(), count), chance)); return this; }
public void save(Consumer<FinishedRecipe> consumer, ResourceLocation id) { consumer.accept( new ChoppingBoardRecipeBuilder.Result( id, this.item, this.tool, this.result, this.byproduces, this.experience, this.recipeTime)); }
@Override public void serializeRecipeData(JsonObject json) { JsonObject recipeJson = RecipeTypeRegistry.CHOPPING_RECIPE_SERIALIZER.get().toJson(recipe); json.add("ingredient", recipeJson.get("ingredient")); json.add("tool", recipeJson.get("tool")); json.add("result", recipeJson.get("result")); json.add("byproducts", recipeJson.get("byproducts")); json.add("experience", recipeJson.get("experience")); json.add("recipeTime", recipeJson.get("recipeTime")); }
@Nullable @Override public JsonObject serializeAdvancement() { return null; }
public static FermenterRecipeBuilder fermenting( FluidIngredient fluid, FluidStack result_fluid, float exp, int time) { return new FermenterRecipeBuilder(fluid, result_fluid, exp, time); }
public static FermenterRecipeBuilder fermenting(FluidIngredient fluid, FluidStack result_fluid) { return new FermenterRecipeBuilder(fluid, result_fluid, 0F, 800); }
public static FermenterRecipeBuilder fermenting( FluidIngredient fluid, ItemLike resultItem, FluidStack result_fluid) { return new FermenterRecipeBuilder(fluid, resultItem, 1, result_fluid, 0F, 800); }
public static FermenterRecipeBuilder fermenting( FluidIngredient fluid, ItemLike resultItem, int count, FluidStack result_fluid) { return new FermenterRecipeBuilder(fluid, resultItem, count, result_fluid, 0F, 800); }
public static FermenterRecipeBuilder fermenting( FluidIngredient fluid, ItemLike resultItem, FluidStack result_fluid, float exp, int time) { return new FermenterRecipeBuilder(fluid, resultItem, 1, result_fluid, exp, time); }
public static FermenterRecipeBuilder fermenting( FluidIngredient fluid, ItemLike resultItem, int count, FluidStack result_fluid, float exp, int time) { return new FermenterRecipeBuilder(fluid, resultItem, count, result_fluid, exp, time); }
public FermenterRecipeBuilder requires(TagKey<Item> tag) { return this.requires(Ingredient.of(tag)); }
public FermenterRecipeBuilder requires(ItemLike item) { return this.requires(item, 1); }
public FermenterRecipeBuilder requires(ItemLike item, int count) { for (int i = 0; i < count; ++i) { this.requires(Ingredient.of(item)); } return this; }
public FermenterRecipeBuilder requires(Ingredient ingre) { return this.requires(ingre, 1); }
public FermenterRecipeBuilder requires(Ingredient ingre, int count) { for (int i = 0; i < count; ++i) { this.ingredients.add(ingre); } return this; }
public FermenterRecipeBuilder addResult(ItemLike result) { return this.addResult(result, 1); }
public FermenterRecipeBuilder addResult(ItemLike result, int count) { this.result.add(new ItemStack(result.asItem(), count)); return this; }
public void save(Consumer<FinishedRecipe> consumer, ResourceLocation id) { consumer.accept( new FermenterRecipeBuilder.Result( id, this.fluid, this.result, this.ingredients, result_fluid, this.experience, this.recipeTime)); }
@Override public void serializeRecipeData(JsonObject json) { JsonObject recipeJson = RecipeTypeRegistry.FERMENTER_RECIPE_SERIALIZER.get().toJson(recipe); json.add("ingredients", recipeJson.get("ingredients")); json.add("fluid", recipeJson.get("fluid")); json.add("results", recipeJson.get("results")); json.add("result_fluid", recipeJson.get("result_fluid")); json.add("experience", recipeJson.get("experience")); json.add("recipeTime", recipeJson.get("recipeTime")); }
public static StoneMortarRecipeBuilder mortar(ItemLike resultItem) { return new StoneMortarRecipeBuilder(resultItem, 1, 0F, 200); }
public static StoneMortarRecipeBuilder mortar(ItemLike resultItem, int count) { return new StoneMortarRecipeBuilder(resultItem, count, 0F, 200); }
public static StoneMortarRecipeBuilder mortar(ItemLike resultItem, float exp, int time) { return new StoneMortarRecipeBuilder(resultItem, 1, exp, time); }
public static StoneMortarRecipeBuilder mortar( ItemLike resultItem, int count, float exp, int time) { return new StoneMortarRecipeBuilder(resultItem, count, exp, time); }
public StoneMortarRecipeBuilder requires(TagKey<Item> tag) { return this.requires(Ingredient.of(tag)); }
public StoneMortarRecipeBuilder requires(ItemLike item) { return this.requires(item, 1); }
public StoneMortarRecipeBuilder requires(ItemLike item, int count) { for (int i = 0; i < count; ++i) { this.requires(Ingredient.of(item)); } return this; }
public StoneMortarRecipeBuilder requires(Ingredient ingre) { return this.requires(ingre, 1); }
public StoneMortarRecipeBuilder requires(Ingredient ingre, int count) { for (int i = 0; i < count; ++i) { this.ingredients.add(ingre); } return this; }
public StoneMortarRecipeBuilder addResult(ItemLike result) { return this.addResult(result, 1); }
public StoneMortarRecipeBuilder addResult(ItemLike result, int count) { this.result.add(new ItemStack(result.asItem(), count)); return this; }
public void save(Consumer<FinishedRecipe> consumer, ResourceLocation id) { consumer.accept( new StoneMortarRecipeBuilder.Result( id, this.result, this.ingredients, this.experience, this.recipeTime)); }
@Override public void serializeRecipeData(JsonObject json) { JsonObject recipeJson = RecipeTypeRegistry.STONE_MORTAR_RECIPE_SERIALIZER.get().toJson(recipe); json.add("ingredients", recipeJson.get("ingredients")); json.add("results", recipeJson.get("results")); json.add("experience", recipeJson.get("experience")); json.add("recipeTime", recipeJson.get("recipeTime")); }
public static CookingPotRecipeBuilder cooking(FluidIngredient fluid, ItemLike resultItem) { return new CookingPotRecipeBuilder(fluid, resultItem, 1, 0F, 200); }
public static CookingPotRecipeBuilder cooking( FluidIngredient fluid, ItemLike resultItem, int count) { return new CookingPotRecipeBuilder(fluid, resultItem, count, 0F, 200); }
public static CookingPotRecipeBuilder cooking( FluidIngredient fluid, ItemLike resultItem, float exp, int time) { return new CookingPotRecipeBuilder(fluid, resultItem, 1, exp, time); }
public static CookingPotRecipeBuilder cooking( FluidIngredient fluid, ItemLike resultItem, int count, float exp, int time) { return new CookingPotRecipeBuilder(fluid, resultItem, count, exp, time); }
public CookingPotRecipeBuilder requires(TagKey<Item> tag) { return this.requires(Ingredient.of(tag)); }
public CookingPotRecipeBuilder requires(ItemLike item) { return this.requires(item, 1); }
public CookingPotRecipeBuilder requires(ItemLike item, int count) { for (int i = 0; i < count; ++i) { this.requires(Ingredient.of(item)); } return this; }
public CookingPotRecipeBuilder requires(Ingredient ingre) { return this.requires(ingre, 1); }
public CookingPotRecipeBuilder requires(Ingredient ingre, int count) { for (int i = 0; i < count; ++i) { this.ingredients.add(ingre); } return this; }
public void save(Consumer<FinishedRecipe> consumer, ResourceLocation id) { consumer.accept( new CookingPotRecipeBuilder.Result( id, this.fluid, this.result, this.ingredients, this.experience, this.recipeTime)); }
@Override public void serializeRecipeData(JsonObject json) { JsonObject recipeJson = RecipeTypeRegistry.COOKING_RECIPE_SERIALIZER.get().toJson(recipe); json.add("ingredients", recipeJson.get("ingredients")); json.add("fluid", recipeJson.get("fluid")); json.add("result", recipeJson.get("result")); json.add("experience", recipeJson.get("experience")); json.add("recipeTime", recipeJson.get("recipeTime")); }
public static DistillerRecipeBuilder distillation( FluidIngredient fluid, FluidStack result_fluid, float exp, int time) { return new DistillerRecipeBuilder(fluid, result_fluid, exp, time); }
public static DistillerRecipeBuilder distillation( FluidIngredient fluid, FluidStack result_fluid) { return new DistillerRecipeBuilder(fluid, result_fluid, 0F, 400); }
public static DistillerRecipeBuilder distillation( FluidIngredient fluid, ItemLike resultItem, FluidStack result_fluid) { return new DistillerRecipeBuilder(fluid, resultItem, 1, result_fluid, 0F, 400); }
public static DistillerRecipeBuilder distillation( FluidIngredient fluid, ItemLike resultItem, int count, FluidStack result_fluid) { return new DistillerRecipeBuilder(fluid, resultItem, count, result_fluid, 0F, 400); }
public static DistillerRecipeBuilder distillation( FluidIngredient fluid, ItemLike resultItem, FluidStack result_fluid, float exp, int time) { return new DistillerRecipeBuilder(fluid, resultItem, 1, result_fluid, exp, time); }
public static DistillerRecipeBuilder distillation( FluidIngredient fluid, ItemLike resultItem, int count, FluidStack result_fluid, float exp, int time) { return new DistillerRecipeBuilder(fluid, resultItem, count, result_fluid, exp, time); }
public DistillerRecipeBuilder requires(TagKey<Item> tag) { return this.requires(Ingredient.of(tag)); }
public DistillerRecipeBuilder requires(ItemLike item) { return this.requires(item, 1); }
public DistillerRecipeBuilder requires(ItemLike item, int count) { for (int i = 0; i < count; ++i) { this.requires(Ingredient.of(item)); } return this; }
public DistillerRecipeBuilder requires(Ingredient ingre) { return this.requires(ingre, 1); }
public DistillerRecipeBuilder requires(Ingredient ingre, int count) { for (int i = 0; i < count; ++i) { this.ingredients.add(ingre); } return this; }
public DistillerRecipeBuilder addResult(ItemLike result) { return this.addResult(result, 1); }
public DistillerRecipeBuilder addResult(ItemLike result, int count) { this.result.add(new ItemStack(result.asItem(), count)); return this; }
public void save(Consumer<FinishedRecipe> consumer, ResourceLocation id) { consumer.accept( new DistillerRecipeBuilder.Result( id, this.fluid, this.result, this.ingredients, result_fluid, this.experience, this.recipeTime)); }
private void createTeishoku(Block block) { LootItemCondition.Builder builder = LootItemBlockStatePropertyCondition.hasBlockStateProperties(block) .setProperties( StatePropertiesPredicate.Builder.properties().hasProperty(TeishokuBlock.BITES, 0)); this.add( block, createTeishokuDrops(block, BlockItemRegistry.OBON.get(), block.asItem(), builder)); }
protected static LootTable.Builder createTeishokuDrops( Block p_124143_, Item p_124144_, Item p_124145_, LootItemCondition.Builder p_124146_) { return applyExplosionDecay( p_124143_, LootTable.lootTable() .withPool(LootPool.lootPool().add(LootItem.lootTableItem(p_124145_).when(p_124146_))) .withPool( LootPool.lootPool() .when(p_124146_.invert()) .add(LootItem.lootTableItem(p_124144_)))); }
private void createCrop(Block block, Item crop, Item seeds, int age) { LootItemCondition.Builder builder = LootItemBlockStatePropertyCondition.hasBlockStateProperties(block) .setProperties( StatePropertiesPredicate.Builder.properties().hasProperty(CropBlock.AGE, age)); this.add(block, createCropDrops(block, crop, seeds, builder)); }
@Override public void addDatas() { FoodRegistry.ITEMS .getEntries() .forEach( item -> { this.addData(item.get()); }); ItemRegistry.ITEMS .getEntries() .forEach( item -> { this.addData(item.get()); }); }
@Override public boolean isItemValid(int slot, @Nonnull ItemStack stack) { return itemHandler.isItemValid(slot, stack); }
@Override @Nonnull public ItemStack insertItem(int slot, @Nonnull ItemStack stack, boolean simulate) { if (side == null || side.equals(Direction.UP)) { return slot < SLOTS_INPUT ? itemHandler.insertItem(slot, stack, simulate) : stack; } else { return stack; } }
@Override @Nonnull public ItemStack extractItem(int slot, int amount, boolean simulate) { if (side == null || side.equals(Direction.UP)) { return slot < SLOTS_INPUT ? itemHandler.extractItem(slot, amount, simulate) : ItemStack.EMPTY; } else { return slot == SLOT_OUTPUT ? itemHandler.extractItem(slot, amount, simulate) : ItemStack.EMPTY; } }
@Override @Nonnull public ItemStack insertItem(int slot, @Nonnull ItemStack stack, boolean simulate) { if (side == null || side.equals(Direction.UP)) { return (slot < SLOTS_INPUT) ? itemHandler.insertItem(slot, stack, simulate) : stack; } else { return stack; } }
@Override @Nonnull public ItemStack extractItem(int slot, int amount, boolean simulate) { if (side == null || side.equals(Direction.UP)) { return slot < SLOTS_INPUT ? itemHandler.extractItem(slot, amount, simulate) : ItemStack.EMPTY; } else { return (slot >= SLOT_OUTPUT_BEGIN || slot <= SLOT_OUTPUT_END) ? itemHandler.extractItem(slot, amount, simulate) : ItemStack.EMPTY; } }
@Override @Nonnull public ItemStack extractItem(int slot, int amount, boolean simulate) { if (side == null || side.equals(Direction.UP)) { return slot < SLOTS_INPUT ? itemHandler.extractItem(slot, amount, simulate) : ItemStack.EMPTY; } else { return slot == SLOT_OUTPUT || slot == SLOT_OUTPUT_EXTRA ? itemHandler.extractItem(slot, amount, simulate) : ItemStack.EMPTY; } }
private static <C extends Container, T extends Recipe<C>> List<T> findRecipesByType( RecipeType<T> type) { return MC.level.getRecipeManager().getAllRecipesFor(type); }
@Override public void registerCategories(IRecipeCategoryRegistration registry) { registry.addRecipeCategories(new CookingPotCategory(registry.getJeiHelpers().getGuiHelper())); registry.addRecipeCategories(new StoneMortarCategory(registry.getJeiHelpers().getGuiHelper())); registry.addRecipeCategories(new FermenterCategory(registry.getJeiHelpers().getGuiHelper())); registry.addRecipeCategories(new DistillerCategory(registry.getJeiHelpers().getGuiHelper())); registry.addRecipeCategories(new ChoppingCategory(registry.getJeiHelpers().getGuiHelper())); }
@Override public void registerRecipes(IRecipeRegistration registration) { registration.addRecipes( COOKING_POT_JEI_TYPE, findRecipesByType(RecipeTypeRegistry.COOKING_RECIPE_TYPE.get())); registration.addRecipes( STONE_MORTAR_JEI_TYPE, findRecipesByType(RecipeTypeRegistry.STONE_MORTAR_RECIPE_TYPE.get())); registration.addRecipes( FERMENTER_JEI_TYPE, findRecipesByType(RecipeTypeRegistry.FERMENTER_RECIPE_TYPE.get())); registration.addRecipes( DISTILLER_JEI_TYPE, findRecipesByType(RecipeTypeRegistry.DISTILLER_RECIPE_TYPE.get())); registration.addRecipes( CHOPPING_JEI_TYPE, findRecipesByType(RecipeTypeRegistry.CHOPPING_RECIPE_TYPE.get())); }
@Override public void registerRecipeCatalysts(IRecipeCatalystRegistration registration) { registration.addRecipeCatalyst( new ItemStack(BlockRegistry.COOKING_POT.get()), COOKING_POT_JEI_TYPE); registration.addRecipeCatalyst( new ItemStack(BlockRegistry.STONE_MORTAR.get()), STONE_MORTAR_JEI_TYPE); registration.addRecipeCatalyst( new ItemStack(BlockRegistry.FERMENTER.get()), FERMENTER_JEI_TYPE); registration.addRecipeCatalyst( new ItemStack(BlockRegistry.DISTILLER.get()), DISTILLER_JEI_TYPE); registration.addRecipeCatalyst( new ItemStack(BlockRegistry.CHOPPING_BOARD.get()), CHOPPING_JEI_TYPE); }
@Override public void registerGuiHandlers(IGuiHandlerRegistration registration) { registration.addRecipeClickArea(CookingPotScreen.class, 94, 16, 32, 54, COOKING_POT_JEI_TYPE); registration.addRecipeClickArea(StoneMortarScreen.class, 79, 32, 18, 24, STONE_MORTAR_JEI_TYPE); registration.addRecipeClickArea(FermenterScreen.class, 75, 34, 18, 24, FERMENTER_JEI_TYPE); registration.addRecipeClickArea(DistillerScreen.class, 75, 34, 18, 24, DISTILLER_JEI_TYPE); }
@Override public void registerRecipeTransferHandlers(IRecipeTransferRegistration registration) { registration.addRecipeTransferHandler( CookingPotContainer.class, COOKING_POT_JEI_TYPE, 0, 9, 10, 36); registration.addRecipeTransferHandler( StoneMortarContainer.class, STONE_MORTAR_JEI_TYPE, 0, 4, 6, 36); registration.addRecipeTransferHandler( FermenterContainer.class, FERMENTER_JEI_TYPE, 0, 3, 6, 36); registration.addRecipeTransferHandler( DistillerContainer.class, DISTILLER_JEI_TYPE, 0, 3, 6, 36); }
@Override public void draw(StoneMortarRecipe recipe, PoseStack matrixStack, double mouseX, double mouseY) { mortar.draw(matrixStack, 42, 20); basket.draw(matrixStack, 41, 36); }
@Override public void draw( ChoppingRecipe recipe, IRecipeSlotsView recipeSlotsView, PoseStack stack, double mouseX, double mouseY) { NonNullList<ChanceResult> byproducts = recipe.getByproducts(); for (int i = 0; i < Math.min(4, byproducts.size()); i++) { ChanceResult chanceResult = byproducts.get(i); if (chanceResult.chance() != 1) { chancedSlot.draw(stack, i * 18 + 10, 50); } } Minecraft minecraft = Minecraft.getInstance(); Font fontRenderer = minecraft.font; fontRenderer.drawShadow( stack, new TranslatableComponent("sakura.jei.chopping.count", recipe.getRecipeTime()), 33, 32, 0xFEFEFE); RenderSystem.setShaderColor(1, 1, 1, 1); }
@Override public void draw(FermenterRecipe recipe, PoseStack matrixStack, double mouseX, double mouseY) { bubbles.draw(matrixStack, 46, 16); arrow.draw(matrixStack, 44, 34); }
@Override public void setRecipe( IRecipeLayoutBuilder builder, CookingPotRecipe recipe, IFocusGroup focuses) { NonNullList<Ingredient> recipeIngredients = recipe.getIngredients(); int borderSlotSize = 18; for (int row = 0; row < 3; ++row) { for (int column = 0; column < 3; ++column) { int inputIndex = row * 3 + column; if (inputIndex < recipeIngredients.size()) { builder .addSlot( RecipeIngredientRole.INPUT, 23 + column * borderSlotSize, 1 + row * borderSlotSize) .addIngredients(recipeIngredients.get(inputIndex)); } } } if (recipe.getRequiredFluid() != FluidIngredient.EMPTY) builder .addSlot(RecipeIngredientRole.INPUT, 1, 1) .setFluidRenderer(CookingPotBlockEntity.TANK_CAPACITY, true, 16, 52) .addIngredients( ForgeTypes.FLUID_STACK, recipe.getRequiredFluid().getMatchingFluidStacks()); builder.addSlot(RecipeIngredientRole.OUTPUT, 120, 22).addItemStack(recipe.getResultItem()); }
@Override public void draw(CookingPotRecipe recipe, PoseStack matrixStack, double mouseX, double mouseY) { arrow.draw(matrixStack, 82, 18); heatIndicator.draw(matrixStack, 85, 36); }
@Override public void draw(DistillerRecipe recipe, PoseStack matrixStack, double mouseX, double mouseY) { bubbles.draw(matrixStack, 46, 6); arrow.draw(matrixStack, 44, 24); heatIndicator.draw(matrixStack, 47, 43); }
@SubscribeEvent public static void onBiomeLoad(BiomeLoadingEvent event) { setVegetalFeature( event, WorldGenerationRegistry.PATCH_BAMBOOSHOOT, SakuraConfig.GENERATE_BAMBOOSHOOT.get(), 0.4F, 1.0F); }
public static void setVegetalFeature( BiomeLoadingEvent event, RegistryObject<PlacedFeature> feature, boolean canGen, float low, float high) { BiomeGenerationSettingsBuilder builder = event.getGeneration(); Biome.ClimateSettings climate = event.getClimate(); if (climate.temperature > low && climate.temperature <= high) { if (canGen) { builder.addFeature(GenerationStep.Decoration.VEGETAL_DECORATION, feature.getHolder().get()); } } }
@SubscribeEvent public static void registerBurnTime(FurnaceFuelBurnTimeEvent event) { register(event, ItemRegistry.MATERIALS.get(SakuraNormalItemSet.BAMBOO), 400); register(event, BlockItemRegistry.BAMBOO_BLOCK, 4000); register(event, ItemRegistry.MATERIALS.get(SakuraNormalItemSet.BAMBOO_SUNBURNT), 400); register(event, BlockItemRegistry.BAMBOO_BLOCK_SUNBURNT, 4000); register(event, ItemRegistry.MATERIALS.get(SakuraNormalItemSet.BAMBOO_CHARCOAL), 1600); register(event, BlockItemRegistry.BAMBOO_CHARCOAL_BLOCK, 16000); }
private static void register( FurnaceFuelBurnTimeEvent event, Supplier<? extends Item> item, int burnTime) { register(event, item.get(), burnTime); }
private static void register(FurnaceFuelBurnTimeEvent event, Item item, int burnTime) { register(event, new ItemStack(item), burnTime); }
private static void register(FurnaceFuelBurnTimeEvent event, ItemStack item, int burnTime) { if (item.getItem() == event.getItemStack().getItem()) event.setBurnTime(burnTime); }
private static void stripLog(BlockToolModificationEvent event, Block log, Block stripped_log) { BlockState origin = event.getState(); if (origin.is(log)) { event .getWorld() .playSound( event.getPlayer(), event.getPos(), SoundEvents.AXE_STRIP, SoundSource.BLOCKS, 1.0F, 1.0F); event.setFinalState(stripped_log.withPropertiesOf(origin)); } }
@Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.csrf() .disable() .securityMatcher(EndpointRequest.toAnyEndpoint()) .authorizeHttpRequests(requests -> requests.anyRequest().hasRole("ENDPOINT_ADMIN")); http.httpBasic(); return http.build(); }
protected String resolveTitle(String titleTemplate, Object... arguments) { return titleTemplate; }
protected String resolveContent(String contentTemplate, Object... args) { if (args.length > 0) { StringBuilder formattedContent = new StringBuilder(contentTemplate); for (Object arg : args) { int start = formattedContent.indexOf(PLACEHOLDER); formattedContent.replace(start, start + PLACEHOLDER.length(), String.valueOf(arg)); } return formattedContent.toString(); } return contentTemplate; }
public List<UserInfo> listUsers(List<Long> userIds) { QueryWrapper<UserInfo> queryWrapper = new QueryWrapper<>(); queryWrapper.in(DatabaseConsts.CommonColumnEnum.ID.getName(), userIds); return userInfoMapper.selectList(queryWrapper); }
public static EsBookDto build(BookInfo bookInfo) { return EsBookDto.builder() .id(bookInfo.getId()) .categoryId(bookInfo.getCategoryId()) .categoryName(bookInfo.getCategoryName()) .bookDesc(bookInfo.getBookDesc()) .bookName(bookInfo.getBookName()) .authorId(bookInfo.getAuthorId()) .authorName(bookInfo.getAuthorName()) .bookStatus(bookInfo.getBookStatus()) .commentCount(bookInfo.getCommentCount()) .isVip(bookInfo.getIsVip()) .score(bookInfo.getScore()) .visitCount(bookInfo.getVisitCount()) .wordCount(bookInfo.getWordCount()) .workDirection(bookInfo.getWorkDirection()) .lastChapterId(bookInfo.getLastChapterId()) .lastChapterName(bookInfo.getLastChapterName()) .lastChapterUpdateTime( bookInfo.getLastChapterUpdateTime().toInstant(ZoneOffset.ofHours(8)).toEpochMilli()) .build(); }
@Override public String toString() { return "PayWechat{" + "id=" + id + ", outTradeNo=" + outTradeNo + ", transactionId=" + transactionId + ", tradeType=" + tradeType + ", tradeState=" + tradeState + ", tradeStateDesc=" + tradeStateDesc + ", amount=" + amount + ", payerTotal=" + payerTotal + ", successTime=" + successTime + ", payerOpenid=" + payerOpenid + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "SysMenu{" + "id=" + id + ", parentId=" + parentId + ", name=" + name + ", url=" + url + ", type=" + type + ", icon=" + icon + ", sort=" + sort + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "SysRole{" + "id=" + id + ", roleName=" + roleName + ", roleSign=" + roleSign + ", remark=" + remark + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "SysLog{" + "id=" + id + ", userId=" + userId + ", username=" + username + ", operation=" + operation + ", time=" + time + ", method=" + method + ", params=" + params + ", ip=" + ip + ", createTime=" + createTime + "}"; }
@Override public String toString() { return "SysRoleMenu{" + "id=" + id + ", roleId=" + roleId + ", menuId=" + menuId + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "SysUserRole{" + "id=" + id + ", userId=" + userId + ", roleId=" + roleId + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "PayAlipay{" + "id=" + id + ", outTradeNo=" + outTradeNo + ", tradeNo=" + tradeNo + ", buyerId=" + buyerId + ", tradeStatus=" + tradeStatus + ", totalAmount=" + totalAmount + ", receiptAmount=" + receiptAmount + ", invoiceAmount=" + invoiceAmount + ", gmtCreate=" + gmtCreate + ", gmtPayment=" + gmtPayment + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public String toString() { return "SysUser{" + "id=" + id + ", username=" + username + ", password=" + password + ", name=" + name + ", sex=" + sex + ", birth=" + birth + ", email=" + email + ", mobile=" + mobile + ", status=" + status + ", createTime=" + createTime + ", updateTime=" + updateTime + "}"; }
@Override public RestResp<Void> deleteComment(Long userId, Long commentId) { QueryWrapper<BookComment> queryWrapper = new QueryWrapper<>(); queryWrapper .eq(DatabaseConsts.CommonColumnEnum.ID.getName(), commentId) .eq(DatabaseConsts.BookCommentTable.COLUMN_USER_ID, userId); bookCommentMapper.delete(queryWrapper); return RestResp.ok(); }
@Override public RestResp<Void> updateComment(Long userId, Long id, String content) { QueryWrapper<BookComment> queryWrapper = new QueryWrapper<>(); queryWrapper .eq(DatabaseConsts.CommonColumnEnum.ID.getName(), id) .eq(DatabaseConsts.BookCommentTable.COLUMN_USER_ID, userId); BookComment bookComment = new BookComment(); bookComment.setCommentContent(content); bookCommentMapper.update(bookComment, queryWrapper); return RestResp.ok(); }
@Override public RestResp<PageRespDto<BookInfoRespDto>> listAuthorBooks(PageReqDto dto) { IPage<BookInfo> page = new Page<>(); page.setCurrent(dto.getPageNum()); page.setSize(dto.getPageSize()); QueryWrapper<BookInfo> queryWrapper = new QueryWrapper<>(); queryWrapper .eq(DatabaseConsts.BookTable.AUTHOR_ID, UserHolder.getAuthorId()) .orderByDesc(DatabaseConsts.CommonColumnEnum.CREATE_TIME.getName()); IPage<BookInfo> bookInfoPage = bookInfoMapper.selectPage(page, queryWrapper); return RestResp.ok( PageRespDto.of( dto.getPageNum(), dto.getPageSize(), page.getTotal(), bookInfoPage.getRecords().stream() .map( v -> BookInfoRespDto.builder() .id(v.getId()) .bookName(v.getBookName()) .picUrl(v.getPicUrl()) .categoryName(v.getCategoryName()) .wordCount(v.getWordCount()) .visitCount(v.getVisitCount()) .updateTime(v.getUpdateTime()) .build()) .toList())); }
@Override public RestResp<PageRespDto<BookChapterRespDto>> listBookChapters(Long bookId, PageReqDto dto) { IPage<BookChapter> page = new Page<>(); page.setCurrent(dto.getPageNum()); page.setSize(dto.getPageSize()); QueryWrapper<BookChapter> queryWrapper = new QueryWrapper<>(); queryWrapper .eq(DatabaseConsts.BookChapterTable.COLUMN_BOOK_ID, bookId) .orderByDesc(DatabaseConsts.BookChapterTable.COLUMN_CHAPTER_NUM); IPage<BookChapter> bookChapterPage = bookChapterMapper.selectPage(page, queryWrapper); return RestResp.ok( PageRespDto.of( dto.getPageNum(), dto.getPageSize(), page.getTotal(), bookChapterPage.getRecords().stream() .map( v -> BookChapterRespDto.builder() .id(v.getId()) .chapterName(v.getChapterName()) .chapterUpdateTime(v.getUpdateTime()) .isVip(v.getIsVip()) .build()) .toList())); }
@Override public RestResp<List<HomeBookRespDto>> listHomeBooks() { return RestResp.ok(homeBookCacheManager.listHomeBooks()); }
@Override public RestResp<PageRespDto<BookInfoRespDto>> searchBooks(BookSearchReqDto condition) { Page<BookInfoRespDto> page = new Page<>(); page.setCurrent(condition.getPageNum()); page.setSize(condition.getPageSize()); List<BookInfo> bookInfos = bookInfoMapper.searchBooks(page, condition); return RestResp.ok( PageRespDto.of( condition.getPageNum(), condition.getPageSize(), page.getTotal(), bookInfos.stream() .map( v -> BookInfoRespDto.builder() .id(v.getId()) .bookName(v.getBookName()) .categoryId(v.getCategoryId()) .categoryName(v.getCategoryName()) .authorId(v.getAuthorId()) .authorName(v.getAuthorName()) .wordCount(v.getWordCount()) .lastChapterName(v.getLastChapterName()) .build()) .toList())); }
@RabbitListener(queues = AmqpConsts.BookChangeMq.QUEUE_ES_UPDATE) @SneakyThrows public void updateEsBook(Long bookId) { BookInfo bookInfo = bookInfoMapper.selectById(bookId); IndexResponse response = esClient.index( i -> i.index(EsConsts.BookIndex.INDEX_NAME) .id(bookInfo.getId().toString()) .document(EsBookDto.build(bookInfo))); log.info("Indexed with version " + response.version()); }
@ConfigurationProperties(prefix = "novel.cors") public record CorsProperties(List<String> allowOrigins) {}
@Bean @SneakyThrows public DataSource shardingSphereDataSource() { log.info(">>>>>>>>>>> shardingSphereDataSource init."); ShardingSphereURLLoadEngine urlLoadEngine = new ShardingSphereURLLoadEngine(ShardingSphereURL.parse(URL)); return YamlShardingSphereDataSourceFactory.createDataSource(urlLoadEngine.loadContent()); }
@Bean public ChatClient chatClient(ChatClient.Builder chatClientBuilder) { return chatClientBuilder.build(); }
@ConfigurationProperties(prefix = "spring.mail") public record MailProperties(String nickname, String username) {}
public String generateToken(Long uid, String systemKey) { return Jwts.builder() .setHeaderParam(HEADER_SYSTEM_KEY, systemKey) .setSubject(uid.toString()) .signWith(Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8))) .compact(); }
@Around(value = "@annotation(io.github.xxyopen.novel.core.annotation.Lock)") @SneakyThrows public Object doAround(ProceedingJoinPoint joinPoint) { MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method targetMethod = methodSignature.getMethod(); Lock lock = targetMethod.getAnnotation(Lock.class); String lockKey = KEY_PREFIX + buildLockKey(lock.prefix(), targetMethod, joinPoint.getArgs()); RLock rLock = redissonClient.getLock(lockKey); if (lock.isWait() ? rLock.tryLock(lock.waitTime(), TimeUnit.SECONDS) : rLock.tryLock()) { try { return joinPoint.proceed(); } finally { rLock.unlock(); } } throw new BusinessException(lock.failCode()); }
@Override public String toString() { return "Author [id=" + id + ", name=" + name + "]"; }
@Override public String toString() { return "Book [id=" + id + ", name=" + name + ", desc=" + desc + ", url=" + url + ", pubdate=" + pubdate + ", pubinfo=" + pubinfo + ", author=" + author + ", price=" + price + "]"; }
@Override public List<Book> findByNameAndPrice(String name, Float price) { return bookRepository.findByNameAndPrice(name, price); }
@Override public List<Book> findByNameOrPrice(String name, Float price) { return bookRepository.findByNameOrPrice(name, price); }
@Override public Page<Book> findByName(String name, Pageable page) { return bookRepository.findByName(name, page); }
@Override public Page<Book> findByNameNot(String name, Pageable page) { return bookRepository.findByNameNot(name, page); }
@Override public Page<Book> findByPriceBetween(Float price, Pageable page) { return bookRepository.findByPriceBetween(price, page); }
@Override public Page<Book> findByNameLike(String name, Pageable page) { return bookRepository.findByNameLike(name, page); }
@Override public Page<Book> findByPrice(Float price, Pageable pageable) { return bookRepository.findByPrice(price, pageable); }
@Override public List<CustomerRelations> queryByCustomerId(String customerId) { return customerRelationsDao.queryByCustomerId(customerId); }
@Override public void insert(CustomerRelations invitedCustomer) { customerRelationsDao.save(invitedCustomer); }
@Override public int queryInviteeCount(Map<String, Object> queryMap) { return customerRelationsDao.queryInviteeCount(queryMap); }
@Override public int queryTodayInvitedTotle(String parentId) { return customerRelationsDao.queryTodayInvitedTotle(parentId); }
@Override public int queryAllInvitedTotle(String parentId) { return customerRelationsDao.queryAllInvitedTotle(parentId); }
@Override public Map<String, Object> generalAnonymousInfo(String customerId) { return null; }
@Override public void save(CustomerBaseExtend customerBaseExtend) { customerBaseExtendDao.save(customerBaseExtend); }
@Override public void save(CustomerBilling customerBilling) { }
@Override public void openAccount(MerchantAcount merchantAcount) { }
public List<User> displayAllUser() { System.out.println(userDao); for (int i = 0; i < 20; i++) { System.out.println(i); } List<User> users = userDao.queryUser(); for (User user : users) { System.out.println(user.toString()); } return users; }
@Override public void save(CustomerAuth customerAuth) { customerAuthDao.save(customerAuth); }
@Override public void save(CustomerBase customerBase) { customerBaseDao.save(customerBase); }
@Override public void updateExtent(CustomerBaseExtend extent) { customerBaseDao.updateExtent(extent); }
@Override public void saveExtend(CustomerBaseExtend extent) { customerBaseDao.saveExtend(extent); }
@Override public void deleteBaseAndExtend(Long id) { customerBaseDao.deleteBaseAndExtend(id); }
@Override public void delete(Long id) { customerBaseDao.delete(id); }
@Override public CustomerBase queryByCustomerId(String customerId) { CustomerBase customerBase = customerBaseDao.queryByCustomerId(customerId); return customerBase; }
@Override public CustomerBase queryByCustomerNo(String customerNo) { CustomerBase customerBase = customerBaseDao.queryByCustomerNo(customerNo); return customerBase; }
@Override public Map<String, Object> selectByCustomerId(Map<String, Object> map) { Map<String, Object> respMap = new HashMap<>(); try { CustomerBase customerBase = (CustomerBase) BeanUtils.mapToObject(map, CustomerBase.class); CustomerBase respdto = customerBaseDao.queryByCustomerId(customerBase.getId()); respMap = (Map<String, Object>) BeanUtils.objectToMap(respdto); } catch (Exception e) { e.printStackTrace(); } return respMap; }
@Override @Transactional(rollbackFor = {Exception.class}) public String openAccount(CustomerAccount customerAccount) { CustomerAccount ca = new CustomerAccount(); String customerAccountNo = "0ca0" + UUIDTool.getUUID(); ca.setCustomerAccountNo(customerAccountNo); ca.setFreezeValue("0"); ca.setStatus("00"); customerAccountDao.save(ca); return customerAccountNo; }
@Override public void deposit(CustomerAccount customerAccount, String amt) { accountingTreatment(customerAccount, amt, FundsDirection.DEBITS.getCode()); }
@Override public void withdraw(CustomerAccount customerAccount, String amt) { accountingTreatment(customerAccount, amt, FundsDirection.CREDITS.getCode()); }
@Override public void save(CustomerAccount customerAccount) { customerAccountDao.save(customerAccount); }
@Override public String toString() { return "User [id=" + id + ", username=" + username + ", password=" + password + ", chinesename=" + chinesename + ", dept=" + dept + ", email=" + email + ", tel=" + tel + ", sysRole=" + sysRole + ", state=" + state + ", registerDate=" + registerDate + ", updateDate=" + updateDate + ", dimissionDate=" + dimissionDate + "]"; }
@Override public String toString() { return "CustomerAccountJournal [id=" + id + ", JournalNo=" + JournalNo + ", customerId=" + customerId + ", customerAccountNo=" + customerAccountNo + ", amt=" + amt + ", fundsDirection=" + fundsDirection + ", createTime=" + createTime + "]"; }
@ResponseBody @RequestMapping(value = "/displayAllUser", method = RequestMethod.GET) public HashMap<String, List<User>> displayAllUser() { HashMap<String, List<User>> map = new HashMap<String, List<User>>(); CustomerAccount customerAccount = new CustomerAccount(); customerAccountService.openAccount(customerAccount); return map; }
public static String sendMail() { return "send email"; }
@Test public void testSendMail() { assertEquals(MailUtil.sendMail(), "send email"); }
@Override public Object plugin(Object target) { if (target instanceof Executor) { return Plugin.wrap(target, this); } else { return target; } }
public static void putDataSource(DynamicDataSourceGlobal dataSource) { holder.set(dataSource); }
public static void clearDataSource() { holder.remove(); }
@Override public void afterPropertiesSet() { if (this.writeDataSource == null) { throw new IllegalArgumentException("Property 'writeDataSource' is required"); } setDefaultTargetDataSource(writeDataSource); Map<Object, Object> targetDataSources = new HashMap<>(); targetDataSources.put(DynamicDataSourceGlobal.WRITE.name(), writeDataSource); if (readDataSource != null) { targetDataSources.put(DynamicDataSourceGlobal.READ.name(), readDataSource); } setTargetDataSources(targetDataSources); super.afterPropertiesSet(); }
@Override protected Object determineCurrentLookupKey() { DynamicDataSourceGlobal dynamicDataSourceGlobal = DynamicDataSourceHolder.getDataSource(); if (dynamicDataSourceGlobal == null || dynamicDataSourceGlobal == DynamicDataSourceGlobal.WRITE) { return DynamicDataSourceGlobal.WRITE.name(); } return DynamicDataSourceGlobal.READ.name(); }
@Override protected void doCleanupAfterCompletion(Object transaction) { super.doCleanupAfterCompletion(transaction); DynamicDataSourceHolder.clearDataSource(); }
@RequestMapping("/info") public R info() { return R.ok().put("user", getUser()); }
@RequestMapping("/info/{orgId}") @RequiresPermissions("sys:org:info") public R info(@PathVariable("orgId") Long orgId) { SysOrgEntity org = sysOrgService.queryObject(orgId); return R.ok().put("org", org); }
@RequestMapping("/save") @RequiresPermissions("sys:org:save") public R save(@RequestBody SysOrgEntity org) { sysOrgService.save(org); return R.ok(); }
@RequestMapping("/update") @RequiresPermissions("sys:org:update") public R update(@RequestBody SysOrgEntity org) { sysOrgService.update(org); return R.ok(); }
@RequestMapping("/list") @RequiresPermissions("sys:menu:list") public List<SysMenuEntity> list() { List<SysMenuEntity> menuList = sysMenuService.queryList(new HashMap<String, Object>()); return menuList; }
@RequestMapping("/info/{menuId}") @RequiresPermissions("sys:menu:info") public R info(@PathVariable("menuId") Long menuId) { SysMenuEntity menu = sysMenuService.queryObject(menuId); return R.ok().put("menu", menu); }
@RequestMapping("/user") public R user() { List<SysMenuEntity> menuList = sysMenuService.getUserMenuList(getUserId()); Set<String> permissions = sysMenuService.getUserPermissions(getUserId()); return R.ok().put("menuList", menuList).put("permissions", permissions); }
@RequestMapping(value = "logout", method = RequestMethod.GET) public String logout() { ShiroUtils.logout(); return "redirect:login.html"; }
public boolean hasPermission(String permission) { Subject subject = SecurityUtils.getSubject(); return subject != null && subject.isPermitted(permission); }
@Override public SysOrgEntity queryObject(Long orgId) { return sysOrgDao.queryObject(orgId); }
@Override public List<SysOrgEntity> queryList(Map<String, Object> map) { return sysOrgDao.queryList(map); }
@Override public void save(SysOrgEntity sysOrg) { sysOrgDao.save(sysOrg); }
@Override public void update(SysOrgEntity sysOrg) { sysOrgDao.update(sysOrg); }
@Override public void delete(Long orgId) { sysOrgDao.delete(orgId); }
@Override public List<Long> queryOrgIdList(Long parentId) { return sysOrgDao.queryOrgIdList(parentId); }
@Override public List<Long> queryMenuIdList(Long roleId) { return sysRoleMenuDao.queryMenuIdList(roleId); }
@Override public List<SysMenuEntity> queryNotButtonList() { return sysMenuDao.queryNotButtonList(); }
@Override public SysMenuEntity queryObject(Long menuId) { return sysMenuDao.queryObject(menuId); }
@Override public List<SysMenuEntity> queryList(Map<String, Object> map) { return sysMenuDao.queryList(map); }
@Override public int queryTotal(Map<String, Object> map) { return sysMenuDao.queryTotal(map); }
@Override public void save(SysMenuEntity menu) { sysMenuDao.save(menu); }
@Override public void update(SysMenuEntity menu) { sysMenuDao.update(menu); }
@Override @Transactional public void deleteBatch(Long[] menuIds) { sysMenuDao.deleteBatch(menuIds); }
@Override public List<SysMenuEntity> queryUserList(Long userId) { return sysMenuDao.queryUserList(userId); }
@Override public List<SysMenuEntity> queryListParentId(Long parentId) { return sysMenuDao.queryListParentId(parentId); }
@Override public List<String> queryAllPerms(Long userId) { return sysUserDao.queryAllPerms(userId); }
@Override public List<Long> queryAllMenuId(Long userId) { return sysUserDao.queryAllMenuId(userId); }
@Override public SysUserEntity queryByUserName(String username) { return sysUserDao.queryByUserName(username); }
@Override public SysUserEntity queryObject(Long userId) { return sysUserDao.queryObject(userId); }
@Override public List<SysUserEntity> queryList(Map<String, Object> map) { return sysUserDao.queryList(map); }
@Override public int queryTotal(Map<String, Object> map) { return sysUserDao.queryTotal(map); }
@Override @Transactional public void deleteBatch(Long[] userId) { sysUserDao.deleteBatch(userId); }
@Override public int updatePassword(Long userId, String password, String newPassword) { Map<String, Object> map = new HashMap<>(); map.put("userId", userId); map.put("password", password); map.put("newPassword", newPassword); return sysUserDao.updatePassword(map); }
@Override public List<Long> queryRoleIdList(Long userId) { return sysUserRoleDao.queryRoleIdList(userId); }
@Override public void delete(Long userId) { sysUserRoleDao.delete(userId); }
@Override public List<SysUserRoleEntity> queryListByUserId(Long userId) { return sysUserRoleDao.queryListByUserId(userId); }
@Override public SysRoleEntity queryObject(Long roleId) { return sysRoleDao.queryObject(roleId); }
@Override public List<SysRoleEntity> queryList(Map<String, Object> map) { return sysRoleDao.queryList(map); }
@Override public int queryTotal(Map<String, Object> map) { return sysRoleDao.queryTotal(map); }
@Override @Transactional public void deleteBatch(Long[] roleIds) { sysRoleDao.deleteBatch(roleIds); }
@Override public List<Long> queryRoleIdList(Long createUserId) { return sysRoleDao.queryRoleIdList(createUserId); }
@Override public List<Long> listOrgId(Long roleId) { return sysRoleOrgDao.listOrgId(roleId); }
@Override public List<Long> listRoleId(Long orgId) { return sysRoleOrgDao.listRoleId(orgId); }
@Override public void delete(Long roleId) { }
public static boolean isLogin() { return SecurityUtils.getSubject().getPrincipal() != null; }
public static void logout() { SecurityUtils.getSubject().logout(); }
@RequestMapping("/info/{id}") @RequiresPermissions("sys:config:info") public R info(@PathVariable("id") Long id) { SysConfigEntity config = sysConfigService.queryObject(id); return R.ok().put("config", config); }
@RequestMapping("/config") @RequiresPermissions("sys:oss:all") public R config() { CloudStorageConfig config = sysConfigService.getConfigObject(KEY, CloudStorageConfig.class); return R.ok().put("config", config); }
@RequestMapping("/delete") @RequiresPermissions("sys:oss:all") public R delete(@RequestBody Long[] ids) { sysOssService.deleteBatch(ids); return R.ok(); }
@RequestMapping("generator/{url}.html") public String generator(@PathVariable("url") String url) { return "generator/" + url + ".html"; }
@Override public SysOssEntity queryObject(Long id) { return sysOssDao.queryObject(id); }
@Override public List<SysOssEntity> queryList(Map<String, Object> map) { return sysOssDao.queryList(map); }
@Override public int queryTotal(Map<String, Object> map) { return sysOssDao.queryTotal(map); }
@Override public void save(SysOssEntity sysOss) { sysOssDao.save(sysOss); }
@Override public void update(SysOssEntity sysOss) { sysOssDao.update(sysOss); }
@Override public void delete(Long id) { sysOssDao.delete(id); }
@Override public void deleteBatch(Long[] ids) { sysOssDao.deleteBatch(ids); }
@Pointcut("@annotation(me.flyray.rbac.annotation.SysLog)") public void logPointCut() {}
public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { registry .addHandler(webSocketHandler(), "/websocket/socketServer") .addInterceptors(new SpringWebSocketHandlerInterceptor()); registry .addHandler(webSocketHandler(), "/sockjs/socketServer") .addInterceptors(new SpringWebSocketHandlerInterceptor()) .withSockJS(); }
@Bean public TextWebSocketHandler webSocketHandler() { return new SpringWebSocketHandler(); }
@Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception { System.out.println(message); }
public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception { if (session.isOpen()) { session.close(); } logger.debug("websocket connection closed......"); users.remove(session); }
public boolean supportsPartialMessages() { return false; }
public void sendMessageToUsers(TextMessage message) { for (WebSocketSession user : users) { try { if (user.isOpen()) { user.sendMessage(message); } } catch (IOException e) { e.printStackTrace(); } } }
@Override public void afterHandshake( ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) { super.afterHandshake(request, response, wsHandler, ex); }
@RequestMapping("/info/{id}") @RequiresPermissions("erp:productCategary:info") public R info(@PathVariable("id") Long id) { Parameter parameter = new Parameter("productCategaryService", "queryById"); parameter.setId(id); Map<?, ?> map1 = apiProvider.execute(parameter).getMap(); return R.ok().put("payChannel", map1); }
@RequestMapping("/info/{id}") @RequiresPermissions("cms:group:info") public R info(@PathVariable("id") Long id) { Parameter parameter = new Parameter("interestGroupService", "queryById"); parameter.setId(id); Map<?, ?> map = apiProvider.execute(parameter).getMap(); return R.ok().put("group", map); }
@RequestMapping("/info/{topicId}") @RequiresPermissions("cms:topic:info") public R info(@PathVariable("topicId") String topicId) { Parameter parameter = new Parameter("topicService", "queryById"); parameter.setId(Long.valueOf(topicId)); Map<?, ?> map1 = apiProvider.execute(parameter).getMap(); return R.ok().put("topic", map1); }
@RequestMapping("/info/{id}") @RequiresPermissions("cms:groupcategory:info") public R info(@PathVariable("id") Long id) { Parameter parameter = new Parameter("interestGroupCategoryService", "queryById"); parameter.setId(id); Map<?, ?> map = apiProvider.execute(parameter).getMap(); return R.ok().put("groupcategory", map); }
@RequestMapping("/info/{id}") @RequiresPermissions("cms:activity:info") public R info(@PathVariable("id") Long id) { Parameter parameter = new Parameter("activityService", "queryById"); parameter.setId(id); Map<?, ?> map = apiProvider.execute(parameter).getMap(); return R.ok().put("groupcategory", map); }
@RequestMapping("/info/{id}") @RequiresPermissions("crm:customerRole:info") public R info(@PathVariable("id") Long id) { Parameter parameter = new Parameter("customerRoleService", "queryById"); parameter.setId(id); Map<?, ?> map = apiProvider.execute(parameter).getMap(); return R.ok().put("CustomerRole", map); }
@RequestMapping("/info/{id}") @RequiresPermissions("crm:customer:info") public R info(@PathVariable("id") Long id) { Parameter parameter = new Parameter("customerBaseService", "queryById"); parameter.setId(id); Map<?, ?> map1 = apiProvider.execute(parameter).getMap(); return R.ok().put("payChannel", map1); }
@RequestMapping("/info/{id}") @RequiresPermissions("crm:merchant:info") public R info(@PathVariable("id") Long id) { Parameter parameter = new Parameter("merchantBaseService", "queryById"); parameter.setId(id); Map<?, ?> map1 = apiProvider.execute(parameter).getMap(); return R.ok().put("payChannel", map1); }
@Override public String upload(byte[] data) { return upload(data, getPath(config.getQcloudPrefix())); }
@Override public String upload(InputStream inputStream) { return upload(inputStream, getPath(config.getQcloudPrefix())); }
private void init() { client = new OSSClient( config.getAliyunEndPoint(), config.getAliyunAccessKeyId(), config.getAliyunAccessKeySecret()); }
@Override public String upload(byte[] data, String path) { return upload(new ByteArrayInputStream(data), path); }
@Override public String upload(byte[] data) { return upload(data, getPath(config.getAliyunPrefix())); }
@Override public String upload(InputStream inputStream) { return upload(inputStream, getPath(config.getAliyunPrefix())); }
private void init() { uploadManager = new UploadManager(new Configuration(Zone.autoZone())); token = Auth.create(config.getQiniuAccessKey(), config.getQiniuSecretKey()) .uploadToken(config.getQiniuBucketName()); }
@Override public String upload(byte[] data) { return upload(data, getPath(config.getQiniuPrefix())); }
@Override public String upload(InputStream inputStream) { return upload(inputStream, getPath(config.getQiniuPrefix())); }
@Override public SysLogEntity queryObject(Long id) { return sysLogDao.queryObject(id); }
@Override public List<SysLogEntity> queryList(Map<String, Object> map) { return sysLogDao.queryList(map); }
@Override public int queryTotal(Map<String, Object> map) { return sysLogDao.queryTotal(map); }
@Override public void save(SysLogEntity sysLog) { sysLogDao.save(sysLog); }
@Override public void update(SysLogEntity sysLog) { sysLogDao.update(sysLog); }
@Override public void delete(Long id) { sysLogDao.delete(id); }
@Override public void deleteBatch(Long[] ids) { sysLogDao.deleteBatch(ids); }
@Override public void save(SysConfigEntity config) { sysConfigDao.save(config); }
@Override public void update(SysConfigEntity config) { sysConfigDao.update(config); }
@Override public void updateValueByKey(String key, String value) { sysConfigDao.updateValueByKey(key, value); }
@Override public void deleteBatch(Long[] ids) { sysConfigDao.deleteBatch(ids); }
@Override public List<SysConfigEntity> queryList(Map<String, Object> map) { return sysConfigDao.queryList(map); }
@Override public int queryTotal(Map<String, Object> map) { return sysConfigDao.queryTotal(map); }
@Override public SysConfigEntity queryObject(Long id) { return sysConfigDao.queryObject(id); }
public static String format(Date date) { return format(date, DATE_PATTERN); }
public static String format(Date date, String pattern) { if (date != null) { SimpleDateFormat df = new SimpleDateFormat(pattern); return df.format(date); } return null; }
public static R error(String msg) { return error(500, msg); }
public static R error(int code, String msg) { R r = new R(); r.put("code", code); r.put("msg", msg); return r; }
public static R ok(String msg) { R r = new R(); r.put("msg", msg); return r; }
public static R ok(Map<String, Object> map) { R r = new R(); r.putAll(map); return r; }
public R put(String key, Object value) { super.put(key, value); return this; }
@Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { SpringContextUtils.applicationContext = applicationContext; }
public static boolean containsBean(String name) { return applicationContext.containsBean(name); }
public static boolean isSingleton(String name) { return applicationContext.isSingleton(name); }
public static void validateEntity(Object object, Class<?>... groups) throws RRException { Set<ConstraintViolation<Object>> constraintViolations = validator.validate(object, groups); if (!constraintViolations.isEmpty()) { ConstraintViolation<Object> constraint = (ConstraintViolation<Object>) constraintViolations.iterator().next(); throw new RRException(constraint.getMessage()); } }
public static void isBlank(String str, String message) { if (StringUtils.isBlank(str)) { throw new RRException(message); } }
public static void isNull(Object object, String message) { if (object == null) { throw new RRException(message); } }
private void debug(final String msg) { if (vDebug) { Logger.getAnonymousLogger().info(msg); } }
public static String chr(final int decimal) { return String.valueOf((char) decimal); }
public static String htmlSpecialChars(final String s) { String result = s; result = regexReplace(P_AMP, "&amp;", result); result = regexReplace(P_QUOTE, "&quot;", result); result = regexReplace(P_LEFT_ARROW, "&lt;", result); result = regexReplace(P_RIGHT_ARROW, "&gt;", result); return result; }
public String filter(final String input) { reset(); String s = input; debug("************************************************"); debug(" INPUT: " + input); s = escapeComments(s); debug(" escapeComments: " + s); s = balanceHTML(s); debug(" balanceHTML: " + s); s = checkTags(s); debug(" checkTags: " + s); s = processRemoveBlanks(s); debug("processRemoveBlanks: " + s); s = validateEntities(s); debug(" validateEntites: " + s); debug("************************************************\n\n"); return s; }
public boolean isAlwaysMakeTags() { return alwaysMakeTags; }
public boolean isStripComments() { return stripComment; }
private String escapeComments(final String s) { final Matcher m = P_COMMENTS.matcher(s); final StringBuffer buf = new StringBuffer(); if (m.find()) { final String match = m.group(1); m.appendReplacement(buf, Matcher.quoteReplacement("<!--" + htmlSpecialChars(match) + "-->")); } m.appendTail(buf); return buf.toString(); }
private String balanceHTML(String s) { if (alwaysMakeTags) { s = regexReplace(P_END_ARROW, "", s); s = regexReplace(P_BODY_TO_END, "<$1>", s); s = regexReplace(P_XML_CONTENT, "$1<$2", s); } else { s = regexReplace(P_STRAY_LEFT_ARROW, "&lt;$1", s); s = regexReplace(P_STRAY_RIGHT_ARROW, "$1$2&gt;<", s); s = regexReplace(P_BOTH_ARROWS, "", s); } return s; }
private String checkTags(String s) { Matcher m = P_TAGS.matcher(s); final StringBuffer buf = new StringBuffer(); while (m.find()) { String replaceStr = m.group(1); replaceStr = processTag(replaceStr); m.appendReplacement(buf, Matcher.quoteReplacement(replaceStr)); } m.appendTail(buf); s = buf.toString(); for (String key : vTagCounts.keySet()) { for (int ii = 0; ii < vTagCounts.get(key); ii++) { s += "</" + key + ">"; } } return s; }
private String processRemoveBlanks(final String s) { String result = s; for (String tag : vRemoveBlanks) { if (!P_REMOVE_PAIR_BLANKS.containsKey(tag)) { P_REMOVE_PAIR_BLANKS.putIfAbsent( tag, Pattern.compile("<" + tag + "(\\s[^>]*)?></" + tag + ">")); } result = regexReplace(P_REMOVE_PAIR_BLANKS.get(tag), "", result); if (!P_REMOVE_SELF_BLANKS.containsKey(tag)) { P_REMOVE_SELF_BLANKS.putIfAbsent(tag, Pattern.compile("<" + tag + "(\\s[^>]*)?/>")); } result = regexReplace(P_REMOVE_SELF_BLANKS.get(tag), "", result); } return result; }
private static String regexReplace( final Pattern regex_pattern, final String replacement, final String s) { Matcher m = regex_pattern.matcher(s); return m.replaceAll(replacement); }
private String processParamProtocol(String s) { s = decodeEntities(s); final Matcher m = P_PROTOCOL.matcher(s); if (m.find()) { final String protocol = m.group(1); if (!inArray(protocol, vAllowedProtocols)) { s = "#" + s.substring(protocol.length() + 1, s.length()); if (s.startsWith("#//")) { s = "#" + s.substring(3, s.length()); } } } return s; }
private String decodeEntities(String s) { StringBuffer buf = new StringBuffer(); Matcher m = P_ENTITY.matcher(s); while (m.find()) { final String match = m.group(1); final int decimal = Integer.decode(match).intValue(); m.appendReplacement(buf, Matcher.quoteReplacement(chr(decimal))); } m.appendTail(buf); s = buf.toString(); buf = new StringBuffer(); m = P_ENTITY_UNICODE.matcher(s); while (m.find()) { final String match = m.group(1); final int decimal = Integer.valueOf(match, 16).intValue(); m.appendReplacement(buf, Matcher.quoteReplacement(chr(decimal))); } m.appendTail(buf); s = buf.toString(); buf = new StringBuffer(); m = P_ENCODE.matcher(s); while (m.find()) { final String match = m.group(1); final int decimal = Integer.valueOf(match, 16).intValue(); m.appendReplacement(buf, Matcher.quoteReplacement(chr(decimal))); } m.appendTail(buf); s = buf.toString(); s = validateEntities(s); return s; }
private String validateEntities(final String s) { StringBuffer buf = new StringBuffer(); Matcher m = P_VALID_ENTITIES.matcher(s); while (m.find()) { final String one = m.group(1); final String two = m.group(2); m.appendReplacement(buf, Matcher.quoteReplacement(checkEntity(one, two))); } m.appendTail(buf); return encodeQuotes(buf.toString()); }
private String encodeQuotes(final String s) { if (encodeQuotes) { StringBuffer buf = new StringBuffer(); Matcher m = P_VALID_QUOTES.matcher(s); while (m.find()) { final String one = m.group(1); final String two = m.group(2); final String three = m.group(3); m.appendReplacement( buf, Matcher.quoteReplacement(one + regexReplace(P_QUOTE, "&quot;", two) + three)); } m.appendTail(buf); return buf.toString(); } else { return s; } }
private String checkEntity(final String preamble, final String term) { return ";".equals(term) && isValidEntity(preamble) ? '&' + preamble : "&amp;" + preamble; }
private boolean isValidEntity(final String entity) { return inArray(entity, vAllowedEntities); }
private static boolean inArray(final String s, final String[] array) { for (String item : array) { if (item != null && item.equals(s)) { return true; } } return false; }
private boolean allowed(final String name) { return (vAllowed.isEmpty() || vAllowed.containsKey(name)) && !inArray(name, vDisallowed); }
private boolean allowedAttribute(final String name, final String paramName) { return allowed(name) && (vAllowed.isEmpty() || vAllowed.get(name).contains(paramName)); }
@Override public boolean isFinished() { return true; }
@Override public boolean isReady() { return true; }
@Override public int read() throws IOException { return bis.read(); }
private String xssEncode(String input) { return htmlFilter.filter(input); }
@Override public void init(FilterConfig config) throws ServletException {}
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper((HttpServletRequest) request); chain.doFilter(xssRequest, response); }
@Override public List<Map<String, Object>> queryList(Map<String, Object> map) { return sysGeneratorDao.queryList(map); }
@Override public int queryTotal(Map<String, Object> map) { return sysGeneratorDao.queryTotal(map); }
@Override public Map<String, String> queryTable(String tableName) { return sysGeneratorDao.queryTable(tableName); }
@Override public List<Map<String, String>> queryColumns(String tableName) { return sysGeneratorDao.queryColumns(tableName); }
public static String columnToJava(String columnName) { return WordUtils.capitalizeFully(columnName, new char[] {'_'}).replace("_", ""); }
public static String tableToJava(String tableName, String tablePrefix) { if (StringUtils.isNotBlank(tablePrefix)) { tableName = tableName.replace(tablePrefix, ""); } return columnToJava(tableName); }
@RequestMapping("/info/{logId}") public R info(@PathVariable("logId") Long logId) { ScheduleJobLogEntity log = scheduleJobLogService.queryObject(logId); return R.ok().put("log", log); }
@RequestMapping("/info/{jobId}") @RequiresPermissions("sys:schedule:info") public R info(@PathVariable("jobId") Long jobId) { ScheduleJobEntity schedule = scheduleJobService.queryObject(jobId); return R.ok().put("schedule", schedule); }
@Override public ScheduleJobLogEntity queryObject(Long jobId) { return scheduleJobLogDao.queryObject(jobId); }
@Override public List<ScheduleJobLogEntity> queryList(Map<String, Object> map) { return scheduleJobLogDao.queryList(map); }
@Override public int queryTotal(Map<String, Object> map) { return scheduleJobLogDao.queryTotal(map); }
@Override public void save(ScheduleJobLogEntity log) { scheduleJobLogDao.save(log); }
@Override public ScheduleJobEntity queryObject(Long jobId) { return schedulerJobDao.queryObject(jobId); }
@Override public List<ScheduleJobEntity> queryList(Map<String, Object> map) { return null; }
@Override public int queryTotal(Map<String, Object> map) { return schedulerJobDao.queryTotal(map); }
@Override @Transactional public void save(ScheduleJobEntity scheduleJob) { scheduleJob.setCreateTime(new Date()); scheduleJob.setStatus(ScheduleStatus.NORMAL.getValue()); schedulerJobDao.save(scheduleJob); ScheduleUtils.createScheduleJob(scheduler, scheduleJob); }
@Override @Transactional public void update(ScheduleJobEntity scheduleJob) { ScheduleUtils.updateScheduleJob(scheduler, scheduleJob); schedulerJobDao.update(scheduleJob); }
@Override public int updateBatch(Long[] jobIds, int status) { Map<String, Object> map = new HashMap<>(); map.put("list", jobIds); map.put("status", status); return schedulerJobDao.updateBatch(map); }
@Override @Transactional public void run(Long[] jobIds) { for (Long jobId : jobIds) { ScheduleUtils.run(scheduler, queryObject(jobId)); } }
@Override @Transactional public void pause(Long[] jobIds) { for (Long jobId : jobIds) { ScheduleUtils.pauseJob(scheduler, jobId); } updateBatch(jobIds, ScheduleStatus.PAUSE.getValue()); }
@Override @Transactional public void resume(Long[] jobIds) { for (Long jobId : jobIds) { ScheduleUtils.resumeJob(scheduler, jobId); } updateBatch(jobIds, ScheduleStatus.NORMAL.getValue()); }
@Override public TokenEntity queryByUserId(Long userId) { return tokenDao.queryByUserId(userId); }
@Override public TokenEntity queryByToken(String token) { return tokenDao.queryByToken(token); }
@Override public void save(TokenEntity token) { tokenDao.save(token); }
@Override public void update(TokenEntity token) { tokenDao.update(token); }
@Override public UserEntity queryObject(Long userId) { return userDao.queryObject(userId); }
@Override public List<UserEntity> queryList(Map<String, Object> map) { return userDao.queryList(map); }
@Override public int queryTotal(Map<String, Object> map) { return userDao.queryTotal(map); }
@Override public void save(UserEntity user) { user.setPassword(DigestUtils.sha256Hex(user.getPassword())); userDao.save(user); }
@Override public void update(UserEntity user) { userDao.update(user); }
@Override public void delete(Long userId) { userDao.delete(userId); }
@Override public void deleteBatch(Long[] userIds) { userDao.deleteBatch(userIds); }
@Override public UserEntity queryByMobile(String mobile) { return userDao.queryByMobile(mobile); }
@Override public boolean supportsParameter(MethodParameter parameter) { return parameter.getParameterType().isAssignableFrom(UserEntity.class) && parameter.hasParameterAnnotation(LoginUser.class); }
@RequestMapping(value = "userInfo", method = RequestMethod.GET) public R userInfo(@LoginUser UserEntity user) { return R.ok().put("user", user); }
@Override public String toString() { return "InterestGroupCustomer [groupId=" + groupId + ", customerId=" + customerId + "]"; }
@Override public String toString() { return "Topic [id=" + id + ", title=" + title + ", content=" + content + ", discription=" + discription + ", img=" + img + ", createBy=" + createBy + ", createTime=" + createTime + ", flag=" + flag + ", name=" + name + ", authImg=" + authImg + "]"; }
@Override public String toString() { return "ViewFavort [id=" + id + ", createBy=" + createBy + ", pointId=" + pointId + ", favortStatus=" + favortStatus + ", createTime=" + createTime + ", updateTime=" + updateTime + ", merchantId=" + merchantId + ", orgId=" + orgId + "]"; }
@Override public String toString() { return "Activity [id=" + id + ", InterestGroupId=" + InterestGroupId + ", activityName=" + activityName + ", activityLogo=" + activityLogo + ", activityDes=" + activityDes + ", activityContent=" + activityContent + ", activityStartTime=" + activityStartTime + ", activityEndTime=" + activityEndTime + ", activityAddr=" + activityAddr + ", createTime=" + createTime + ", createBy=" + createBy + ", flag=" + flag + ", highlights=" + highlights + "]"; }
@Override public String toString() { return "InterestGroup [getId()=" + getId() + ", getGroupCategoryId()=" + getGroupCategoryId() + ", getGroupName()=" + getGroupName() + ", getGroupLogo()=" + getGroupLogo() + ", getGroupSlogan()=" + getGroupSlogan() + ", getGroupIntro()=" + getGroupIntro() + ", getCreateTime()=" + getCreateTime() + ", getCustmerNo()=" + getCustmerNo() + ", getGroupAddress()=" + getGroupAddress() + ", getFlag()=" + getFlag() + ", getMerchantId()=" + getMerchantId() + ", getOrgId()=" + getOrgId() + "]"; }
@Override public String toString() { return "Viewpoint [id=" + id + ", createBy=" + createBy + ", pointText=" + pointText + ", pointImg=" + pointImg + ", pointTime=" + pointTime + ", pointAddress=" + pointAddress + ", favortCount=" + favortCount + ", commentCount=" + commentCount + ", diffTime=" + diffTime + ", ifFavort=" + ifFavort + "]"; }
@Override public String toString() { return "InterestGroupCategory [getId()=" + getId() + ", getCategoryName()=" + getCategoryName() + ", getCreatetime()=" + getCreatetime() + ", getFlag()=" + getFlag() + ", getGroupList()=" + getGroupList() + ", getMerchantId()=" + getMerchantId() + ", getOrgId()=" + getOrgId() + "]"; }
@Override public String toString() { return "Comment [id=" + id + ", parentId=" + parentId + ", commentType=" + commentType + ", commentContent=" + commentContent + ", commentTargetId=" + commentTargetId + ", commentBy=" + commentBy + ", commentByName=" + commentByName + ", commentTargetUserId=" + commentTargetUserId + ", commentTargetUserName=" + commentTargetUserName + ", commentLikeCount=" + commentLikeCount + ", commentTime=" + commentTime + ", commentModuleNo=" + commentModuleNo + ", commentImg=" + commentImg + ", commentTimes=" + commentTimes + "]"; }
@Override public String toString() { return "ActivityCustomer [activityId=" + activityId + ", customerId=" + customerId + "]"; }
@Override public String toString() { return "InterestGroupCustomerModel [groupId=" + groupId + ", groupName=" + groupName + ", customerId=" + customerId + ", customerNo=" + customerNo + ", custName=" + custName + ", nickname=" + nickname + ", phone=" + phone + ", sex=" + sex + ", identityCard=" + identityCard + ", address=" + address + ", age=" + age + ", birthday=" + birthday + ", avatar=" + avatar + "]"; }
@Override public String toString() { return "ActivityCustomerModel [activityId=" + activityId + ", activityName=" + activityName + ", customerId=" + customerId + ", customerNo=" + customerNo + ", custName=" + custName + ", nickname=" + nickname + ", phone=" + phone + ", sex=" + sex + ", identityCard=" + identityCard + ", address=" + address + ", age=" + age + ", birthday=" + birthday + ", avatar=" + avatar + "]"; }
@Override public Topic queryTopicInfo(Map<String, Object> param) { String id = (String) param.get("id"); Topic topic = topicDao.selectById(id); return topic; }
@Override public void insert(InterestGroupCategory groupCategory) { interestGroupCategoryDao.insert(groupCategory); }
@Override public List<InterestGroupCategory> query(Map<String, Object> queryMap) { return interestGroupCategoryDao.queryList(queryMap); }
@Override public List<Comment> query(Map<String, Object> param) { return commentDao.queryList(param); }
public Map<String, Object> saveTopicComment(Map<String, Object> param) { String content = (String) param.get("content"); String targetId = (String) param.get("targetId"); String commentByName = (String) param.get("commentByName"); String commentBy = (String) param.get("commentBy"); Long id = SnowFlake.getId(); Comment comment = new Comment(); comment.setId(id.toString()); comment.setCommentModuleNo("2"); comment.setCommentType("1"); comment.setCommentContent(content); comment.setCommentTargetId(targetId); comment.setCommentByName(commentByName); comment.setCommentBy(commentBy); comment.setCommentTime(new Timestamp(new Date().getTime())); Map<String, Object> map = new HashMap<String, Object>(); try { commentDao.save(comment); String format = "yyyy-MM-dd HH:mm:ss"; SimpleDateFormat sdf = new SimpleDateFormat(format); String time = sdf.format(comment.getCommentTime()); comment.setCommentTimes(time); map.put("code", "00"); map.put("comment", comment); } catch (Exception e) { map.put("code", "01"); e.printStackTrace(); } return map; }
@Override public List<Map<String, Object>> queryList(Map<String, Object> map) { return null; }
@Override public Map<String, Object> queryObject(Map<String, Object> map) { return null; }
@Override public Map<String, Object> queryById(Long id) { return null; }
@Override public int queryTotal(Map<String, Object> map) { return 0; }
@Override public void save(Map<String, Object> map) { ActivityCustomer ac = new ActivityCustomer(); ac.setActivityId((String) map.get("activityId")); ac.setCustomerId((String) map.get("customerId")); activityCustomerDao.save(ac); }
@Override public void update(Map<String, Object> map) { }
@Override public List<ActivityCustomer> selectByBizKeys(ActivityCustomer activityCustomer) { return activityCustomerDao.selectByBizKeys(activityCustomer); }
@Override public void deleteBatch(List<Long> ids) { }
@Override public List<Map<String, Object>> selectByMapKey(Map<String, Object> map) { List<Map<String, Object>> respList = new ArrayList<>(); try { ActivityCustomer activityCustomer = (ActivityCustomer) BeanUtils.mapToObject(map, ActivityCustomer.class); List<ActivityCustomer> actcusList = activityCustomerDao.selectByBizKeys(activityCustomer); if (actcusList != null && actcusList.size() > 0) { for (int i = 0; i < actcusList.size(); i++) { ActivityCustomer actCusItem = actcusList.get(i); respList.add(BeanUtils.objectToMap(actCusItem)); } } } catch (Exception e) { e.printStackTrace(); } return respList; }
@Override public SpecialColumnContent queryEntity(SpecialColumnContent param) { return specialColumnContentDao.queryObject(param); }
@Override public void delete(String id) { viewPointDao.delete(id.toString()); }
@Override public List<Viewpoint> query(Map<String, Object> map) { return viewPointDao.queryList(map); }
@Override public Map<String, Object> selectPointById(Map<String, Object> map) { Map<String, Object> result = new HashMap<String, Object>(); String id = (String) map.get("id"); Viewpoint point = new Viewpoint(); try { point = viewPointDao.selectById(id); result.put("point", point); result.put("code", "00"); } catch (Exception e) { e.printStackTrace(); result.put("code", "01"); } return result; }
@Override public List<SpecialColumn> queryCustomerColumnsList(Map<String, Object> queryMap) { return specialColumnDao.queryCustomerColumnsList(queryMap); }
@Override public void unsubscribe(Map<String, String> param) { customerSpecialColumnDao.deleteOne(param); }
@Override public void delete(Long id) { dao.delete(id); }
@Override public void save(Map<String, Object> map) { InterestGroupCustomer igc = new InterestGroupCustomer(); igc.setCustomerId((String) map.get("customerId")); igc.setGroupId((String) map.get("groupId")); interestGroupCustomerDao.save(igc); }
@Override public List<InterestGroupCustomer> selectByBizKeys(InterestGroupCustomer interestGroupCustomer) { return interestGroupCustomerDao.selectByBizKeys(interestGroupCustomer); }
@Override public void delete(InterestGroupCustomer interestGroupCustomer) { interestGroupCustomerDao.delete(interestGroupCustomer); }
@Override public List<Map<String, Object>> selectByMapKey(Map<String, Object> map) { List<Map<String, Object>> respList = new ArrayList<>(); try { InterestGroupCustomer interestGroupCustomer = (InterestGroupCustomer) BeanUtils.mapToObject(map, InterestGroupCustomer.class); List<InterestGroupCustomer> groupCusList = interestGroupCustomerDao.selectByBizKeys(interestGroupCustomer); if (groupCusList != null && groupCusList.size() > 0) { for (int i = 0; i < groupCusList.size(); i++) { InterestGroupCustomer groupCusItem = groupCusList.get(i); respList.add(BeanUtils.objectToMap(groupCusItem)); } } } catch (Exception e) { e.printStackTrace(); } return respList; }
@Override public void insert(InterestGroup group) { interestGroupDao.insert(group); }
@Override public List<InterestGroup> query(Map<String, Object> queryGroupMap) { return interestGroupDao.queryList(queryGroupMap); }
@Override public List<Map<String, Object>> selectByMapKey(Map<String, Object> map) { List<Map<String, Object>> respList = new ArrayList<>(); try { InterestGroup interestGroup = (InterestGroup) BeanUtils.mapToObject(map, InterestGroup.class); List<InterestGroup> groupList = interestGroupDao.selectByBizKeys(interestGroup); if (groupList != null && groupList.size() > 0) { for (int i = 0; i < groupList.size(); i++) { InterestGroup groupItem = groupList.get(i); respList.add(BeanUtils.objectToMap(groupItem)); } } } catch (Exception e) { e.printStackTrace(); } return respList; }
public void displayAllUser() { }
@Override public void insert(Activity activity) { activityDao.insert(activity); }
@Override public void updateById(Activity activity) { activityDao.update(activity); }
@Override public List<Activity> selectByBizKeys(Activity activity) { return activityDao.selectByBizKeys(activity); }
@Override public List<Activity> selectRecommendActivity(Map<String, Object> map) { return activityDao.selectRecommendActivity(map); }
@Override public int queryGroupActTotal(Map<String, Object> map) { String actStatus = (String) map.get("actStatus"); map.put("currentTime", new Timestamp(System.currentTimeMillis())); if ("1".equals(actStatus)) { return activityDao.selectStartActTotal(map); } else if ("2".equals(actStatus)) { return activityDao.selectProcessActTotal(map); } else if ("3".equals(actStatus)) { return activityDao.selectEndActTotal(map); } else { return 0; } }
@Override public List<Activity> queryGroupActList(Map<String, Object> map) { String actStatus = (String) map.get("actStatus"); map.put("currentTime", new Timestamp(System.currentTimeMillis())); if ("1".equals(actStatus)) { return activityDao.selectStartActivity(map); } else if ("2".equals(actStatus)) { return activityDao.selectProcessActivity(map); } else if ("3".equals(actStatus)) { return activityDao.selectEndActivity(map); } else { return null; } }
@Override public Activity queryEntity(Activity activity) { return activityDao.queryEntity(activity); }
@Override public List<Map<String, Object>> selectByMapKey(Map<String, Object> map) { List<Map<String, Object>> respList = new ArrayList<>(); try { Activity activity = (Activity) BeanUtils.mapToObject(map, Activity.class); List<Activity> actList = activityDao.selectByBizKeys(activity); if (actList != null && actList.size() > 0) { for (int i = 0; i < actList.size(); i++) { Activity actItem = actList.get(i); respList.add(BeanUtils.objectToMap(actItem)); } } } catch (Exception e) { e.printStackTrace(); } return respList; }
@ResponseBody @RequestMapping(value = "/displayAllUser", method = RequestMethod.GET) public void displayAllUser() { cmsUserService.displayAllUser(); }
public static void main(String[] args) { BigInteger targetValue = BigInteger.valueOf(1).shiftLeft((256 - 20)); System.out.println(targetValue); }
@PreDestroy public void destroy() { defaultMQProducer.shutdown(); }
@ResponseBody @RequestMapping(value = "/displayAllUser", method = RequestMethod.GET) public HashMap<String, List<PayChannel>> displayAllUser() { HashMap<String, List<PayChannel>> map = new HashMap<String, List<PayChannel>>(); Map<String, Object> map1 = new HashMap<>(); map1.put("payChannelNo", "payChannelNo"); map1.put("payCompanyNo", "payCompanyNo"); map1.put("feeRatio", "1"); payChannelServiceImpl.save(map1); return map; }
@Override public void insert(PaySerial paySerial) { paySerialDao.save(paySerial); }
@Override public void save(PayOrder payOrder) { payOrderDao.save(payOrder); }
@Override public PayOrder queryByPayOrder(PayOrder payOrder) { return payOrderDao.queryObject(payOrder); }
@Override public List<PayChannel> route(List<PayChannel> payChannels) { return null; }
@Override public CreateOrderResponse createOrder(CreateOrderRequst requst) { PayOrder payOrder = new PayOrder(); payOrder.setPayOrderNo(requst.getPayOrderNo()); payOrder.setCustomerNo(requst.getCustomerNo()); payOrderService.save(payOrder); return null; }
@Override public PayOrderResponse createPayOrder(PayOrderRequest request) { PayOrder payOrder = new PayOrder(); payOrder.setMerchantNo(""); payOrderService.save(payOrder); return null; }
private InputStream getStringStream(String sInputString) throws UnsupportedEncodingException { ByteArrayInputStream tInputStringStream = null; if (sInputString != null && !sInputString.trim().equals("")) { tInputStringStream = new ByteArrayInputStream(sInputString.getBytes("UTF-8")); } return tInputStringStream; }
public String sign(Object obj, PayChannelConfig channelConfig) throws Exception { return toSign(BeanUtils.objectToMap(obj), channelConfig); }
public String toSign(Map<String, Object> sPara, PayChannelConfig channelConfig) { return null; }
public static Map<String, String> paraFilter(Map<String, String> sArray) { Map<String, String> result = new HashMap<String, String>(); if (sArray == null || sArray.size() <= 0) { return result; } for (String key : sArray.keySet()) { String value = sArray.get(key); if (value == null || value.equals("") || key.equalsIgnoreCase("sign") || key.equalsIgnoreCase("sign_type")) { continue; } result.put(key, value); } return result; }
public static String getAbstract(String strFilePath, String file_digest_type) throws IOException { FileDataSource file = new FileDataSource(new File(strFilePath)); if (file_digest_type.equals("MD5")) { return DigestUtils.md5Hex(file.getInputStream()); } else if (file_digest_type.equals("SHA")) { return DigestUtils.sha256Hex(file.getInputStream()); } else { return ""; } }
@Override public RefundResponse refund(RefundRequest request) { return null; }
@Override public String toString() { return "WechatRefundResponse [returnCode=" + returnCode + ", returnMsg=" + returnMsg + ", resultCode=" + resultCode + ", errCode=" + errCode + ", errCodeDes=" + errCodeDes + ", outTradeNo=" + outTradeNo + ", outRefundNo=" + outRefundNo + ", refundId=" + refundId + ", refundFee=" + refundFee + "]"; }
private WechatRefundResponse xmlToResponseData(InputStream inputStream) throws JAXBException { Reader reader = new InputStreamReader(inputStream, Charset.forName("UTF-8")); JAXBContext context = JAXBContext.newInstance(WechatRefundResponse.class); try { Unmarshaller unmarshaller = context.createUnmarshaller(); return (WechatRefundResponse) unmarshaller.unmarshal(reader); } finally { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } }
@Override public String toString() { return "WechatRefundRequest [appid=" + appid + ", mch_id=" + mch_id + ", nonce_str=" + nonce_str + ", sign=" + sign + ", out_trade_no=" + out_trade_no + ", out_refund_no=" + out_refund_no + ", total_fee=" + total_fee + ", refund_fee=" + refund_fee + ", op_user_id=" + op_user_id + "]"; }
public static void main(String[] args) { try { Map<String, Object> map = new HashMap<String, Object>(); map.put("PayChannelId", 1); map.put("payChannelNo", "2"); map.put("payCompanyNo", "3"); map.put("feeRatio", 1); PayChannel payChannel = (PayChannel) BeanUtils.mapToObject(map, PayChannel.class); } catch (Exception e) { e.printStackTrace(); } }
@Test public void testQueryUser() { payChannelConfigDao.queryById(Long.valueOf(1)); }
public static Map<String, Object> objectToMap(Object obj) throws Exception { if (obj == null) return null; Map<String, Object> map = new HashMap<String, Object>(); BeanInfo beanInfo = Introspector.getBeanInfo(obj.getClass()); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor property : propertyDescriptors) { String key = property.getName(); if (key.compareToIgnoreCase("class") == 0) { continue; } Method getter = property.getReadMethod(); Object value = getter != null ? getter.invoke(obj) : null; map.put(key, value); } return map; }
@Override public String toString() { return "PageUtils [totalCount=" + totalCount + ", pageSize=" + pageSize + ", totalPage=" + totalPage + ", currentPage=" + currentPage + "]"; }
public static <T> Map<String, Object> success( Object clazz, PageUtils pageUtils, String code, String msg) { Map<String, Object> map = new HashMap<>(); map.put("code", code); map.put("status", "200"); map.put("msg", msg); try { map.put("pagination", BeanUtil.objectToMap(pageUtils)); if (clazz == null) { return map; } if (clazz instanceof Map) { map.put("data", clazz); return map; } if (clazz instanceof List) { map.put("data", clazz); } else { map.put("data", BeanUtil.objectToMap(clazz)); } } catch (Exception e) { e.printStackTrace(); } return map; }
public static <T> Map<String, Object> failure(String code, String msg) { Map<String, Object> map = new HashMap<>(); map.put("code", code); map.put("status", "200"); map.put("msg", msg); map.put("data", "[]"); return map; }
private static int parse(char c) { if (c >= 'a') return (c - 'a' + 10) & 0x0f; if (c >= 'A') return (c - 'A' + 10) & 0x0f; return (c - '0') & 0x0f; }
public static byte[] HexString2Bytes(String hexstr) { byte[] b = new byte[hexstr.length() / 2]; int j = 0; for (int i = 0; i < b.length; i++) { char c0 = hexstr.charAt(j++); char c1 = hexstr.charAt(j++); b[i] = (byte) ((parse(c0) << 4) | parse(c1)); } return b; }
public static String sign(String text, String key, String input_charset) { text = text + key; return DigestUtils.md5Hex(getContentBytes(text, input_charset)); }
public static String sign(String text, String input_charset) { return DigestUtils.md5Hex(getContentBytes(text, input_charset)); }
public static boolean verify(String text, String sign, String key, String input_charset) { text = text + key; String mysign = DigestUtils.md5Hex(getContentBytes(text, input_charset)); if (mysign.equals(sign)) { return true; } else { return false; } }
public static boolean verify(String text, String sign, String input_charset) { String mysign = DigestUtils.md5Hex(getContentBytes(text, input_charset)); if (mysign.equals(sign)) { return true; } else { return false; } }
public static synchronized PrivateKey getPrivateKeyFromStore( String keyStorePath, String alias, String password) throws Exception { logger.debug("PrivateKeyCacheUtils:::get Private Key From Store!"); KeyStore keyStore = BouncyCertificateUtils.getKeyStore(keyStorePath, password); PrivateKey privateKey = (PrivateKey) keyStore.getKey(alias, password.toCharArray()); return privateKey; }
public static synchronized PublicKey getPublicKeyFromCertificate(String certificatePath) throws Exception { logger.debug("PrivateKeyCacheUtils:::get public Key From Store!"); Certificate certificate = BouncyCertificateUtils.getCertificate(certificatePath); PublicKey publicKey = certificate.getPublicKey(); return publicKey; }
public static PublicKey getPublicKey(String certificatePath) throws Exception { PublicKey publicKey = publicKeys.get(certificatePath); if (publicKey != null) { logger.debug("PrivateKeyCacheUtils:::get PrivateKey From Cache!"); return publicKey; } else { publicKey = getPublicKeyFromCertificate(certificatePath); publicKeys.put(certificatePath, publicKey); return publicKey; } }
public static PrivateKey getPrivateKey(String keyStorePath, String alias, String password) throws Exception { String key = keyStorePath + alias + password; PrivateKey privateKey = privateKeys.get(key); if (privateKey != null) { logger.debug("PrivateKeyCacheUtils:::get PrivateKey From Cache!"); return privateKey; } else { privateKey = getPrivateKeyFromStore(keyStorePath, alias, password); privateKeys.put(key, privateKey); return privateKey; } }
public static byte[] decryptByPrivateKey( byte[] encryptedData, String keyStorePath, String alias, String password) throws Exception { logger.debug("PrivateKeyCacheUtils:::decryptByPrivateKey start "); DecryptTask decryptTask = new DecryptTask(keyStorePath, alias, password, encryptedData); Future<byte[]> result = decryptExecutor.submit(decryptTask); byte[] decryptData = result.get(1, TimeUnit.MINUTES); logger.debug("PrivateKeyCacheUtils:::decryptByPrivateKey end "); return decryptData; }
public static byte[] encryptByPublicKey(byte[] data, String certificatePath) throws Exception { logger.debug("PrivateKeyCacheUtils:::encryptByPublicKey start "); EncryptTask encryptTask = new EncryptTask(certificatePath, data); Future<byte[]> result = encryptExecutor.submit(encryptTask); byte[] encryptData = result.get(1, TimeUnit.MINUTES); logger.debug("PrivateKeyCacheUtils:::encryptByPublicKey end "); return encryptData; }
public static String from3DESAndBase64(String sourceString, String hex3DES) { String strRTN = null; try { byte[] bytesString = Base64.decode(sourceString); byte[] bytesKey = Hex.decode(hex3DES); Security.addProvider(new BouncyCastleProvider()); Cipher cEnc = Cipher.getInstance("DESede/CBC/PKCS7Padding", "BC"); cEnc.init( Cipher.DECRYPT_MODE, new SecretKeySpec(bytesKey, "DESede"), new IvParameterSpec(Hex.decode("0102030405060708"))); byte[] bytes3DES = cEnc.doFinal(bytesString); strRTN = new String(bytes3DES, "UTF-8"); } catch (Exception e) { System.out.println( "CommonAlgorithm.calculateRS(String sourceString,String hex3DES)" + e.getMessage()); return strRTN; } return strRTN; }
public static PrivateKey getPrivateKey(String keyStorePath, String alias, String password) throws Exception { return PrivateKeyCacheUtils.getPrivateKey(keyStorePath, alias, password); }
public static KeyStore getKeyStore(String keyStorePath, String password) throws Exception { FileInputStream in = new FileInputStream(keyStorePath); KeyStore keyStore = KeyStore.getInstance(KEY_STORE); keyStore.load(in, password.toCharArray()); in.close(); return keyStore; }
public static PublicKey getPublicKey(String certificatePath) throws Exception { Certificate certificate = getCertificate(certificatePath); PublicKey publicKey = certificate.getPublicKey(); return publicKey; }
public static Certificate getCertificate(String certificatePath) throws Exception { CertificateFactory certificateFactory = CertificateFactory.getInstance(X509); FileInputStream in = new FileInputStream(certificatePath); Certificate certificate = certificateFactory.generateCertificate(in); in.close(); return certificate; }
public static String getModulus(String publicKeyPath) throws Exception { X509EncodedKeySpec spec = new X509EncodedKeySpec(CertificateUtils.getPublicKey(publicKeyPath).getEncoded()); KeyFactory kf = KeyFactory.getInstance("RSA"); kf.generatePublic(spec); RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(spec); String modulus = publicKey.getModulus().toString(16); return modulus; }
public static String getPublicExponent(String publicKeyPath) throws Exception { X509EncodedKeySpec spec = new X509EncodedKeySpec(CertificateUtils.getPublicKey(publicKeyPath).getEncoded()); KeyFactory kf = KeyFactory.getInstance("RSA"); kf.generatePublic(spec); RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(spec); String publicExponent = publicKey.getPublicExponent().toString(16); return publicExponent; }
public static String getPrivateExponent(String keyStorePath, String alias, String password) throws Exception { PrivateKey privateKey = getPrivateKey(keyStorePath, alias, password); RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) privateKey; String privateExponent = rsaPrivateKey.getPrivateExponent().toString(); return privateExponent; }
public static PublicKey getReducePublicKey(String modulus, String publicExponent) throws NoSuchAlgorithmException, InvalidKeySpecException { BigInteger bigIntModulus = new BigInteger(modulus); BigInteger bigIntPrivateExponent = new BigInteger(publicExponent); RSAPublicKeySpec keySpec = new RSAPublicKeySpec(bigIntModulus, bigIntPrivateExponent); KeyFactory keyFactory = KeyFactory.getInstance("RSA"); PublicKey publicKey = keyFactory.generatePublic(keySpec); return publicKey; }
public static PrivateKey getReducePrivateKey(String modulus, String privateExponent) throws NoSuchAlgorithmException, InvalidKeySpecException { BigInteger bigIntModulus = new BigInteger(modulus); BigInteger bigIntPrivateExponent = new BigInteger(privateExponent); RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(bigIntModulus, bigIntPrivateExponent); KeyFactory keyFactory = KeyFactory.getInstance("RSA"); PrivateKey privateKey = keyFactory.generatePrivate(keySpec); return privateKey; }
private static boolean isWhiteSpace(char octect) { return (octect == 0x20 || octect == 0xd || octect == 0xa || octect == 0x9); }
private static boolean isPad(char octect) { return (octect == PAD); }
private static boolean isData(char octect) { return (octect < BASELENGTH && base64Alphabet[octect] != -1); }
private static int removeWhiteSpace(char[] data) { if (data == null) { return 0; } int newSize = 0; int len = data.length; for (int i = 0; i < len; i++) { if (!isWhiteSpace(data[i])) { data[newSize++] = data[i]; } } return newSize; }
public static String bytes2HexString(byte[] b) { StringBuffer result = new StringBuffer(); String hex; for (int i = 0; i < b.length; i++) { hex = Integer.toHexString(b[i] & 0xFF); if (hex.length() == 1) { hex = '0' + hex; } result.append(hex.toUpperCase()); } return result.toString(); }
public static byte[] hexString2Bytes(String src) { int l = src.length() / 2; byte[] ret = new byte[l]; for (int i = 0; i < l; i++) { ret[i] = (byte) Integer.valueOf(src.substring(i * 2, i * 2 + 2), 16).byteValue(); } return ret; }
public static String string2HexString(String strPart) { StringBuffer hexString = new StringBuffer(); for (int i = 0; i < strPart.length(); i++) { int ch = (int) strPart.charAt(i); String strHex = Integer.toHexString(ch); hexString.append(strHex); } return hexString.toString(); }
public static String hexString2String(String src) { String temp = ""; for (int i = 0; i < src.length() / 2; i++) { temp = temp + (char) Integer.valueOf(src.substring(i * 2, i * 2 + 2), 16).byteValue(); } return temp; }
public static Byte char2Byte(Character src) { return Integer.valueOf((int) src).byteValue(); }
private static String intToHexString(int a, int len) { len <<= 1; String hexString = Integer.toHexString(a); int b = len - hexString.length(); if (b > 0) { for (int i = 0; i < b; i++) { hexString = "0" + hexString; } } return hexString; }
public static void main(String args[]) { System.out.println(hexString2String("3133383131313536373838")); }
public static PrivateKey getPrivateKey(String key) throws Exception { byte[] keyBytes; keyBytes = Base64.decode(key); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance("RSA"); PrivateKey privateKey = keyFactory.generatePrivate(keySpec); return privateKey; }
@Override protected Cipher initialValue() { try { Cipher cipher = Cipher.getInstance("RSA/ECB/NoPadding"); return cipher; } catch (Exception e) { throw new RuntimeException(e); } }
public static byte[] decode(String base64) throws Exception { return Base64.decodeBase64(base64); }
public static String encode(byte[] bytes) throws Exception { return new String(Base64.encodeBase64(bytes)); }
public static String encodeFile(String filePath) throws Exception { byte[] bytes = fileToByte(filePath); return encode(bytes); }
public static void decodeToFile(String filePath, String base64) throws Exception { byte[] bytes = decode(base64); byteArrayToFile(bytes, filePath); }
public static byte[] fileToByte(String filePath) throws Exception { byte[] data = new byte[0]; File file = new File(filePath); if (file.exists()) { FileInputStream in = new FileInputStream(file); ByteArrayOutputStream out = new ByteArrayOutputStream(2048); byte[] cache = new byte[CACHE_SIZE]; int nRead = 0; while ((nRead = in.read(cache)) != -1) { out.write(cache, 0, nRead); out.flush(); } out.close(); in.close(); data = out.toByteArray(); } return data; }
public static PrivateKey getPrivateKey(String keyStorePath, String alias, String password) throws Exception { KeyStore keyStore = getKeyStore(keyStorePath, password); PrivateKey privateKey = (PrivateKey) keyStore.getKey(alias, password.toCharArray()); return privateKey; }
private static Certificate getCertificate(String certificatePath) throws Exception { CertificateFactory certificateFactory = CertificateFactory.getInstance(X509); FileInputStream in = new FileInputStream(certificatePath); Certificate certificate = certificateFactory.generateCertificate(in); in.close(); return certificate; }
private static Certificate getCertificate(String keyStorePath, String alias, String password) throws Exception { KeyStore keyStore = getKeyStore(keyStorePath, password); Certificate certificate = keyStore.getCertificate(alias); return certificate; }
public static String signToBase64(byte[] data, String keyStorePath, String alias, String password) throws Exception { return Base64Utils.encode(sign(data, keyStorePath, alias, password)); }
public static String signFileToBase64( String filePath, String keyStorePath, String alias, String password) throws Exception { return Base64Utils.encode(generateFileSign(filePath, keyStorePath, alias, password)); }
public static boolean verifyBase64Sign(String base64String, String sign, String certificatePath) throws Exception { byte[] data = Base64Utils.decode(base64String); return verifySign(data, sign, certificatePath); }
public static boolean verifyBase64SignWithDecrypt( String base64String, String sign, String certificatePath) throws Exception { byte[] encryptedData = Base64Utils.decode(base64String); byte[] data = decryptByPublicKey(encryptedData, certificatePath); return verifySign(data, sign, certificatePath); }
@Override protected Cipher initialValue() { try { Security.addProvider(new BouncyCastleProvider()); Cipher cipher = Cipher.getInstance(ALGORITHOM, "BC"); return cipher; } catch (Exception e) { throw new RuntimeException(e); } }
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; }
@RequestMapping(value = "/33434", method = RequestMethod.GET) public String home() { return "3434"; }
@ResponseBody @RequestMapping(value = "/cancel", method = RequestMethod.POST) public Map<String, Object> cancel(@RequestBody Map<String, String> param) { return null; }
@ResponseBody @RequestMapping(value = "/query", method = RequestMethod.POST) public Map<String, Object> query(@RequestBody Map<String, String> param) { return null; }
@ResponseBody @RequestMapping(value = "/apply", method = RequestMethod.POST) public Map<String, Object> apply(@RequestBody Map<String, String> param) { return null; }
@ResponseBody @RequestMapping(value = "/query", method = RequestMethod.POST) public Map<String, Object> query(@RequestBody Map<String, String> param) { return null; }
@ResponseBody @RequestMapping(value = "/addImg", method = RequestMethod.POST) public Map<String, Object> addImg(@RequestBody Map<String, Object> param) { System.out.println(param); return null; }
@RequestMapping(value = "/upload", method = RequestMethod.GET) public String index() { return "upload"; }
@RequestMapping(value = "/doUpload", method = RequestMethod.POST) public String doUploadFile(@RequestParam("file") MultipartFile file) { System.out.println(file); return ""; }
@RequestMapping(value = "/apply", method = RequestMethod.GET) public String index() { return "apply"; }
@RequestMapping("/applyForProficient") public Map<String, Object> applyForProficient( HttpServletRequest request, HttpServletResponse response) throws IllegalStateException, IOException { return null; }
@RequestMapping(value = "/proficientRecommendIndex", method = RequestMethod.GET) public String index() { return "proficientRecommendIndex"; }
@Override public void init(FilterConfig filterConfig) throws ServletException {}
@Override public BufferedReader getReader() throws IOException { return new BufferedReader(new InputStreamReader(getInputStream())); }
@Override public int read() throws IOException { return bais.read(); }
public boolean isFinished() { return false; }
public boolean isReady() { return false; }
private static final void out(HttpServletResponse response, String msg) { ObjectMapper objectMapper = new ObjectMapper(); response.setCharacterEncoding("UTF-8"); response.setContentType("application/json; charset=utf-8"); PrintWriter out = null; try { out = response.getWriter(); Map<String, Object> map = new HashMap<String, Object>(); map.put("code", "01"); map.put("msg", msg); map.put("status", "201"); out.append(objectMapper.writeValueAsString(map)); } catch (IOException e) { e.printStackTrace(); } finally { if (out != null) { out.flush(); out.close(); } } }
@Override public void postHandle(WebRequest arg0, ModelMap arg1) throws Exception { }
@Override public void preHandle(WebRequest arg0) throws Exception { }
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { logger.info("HandlerInterceptorAdapter------start------{}", request); return true; }
@ResponseBody @RequestMapping(value = "/displayAllUser", method = RequestMethod.GET) public HashMap<String, List<Product>> displayAllUser() { HashMap<String, List<Product>> map = new HashMap<String, List<Product>>(); return map; }
@Override public List<Map<String, Object>> queryList(Map<String, Object> map) { List<Map<String, Object>> resultMaps = new ArrayList<>(); try { List<T> ts = baseDao.queryList(map); for (T t : ts) { Map<String, Object> resultMap = BeanUtils.objectToMap(t); resultMaps.add(resultMap); } } catch (Exception e) { e.printStackTrace(); } return resultMaps; }
@Override public int queryTotal(Map<String, Object> map) { return baseDao.queryTotal(map); }
@Override public void save(Map<String, Object> map) { if (map == null) return; try { @SuppressWarnings("unchecked") Class<T> clazz = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0]; @SuppressWarnings("unchecked") T t = (T) BeanUtils.mapToObject(map, clazz); baseDao.save(t); } catch (Exception e) { e.printStackTrace(); } }
@Override public void update(Map<String, Object> map) { if (map == null) return; try { @SuppressWarnings("unchecked") Class<T> clazz = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0]; @SuppressWarnings("unchecked") T t = (T) BeanUtils.mapToObject(map, clazz); baseDao.update(t); } catch (Exception e) { e.printStackTrace(); } }
@Override public void deleteBatch(List<Long> ids) { if (ids == null) { return; } try { baseDao.deleteBatch(ids); } catch (Exception e) { e.printStackTrace(); } }
@Override public Map<String, Object> queryObject(Map<String, Object> map) { if (map == null) return null; Map<String, Object> resultMap = null; try { @SuppressWarnings("unchecked") Class<T> clazz = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0]; @SuppressWarnings("unchecked") T t = (T) BeanUtils.mapToObject(map, clazz); resultMap = BeanUtils.objectToMap(baseDao.queryObject(t)); } catch (Exception e) { e.printStackTrace(); } return resultMap; }
@Override public Map<String, Object> queryById(Long id) { Map<String, Object> resultMap = null; try { resultMap = BeanUtils.objectToMap(baseDao.queryById(id)); } catch (Exception e) { e.printStackTrace(); } ; return resultMap; }
public static final Sex getGenderFromPersonIDCode(String identity) throws Throwable { String id = getFixedPersonIDCode(identity); char sex = id.charAt(16); return sex % 2 == 0 ? Sex.Female : Sex.Male; }
public static void main(String[] args) throws Throwable { String idcard1 = "11010519491231002X"; String idcard2 = "440524188001010014"; System.out.println(IDCardUtil.getGenderFromPersonIDCode(idcard1)); System.out.println(IDCardUtil.isIdentity(idcard2)); }
public static BigDecimal turnNullToZero(BigDecimal nullValue) { return nullValue == null ? BigDecimal.ZERO : nullValue; }
public static BigInteger turnNullToZero(BigInteger nullValue) { return nullValue == null ? BigInteger.ZERO : nullValue; }
public static Integer turnNullToZero(Integer nullValue) { return nullValue == null ? Integer.valueOf(0) : nullValue; }
public static Time formatTime(Time time) { SimpleDateFormat sf = new SimpleDateFormat("HH:mm:ss"); try { time = new Time(sf.parse(sf.format(new Date(time.getTime()))).getTime()); } catch (ParseException e) { e.printStackTrace(); } return time; }
public static Date formatDate(Date date) { SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd"); try { date = new Date(sf.parse(sf.format(date)).getTime()); } catch (ParseException e) { e.printStackTrace(); } return date; }
public static Date parseDate(String dateStr) { SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd"); Date date = null; try { date = sf.parse(dateStr); } catch (ParseException e) { e.printStackTrace(); } return date; }
public static String formatTimeToString(Date date) { SimpleDateFormat sf = new SimpleDateFormat("HH:mm:ss"); return sf.format(date); }
public static String formatDateToString(Date date) { SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd"); return sf.format(date); }
public static String addDayOfYear(Date date, int amt) { Calendar rightNow = Calendar.getInstance(); rightNow.setTime(date); rightNow.add(Calendar.DAY_OF_YEAR, amt); Date dt1 = rightNow.getTime(); return formatDateToString(dt1); }
public static boolean checkVerificationCode(String str) { String regex = "^[0-9]{6}$"; return Pattern.matches(regex, str); }
public static String formatTimeToStringNoSign(Date date) { SimpleDateFormat sf = new SimpleDateFormat("HHmmss"); return sf.format(date); }
public static String formatDateToStringNoSign(Date date) { SimpleDateFormat sf = new SimpleDateFormat("yyyyMMdd"); return sf.format(date); }
public static String changeToYuan(String tradeAmount) { if (!StringUtils.hasText(tradeAmount)) { return ""; } BigDecimal amt = new BigDecimal(tradeAmount); BigDecimal divide = new BigDecimal(100); DecimalFormat format = new DecimalFormat("0.00"); return format.format(amt.divide(divide)); }
public static BigDecimal changeToYuanDecimal(String tradeAmount) { if (!StringUtils.hasText(tradeAmount)) { return new BigDecimal("0.00"); } BigDecimal amt = new BigDecimal(tradeAmount); BigDecimal divide = new BigDecimal(100); return amt.divide(divide).setScale(2); }
public static String changeToDivide(String tradeAmount) { if (!StringUtils.hasText(tradeAmount)) { return ""; } BigDecimal amt = new BigDecimal(tradeAmount); BigDecimal divide = new BigDecimal("100"); return amt.multiply(divide).setScale(0).toString(); }
public static BigInteger changeToCent(String tradeAmount) { if (!StringUtils.hasText(tradeAmount)) { return BigInteger.valueOf(0); } BigDecimal amt = new BigDecimal(tradeAmount); BigDecimal divide = new BigDecimal(100); return amt.multiply(divide).toBigInteger(); }
public static boolean isChineseChar(String str) { boolean temp = false; for (int i = 0; i < str.length(); i++) { Pattern p = Pattern.compile("[\u4e00-\u9fa5]"); Matcher m = p.matcher(String.valueOf(str.charAt(i))); if (m.find()) { temp = false; } else { temp = true; return temp; } } return temp; }
public static String generateOrderNo() { return formatDateToStringNoSign(new Date()) + formatTimeToStringNoSign(new Date()) + ((int) (Math.random() * 89999) + 10000); }
public static String formatDateToString14(Date date) { SimpleDateFormat sf = new SimpleDateFormat("yyyyMMddHHmmss"); return sf.format(date); }
public BufferedImage loadImageUrl(String imgName) { try { URL url = new URL(imgName); return ImageIO.read(url); } catch (IOException e) { System.out.println(e.getMessage()); } return null; }
private static int parseDoubleToInt(double sourceDouble) { int result = 0; result = (int) sourceDouble; return result; }
private static ArrayList<Integer> getAutoWidthAndHeight( BufferedImage bufferedImage, int width_scale, int height_scale) { ArrayList<Integer> arrayList = new ArrayList<Integer>(); int width = bufferedImage.getWidth(); int height = bufferedImage.getHeight(); double scale_w = getDot2Decimal(width_scale, width); System.out.println("getAutoWidthAndHeight width=" + width + "scale_w=" + scale_w); double scale_h = getDot2Decimal(height_scale, height); if (scale_w < scale_h) { arrayList.add(parseDoubleToInt(scale_w * width)); arrayList.add(parseDoubleToInt(scale_w * height)); } else { arrayList.add(parseDoubleToInt(scale_h * width)); arrayList.add(parseDoubleToInt(scale_h * height)); } return arrayList; }
public static void main(String[] args) { ImageHelper.scaleImage( "F:/assets/test/qrcode.jpg", "F:/assets/test/scale-qrcode.jpg", 0.4, "JPEG"); }
public static void main(String[] args) throws IOException, WriterException { createQrCode( new FileOutputStream(new File("F:/assets/test/qrcode.jpg")), "WE1231238239128sASDASDSADSDWEWWREWRERWSDFDFSDSDF123123123123213123", 900, "JPEG"); readQrCode(new FileInputStream(new File("F:/assets/test/qrcode.jpg"))); }
public void update(byte[] puchMsg, int usDataLen) { int uIndex; for (int i = 0; i < usDataLen; i++) { uIndex = (uchCRCHi ^ puchMsg[i]) & 0xff; uchCRCHi = (byte) (uchCRCLo ^ auchCRCHi[uIndex]); uchCRCLo = auchCRCLo[uIndex]; } value = ((((int) uchCRCHi) << 8 | (((int) uchCRCLo) & 0xff))) & 0xffff; return; }
public void reset() { value = 0; uchCRCHi = (byte) 0xff; uchCRCLo = (byte) 0xff; }
private static byte uniteBytes(byte src0, byte src1) { byte _b0 = Byte.decode("0x" + new String(new byte[] {src0})).byteValue(); _b0 = (byte) (_b0 << 4); byte _b1 = Byte.decode("0x" + new String(new byte[] {src1})).byteValue(); byte ret = (byte) (_b0 ^ _b1); return ret; }
private static byte[] HexString2Buf(String src) { int len = src.length(); byte[] ret = new byte[len / 2 + 2]; byte[] tmp = src.getBytes(); for (int i = 0; i < len; i += 2) { ret[i / 2] = uniteBytes(tmp[i], tmp[i + 1]); } return ret; }
public static boolean checkBuf(byte[] bb) { CRC16M crc16 = new CRC16M(); crc16.update(bb, bb.length - 2); int ri = crc16.getValue(); if (bb[bb.length - 1] == (byte) (ri & 0xff) && bb[bb.length - 2] == (byte) ((0xff00 & ri) >> 8)) return true; return false; }
public static void main(String[] args) { byte[] sbuf = CRC16M.getSendBuf(String.valueOf(SnowFlake.getId())); System.out.println(CRC16M.getBufHexStr(sbuf)); String hexStr = CRC16M.getBufHexStr(sbuf); byte[] bt = CRC16M.HexString2Buf(hexStr); System.out.println(CRC16M.checkBuf(bt)); }
public static void main(String[] args) { for (int i = 0; i < 10; i++) { System.out.println("ss[" + i + "]=====" + getUUID()); } }
public static synchronized String generateSequenceNo() { Calendar rightNow = Calendar.getInstance(); StringBuffer sb = new StringBuffer(); dateFormat.format(rightNow.getTime(), sb, HELPER_POSITION); numberFormat.format(seq, sb, HELPER_POSITION); if (seq == MAX) { seq = 0; } else { seq++; } return sb.toString(); }
public static void main(String[] args) { for (int i = 0; i < (1 << 102); i++) { System.out.println(SnowFlake.getId()); } }
public static String sign(String content, String privateKey, String input_charset) { try { PKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(Base64.decode(privateKey)); KeyFactory keyf = KeyFactory.getInstance("RSA"); PrivateKey priKey = keyf.generatePrivate(priPKCS8); java.security.Signature signature = java.security.Signature.getInstance(SIGN_ALGORITHMS); signature.initSign(priKey); signature.update(content.getBytes(input_charset)); byte[] signed = signature.sign(); return Base64.encode(signed); } catch (Exception e) { } return null; }
public static boolean verify( String content, String sign, String ali_public_key, String input_charset) { try { KeyFactory keyFactory = KeyFactory.getInstance("RSA"); byte[] encodedKey = Base64.decode(ali_public_key); PublicKey pubKey = keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey)); java.security.Signature signature = java.security.Signature.getInstance(SIGN_ALGORITHMS); signature.initVerify(pubKey); signature.update(content.getBytes(input_charset)); boolean bverify = signature.verify(Base64.decode(sign)); return bverify; } catch (Exception e) { } return false; }
public static Object mapToObject(Map<String, Object> map, Class<?> beanClass) throws Exception { if (map == null) return null; Object obj = beanClass.newInstance(); org.apache.commons.beanutils.BeanUtils.populate(obj, map); return obj; }
protected JsonResult renderError() { JsonResult result = new JsonResult(); result.setSuccess(false); result.setStatus("500"); return result; }
protected JsonResult renderError(String msg) { JsonResult result = renderError(); result.setMsg(msg); return result; }
protected JsonResult renderSuccess() { JsonResult result = new JsonResult(); result.setSuccess(true); result.setStatus("200"); return result; }
protected JsonResult renderSuccess(String msg) { JsonResult result = renderSuccess(); result.setMsg(msg); return result; }
protected JsonResult renderSuccess(Object obj) { JsonResult result = renderSuccess(); result.setObj(obj); return result; }
@RequestMapping("/") public ModelAndView index(ModelAndView modelAndView) { modelAndView.setViewName("index"); modelAndView.addObject("userList", userService.selectList(null)); return modelAndView; }
@RequestMapping("/preSave") public ModelAndView preSave( ModelAndView modelAndView, @RequestParam(value = "id", required = false) Long id) { modelAndView.setViewName("save"); if (id != null) { modelAndView.addObject("user", userService.selectById(id)); } return modelAndView; }
@PreDestroy public void destroy() { defaultMQPushConsumer.shutdown(); }
@Override public ConsumeConcurrentlyStatus consumeMessage( List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) { if (rocketMqMessageListener.onMessage(list, consumeConcurrentlyContext)) { return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } return ConsumeConcurrentlyStatus.RECONSUME_LATER; }
@Override public void insertFill(MetaObject metaObject) { this.insertFill(metaObject); }
@Override public boolean openUpdateFill() { return false; }
public Object around(ProceedingJoinPoint point) throws Throwable { String serviceName = Joiner.on(DOT_CHAR) .join(point.getSignature().getDeclaringTypeName(), point.getSignature().getName()); String args = ToStringBuilder.reflectionToString(point.getArgs(), ToStringStyle.SHORT_PREFIX_STYLE); logger.info("Service start: serviceName={}, args={}", serviceName, args); StopWatch stopWatch = new StopWatch(); stopWatch.start(); try { Object result = point.proceed(); logger.info( "Service finished: serviceName={}, args={}, result={}, duration={}ms", serviceName, args, ToStringBuilder.reflectionToString(result, ToStringStyle.SHORT_PREFIX_STYLE), stopWatch.getTime()); return result; } catch (Exception e) { logger.error( "Service exception: serviceName={}, args={}, duration={}ms", serviceName, args, stopWatch.getTime(), e); throw e; } finally { stopWatch.stop(); } }
public boolean isSetResourceIdentifier() { return ((this.resourceIdentifier != null) && (!this.resourceIdentifier.isEmpty())); }
public void unsetResourceIdentifier() { this.resourceIdentifier = null; }
public boolean isSetTemporalOperator() { return ((this.temporalOperator != null) && (!this.temporalOperator.isEmpty())); }
public void unsetTemporalOperator() { this.temporalOperator = null; }
public boolean isSetMetadata() { return (this.metadata != null); }
public boolean isSetType() { return (this.type != null); }
public boolean isSetName() { return (this.name != null); }
public boolean isSetValueReference() { return (this.valueReference != null); }
public boolean isSetSortOrder() { return (this.sortOrder != null); }
public boolean isSetExpression() { return (this.expression != null); }
public boolean isSetRid() { return (this.rid != null); }
public boolean isSetPreviousRid() { return (this.previousRid != null); }
public boolean isSetVersion() { return (this.version != null); }
public boolean isSetStartDate() { return (this.startDate != null); }
public boolean isSetEndDate() { return (this.endDate != null); }
public boolean isSetConformance() { return (this.conformance != null); }
public boolean isSetId_Capabilities() { return (this.id_Capabilities != null); }
public boolean isSetScalar_Capabilities() { return (this.scalar_Capabilities != null); }
public boolean isSetSpatial_Capabilities() { return (this.spatial_Capabilities != null); }
public boolean isSetTemporal_Capabilities() { return (this.temporal_Capabilities != null); }
public boolean isSetFunctions() { return (this.functions != null); }
public boolean isSetExtended_Capabilities() { return (this.extended_Capabilities != null); }
public boolean isSetArgument() { return ((this.argument != null) && (!this.argument.isEmpty())); }
public void unsetArgument() { this.argument = null; }
public boolean isSetLogicalOperators() { return (this.logicalOperators != null); }
public boolean isSetComparisonOperators() { return (this.comparisonOperators != null); }
public static SortOrderType fromValue(String v) { return valueOf(v); }
public boolean isSetReturns() { return (this.returns != null); }
public boolean isSetArguments() { return (this.arguments != null); }
public boolean isSetTemporalOperands() { return (this.temporalOperands != null); }
public boolean isSetTemporalOperators() { return (this.temporalOperators != null); }
public boolean isSetGeometryOperands() { return (this.geometryOperands != null); }
public boolean isSetSpatialOperators() { return (this.spatialOperators != null); }
public boolean isSetComparisonOpsOrSpatialOpsOrTemporalOps() { return ((this.comparisonOpsOrSpatialOpsOrTemporalOps != null) && (!this.comparisonOpsOrSpatialOpsOrTemporalOps.isEmpty())); }
public void unsetComparisonOpsOrSpatialOpsOrTemporalOps() { this.comparisonOpsOrSpatialOpsOrTemporalOps = null; }
public boolean isSetExpressionOrAny() { return ((this.expressionOrAny != null) && (!this.expressionOrAny.isEmpty())); }
public void unsetExpressionOrAny() { this.expressionOrAny = null; }
public static VersionActionTokens fromValue(String v) { return valueOf(v); }
public boolean isSetGeometryOperand() { return ((this.geometryOperand != null) && (!this.geometryOperand.isEmpty())); }
public void unsetGeometryOperand() { this.geometryOperand = null; }
public boolean isSetUom() { return (this.uom != null); }
public boolean isSetComparisonOperator() { return ((this.comparisonOperator != null) && (!this.comparisonOperator.isEmpty())); }
public void unsetComparisonOperator() { this.comparisonOperator = null; }
public boolean isSetExpression() { return ((this.expression != null) && (!this.expression.isEmpty())); }
public void unsetExpression() { this.expression = null; }
public boolean isMatchCase() { if (matchCase == null) { return true; } else { return matchCase; } }
public boolean isSetMatchCase() { return (this.matchCase != null); }
public void unsetMatchCase() { this.matchCase = null; }
public boolean isSetMatchAction() { return (this.matchAction != null); }
public static MatchActionType fromValue(String v) { for (MatchActionType c : MatchActionType.values()) { if (c.value.equals(v)) { return c; } } throw new IllegalArgumentException(v); }
public boolean isSetLowerBoundary() { return (this.lowerBoundary != null); }
public boolean isSetUpperBoundary() { return (this.upperBoundary != null); }
public boolean isSetConstraint() { return ((this.constraint != null) && (!this.constraint.isEmpty())); }
public void unsetConstraint() { this.constraint = null; }
public boolean isSetAdditionalOperators() { return (this.additionalOperators != null); }
public boolean isSetSpatialOperator() { return ((this.spatialOperator != null) && (!this.spatialOperator.isEmpty())); }
public void unsetSpatialOperator() { this.spatialOperator = null; }
public boolean isSetFunction() { return ((this.function != null) && (!this.function.isEmpty())); }
public void unsetFunction() { this.function = null; }
public TemporalOperandsType createTemporalOperandsType() { return new TemporalOperandsType(); }
public GeometryOperandsType createGeometryOperandsType() { return new GeometryOperandsType(); }
public FunctionType createFunctionType() { return new FunctionType(); }
public LiteralType createLiteralType() { return new LiteralType(); }
public Filter_Capabilities createFilter_Capabilities() { return new Filter_Capabilities(); }
public ConformanceType createConformanceType() { return new ConformanceType(); }
public Id_CapabilitiesType createId_CapabilitiesType() { return new Id_CapabilitiesType(); }
public Scalar_CapabilitiesType createScalar_CapabilitiesType() { return new Scalar_CapabilitiesType(); }
public Spatial_CapabilitiesType createSpatial_CapabilitiesType() { return new Spatial_CapabilitiesType(); }
public Temporal_CapabilitiesType createTemporal_CapabilitiesType() { return new Temporal_CapabilitiesType(); }
public AvailableFunctionsType createAvailableFunctionsType() { return new AvailableFunctionsType(); }
public Extended_CapabilitiesType createExtended_CapabilitiesType() { return new Extended_CapabilitiesType(); }
public LogicalOperators createLogicalOperators() { return new LogicalOperators(); }
public FilterType createFilterType() { return new FilterType(); }
public BinaryComparisonOpType createBinaryComparisonOpType() { return new BinaryComparisonOpType(); }
public PropertyIsLikeType createPropertyIsLikeType() { return new PropertyIsLikeType(); }
public PropertyIsNullType createPropertyIsNullType() { return new PropertyIsNullType(); }
public PropertyIsNilType createPropertyIsNilType() { return new PropertyIsNilType(); }
public PropertyIsBetweenType createPropertyIsBetweenType() { return new PropertyIsBetweenType(); }
public BinarySpatialOpType createBinarySpatialOpType() { return new BinarySpatialOpType(); }
public DistanceBufferType createDistanceBufferType() { return new DistanceBufferType(); }
public BBOXType createBBOXType() { return new BBOXType(); }
public BinaryTemporalOpType createBinaryTemporalOpType() { return new BinaryTemporalOpType(); }
public BinaryLogicOpType createBinaryLogicOpType() { return new BinaryLogicOpType(); }
public UnaryLogicOpType createUnaryLogicOpType() { return new UnaryLogicOpType(); }
public ResourceIdType createResourceIdType() { return new ResourceIdType(); }
public SortByType createSortByType() { return new SortByType(); }
public ResourceIdentifierType createResourceIdentifierType() { return new ResourceIdentifierType(); }
public ComparisonOperatorsType createComparisonOperatorsType() { return new ComparisonOperatorsType(); }
public ComparisonOperatorType createComparisonOperatorType() { return new ComparisonOperatorType(); }
public AvailableFunctionType createAvailableFunctionType() { return new AvailableFunctionType(); }
public ArgumentsType createArgumentsType() { return new ArgumentsType(); }
public ArgumentType createArgumentType() { return new ArgumentType(); }
public SpatialOperatorsType createSpatialOperatorsType() { return new SpatialOperatorsType(); }
public SpatialOperatorType createSpatialOperatorType() { return new SpatialOperatorType(); }
public TemporalOperatorsType createTemporalOperatorsType() { return new TemporalOperatorsType(); }
public TemporalOperatorType createTemporalOperatorType() { return new TemporalOperatorType(); }
public AdditionalOperatorsType createAdditionalOperatorsType() { return new AdditionalOperatorsType(); }
public ExtensionOperatorType createExtensionOperatorType() { return new ExtensionOperatorType(); }
public LowerBoundaryType createLowerBoundaryType() { return new LowerBoundaryType(); }
public UpperBoundaryType createUpperBoundaryType() { return new UpperBoundaryType(); }
public MeasureType createMeasureType() { return new MeasureType(); }
public SortPropertyType createSortPropertyType() { return new SortPropertyType(); }
public TemporalOperandsType.TemporalOperand createTemporalOperandsTypeTemporalOperand() { return new TemporalOperandsType.TemporalOperand(); }
public GeometryOperandsType.GeometryOperand createGeometryOperandsTypeGeometryOperand() { return new GeometryOperandsType.GeometryOperand(); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "AbstractAdhocQueryExpression", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "AbstractQueryExpression") public JAXBElement<AbstractAdhocQueryExpressionType> createAbstractAdhocQueryExpression( AbstractAdhocQueryExpressionType value) { return new JAXBElement<AbstractAdhocQueryExpressionType>( _AbstractAdhocQueryExpression_QNAME, AbstractAdhocQueryExpressionType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "AbstractQueryExpression") public JAXBElement<AbstractQueryExpressionType> createAbstractQueryExpression( AbstractQueryExpressionType value) { return new JAXBElement<AbstractQueryExpressionType>( _AbstractQueryExpression_QNAME, AbstractQueryExpressionType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "AbstractProjectionClause") public JAXBElement<Object> createAbstractProjectionClause(Object value) { return new JAXBElement<Object>(_AbstractProjectionClause_QNAME, Object.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "AbstractSelectionClause") public JAXBElement<Object> createAbstractSelectionClause(Object value) { return new JAXBElement<Object>(_AbstractSelectionClause_QNAME, Object.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "AbstractSortingClause") public JAXBElement<Object> createAbstractSortingClause(Object value) { return new JAXBElement<Object>(_AbstractSortingClause_QNAME, Object.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "expression") public JAXBElement<Object> createExpression(Object value) { return new JAXBElement<Object>(_Expression_QNAME, Object.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "ValueReference", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "expression") public JAXBElement<String> createValueReference(String value) { return new JAXBElement<String>(_ValueReference_QNAME, String.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Function", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "expression") public JAXBElement<FunctionType> createFunction(FunctionType value) { return new JAXBElement<FunctionType>(_Function_QNAME, FunctionType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Literal", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "expression") public JAXBElement<LiteralType> createLiteral(LiteralType value) { return new JAXBElement<LiteralType>(_Literal_QNAME, LiteralType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Filter", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "AbstractSelectionClause") public JAXBElement<FilterType> createFilter(FilterType value) { return new JAXBElement<FilterType>(_Filter_QNAME, FilterType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "comparisonOps") public JAXBElement<ComparisonOpsType> createComparisonOps(ComparisonOpsType value) { return new JAXBElement<ComparisonOpsType>( _ComparisonOps_QNAME, ComparisonOpsType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "PropertyIsEqualTo", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "comparisonOps") public JAXBElement<BinaryComparisonOpType> createPropertyIsEqualTo(BinaryComparisonOpType value) { return new JAXBElement<BinaryComparisonOpType>( _PropertyIsEqualTo_QNAME, BinaryComparisonOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "PropertyIsNotEqualTo", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "comparisonOps") public JAXBElement<BinaryComparisonOpType> createPropertyIsNotEqualTo( BinaryComparisonOpType value) { return new JAXBElement<BinaryComparisonOpType>( _PropertyIsNotEqualTo_QNAME, BinaryComparisonOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "PropertyIsLessThan", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "comparisonOps") public JAXBElement<BinaryComparisonOpType> createPropertyIsLessThan( BinaryComparisonOpType value) { return new JAXBElement<BinaryComparisonOpType>( _PropertyIsLessThan_QNAME, BinaryComparisonOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "PropertyIsGreaterThan", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "comparisonOps") public JAXBElement<BinaryComparisonOpType> createPropertyIsGreaterThan( BinaryComparisonOpType value) { return new JAXBElement<BinaryComparisonOpType>( _PropertyIsGreaterThan_QNAME, BinaryComparisonOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "PropertyIsLessThanOrEqualTo", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "comparisonOps") public JAXBElement<BinaryComparisonOpType> createPropertyIsLessThanOrEqualTo( BinaryComparisonOpType value) { return new JAXBElement<BinaryComparisonOpType>( _PropertyIsLessThanOrEqualTo_QNAME, BinaryComparisonOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "PropertyIsGreaterThanOrEqualTo", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "comparisonOps") public JAXBElement<BinaryComparisonOpType> createPropertyIsGreaterThanOrEqualTo( BinaryComparisonOpType value) { return new JAXBElement<BinaryComparisonOpType>( _PropertyIsGreaterThanOrEqualTo_QNAME, BinaryComparisonOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "PropertyIsLike", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "comparisonOps") public JAXBElement<PropertyIsLikeType> createPropertyIsLike(PropertyIsLikeType value) { return new JAXBElement<PropertyIsLikeType>( _PropertyIsLike_QNAME, PropertyIsLikeType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "PropertyIsNull", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "comparisonOps") public JAXBElement<PropertyIsNullType> createPropertyIsNull(PropertyIsNullType value) { return new JAXBElement<PropertyIsNullType>( _PropertyIsNull_QNAME, PropertyIsNullType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "PropertyIsNil", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "comparisonOps") public JAXBElement<PropertyIsNilType> createPropertyIsNil(PropertyIsNilType value) { return new JAXBElement<PropertyIsNilType>( _PropertyIsNil_QNAME, PropertyIsNilType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "PropertyIsBetween", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "comparisonOps") public JAXBElement<PropertyIsBetweenType> createPropertyIsBetween(PropertyIsBetweenType value) { return new JAXBElement<PropertyIsBetweenType>( _PropertyIsBetween_QNAME, PropertyIsBetweenType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "spatialOps") public JAXBElement<SpatialOpsType> createSpatialOps(SpatialOpsType value) { return new JAXBElement<SpatialOpsType>(_SpatialOps_QNAME, SpatialOpsType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Equals", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<BinarySpatialOpType> createEquals(BinarySpatialOpType value) { return new JAXBElement<BinarySpatialOpType>( _Equals_QNAME, BinarySpatialOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Disjoint", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<BinarySpatialOpType> createDisjoint(BinarySpatialOpType value) { return new JAXBElement<BinarySpatialOpType>( _Disjoint_QNAME, BinarySpatialOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Touches", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<BinarySpatialOpType> createTouches(BinarySpatialOpType value) { return new JAXBElement<BinarySpatialOpType>( _Touches_QNAME, BinarySpatialOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Within", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<BinarySpatialOpType> createWithin(BinarySpatialOpType value) { return new JAXBElement<BinarySpatialOpType>( _Within_QNAME, BinarySpatialOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Overlaps", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<BinarySpatialOpType> createOverlaps(BinarySpatialOpType value) { return new JAXBElement<BinarySpatialOpType>( _Overlaps_QNAME, BinarySpatialOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Crosses", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<BinarySpatialOpType> createCrosses(BinarySpatialOpType value) { return new JAXBElement<BinarySpatialOpType>( _Crosses_QNAME, BinarySpatialOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Intersects", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<BinarySpatialOpType> createIntersects(BinarySpatialOpType value) { return new JAXBElement<BinarySpatialOpType>( _Intersects_QNAME, BinarySpatialOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Contains", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<BinarySpatialOpType> createContains(BinarySpatialOpType value) { return new JAXBElement<BinarySpatialOpType>( _Contains_QNAME, BinarySpatialOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "DWithin", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<DistanceBufferType> createDWithin(DistanceBufferType value) { return new JAXBElement<DistanceBufferType>( _DWithin_QNAME, DistanceBufferType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Beyond", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<DistanceBufferType> createBeyond(DistanceBufferType value) { return new JAXBElement<DistanceBufferType>( _Beyond_QNAME, DistanceBufferType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "BBOX", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "spatialOps") public JAXBElement<BBOXType> createBBOX(BBOXType value) { return new JAXBElement<BBOXType>(_BBOX_QNAME, BBOXType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "temporalOps") public JAXBElement<TemporalOpsType> createTemporalOps(TemporalOpsType value) { return new JAXBElement<TemporalOpsType>(_TemporalOps_QNAME, TemporalOpsType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "After", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createAfter(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _After_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Before", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createBefore(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _Before_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Begins", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createBegins(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _Begins_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "BegunBy", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createBegunBy(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _BegunBy_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "TContains", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createTContains(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _TContains_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "During", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createDuring(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _During_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "EndedBy", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createEndedBy(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _EndedBy_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Ends", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createEnds(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _Ends_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "TEquals", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createTEquals(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _TEquals_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Meets", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createMeets(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _Meets_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "MetBy", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createMetBy(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _MetBy_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "TOverlaps", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createTOverlaps(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _TOverlaps_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "OverlappedBy", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createOverlappedBy(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _OverlappedBy_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "AnyInteracts", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "temporalOps") public JAXBElement<BinaryTemporalOpType> createAnyInteracts(BinaryTemporalOpType value) { return new JAXBElement<BinaryTemporalOpType>( _AnyInteracts_QNAME, BinaryTemporalOpType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "logicOps") public JAXBElement<LogicOpsType> createLogicOps(LogicOpsType value) { return new JAXBElement<LogicOpsType>(_LogicOps_QNAME, LogicOpsType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "And", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "logicOps") public JAXBElement<BinaryLogicOpType> createAnd(BinaryLogicOpType value) { return new JAXBElement<BinaryLogicOpType>(_And_QNAME, BinaryLogicOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Or", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "logicOps") public JAXBElement<BinaryLogicOpType> createOr(BinaryLogicOpType value) { return new JAXBElement<BinaryLogicOpType>(_Or_QNAME, BinaryLogicOpType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "Not", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "logicOps") public JAXBElement<UnaryLogicOpType> createNot(UnaryLogicOpType value) { return new JAXBElement<UnaryLogicOpType>(_Not_QNAME, UnaryLogicOpType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "extensionOps") public JAXBElement<ExtensionOpsType> createExtensionOps(ExtensionOpsType value) { return new JAXBElement<ExtensionOpsType>( _ExtensionOps_QNAME, ExtensionOpsType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/fes/2.0", name = "_Id") public JAXBElement<AbstractIdType> create_Id(AbstractIdType value) { return new JAXBElement<AbstractIdType>(__Id_QNAME, AbstractIdType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "ResourceId", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "_Id") public JAXBElement<ResourceIdType> createResourceId(ResourceIdType value) { return new JAXBElement<ResourceIdType>(_ResourceId_QNAME, ResourceIdType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/fes/2.0", name = "SortBy", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "AbstractSortingClause") public JAXBElement<SortByType> createSortBy(SortByType value) { return new JAXBElement<SortByType>(_SortBy_QNAME, SortByType.class, null, value); }
public boolean isSetComparisonOps() { return (this.comparisonOps != null); }
public boolean isSetSpatialOps() { return (this.spatialOps != null); }
public boolean isSetTemporalOps() { return (this.temporalOps != null); }
public boolean isSetLogicOps() { return (this.logicOps != null); }
public boolean isSetExtensionOps() { return (this.extensionOps != null); }
public boolean isSetFunction() { return (this.function != null); }
public List<JAXBElement<? extends AbstractIdType>> get_Id() { if (_Id == null) { _Id = new ArrayList<JAXBElement<? extends AbstractIdType>>(); } return this._Id; }
public boolean isSet_Id() { return ((this._Id != null) && (!this._Id.isEmpty())); }
public void set_Id(List<JAXBElement<? extends AbstractIdType>> value) { this._Id = value; }
public boolean isSetOperator() { return ((this.operator != null) && (!this.operator.isEmpty())); }
public void unsetOperator() { this.operator = null; }
public boolean isSetSortProperty() { return ((this.sortProperty != null) && (!this.sortProperty.isEmpty())); }
public void unsetSortProperty() { this.sortProperty = null; }
public boolean isSetContent() { return ((this.content != null) && (!this.content.isEmpty())); }
public boolean isSetNilReason() { return (this.nilReason != null); }
public boolean isSetHandle() { return (this.handle != null); }
public boolean isSetAbstractProjectionClause() { return ((this.abstractProjectionClause != null) && (!this.abstractProjectionClause.isEmpty())); }
public void unsetAbstractProjectionClause() { this.abstractProjectionClause = null; }
public boolean isSetAbstractSelectionClause() { return (this.abstractSelectionClause != null); }
public boolean isSetAbstractSortingClause() { return (this.abstractSortingClause != null); }
public boolean isSetTypeNames() { return ((this.typeNames != null) && (!this.typeNames.isEmpty())); }
public void unsetTypeNames() { this.typeNames = null; }
public boolean isSetAliases() { return ((this.aliases != null) && (!this.aliases.isEmpty())); }
public boolean isSetWildCard() { return (this.wildCard != null); }
public boolean isSetSingleChar() { return (this.singleChar != null); }
public boolean isSetEscapeChar() { return (this.escapeChar != null); }
public boolean isSetTemporalOperand() { return ((this.temporalOperand != null) && (!this.temporalOperand.isEmpty())); }
public void unsetTemporalOperand() { this.temporalOperand = null; }
public boolean isSetDistance() { return (this.distance != null); }
public boolean isSetReturnFeatureTypes() { return ((this.returnFeatureTypes != null) && (!this.returnFeatureTypes.isEmpty())); }
public void unsetReturnFeatureTypes() { this.returnFeatureTypes = null; }
public boolean isSetLanguage() { return (this.language != null); }
public boolean isIsPrivate() { if (isPrivate == null) { return false; } else { return isPrivate; } }
public boolean isSetIsPrivate() { return (this.isPrivate != null); }
public void unsetIsPrivate() { this.isPrivate = null; }
public static UpdateActionType fromValue(String v) { for (UpdateActionType c : UpdateActionType.values()) { if (c.value.equals(v)) { return c; } } throw new IllegalArgumentException(v); }
public boolean isSetWSDL() { return (this.wsdl != null); }
public boolean isSetFeatureTypeList() { return (this.featureTypeList != null); }
public boolean isSetFilter_Capabilities() { return (this.filter_Capabilities != null); }
public boolean isSetHref() { return (this.href != null); }
public boolean isSetRole() { return (this.role != null); }
public boolean isSetArcrole() { return (this.arcrole != null); }
public boolean isSetTitle() { return (this.title != null); }
public boolean isSetShow() { return (this.show != null); }
public boolean isSetActuate() { return (this.actuate != null); }
public boolean isSetFeatureType() { return ((this.featureType != null) && (!this.featureType.isEmpty())); }
public void unsetFeatureType() { this.featureType = null; }
public boolean isSetAny() { return ((this.any != null) && (!this.any.isEmpty())); }
public boolean isSetInputFormat() { return (this.inputFormat != null); }
public boolean isSetSrsName() { return (this.srsName != null); }
public boolean isSetTotalInserted() { return (this.totalInserted != null); }
public boolean isSetTotalUpdated() { return (this.totalUpdated != null); }
public boolean isSetTotalReplaced() { return (this.totalReplaced != null); }
public boolean isSetTotalDeleted() { return (this.totalDeleted != null); }
public boolean isSetResourceId() { return ((this.resourceId != null) && (!this.resourceId.isEmpty())); }
public void unsetResourceId() { this.resourceId = null; }
public boolean isSetParameter() { return ((this.parameter != null) && (!this.parameter.isEmpty())); }
public void unsetParameter() { this.parameter = null; }
public boolean isSetId() { return (this.id != null); }
public boolean isSetMember() { return ((this.member != null) && (!this.member.isEmpty())); }
public boolean isSetExceptionReport() { return (this.exceptionReport != null); }
public boolean isSetTitle() { return ((this.title != null) && (!this.title.isEmpty())); }
public boolean isSetAbstract() { return ((this._abstract != null) && (!this._abstract.isEmpty())); }
public void unsetAbstract() { this._abstract = null; }
public boolean isSetMetadata() { return ((this.metadata != null) && (!this.metadata.isEmpty())); }
public void unsetMetadata() { this.metadata = null; }
public boolean isSetStoredQuery() { return ((this.storedQuery != null) && (!this.storedQuery.isEmpty())); }
public void unsetStoredQuery() { this.storedQuery = null; }
public boolean isSetAdditionalObjects() { return (this.additionalObjects != null); }
public boolean isSetTruncatedResponse() { return (this.truncatedResponse != null); }
public boolean isSetLockId() { return (this.lockId != null); }
public boolean isSetTimeStamp() { return (this.timeStamp != null); }
public boolean isSetNumberMatched() { return (this.numberMatched != null); }
public boolean isSetNumberReturned() { return (this.numberReturned != null); }
public boolean isSetNext() { return (this.next != null); }
public boolean isSetPrevious() { return (this.previous != null); }
public boolean isSetValueList() { return (this.valueList != null); }
public boolean isSetAny() { return (this.any != null); }
public boolean isSetFilter() { return (this.filter != null); }
public boolean isSetAbstractQueryExpression() { return (this.abstractQueryExpression != null); }
public boolean isSetResolvePath() { return (this.resolvePath != null); }
public boolean isSetStartIndex() { return (this.startIndex != null); }
public boolean isSetCount() { return (this.count != null); }
public boolean isSetResultType() { return (this.resultType != null); }
public boolean isSetOutputFormat() { return (this.outputFormat != null); }
public boolean isSetResolve() { return (this.resolve != null); }
public boolean isSetResolveDepth() { return (this.resolveDepth != null); }
public boolean isSetResolveTimeout() { return (this.resolveTimeout != null); }
public boolean isSetTypeName() { return (this.typeName != null); }
public boolean isSetStoredQueryDescription() { return ((this.storedQueryDescription != null) && (!this.storedQueryDescription.isEmpty())); }
public void unsetStoredQueryDescription() { this.storedQueryDescription = null; }
public boolean isSetService() { return (this.service != null); }
public boolean isSetValue() { return (this.value != null); }
public boolean isSetLang() { return (this.lang != null); }
public boolean isSetTransactionSummary() { return (this.transactionSummary != null); }
public boolean isSetInsertResults() { return (this.insertResults != null); }
public boolean isSetUpdateResults() { return (this.updateResults != null); }
public boolean isSetReplaceResults() { return (this.replaceResults != null); }
public boolean isSetValue() { return ((this.value != null) && (!this.value.isEmpty())); }
public boolean isSetTypeName() { return ((this.typeName != null) && (!this.typeName.isEmpty())); }
public void unsetTypeName() { this.typeName = null; }
public boolean isSetAbstractQueryExpression() { return ((this.abstractQueryExpression != null) && (!this.abstractQueryExpression.isEmpty())); }
public void unsetAbstractQueryExpression() { this.abstractQueryExpression = null; }
public boolean isSetExpiry() { return (this.expiry != null); }
public boolean isSetLockAction() { return (this.lockAction != null); }
public void setAbstractQueryExpression( List<JAXBElement<? extends AbstractQueryExpressionType>> value) { this.abstractQueryExpression = value; }
public boolean isSetIdentifier() { return (this.identifier != null); }
public boolean isSetState() { return (this.state != null); }
public boolean isSetStoredQueryDefinition() { return ((this.storedQueryDefinition != null) && (!this.storedQueryDefinition.isEmpty())); }
public void unsetStoredQueryDefinition() { this.storedQueryDefinition = null; }
public boolean isSetStoredQueryId() { return ((this.storedQueryId != null) && (!this.storedQueryId.isEmpty())); }
public void unsetStoredQueryId() { this.storedQueryId = null; }
public boolean isSetValueCollection() { return (this.valueCollection != null); }
public boolean isSetSimpleFeatureCollection() { return (this.simpleFeatureCollection != null); }
public boolean isSetFeaturesLocked() { return (this.featuresLocked != null); }
public boolean isSetFeaturesNotLocked() { return (this.featuresNotLocked != null); }
public boolean isSetReturnFeatureType() { return ((this.returnFeatureType != null) && (!this.returnFeatureType.isEmpty())); }
public void unsetReturnFeatureType() { this.returnFeatureType = null; }
public FeatureTypeType createFeatureTypeType() { return new FeatureTypeType(); }
public PropertyType createPropertyType() { return new PropertyType(); }
public WFS_CapabilitiesType createWFS_CapabilitiesType() { return new WFS_CapabilitiesType(); }
public Abstract createAbstract() { return new Abstract(); }
public QueryType createQueryType() { return new QueryType(); }
public StoredQueryType createStoredQueryType() { return new StoredQueryType(); }
public GetCapabilitiesType createGetCapabilitiesType() { return new GetCapabilitiesType(); }
public FeatureTypeListType createFeatureTypeListType() { return new FeatureTypeListType(); }
public ElementType createElementType() { return new ElementType(); }
public ValueListType createValueListType() { return new ValueListType(); }
public DescribeFeatureTypeType createDescribeFeatureTypeType() { return new DescribeFeatureTypeType(); }
public GetPropertyValueType createGetPropertyValueType() { return new GetPropertyValueType(); }
public ValueCollectionType createValueCollectionType() { return new ValueCollectionType(); }
public MemberPropertyType createMemberPropertyType() { return new MemberPropertyType(); }
public TupleType createTupleType() { return new TupleType(); }
public AdditionalValues createAdditionalValues() { return new AdditionalValues(); }
public SimpleFeatureCollectionType createSimpleFeatureCollectionType() { return new SimpleFeatureCollectionType(); }
public TruncatedResponse createTruncatedResponse() { return new TruncatedResponse(); }
public GetFeatureType createGetFeatureType() { return new GetFeatureType(); }
public GetFeatureWithLockType createGetFeatureWithLockType() { return new GetFeatureWithLockType(); }
public PropertyName createPropertyName() { return new PropertyName(); }
public FeatureCollectionType createFeatureCollectionType() { return new FeatureCollectionType(); }
public AdditionalObjects createAdditionalObjects() { return new AdditionalObjects(); }
public EnvelopePropertyType createEnvelopePropertyType() { return new EnvelopePropertyType(); }
public ListStoredQueriesType createListStoredQueriesType() { return new ListStoredQueriesType(); }
public ListStoredQueriesResponseType createListStoredQueriesResponseType() { return new ListStoredQueriesResponseType(); }
public DescribeStoredQueriesType createDescribeStoredQueriesType() { return new DescribeStoredQueriesType(); }
public DescribeStoredQueriesResponseType createDescribeStoredQueriesResponseType() { return new DescribeStoredQueriesResponseType(); }
public CreateStoredQueryType createCreateStoredQueryType() { return new CreateStoredQueryType(); }
public CreateStoredQueryResponseType createCreateStoredQueryResponseType() { return new CreateStoredQueryResponseType(); }
public DropStoredQueryType createDropStoredQueryType() { return new DropStoredQueryType(); }
public ExecutionStatusType createExecutionStatusType() { return new ExecutionStatusType(); }
public LockFeatureType createLockFeatureType() { return new LockFeatureType(); }
public LockFeatureResponseType createLockFeatureResponseType() { return new LockFeatureResponseType(); }
public TransactionType createTransactionType() { return new TransactionType(); }
public InsertType createInsertType() { return new InsertType(); }
public UpdateType createUpdateType() { return new UpdateType(); }
public ReplaceType createReplaceType() { return new ReplaceType(); }
public DeleteType createDeleteType() { return new DeleteType(); }
public NativeType createNativeType() { return new NativeType(); }
public TransactionResponseType createTransactionResponseType() { return new TransactionResponseType(); }
public ParameterType createParameterType() { return new ParameterType(); }
public OutputFormatListType createOutputFormatListType() { return new OutputFormatListType(); }
public MetadataURLType createMetadataURLType() { return new MetadataURLType(); }
public ExtendedDescriptionType createExtendedDescriptionType() { return new ExtendedDescriptionType(); }
public StoredQueryListItemType createStoredQueryListItemType() { return new StoredQueryListItemType(); }
public StoredQueryDescriptionType createStoredQueryDescriptionType() { return new StoredQueryDescriptionType(); }
public ParameterExpressionType createParameterExpressionType() { return new ParameterExpressionType(); }
public QueryExpressionTextType createQueryExpressionTextType() { return new QueryExpressionTextType(); }
public FeaturesLockedType createFeaturesLockedType() { return new FeaturesLockedType(); }
public FeaturesNotLockedType createFeaturesNotLockedType() { return new FeaturesNotLockedType(); }
public TransactionSummaryType createTransactionSummaryType() { return new TransactionSummaryType(); }
public ActionResultsType createActionResultsType() { return new ActionResultsType(); }
public CreatedOrModifiedFeatureType createCreatedOrModifiedFeatureType() { return new CreatedOrModifiedFeatureType(); }
public EmptyType createEmptyType() { return new EmptyType(); }
public FeatureTypeType.NoCRS createFeatureTypeTypeNoCRS() { return new FeatureTypeType.NoCRS(); }
public PropertyType.ValueReference createPropertyTypeValueReference() { return new PropertyType.ValueReference(); }
public WFS_CapabilitiesType.WSDL createWFS_CapabilitiesTypeWSDL() { return new WFS_CapabilitiesType.WSDL(); }
@XmlElementDecl( namespace = "http://www.opengis.net/wfs/2.0", name = "Query", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "AbstractAdhocQueryExpression") public JAXBElement<QueryType> createQuery(QueryType value) { return new JAXBElement<QueryType>(_Query_QNAME, QueryType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/wfs/2.0", name = "StoredQuery", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "AbstractQueryExpression") public JAXBElement<StoredQueryType> createStoredQuery(StoredQueryType value) { return new JAXBElement<StoredQueryType>(_StoredQuery_QNAME, StoredQueryType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "GetCapabilities") public JAXBElement<GetCapabilitiesType> createGetCapabilities(GetCapabilitiesType value) { return new JAXBElement<GetCapabilitiesType>( _GetCapabilities_QNAME, GetCapabilitiesType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "WFS_Capabilities") public JAXBElement<WFS_CapabilitiesType> createWFS_Capabilities(WFS_CapabilitiesType value) { return new JAXBElement<WFS_CapabilitiesType>( _WFS_Capabilities_QNAME, WFS_CapabilitiesType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "FeatureTypeList") public JAXBElement<FeatureTypeListType> createFeatureTypeList(FeatureTypeListType value) { return new JAXBElement<FeatureTypeListType>( _FeatureTypeList_QNAME, FeatureTypeListType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "Element") public JAXBElement<ElementType> createElement(ElementType value) { return new JAXBElement<ElementType>(_Element_QNAME, ElementType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "ValueList") public JAXBElement<ValueListType> createValueList(ValueListType value) { return new JAXBElement<ValueListType>(_ValueList_QNAME, ValueListType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "Value") public JAXBElement<Object> createValue(Object value) { return new JAXBElement<Object>(_Value_QNAME, Object.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "DescribeFeatureType") public JAXBElement<DescribeFeatureTypeType> createDescribeFeatureType( DescribeFeatureTypeType value) { return new JAXBElement<DescribeFeatureTypeType>( _DescribeFeatureType_QNAME, DescribeFeatureTypeType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "GetPropertyValue") public JAXBElement<GetPropertyValueType> createGetPropertyValue(GetPropertyValueType value) { return new JAXBElement<GetPropertyValueType>( _GetPropertyValue_QNAME, GetPropertyValueType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "ValueCollection") public JAXBElement<ValueCollectionType> createValueCollection(ValueCollectionType value) { return new JAXBElement<ValueCollectionType>( _ValueCollection_QNAME, ValueCollectionType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "member") public JAXBElement<MemberPropertyType> createMember(MemberPropertyType value) { return new JAXBElement<MemberPropertyType>( _Member_QNAME, MemberPropertyType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "Tuple") public JAXBElement<TupleType> createTuple(TupleType value) { return new JAXBElement<TupleType>(_Tuple_QNAME, TupleType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "SimpleFeatureCollection") public JAXBElement<SimpleFeatureCollectionType> createSimpleFeatureCollection( SimpleFeatureCollectionType value) { return new JAXBElement<SimpleFeatureCollectionType>( _SimpleFeatureCollection_QNAME, SimpleFeatureCollectionType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "GetFeature") public JAXBElement<GetFeatureType> createGetFeature(GetFeatureType value) { return new JAXBElement<GetFeatureType>(_GetFeature_QNAME, GetFeatureType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "GetFeatureWithLock") public JAXBElement<GetFeatureWithLockType> createGetFeatureWithLock( GetFeatureWithLockType value) { return new JAXBElement<GetFeatureWithLockType>( _GetFeatureWithLock_QNAME, GetFeatureWithLockType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/wfs/2.0", name = "PropertyName", substitutionHeadNamespace = "http://www.opengis.net/fes/2.0", substitutionHeadName = "AbstractProjectionClause") public JAXBElement<PropertyName> createPropertyName(PropertyName value) { return new JAXBElement<PropertyName>(_PropertyName_QNAME, PropertyName.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/wfs/2.0", name = "FeatureCollection", substitutionHeadNamespace = "http://www.opengis.net/wfs/2.0", substitutionHeadName = "SimpleFeatureCollection") public JAXBElement<FeatureCollectionType> createFeatureCollection(FeatureCollectionType value) { return new JAXBElement<FeatureCollectionType>( _FeatureCollection_QNAME, FeatureCollectionType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "boundedBy") public JAXBElement<EnvelopePropertyType> createBoundedBy(EnvelopePropertyType value) { return new JAXBElement<EnvelopePropertyType>( _BoundedBy_QNAME, EnvelopePropertyType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "ListStoredQueries") public JAXBElement<ListStoredQueriesType> createListStoredQueries(ListStoredQueriesType value) { return new JAXBElement<ListStoredQueriesType>( _ListStoredQueries_QNAME, ListStoredQueriesType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "ListStoredQueriesResponse") public JAXBElement<ListStoredQueriesResponseType> createListStoredQueriesResponse( ListStoredQueriesResponseType value) { return new JAXBElement<ListStoredQueriesResponseType>( _ListStoredQueriesResponse_QNAME, ListStoredQueriesResponseType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "DescribeStoredQueries") public JAXBElement<DescribeStoredQueriesType> createDescribeStoredQueries( DescribeStoredQueriesType value) { return new JAXBElement<DescribeStoredQueriesType>( _DescribeStoredQueries_QNAME, DescribeStoredQueriesType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/wfs/2.0", name = "DescribeStoredQueriesResponse") public JAXBElement<DescribeStoredQueriesResponseType> createDescribeStoredQueriesResponse( DescribeStoredQueriesResponseType value) { return new JAXBElement<DescribeStoredQueriesResponseType>( _DescribeStoredQueriesResponse_QNAME, DescribeStoredQueriesResponseType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "CreateStoredQuery") public JAXBElement<CreateStoredQueryType> createCreateStoredQuery(CreateStoredQueryType value) { return new JAXBElement<CreateStoredQueryType>( _CreateStoredQuery_QNAME, CreateStoredQueryType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "CreateStoredQueryResponse") public JAXBElement<CreateStoredQueryResponseType> createCreateStoredQueryResponse( CreateStoredQueryResponseType value) { return new JAXBElement<CreateStoredQueryResponseType>( _CreateStoredQueryResponse_QNAME, CreateStoredQueryResponseType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "DropStoredQuery") public JAXBElement<DropStoredQueryType> createDropStoredQuery(DropStoredQueryType value) { return new JAXBElement<DropStoredQueryType>( _DropStoredQuery_QNAME, DropStoredQueryType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "DropStoredQueryResponse") public JAXBElement<ExecutionStatusType> createDropStoredQueryResponse(ExecutionStatusType value) { return new JAXBElement<ExecutionStatusType>( _DropStoredQueryResponse_QNAME, ExecutionStatusType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "LockFeature") public JAXBElement<LockFeatureType> createLockFeature(LockFeatureType value) { return new JAXBElement<LockFeatureType>(_LockFeature_QNAME, LockFeatureType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "LockFeatureResponse") public JAXBElement<LockFeatureResponseType> createLockFeatureResponse( LockFeatureResponseType value) { return new JAXBElement<LockFeatureResponseType>( _LockFeatureResponse_QNAME, LockFeatureResponseType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "Transaction") public JAXBElement<TransactionType> createTransaction(TransactionType value) { return new JAXBElement<TransactionType>(_Transaction_QNAME, TransactionType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "AbstractTransactionAction") public JAXBElement<AbstractTransactionActionType> createAbstractTransactionAction( AbstractTransactionActionType value) { return new JAXBElement<AbstractTransactionActionType>( _AbstractTransactionAction_QNAME, AbstractTransactionActionType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/wfs/2.0", name = "Insert", substitutionHeadNamespace = "http://www.opengis.net/wfs/2.0", substitutionHeadName = "AbstractTransactionAction") public JAXBElement<InsertType> createInsert(InsertType value) { return new JAXBElement<InsertType>(_Insert_QNAME, InsertType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/wfs/2.0", name = "Update", substitutionHeadNamespace = "http://www.opengis.net/wfs/2.0", substitutionHeadName = "AbstractTransactionAction") public JAXBElement<UpdateType> createUpdate(UpdateType value) { return new JAXBElement<UpdateType>(_Update_QNAME, UpdateType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "Property") public JAXBElement<PropertyType> createProperty(PropertyType value) { return new JAXBElement<PropertyType>(_Property_QNAME, PropertyType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/wfs/2.0", name = "Replace", substitutionHeadNamespace = "http://www.opengis.net/wfs/2.0", substitutionHeadName = "AbstractTransactionAction") public JAXBElement<ReplaceType> createReplace(ReplaceType value) { return new JAXBElement<ReplaceType>(_Replace_QNAME, ReplaceType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/wfs/2.0", name = "Delete", substitutionHeadNamespace = "http://www.opengis.net/wfs/2.0", substitutionHeadName = "AbstractTransactionAction") public JAXBElement<DeleteType> createDelete(DeleteType value) { return new JAXBElement<DeleteType>(_Delete_QNAME, DeleteType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/wfs/2.0", name = "Native", substitutionHeadNamespace = "http://www.opengis.net/wfs/2.0", substitutionHeadName = "AbstractTransactionAction") public JAXBElement<NativeType> createNative(NativeType value) { return new JAXBElement<NativeType>(_Native_QNAME, NativeType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/wfs/2.0", name = "TransactionResponse") public JAXBElement<TransactionResponseType> createTransactionResponse( TransactionResponseType value) { return new JAXBElement<TransactionResponseType>( _TransactionResponse_QNAME, TransactionResponseType.class, null, value); }
public boolean isSetProperty() { return ((this.property != null) && (!this.property.isEmpty())); }
public void unsetProperty() { this.property = null; }
public static AllSomeType fromValue(String v) { return valueOf(v); }
public static StarStringType fromValue(String v) { for (StarStringType c : StarStringType.values()) { if (c.value.equals(v)) { return c; } } throw new IllegalArgumentException(v); }
public boolean isSetBoundedBy() { return (this.boundedBy != null); }
public static ResolveValueType fromValue(String v) { for (ResolveValueType c : ResolveValueType.values()) { if (c.value.equals(v)) { return c; } } throw new IllegalArgumentException(v); }
public boolean isSetStatus() { return (this.status != null); }
public static ResultTypeType fromValue(String v) { for (ResultTypeType c : ResultTypeType.values()) { if (c.value.equals(v)) { return c; } } throw new IllegalArgumentException(v); }
public boolean isSetFeature() { return ((this.feature != null) && (!this.feature.isEmpty())); }
public boolean isSetFormat() { return ((this.format != null) && (!this.format.isEmpty())); }
public boolean isSetAbout() { return (this.about != null); }
public boolean isSetAbstractTransactionAction() { return ((this.abstractTransactionAction != null) && (!this.abstractTransactionAction.isEmpty())); }
public void unsetAbstractTransactionAction() { this.abstractTransactionAction = null; }
public boolean isSetReleaseAction() { return (this.releaseAction != null); }
public boolean isSetAction() { return (this.action != null); }
public boolean isSetElement() { return ((this.element != null) && (!this.element.isEmpty())); }
public boolean isSetQueryExpressionText() { return ((this.queryExpressionText != null) && (!this.queryExpressionText.isEmpty())); }
public void unsetQueryExpressionText() { this.queryExpressionText = null; }
public boolean isSetVendorId() { return (this.vendorId != null); }
public boolean isSafeToIgnore() { return safeToIgnore; }
public boolean isSetKeywords() { return ((this.keywords != null) && (!this.keywords.isEmpty())); }
public void unsetKeywords() { this.keywords = null; }
public boolean isSetDefaultCRS() { return (this.defaultCRS != null); }
public boolean isSetOtherCRS() { return ((this.otherCRS != null) && (!this.otherCRS.isEmpty())); }
public void unsetOtherCRS() { this.otherCRS = null; }
public boolean isSetNoCRS() { return (this.noCRS != null); }
public boolean isSetOutputFormats() { return (this.outputFormats != null); }
public boolean isSetWGS84BoundingBox() { return ((this.wgs84BoundingBox != null) && (!this.wgs84BoundingBox.isEmpty())); }
public void unsetWGS84BoundingBox() { this.wgs84BoundingBox = null; }
public boolean isSetMetadataURL() { return ((this.metadataURL != null) && (!this.metadataURL.isEmpty())); }
public void unsetMetadataURL() { this.metadataURL = null; }
public boolean isSetExtendedDescription() { return (this.extendedDescription != null); }
public boolean isSetFeatureVersion() { return (this.featureVersion != null); }
public boolean isSetFeatureIdentifier() { return (this.featureIdentifier != null); }
public boolean isSetAdditionalValues() { return (this.additionalValues != null); }
public boolean isSetReference() { return (this.reference != null); }
public boolean isSetAbstractReferenceBase() { return ((this.abstractReferenceBase != null) && (!this.abstractReferenceBase.isEmpty())); }
public void unsetAbstractReferenceBase() { this.abstractReferenceBase = null; }
public void setAbstractReferenceBase( List<JAXBElement<? extends AbstractReferenceBaseType>> value) { this.abstractReferenceBase = value; }
public boolean isSetVoice() { return ((this.voice != null) && (!this.voice.isEmpty())); }
public boolean isSetFacsimile() { return ((this.facsimile != null) && (!this.facsimile.isEmpty())); }
public void unsetFacsimile() { this.facsimile = null; }
public boolean isSetIndividualName() { return (this.individualName != null); }
public boolean isSetPositionName() { return (this.positionName != null); }
public boolean isSetContactInfo() { return (this.contactInfo != null); }
public boolean isSetReferenceGroup() { return ((this.referenceGroup != null) && (!this.referenceGroup.isEmpty())); }
public void unsetReferenceGroup() { this.referenceGroup = null; }
public boolean isSetHTTP() { return (this.http != null); }
public boolean isSetServiceIdentification() { return (this.serviceIdentification != null); }
public boolean isSetServiceProvider() { return (this.serviceProvider != null); }
public boolean isSetOperationsMetadata() { return (this.operationsMetadata != null); }
public boolean isSetUpdateSequence() { return (this.updateSequence != null); }
public boolean isSetServiceType() { return (this.serviceType != null); }
public boolean isSetServiceTypeVersion() { return ((this.serviceTypeVersion != null) && (!this.serviceTypeVersion.isEmpty())); }
public void unsetServiceTypeVersion() { this.serviceTypeVersion = null; }
public boolean isSetProfile() { return ((this.profile != null) && (!this.profile.isEmpty())); }
public boolean isSetFees() { return (this.fees != null); }
public boolean isSetAccessConstraints() { return ((this.accessConstraints != null) && (!this.accessConstraints.isEmpty())); }
public void unsetAccessConstraints() { this.accessConstraints = null; }
public boolean isSetMinimumValue() { return (this.minimumValue != null); }
public boolean isSetMaximumValue() { return (this.maximumValue != null); }
public boolean isSetSpacing() { return (this.spacing != null); }
public boolean isSetRangeClosure() { return ((this.rangeClosure != null) && (!this.rangeClosure.isEmpty())); }
public void unsetRangeClosure() { this.rangeClosure = null; }
public boolean isSetDeliveryPoint() { return ((this.deliveryPoint != null) && (!this.deliveryPoint.isEmpty())); }
public void unsetDeliveryPoint() { this.deliveryPoint = null; }
public boolean isSetCity() { return (this.city != null); }
public boolean isSetAdministrativeArea() { return (this.administrativeArea != null); }
public boolean isSetPostalCode() { return (this.postalCode != null); }
public boolean isSetCountry() { return (this.country != null); }
public boolean isSetElectronicMailAddress() { return ((this.electronicMailAddress != null) && (!this.electronicMailAddress.isEmpty())); }
public void unsetElectronicMailAddress() { this.electronicMailAddress = null; }
public boolean isSetOutputFormat() { return ((this.outputFormat != null) && (!this.outputFormat.isEmpty())); }
public void unsetOutputFormat() { this.outputFormat = null; }
public boolean isSetBoundingBox() { return ((this.boundingBox != null) && (!this.boundingBox.isEmpty())); }
public void unsetBoundingBox() { this.boundingBox = null; }
public boolean isSetDatasetDescriptionSummary() { return ((this.datasetDescriptionSummary != null) && (!this.datasetDescriptionSummary.isEmpty())); }
public void unsetDatasetDescriptionSummary() { this.datasetDescriptionSummary = null; }
public boolean isSetAllowedValues() { return (this.allowedValues != null); }
public boolean isSetAnyValue() { return (this.anyValue != null); }
public boolean isSetNoValues() { return (this.noValues != null); }
public boolean isSetValuesReference() { return (this.valuesReference != null); }
public boolean isSetDefaultValue() { return (this.defaultValue != null); }
public boolean isSetMeaning() { return (this.meaning != null); }
public boolean isSetDataType() { return (this.dataType != null); }
public boolean isSetUOM() { return (this.uom != null); }
public boolean isSetReferenceSystem() { return (this.referenceSystem != null); }
public boolean isSetProviderName() { return (this.providerName != null); }
public boolean isSetProviderSite() { return (this.providerSite != null); }
public boolean isSetServiceContact() { return (this.serviceContact != null); }
public boolean isSetAcceptVersions() { return (this.acceptVersions != null); }
public boolean isSetSections() { return (this.sections != null); }
public boolean isSetAcceptFormats() { return (this.acceptFormats != null); }
public boolean isSetDCP() { return ((this.dcp != null) && (!this.dcp.isEmpty())); }
public boolean isSetKeyword() { return ((this.keyword != null) && (!this.keyword.isEmpty())); }
public boolean isSetCodeSpace() { return (this.codeSpace != null); }
public boolean isSetAbstractMetaData() { return (this.abstractMetaData != null); }
public boolean isSetValueOrRange() { return ((this.valueOrRange != null) && (!this.valueOrRange.isEmpty())); }
public void unsetValueOrRange() { this.valueOrRange = null; }
public boolean isSetOperation() { return ((this.operation != null) && (!this.operation.isEmpty())); }
public void unsetOperation() { this.operation = null; }
public boolean isSetExtendedCapabilities() { return (this.extendedCapabilities != null); }
public boolean isSetException() { return ((this.exception != null) && (!this.exception.isEmpty())); }
public void unsetException() { this.exception = null; }
public boolean isSetGetOrPost() { return ((this.getOrPost != null) && (!this.getOrPost.isEmpty())); }
public void unsetGetOrPost() { this.getOrPost = null; }
public boolean isSetOtherSource() { return ((this.otherSource != null) && (!this.otherSource.isEmpty())); }
public void unsetOtherSource() { this.otherSource = null; }
public boolean isSetRequestMessage() { return (this.requestMessage != null); }
public boolean isSetRequestMessageReference() { return (this.requestMessageReference != null); }
public boolean isSetAvailableCRS() { return ((this.availableCRS != null) && (!this.availableCRS.isEmpty())); }
public void unsetAvailableCRS() { this.availableCRS = null; }
public boolean isSetOrganisationName() { return (this.organisationName != null); }
public boolean isSetSection() { return ((this.section != null) && (!this.section.isEmpty())); }
public boolean isSetLowerCorner() { return ((this.lowerCorner != null) && (!this.lowerCorner.isEmpty())); }
public void unsetLowerCorner() { this.lowerCorner = null; }
public boolean isSetUpperCorner() { return ((this.upperCorner != null) && (!this.upperCorner.isEmpty())); }
public void unsetUpperCorner() { this.upperCorner = null; }
public boolean isSetCrs() { return (this.crs != null); }
public boolean isSetDimensions() { return (this.dimensions != null); }
public ExceptionReport createExceptionReport() { return new ExceptionReport(); }
public ExceptionType createExceptionType() { return new ExceptionType(); }
public MetadataType createMetadataType() { return new MetadataType(); }
public BoundingBoxType createBoundingBoxType() { return new BoundingBoxType(); }
public WGS84BoundingBoxType createWGS84BoundingBoxType() { return new WGS84BoundingBoxType(); }
public LanguageStringType createLanguageStringType() { return new LanguageStringType(); }
public KeywordsType createKeywordsType() { return new KeywordsType(); }
public ResponsiblePartyType createResponsiblePartyType() { return new ResponsiblePartyType(); }
public CodeType createCodeType() { return new CodeType(); }
public ContactType createContactType() { return new ContactType(); }
public ServiceIdentification createServiceIdentification() { return new ServiceIdentification(); }
public DescriptionType createDescriptionType() { return new DescriptionType(); }
public ServiceProvider createServiceProvider() { return new ServiceProvider(); }
public OnlineResourceType createOnlineResourceType() { return new OnlineResourceType(); }
public ResponsiblePartySubsetType createResponsiblePartySubsetType() { return new ResponsiblePartySubsetType(); }
public AnyValue createAnyValue() { return new AnyValue(); }
public NoValues createNoValues() { return new NoValues(); }
public ValuesReference createValuesReference() { return new ValuesReference(); }
public AllowedValues createAllowedValues() { return new AllowedValues(); }
public ValueType createValueType() { return new ValueType(); }
public RangeType createRangeType() { return new RangeType(); }
public DomainMetadataType createDomainMetadataType() { return new DomainMetadataType(); }
public OperationsMetadata createOperationsMetadata() { return new OperationsMetadata(); }
public Operation createOperation() { return new Operation(); }
public RequestMethodType createRequestMethodType() { return new RequestMethodType(); }
public DomainType createDomainType() { return new DomainType(); }
public GetResourceByIdType createGetResourceByIdType() { return new GetResourceByIdType(); }
public DatasetDescriptionSummaryBaseType createDatasetDescriptionSummaryBaseType() { return new DatasetDescriptionSummaryBaseType(); }
public AbstractReferenceBaseType createAbstractReferenceBaseType() { return new AbstractReferenceBaseType(); }
public ReferenceType createReferenceType() { return new ReferenceType(); }
public ReferenceGroupType createReferenceGroupType() { return new ReferenceGroupType(); }
public ManifestType createManifestType() { return new ManifestType(); }
public ServiceReferenceType createServiceReferenceType() { return new ServiceReferenceType(); }
public TelephoneType createTelephoneType() { return new TelephoneType(); }
public AddressType createAddressType() { return new AddressType(); }
public BasicIdentificationType createBasicIdentificationType() { return new BasicIdentificationType(); }
public IdentificationType createIdentificationType() { return new IdentificationType(); }
public UnNamedDomainType createUnNamedDomainType() { return new UnNamedDomainType(); }
public CapabilitiesBaseType createCapabilitiesBaseType() { return new CapabilitiesBaseType(); }
public AcceptVersionsType createAcceptVersionsType() { return new AcceptVersionsType(); }
public SectionsType createSectionsType() { return new SectionsType(); }
public AcceptFormatsType createAcceptFormatsType() { return new AcceptFormatsType(); }
public ContentsBaseType createContentsBaseType() { return new ContentsBaseType(); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Exception") public JAXBElement<ExceptionType> createException(ExceptionType value) { return new JAXBElement<ExceptionType>(_Exception_QNAME, ExceptionType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Metadata") public JAXBElement<MetadataType> createMetadata(MetadataType value) { return new JAXBElement<MetadataType>(_Metadata_QNAME, MetadataType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "AbstractMetaData") public JAXBElement<Object> createAbstractMetaData(Object value) { return new JAXBElement<Object>(_AbstractMetaData_QNAME, Object.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "BoundingBox") public JAXBElement<BoundingBoxType> createBoundingBox(BoundingBoxType value) { return new JAXBElement<BoundingBoxType>(_BoundingBox_QNAME, BoundingBoxType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/ows/1.1", name = "WGS84BoundingBox", substitutionHeadNamespace = "http://www.opengis.net/ows/1.1", substitutionHeadName = "BoundingBox") public JAXBElement<WGS84BoundingBoxType> createWGS84BoundingBox(WGS84BoundingBoxType value) { return new JAXBElement<WGS84BoundingBoxType>( _WGS84BoundingBox_QNAME, WGS84BoundingBoxType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Title") public JAXBElement<LanguageStringType> createTitle(LanguageStringType value) { return new JAXBElement<LanguageStringType>(_Title_QNAME, LanguageStringType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Abstract") public JAXBElement<LanguageStringType> createAbstract(LanguageStringType value) { return new JAXBElement<LanguageStringType>( _Abstract_QNAME, LanguageStringType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Keywords") public JAXBElement<KeywordsType> createKeywords(KeywordsType value) { return new JAXBElement<KeywordsType>(_Keywords_QNAME, KeywordsType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "PointOfContact") public JAXBElement<ResponsiblePartyType> createPointOfContact(ResponsiblePartyType value) { return new JAXBElement<ResponsiblePartyType>( _PointOfContact_QNAME, ResponsiblePartyType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "IndividualName") public JAXBElement<String> createIndividualName(String value) { return new JAXBElement<String>(_IndividualName_QNAME, String.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "OrganisationName") public JAXBElement<String> createOrganisationName(String value) { return new JAXBElement<String>(_OrganisationName_QNAME, String.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "PositionName") public JAXBElement<String> createPositionName(String value) { return new JAXBElement<String>(_PositionName_QNAME, String.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Role") public JAXBElement<CodeType> createRole(CodeType value) { return new JAXBElement<CodeType>(_Role_QNAME, CodeType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "ContactInfo") public JAXBElement<ContactType> createContactInfo(ContactType value) { return new JAXBElement<ContactType>(_ContactInfo_QNAME, ContactType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Identifier") public JAXBElement<CodeType> createIdentifier(CodeType value) { return new JAXBElement<CodeType>(_Identifier_QNAME, CodeType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "OutputFormat") public JAXBElement<String> createOutputFormat(String value) { return new JAXBElement<String>(_OutputFormat_QNAME, String.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "AvailableCRS") public JAXBElement<String> createAvailableCRS(String value) { return new JAXBElement<String>(_AvailableCRS_QNAME, String.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/ows/1.1", name = "SupportedCRS", substitutionHeadNamespace = "http://www.opengis.net/ows/1.1", substitutionHeadName = "AvailableCRS") public JAXBElement<String> createSupportedCRS(String value) { return new JAXBElement<String>(_SupportedCRS_QNAME, String.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "AccessConstraints") public JAXBElement<String> createAccessConstraints(String value) { return new JAXBElement<String>(_AccessConstraints_QNAME, String.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Fees") public JAXBElement<String> createFees(String value) { return new JAXBElement<String>(_Fees_QNAME, String.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Language") @XmlJavaTypeAdapter(CollapsedStringAdapter.class) public JAXBElement<String> createLanguage(String value) { return new JAXBElement<String>(_Language_QNAME, String.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Value") public JAXBElement<ValueType> createValue(ValueType value) { return new JAXBElement<ValueType>(_Value_QNAME, ValueType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Range") public JAXBElement<RangeType> createRange(RangeType value) { return new JAXBElement<RangeType>(_Range_QNAME, RangeType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "DefaultValue") public JAXBElement<ValueType> createDefaultValue(ValueType value) { return new JAXBElement<ValueType>(_DefaultValue_QNAME, ValueType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "MinimumValue") public JAXBElement<ValueType> createMinimumValue(ValueType value) { return new JAXBElement<ValueType>(_MinimumValue_QNAME, ValueType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "MaximumValue") public JAXBElement<ValueType> createMaximumValue(ValueType value) { return new JAXBElement<ValueType>(_MaximumValue_QNAME, ValueType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Spacing") public JAXBElement<ValueType> createSpacing(ValueType value) { return new JAXBElement<ValueType>(_Spacing_QNAME, ValueType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Meaning") public JAXBElement<DomainMetadataType> createMeaning(DomainMetadataType value) { return new JAXBElement<DomainMetadataType>( _Meaning_QNAME, DomainMetadataType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "DataType") public JAXBElement<DomainMetadataType> createDataType(DomainMetadataType value) { return new JAXBElement<DomainMetadataType>( _DataType_QNAME, DomainMetadataType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "ReferenceSystem") public JAXBElement<DomainMetadataType> createReferenceSystem(DomainMetadataType value) { return new JAXBElement<DomainMetadataType>( _ReferenceSystem_QNAME, DomainMetadataType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "UOM") public JAXBElement<DomainMetadataType> createUOM(DomainMetadataType value) { return new JAXBElement<DomainMetadataType>(_UOM_QNAME, DomainMetadataType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "ExtendedCapabilities") public JAXBElement<Object> createExtendedCapabilities(Object value) { return new JAXBElement<Object>(_ExtendedCapabilities_QNAME, Object.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "GetCapabilities") public JAXBElement<GetCapabilitiesType> createGetCapabilities(GetCapabilitiesType value) { return new JAXBElement<GetCapabilitiesType>( _GetCapabilities_QNAME, GetCapabilitiesType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Resource") public JAXBElement<Object> createResource(Object value) { return new JAXBElement<Object>(_Resource_QNAME, Object.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "GetResourceByID") public JAXBElement<GetResourceByIdType> createGetResourceByID(GetResourceByIdType value) { return new JAXBElement<GetResourceByIdType>( _GetResourceByID_QNAME, GetResourceByIdType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "OtherSource") public JAXBElement<MetadataType> createOtherSource(MetadataType value) { return new JAXBElement<MetadataType>(_OtherSource_QNAME, MetadataType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "DatasetDescriptionSummary") public JAXBElement<DatasetDescriptionSummaryBaseType> createDatasetDescriptionSummary( DatasetDescriptionSummaryBaseType value) { return new JAXBElement<DatasetDescriptionSummaryBaseType>( _DatasetDescriptionSummary_QNAME, DatasetDescriptionSummaryBaseType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "AbstractReferenceBase") public JAXBElement<AbstractReferenceBaseType> createAbstractReferenceBase( AbstractReferenceBaseType value) { return new JAXBElement<AbstractReferenceBaseType>( _AbstractReferenceBase_QNAME, AbstractReferenceBaseType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/ows/1.1", name = "Reference", substitutionHeadNamespace = "http://www.opengis.net/ows/1.1", substitutionHeadName = "AbstractReferenceBase") public JAXBElement<ReferenceType> createReference(ReferenceType value) { return new JAXBElement<ReferenceType>(_Reference_QNAME, ReferenceType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "ReferenceGroup") public JAXBElement<ReferenceGroupType> createReferenceGroup(ReferenceGroupType value) { return new JAXBElement<ReferenceGroupType>( _ReferenceGroup_QNAME, ReferenceGroupType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Manifest") public JAXBElement<ManifestType> createManifest(ManifestType value) { return new JAXBElement<ManifestType>(_Manifest_QNAME, ManifestType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "OperationResponse") public JAXBElement<ManifestType> createOperationResponse(ManifestType value) { return new JAXBElement<ManifestType>(_OperationResponse_QNAME, ManifestType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "InputData") public JAXBElement<ManifestType> createInputData(ManifestType value) { return new JAXBElement<ManifestType>(_InputData_QNAME, ManifestType.class, null, value); }
@XmlElementDecl( namespace = "http://www.opengis.net/ows/1.1", name = "ServiceReference", substitutionHeadNamespace = "http://www.opengis.net/ows/1.1", substitutionHeadName = "Reference") public JAXBElement<ServiceReferenceType> createServiceReference(ServiceReferenceType value) { return new JAXBElement<ServiceReferenceType>( _ServiceReference_QNAME, ServiceReferenceType.class, null, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Get", scope = HTTP.class) public JAXBElement<RequestMethodType> createHTTPGet(RequestMethodType value) { return new JAXBElement<RequestMethodType>( _HTTPGet_QNAME, RequestMethodType.class, HTTP.class, value); }
@XmlElementDecl(namespace = "http://www.opengis.net/ows/1.1", name = "Post", scope = HTTP.class) public JAXBElement<RequestMethodType> createHTTPPost(RequestMethodType value) { return new JAXBElement<RequestMethodType>( _HTTPPost_QNAME, RequestMethodType.class, HTTP.class, value); }
public boolean isSetVersion() { return ((this.version != null) && (!this.version.isEmpty())); }
public boolean isSetExceptionText() { return ((this.exceptionText != null) && (!this.exceptionText.isEmpty())); }
public void unsetExceptionText() { this.exceptionText = null; }
public boolean isSetExceptionCode() { return (this.exceptionCode != null); }
public boolean isSetLocator() { return (this.locator != null); }
public boolean isSetFormat() { return (this.format != null); }
public boolean isSetResourceID() { return ((this.resourceID != null) && (!this.resourceID.isEmpty())); }
public void unsetResourceID() { this.resourceID = null; }
public boolean isSetPhone() { return (this.phone != null); }
public boolean isSetAddress() { return (this.address != null); }
public boolean isSetOnlineResource() { return (this.onlineResource != null); }
public boolean isSetHoursOfService() { return (this.hoursOfService != null); }
public boolean isSetContactInstructions() { return (this.contactInstructions != null); }
@Override public void destroy() { log.info("WFS service is destroyed by the servlet container."); try { cacheCleanerPool.shutdownAndWait(); } catch (InterruptedException e) { String message = "Failed to shutdown cache cleaner pool."; log.error(message); log.error(e.getMessage()); } }
@Override protected void doOptions(HttpServletRequest request, HttpServletResponse response) throws IOException { if (wfsConfig.getServer().isEnableCORS()) addCORSHeaders(request, response, true); }
@Override public DropStoredQueryType readRequest() throws WFSException { DropStoredQueryType wfsRequest = new DropStoredQueryType(); baseRequestReader.read(wfsRequest, parameters); try { if (parameters.containsKey(KVPConstants.STOREDQUERY_ID)) wfsRequest.setId( new StringParser() .parse(KVPConstants.STOREDQUERY_ID, parameters.get(KVPConstants.STOREDQUERY_ID))); } catch (KVPParseException e) { throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, e.getMessage(), e.getParameter(), e.getCause()); } return wfsRequest; }
@Override public DescribeFeatureTypeType readRequest() throws WFSException { DescribeFeatureTypeType wfsRequest = new DescribeFeatureTypeType(); baseRequestReader.read(wfsRequest, parameters); try { if (parameters.containsKey(KVPConstants.TYPE_NAME)) wfsRequest .getTypeName() .addAll( new FlatValueListParser<>(new QNameParser(getNamespaces())) .parse(KVPConstants.TYPE_NAME, parameters.get(KVPConstants.TYPE_NAME))); if (parameters.containsKey(KVPConstants.TYPE_NAMES)) wfsRequest .getTypeName() .addAll( new FlatValueListParser<>(new QNameParser(getNamespaces())) .parse(KVPConstants.TYPE_NAMES, parameters.get(KVPConstants.TYPE_NAMES))); if (parameters.containsKey(KVPConstants.OUTPUT_FORMAT)) wfsRequest.setOutputFormat( new StringParser() .parse(KVPConstants.OUTPUT_FORMAT, parameters.get(KVPConstants.OUTPUT_FORMAT))); } catch (KVPParseException e) { throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, e.getMessage(), e.getParameter(), e.getCause()); } return wfsRequest; }
@Override public DescribeStoredQueriesType readRequest() throws WFSException { DescribeStoredQueriesType wfsRequest = new DescribeStoredQueriesType(); baseRequestReader.read(wfsRequest, parameters); try { if (parameters.containsKey(KVPConstants.STOREDQUERY_ID)) wfsRequest.setStoredQueryId( new FlatValueListParser<>(new StringParser()) .parse(KVPConstants.STOREDQUERY_ID, parameters.get(KVPConstants.STOREDQUERY_ID))); } catch (KVPParseException e) { throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, e.getMessage(), e.getParameter(), e.getCause()); } return wfsRequest; }
private void checkMutualExclusivity( Map<String, String> parameters, String operationName, String... keys) throws WFSException { String found = null; for (String key : keys) { if (parameters.containsKey(key)) { if (found == null) found = key; else throw new WFSException( WFSExceptionCode.OPERATION_PARSING_FAILED, "The parameters " + found + " and " + key + " are mutually exclusive.", operationName); } } }
private List<List<String>> checkTypeNames( List<List<String>> typeNames, List<FilterType> resourceIds) { if (typeNames == null && resourceIds != null) { typeNames = new ArrayList<>(resourceIds.size()); for (int i = 0; i < resourceIds.size(); i++) { CityGMLModule core = wfsConfig .getFeatureTypes() .getDefaultVersion() .getCityGMLModule(CityGMLModuleType.CORE); typeNames.add( Collections.singletonList( "schema-element(" + core.getNamespacePrefix() + ":_CityObject)")); } } return typeNames; }
private void checkAlignedListSize( int size, Map<String, String> parameters, String operationName, String... keys) throws WFSException { for (String key : keys) { if (parameters.containsKey(key)) { String[] lists = parameters.get(key).split(KVPConstants.LIST_DELIMITER); if (lists.length != size) throw new WFSException( WFSExceptionCode.OPERATION_PARSING_FAILED, "The query uses parameter lists whose sizes are not aligned.", operationName); } } }
public void read(BaseRequestType wfsRequest, Map<String, String> parameters) throws WFSException { try { if (parameters.containsKey(KVPConstants.SERVICE)) wfsRequest.setService( new StringParser().parse(KVPConstants.SERVICE, parameters.get(KVPConstants.SERVICE))); else throw new WFSException( WFSExceptionCode.MISSING_PARAMETER_VALUE, "The request lacks the mandatory " + KVPConstants.SERVICE + " parameter.", KVPConstants.SERVICE); if (parameters.containsKey(KVPConstants.VERSION)) wfsRequest.setVersion( new StringParser().parse(KVPConstants.VERSION, parameters.get(KVPConstants.VERSION))); else throw new WFSException( WFSExceptionCode.MISSING_PARAMETER_VALUE, "The request lacks the mandatory " + KVPConstants.VERSION + " parameter.", KVPConstants.VERSION); } catch (KVPParseException e) { throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, e.getMessage(), e.getParameter(), e.getCause()); } }
@Override public PageRequest readRequest() throws WFSException { String pageId = parameters.get(KVPConstants.PAGE_ID.toUpperCase()); if (pageId == null) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "A paging request requires a '" + KVPConstants.PAGE_ID + "' parameter value."); if (!pagingCacheManager.isValidPageId(pageId)) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "Invalid value provided for the '" + KVPConstants.PAGE_ID + "' parameter.", KVPConstants.PAGE_ID); PageRequest pageRequest = pagingCacheManager.getIfValid(pageId); if (pageRequest == null) throw new WFSException( WFSExceptionCode.RESPONSE_CACHE_EXPIRED, "Paging results are no longer available.", pageId); operationName = pageRequest.getOperationName(); return pageRequest; }
@Override public NamespaceFilter getNamespaces() throws WFSException { return null; }
@Override public ListStoredQueriesType readRequest() throws WFSException { ListStoredQueriesType wfsRequest = new ListStoredQueriesType(); baseRequestReader.read(wfsRequest, parameters); return wfsRequest; }
@Override public GetCapabilitiesType readRequest() throws WFSException { GetCapabilitiesType wfsRequest = new GetCapabilitiesType(); try { if (parameters.containsKey(KVPConstants.SERVICE)) wfsRequest.setService( new StringParser().parse(KVPConstants.SERVICE, parameters.get(KVPConstants.SERVICE))); else throw new WFSException( WFSExceptionCode.MISSING_PARAMETER_VALUE, "The request lacks the mandatory " + KVPConstants.SERVICE + " parameter.", KVPConstants.SERVICE); if (parameters.containsKey(KVPConstants.ACCEPT_VERSIONS)) wfsRequest.setAcceptVersions( new AcceptVersionsParser() .parse(KVPConstants.ACCEPT_VERSIONS, parameters.get(KVPConstants.ACCEPT_VERSIONS))); } catch (KVPParseException e) { throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, e.getMessage(), e.getParameter(), e.getCause()); } return wfsRequest; }
public NamespaceFilter getNamespaces() throws WFSException { if (namespaceFilter == null) { try { namespaceFilter = new NamespacesParser(wfsConfig) .parse(KVPConstants.NAMESPACES, parameters.get(KVPConstants.NAMESPACES)); } catch (KVPParseException e) { throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, e.getMessage(), e.getParameter(), e.getCause()); } } return namespaceFilter; }
@Override public List<T> parse(String key, String value) throws KVPParseException { List<T> result = new ArrayList<>(); ValueListParser<String> listParser = new ValueListParser<>(new StringParser()); List<List<String>> lists = listParser.parse(key, value); if (lists.size() > 1) throw new KVPParseException("Multiple lists are not supported for the parameter " + key, key); for (String item : lists.get(0)) result.add(valueParser.parse(key, item)); return result; }
@Override public ResolveValueType parse(String key, String value) throws KVPParseException { try { return ResolveValueType.fromValue(value.trim()); } catch (IllegalArgumentException e) { throw new KVPParseException( "The value '" + value + "' is not allowed for the parameter " + key + ".", key); } }
@Override public List<FilterType> parse(String key, String value) throws KVPParseException { List<FilterType> filters = new ArrayList<>(); ValueListParser<String> listParser = new ValueListParser<>(new StringParser()); for (List<String> ids : listParser.parse(key, value)) { FilterType filter = new FilterType(); for (String id : ids) { ResourceIdType resourceId = new ResourceIdType(); resourceId.setRid(id); filter.get_Id().add(fesFactory.create_Id(resourceId)); } filters.add(filter); } return filters; }
@Override public QName parse(String key, String value) throws KVPParseException { String[] items = value.trim().split(":"); if (items.length > 2) throw new KVPParseException( "The value '" + value + "' of the parameter " + key + " is not a valid qualified property name.", key); String prefix; String name; if (items.length == 1) { prefix = XMLConstants.DEFAULT_NS_PREFIX; name = items[0]; } else { prefix = items[0]; if (prefix.startsWith("@")) prefix = prefix.substring(1); name = items[1]; } String namespaceURI = namespaceFilter.getNamespaceURI(prefix); if (namespaceURI == null) throw new KVPParseException( "The prefix '" + prefix + "' used in the property name '" + value + "' of the parameter " + key + " is not bound to a namespace URI.", key); return new QName(namespaceURI, name); }
@Override public PropertyName parse(String key, String value) throws KVPParseException { PropertyName propertyName = new PropertyName(); QName name = new QNameParser(namespaceFilter).parse(key, value); propertyName.setValue(name); return propertyName; }
@Override public BigInteger parse(String key, String value) throws KVPParseException { try { return new BigInteger(value.trim()); } catch (NumberFormatException e) { throw new KVPParseException( "The value '" + value + "' is not allowed for the parameter " + key + ".", key); } }
@Override public AcceptVersionsType parse(String key, String value) throws KVPParseException { AcceptVersionsType acceptVersions = new AcceptVersionsType(); List<String> versions = new FlatValueListParser<String>(new StringParser()).parse(key, value); acceptVersions.setVersion(versions); return acceptVersions; }
@Override public List<T> parse(String key, String value) throws KVPParseException { String[] items = value.split(KVPConstants.LIST_DELIMITER); List<T> result = new ArrayList<>(items.length); for (int i = 0; i < items.length; i++) { String item = items[i]; if (i == 0) item = item.replaceFirst("^\\(", ""); if (i == items.length - 1) item = item.replaceFirst("\\)$", ""); if (!item.trim().isEmpty()) result.add(valueParser.parse(key, item)); } if (result.isEmpty()) throw new KVPParseException( "The value of the parameter " + key + " must not be an empty list.", key); return result; }
@Override public ResultTypeType parse(String key, String value) throws KVPParseException { try { return ResultTypeType.fromValue(value.trim()); } catch (IllegalArgumentException e) { throw new KVPParseException( "The value '" + value + "' is not allowed for the parameter " + key + ".", key); } }
@Override public String parse(String key, String value) throws KVPParseException { return value.trim(); }
public List<List<T>> parse(String key, String value) throws KVPParseException { if (value.startsWith("(") && value.endsWith(")")) value = value.substring(1, value.length() - 1); String[] lists = value.split(KVPConstants.LIST_DELIMITER); List<List<T>> result = new ArrayList<>(lists.length); for (String list : lists) { String[] items = list.split(KVPConstants.ITEM_DELIMITER); List<T> tmp = new ArrayList<>(items.length); for (String item : items) { if (!item.trim().isEmpty()) tmp.add(valueParser.parse(key, item)); } if (tmp.isEmpty()) throw new KVPParseException( "The parameter " + key + " must not contain an empty parameter list.", key); result.add(tmp); } return result; }
PageRequest generateRequestFor(long pageNumber) { return pageRequest.generateRequestFor(pageNumber); }
public boolean isSerialized() { return serialized; }
void updateCacheTime() { cacheTime = System.nanoTime(); }
@Override PageRequest newInstance(long pageNumber, String identifier) { GetPropertyValueRequest instance = new GetPropertyValueRequest(); instance.startIndex = startIndex; instance.count = count; instance.wfsRequest = new GetPropertyValueType(); instance.wfsRequest.setValueReference(wfsRequest.getValueReference()); instance.wfsRequest.setStartIndex(BigInteger.valueOf(startIndex + count * pageNumber)); instance.wfsRequest.setCount(BigInteger.valueOf(count)); instance.wfsRequest.setResultType(ResultTypeType.RESULTS); instance.wfsRequest.setOutputFormat( wfsRequest.isSetOutputFormat() ? wfsRequest.getOutputFormat() : null); instance.wfsRequest.setIdentifier(identifier); instance.queryExpression = new QueryExpression(queryExpression); instance.namespaceFilter = namespaceFilter; return instance; }
public static PageRequest dummy() { return DummyRequest.getInstance(); }
PageRequest generateRequestFor(long pageNumber) { PageRequest pageRequest = newInstance(pageNumber, pageObject.getIdentifier()); pageRequest.pageObject = pageObject; pageRequest.wfsConfig = wfsConfig; pageRequest.pageNumber = pageNumber; return pageRequest; }
public String first(HttpServletRequest request) throws WFSException { return generateURL(0, request); }
public String next(HttpServletRequest request) throws WFSException { return generateURL(pageNumber + 1, request); }
public String previous(HttpServletRequest request) throws WFSException { return generateURL(pageNumber - 1, request); }
private String generateURL(long pageNumber, HttpServletRequest request) throws WFSException { long[] identifierBits = pageObject.getIdentifierBits(); String pageId = pageObject.getIdentifier() + "-" + Long.toHexString(identifierBits[0] ^ identifierBits[1] ^ pageNumber); String serviceURL = wfsConfig.getServer().isSetExternalServiceURL() ? wfsConfig.getServer().getExternalServiceURL() : ServerUtil.getServiceURL(request); return serviceURL + Constants.WFS_SERVICE_PATH + "?" + KVPConstants.PAGE_ID + "=" + pageId; }
public PageRequest create(GetFeatureType wfsRequest, List<QueryExpression> queryExpressions) { String key = getOrCreateIdentifier(wfsRequest); return create( key, v -> new PageObject(key, getIdentifierBits(key), wfsRequest, queryExpressions, wfsConfig)); }
public PageRequest create( GetPropertyValueType wfsRequest, vcs.citydb.wfs.operation.getpropertyvalue.QueryExpression queryExpression, NamespaceFilter namespaceFilter) { String key = getOrCreateIdentifier(wfsRequest); return create( key, v -> new PageObject( key, getIdentifierBits(key), wfsRequest, queryExpression, namespaceFilter, wfsConfig)); }
private PageRequest create(String key, Function<String, PageObject> mapping) { if (pageObjects.size() > MAINTENANCE_COUNT) cacheCleanerPool.addWork(this::cleanUp); return pageObjects.computeIfAbsent(key, mapping).getBaseRequest(); }
public void update(PageRequest pageRequest) throws IOException { PageObject pageObject = pageObjects.get(pageRequest.getIdentifier()); if (pageObject != null) { pageRequest.cacheValues(); pageObject.updateCacheTime(); } }
public void remove(PageRequest pageRequest) { PageObject pageObject = pageObjects.get(pageRequest.getIdentifier()); if (pageObject != null) remove(pageObject); }
private void remove(PageObject pageObject) { pageObjects.remove(pageObject.getIdentifier()); if (pageObject.isSerialized()) cacheCleanerPool.addWork(() -> Files.delete(pageObject.getTempFile())); }
public void cleanUp() { long accessTime = System.nanoTime(); pageObjects.values().stream() .filter(p -> p.isSerialized() && accessTime - p.getCacheTime() > maxLifeTime) .collect(Collectors.toList()) .forEach(this::remove); }
public boolean isValidPageId(String pageId) { return pageIdPattern.matcher(pageId).matches(); }
@Override PageRequest newInstance(long pageNumber, String identifier) { GetFeatureRequest instance = new GetFeatureRequest(); instance.startIndex = startIndex; instance.count = count; instance.wfsRequest = new GetFeatureType(); instance.wfsRequest.setStartIndex(BigInteger.valueOf(startIndex + count * pageNumber)); instance.wfsRequest.setCount(BigInteger.valueOf(count)); instance.wfsRequest.setResultType(ResultTypeType.RESULTS); instance.wfsRequest.setOutputFormat( wfsRequest.isSetOutputFormat() ? wfsRequest.getOutputFormat() : null); instance.wfsRequest.setIdentifier(identifier); instance.queryExpressions = new ArrayList<>(queryExpressions.size()); for (QueryExpression queryExpression : queryExpressions) instance.queryExpressions.add(new QueryExpression(queryExpression)); return instance; }
@Override int size() { return queryExpressions.size(); }
@Override PageRequest newInstance(long pageNumber, String identifier) { return instance; }
@Override PageRequest generateRequestFor(long pageNumber) { return instance; }
@Override public String first(HttpServletRequest request) { return null; }
@Override public String next(HttpServletRequest request) { return null; }
@Override public String previous(HttpServletRequest request) { return null; }
@Override void cacheValues() throws IOException { }
@Override public void updateValues() throws IOException { }
public void requireAccess(String operationName, HttpServletRequest request) throws AccessControlException { if (permissions != null) { WFSOperation operation = WFSOperation.fromValue(operationName); if (operation == null) throw new AccessControlException( "Failed to map client request '" + operationName + "' to a valid WFS operation."); AccessPermission permission = permissions.get(operation); if (permission != null) permission.requireAccess(operationName, request); } }
void addToken(String token) { if (tokens == null) tokens = new HashSet<>(); tokens.add(token); }
void addIPAddress(IPAddress ipAddress, boolean allow) { if (allow) addAllowedIPAddress(ipAddress); else addDeniedIPAddress(ipAddress); }
void addPermissions(AccessPermission other) { if (other.tokens != null) other.tokens.forEach(this::addToken); if (other.allowedIPAddresses != null) other.allowedIPAddresses.forEach(this::addAllowedIPAddress); if (other.deniedIPAddresses != null) other.deniedIPAddresses.forEach(this::addDeniedIPAddress); }
private void addAllowedIPAddress(IPAddress ipAddress) { if (allowedIPAddresses == null) allowedIPAddresses = new ArrayList<>(); allowedIPAddresses.add(ipAddress); }
private void addDeniedIPAddress(IPAddress ipAddress) { if (deniedIPAddresses == null) deniedIPAddresses = new ArrayList<>(); deniedIPAddresses.add(ipAddress); }
@Override public ServletOutputStream getOutputStream() throws IOException { if (writer != null) throw new IllegalStateException("getWriter() has already been called for this response"); if (outputStream == null) outputStream = new GZIPServletOutputStream(super.getOutputStream()); return outputStream; }
@Override public PrintWriter getWriter() throws IOException { if (writer == null && outputStream != null) throw new IllegalStateException( "getOutputStream() has already been called for this response"); if (writer == null) { outputStream = new GZIPServletOutputStream(super.getOutputStream()); writer = new PrintWriter(new OutputStreamWriter(outputStream, getCharacterEncoding())); } return writer; }
@Override public void flushBuffer() throws IOException { if (writer != null) writer.flush(); else if (outputStream != null) outputStream.flush(); super.flushBuffer(); }
@Override public void addHeader(String name, String value) { if (!"content-length".equalsIgnoreCase(name)) super.addHeader(name, value); }
@Override public void addIntHeader(String name, int value) { if (!"content-length".equalsIgnoreCase(name)) super.addIntHeader(name, value); }
public void finish() throws IOException { if (writer != null) writer.close(); else if (outputStream != null) outputStream.finish(); }
@Override public void init(FilterConfig filterConfig) throws ServletException { }
@Override public void destroy() { }
@Override public boolean isReady() { return servletOutputStream.isReady(); }
@Override public void write(int b) throws IOException { gzipOutputStream.write(b); }
@Override public void flush() throws IOException { gzipOutputStream.flush(); }
@Override public void close() throws IOException { gzipOutputStream.close(); }
public void finish() throws IOException { gzipOutputStream.finish(); }
public static WFSConfig load(ServletContext context) throws JAXBException { return new WFSConfigLoader(context).unmarshal(); }
public WFSConfig unmarshal() throws JAXBException { JAXBContext configContext = JAXBContext.newInstance(WFSConfig.class); Unmarshaller um = configContext.createUnmarshaller(); InputStream inputStream; try { inputStream = Paths.get(Constants.CONFIG_FILE).isAbsolute() ? new FileInputStream(Constants.CONFIG_FILE) : context.getResourceAsStream(Constants.CONFIG_FILE); } catch (FileNotFoundException e) { throw new JAXBException("WFS config file '" + Constants.CONFIG_FILE + "' not found.", e); } Object object = um.unmarshal(inputStream); if (!(object instanceof WFSConfig)) throw new JAXBException("Illegal XML root element used in config file."); WFSConfig wfsConfig = (WFSConfig) object; afterUnmarshal(wfsConfig.getCapabilities().getOwsMetadata()); afterUnmarshal(wfsConfig.getPostProcessing().getXSLTransformation()); afterUnmarshal(wfsConfig.getServer()); return wfsConfig; }
private void afterUnmarshal(XSLTransformation transformation) { if (transformation.isEnabled() && transformation.isSetStylesheets()) { transformation .getStylesheets() .replaceAll( stylesheet -> !Paths.get(stylesheet).isAbsolute() ? context.getRealPath(Constants.XSLT_STYLESHEETS_PATH + "/" + stylesheet) : stylesheet); } }
private void afterUnmarshal(Server server) { server.setExternalServiceURL(processServiceURL(server.getExternalServiceURL())); server.setTextureServiceURL(processServiceURL(server.getTextureServiceURL())); Path tempDir = ((File) context.getAttribute(context.TEMPDIR)).toPath(); server.setTempDir( Files.isWritable(tempDir) ? tempDir : Paths.get(System.getProperty("java.io.tmpdir"))); }
private String processServiceURL(String serviceURL) { if (serviceURL != null && serviceURL.endsWith("/")) serviceURL = serviceURL.substring(0, serviceURL.length() - 1); return serviceURL; }
@Override public Result createOutput(String namespaceUri, String suggestedFileName) throws IOException { File file; if (namespaceUri.equals(ConfigConstants.CITYDB_CONFIG_NAMESPACE_URI)) file = new File(Constants.CONFIG_SCHEMA_FILE); else file = new File(Constants.CONFIG_SCHEMA_PATH + "/ows/" + suggestedFileName); file.getAbsoluteFile().getParentFile().mkdirs(); StreamResult res = new StreamResult(); res.setSystemId(file.toURI().toString()); return res; }
public boolean implementsBasicWFS() { return wfsConfig.getOperations().getGetPropertyValue().isEnabled() && wfsConfig.getConstraints().isSupportAdHocQueries() && wfsConfig.getConstraints().isUseDefaultSorting() && wfsConfig.getFilterCapabilities().isSetSpatialCapabilities() && wfsConfig .getFilterCapabilities() .getSpatialCapabilities() .containsAll(SpatialOperatorName.MIN_SPATIAL_FILTER); }
public boolean implementsTransactionalWFS() { return false; }
public boolean implementsLockingWFS() { return false; }
public boolean implementsKVPEncoding() { return wfsConfig.getOperations().getRequestEncoding().getMethod() != EncodingMethod.XML; }
public boolean implementsXMLEncoding() { return wfsConfig.getOperations().getRequestEncoding().getMethod() != EncodingMethod.KVP; }
public boolean implementsSOAPEncoding() { return false; }
public boolean implementsInheritance() { return true; }
public boolean implementsRemoteResolve() { return false; }
public boolean implementsResultPaging() { return wfsConfig.getConstraints().isUseResultPaging(); }
public boolean implementsStandardJoins() { return false; }
public boolean implementsSpatialJoins() { return false; }
public boolean implementsTemporalJoins() { return false; }
public boolean implementsFeatureVersioning() { return false; }
public boolean implementsManageStoredQueries() { return wfsConfig.getOperations().getManagedStoredQueries().isEnabled(); }
public boolean implementsAdHocQuery() { return wfsConfig.getConstraints().isSupportAdHocQueries(); }
public boolean implementsFunctions() { return false; }
public boolean implementsResourceld() { return true; }
public boolean implementsMinStandardFilter() { return wfsConfig.getFilterCapabilities().isSetScalarCapabilities() && wfsConfig.getFilterCapabilities().getScalarCapabilities().isSetLogicalOperators() && wfsConfig.getFilterCapabilities().getScalarCapabilities().isSetComparisonOperators() && wfsConfig .getFilterCapabilities() .getScalarCapabilities() .containsAll(ComparisonOperatorName.MIN_STANDARD_FILTER); }
public boolean implementsStandardFilter() { return wfsConfig.getFilterCapabilities().isSetScalarCapabilities() && wfsConfig.getFilterCapabilities().getScalarCapabilities().isSetLogicalOperators() && wfsConfig.getFilterCapabilities().getScalarCapabilities().isSetComparisonOperators() && wfsConfig .getFilterCapabilities() .getScalarCapabilities() .containsAll(ComparisonOperatorName.STANDARD_FILTER); }
public boolean implementsMinSpatialFilter() { return wfsConfig.getFilterCapabilities().isSetSpatialCapabilities() && wfsConfig .getFilterCapabilities() .getSpatialCapabilities() .containsAll(SpatialOperatorName.MIN_SPATIAL_FILTER); }
public boolean implementsSpatialFilter() { return implementsMinSpatialFilter() && wfsConfig.getFilterCapabilities().getSpatialCapabilities().getSpatialOperators().size() > 1; }
public boolean implementsMinTemporalFilter() { return false; }
public boolean implementsTemporalFilter() { return false; }
public boolean implementsVersionNav() { return false; }
public boolean implementsExtendedOperators() { return false; }
public boolean implementsMinimumXPath() { return true; }
public boolean implementsSchemaElementFunc() { return true; }
@Override public int hashCode() { return name != null ? Objects.hash(name.getLocalPart(), name.getNamespaceURI()) : 0; }
@Override public boolean equals(Object obj) { if (obj instanceof ADEFeatureType) { ADEFeatureType other = (ADEFeatureType) obj; if (name != null && other.name != null) return name.getLocalPart().equals(other.name.getLocalPart()) && name.getNamespaceURI().equals(other.name.getNamespaceURI()); } return super.equals(obj); }
public boolean contains(QName featureName) { return getFeatureTypes().containsKey(featureName); }
public void preprocessFeatureTypes() { getFeatureTypes(); }
public boolean isDefault() { return isDefault != null ? isDefault.booleanValue() : false; }
@Override public int hashCode() { return Objects.hash(value); }
@Override public boolean equals(Object obj) { if (obj instanceof CityGMLVersionType && value == ((CityGMLVersionType) obj).value) return true; return super.equals(obj); }
public static CityGMLVersionEnum fromCityGMLVersion(CityGMLVersion version) { if (version == CityGMLVersion.v1_0_0) return v1_0_0; else return v2_0_0; }
@Override public int hashCode() { return Objects.hash(name); }
@Override public boolean equals(Object obj) { if (obj instanceof CityGMLFeatureType && name == ((CityGMLFeatureType) obj).name) return true; return super.equals(obj); }
public static CityGMLFeatureTypeName fromCityGMLClass(CityGMLClass cityGMLClass) { for (CityGMLFeatureTypeName typeName : values()) if (typeName.getCityGMLClass() == cityGMLClass) return typeName; return null; }
public void addTitle(Title title) { if (titles == null) titles = new ArrayList<Title>(); titles.add(title); }
public boolean isSetTitles() { return titles != null; }
public void addAbstract(Abstract _abstract) { if (abstracts == null) abstracts = new ArrayList<Abstract>(); abstracts.add(_abstract); }
public boolean isSetAbstracts() { return abstracts != null; }
public void addKeyword(KeywordsType keyword) { if (keywords == null) keywords = new ArrayList<KeywordsType>(); keywords.add(keyword); }
public boolean isSetKeywords() { return keywords != null; }
public void addWGS84BoundingBox(WGS84BoundingBoxType wgs84BoundingBox) { if (wgs84BoundingBoxes == null) wgs84BoundingBoxes = new ArrayList<WGS84BoundingBoxType>(); wgs84BoundingBoxes.add(wgs84BoundingBox); }
public boolean isSetWGS84BoundingBoxes() { return wgs84BoundingBoxes != null; }
public void addMetadataURL(MetadataURLType metadataURL) { if (metadataURLs == null) metadataURLs = new ArrayList<MetadataURLType>(); metadataURLs.add(metadataURL); }
public boolean isSetMetadataURLs() { return metadataURLs != null; }
public boolean isSetExtendedDescription() { return extendedDescription != null; }
public boolean isSetLocalCachePath() { return localCachePath != null && !localCachePath.trim().isEmpty(); }
public boolean isSetExternalServiceURL() { return externalServiceURL != null && !externalServiceURL.isEmpty(); }
public boolean isEnableCORS() { return enableCORS; }
public boolean isSetTimeZone() { return timeZone != null && !timeZone.isEmpty(); }
public boolean isSetTextureServiceURL() { return textureServiceURL != null && !textureServiceURL.isEmpty(); }
public boolean isSupportAdHocQueries() { return supportAdHocQueries; }
public boolean isSetCountDefault() { return countDefault != Constants.COUNT_DEFAULT; }
public boolean isComputeNumberMatched() { return computeNumberMatched; }
public boolean isUseDefaultSorting() { return useDefaultSorting; }
public boolean isCurrentVersionOnly() { return currentVersionOnly; }
public boolean isExportCityDBMetadata() { return exportCityDBMetadata; }
public boolean isExportAppearance() { return exportAppearance; }
public boolean isUseResultPaging() { return useResultPaging; }
public boolean isStripGeometry() { return stripGeometry; }
public void addSpatialOperator(SpatialOperatorName spatialOperator) { if (!operators.contains(spatialOperator)) operators.add(spatialOperator); }
public boolean containsSpatialOperator(SpatialOperatorName spatialOperator) { return operators.contains(spatialOperator); }
public boolean containsAll(EnumSet<SpatialOperatorName> spatialOperators) { return operators.containsAll(spatialOperators); }
public boolean isSetLogicalOperators() { return logicalOperators != null && logicalOperators; }
public void enableLogicalOperators(boolean enable) { logicalOperators = enable; }
public boolean isSetComparisonOperators() { return comparisonOperators != null && !comparisonOperators.isEmpty(); }
public void addComparisonOperator(ComparisonOperatorName comparisonOperator) { if (!comparisonOperators.contains(comparisonOperator)) comparisonOperators.add(comparisonOperator); }
public boolean containsComparisonOperator(ComparisonOperatorName comparisonOperator) { return comparisonOperators.contains(comparisonOperator); }
public boolean containsAll(EnumSet<ComparisonOperatorName> comparisonOperators) { return this.comparisonOperators.containsAll(comparisonOperators); }
public boolean isSetScalarCapabilities() { return scalarCapabilities != null && (scalarCapabilities.isSetLogicalOperators() || scalarCapabilities.isSetComparisonOperators()); }
public boolean isSetSpatialCapabilities() { return spatialCapabilities.getSpatialOperators() != null && !spatialCapabilities.getSpatialOperators().isEmpty(); }
public static boolean contains(GMLClass type) { for (SpatialOperandName operand : values()) if (operand.type == type) return true; return false; }
public static SpatialOperatorName fromValue(String value) { for (SpatialOperatorName name : values()) if (name.value.equals(value)) return name; return null; }
public static ComparisonOperatorName fromValue(String value) { for (ComparisonOperatorName name : values()) if (name.value.equals(value)) return name; return null; }
public boolean isUseXMLValidation() { return useXMLValidation; }
public boolean supportsOutputFormat(GetFeatureOutputFormat outputFormat) { return outputFormats.containsKey(outputFormat.value()); }
public boolean supportsOutputFormat(String outputFormat) { GetFeatureOutputFormat candidate = GetFeatureOutputFormat.fromValue(outputFormat); return candidate != null && supportsOutputFormat(candidate); }
@Override public LinkedHashMap<String, OutputFormat> unmarshal(OutputFormatList v) throws Exception { LinkedHashMap<String, OutputFormat> outputFormats = new LinkedHashMap<>(); for (OutputFormat outputFormat : v.outputFormats) { GetFeatureOutputFormat candidate = GetFeatureOutputFormat.fromValue(outputFormat.getName()); if (candidate != null) outputFormats.put(outputFormat.getName(), outputFormat); } if (!outputFormats.containsKey(GetFeatureOutputFormat.GML3_1.value())) outputFormats.put( GetFeatureOutputFormat.GML3_1.value(), new OutputFormat(GetFeatureOutputFormat.GML3_1.value())); return outputFormats; }
@Override public OutputFormatList marshal(LinkedHashMap<String, OutputFormat> v) throws Exception { OutputFormatList list = new OutputFormatList(); list.outputFormats = new ArrayList<>(v.values()); return list; }
public static GetPropertyValueOutputFormat fromValue(String value) { for (GetPropertyValueOutputFormat c : GetPropertyValueOutputFormat.values()) { if (c.value.equals(value)) return c; } return null; }
public static GetFeatureOutputFormat fromValue(String value) { for (GetFeatureOutputFormat c : GetFeatureOutputFormat.values()) { if (c.value.equals(value)) return c; } return null; }
public static WFSOperation fromValue(String value) { for (WFSOperation c : WFSOperation.values()) { if (c.value.equals(value)) return c; } return null; }
public boolean supportsOutputFormat(DescribeFeatureTypeOutputFormat outputFormat) { return outputFormats.containsKey(outputFormat.value()); }
public boolean supportsOutputFormat(String outputFormat) { DescribeFeatureTypeOutputFormat candidate = DescribeFeatureTypeOutputFormat.fromValue(outputFormat); return candidate != null && supportsOutputFormat(candidate); }
@Override public LinkedHashMap<String, OutputFormat> unmarshal(OutputFormatList v) throws Exception { LinkedHashMap<String, OutputFormat> outputFormats = new LinkedHashMap<>(); for (OutputFormat outputFormat : v.outputFormats) { DescribeFeatureTypeOutputFormat candidate = DescribeFeatureTypeOutputFormat.fromValue(outputFormat.getName()); if (candidate != null) outputFormats.put(outputFormat.getName(), outputFormat); } if (!outputFormats.containsKey(DescribeFeatureTypeOutputFormat.GML3_1.value())) outputFormats.put( DescribeFeatureTypeOutputFormat.GML3_1.value(), new OutputFormat(DescribeFeatureTypeOutputFormat.GML3_1.value())); return outputFormats; }
public boolean hasOptions() { return !options.isEmpty(); }
@Override public LinkedHashMap<String, String> unmarshal(OutputFormatOptionList v) throws Exception { LinkedHashMap<String, String> options = new LinkedHashMap<>(); for (OutputFormatOption option : v.options) { if (option.name != null && !option.name.isEmpty()) options.put(option.name, option.value); } return options; }
@Override public OutputFormatOptionList marshal(LinkedHashMap<String, String> v) throws Exception { OutputFormatOptionList list = new OutputFormatOptionList(); list.options = new ArrayList<>(); for (Entry<String, String> entry : v.entrySet()) { OutputFormatOption option = new OutputFormatOption(); option.name = entry.getKey(); option.value = entry.getValue(); list.options.add(option); } return !list.options.isEmpty() ? list : null; }
public boolean supportsOutputFormat(String outputFormat) { return GetPropertyValueOutputFormat.fromValue(outputFormat) != null; }
public static DescribeFeatureTypeOutputFormat fromValue(String value) { for (DescribeFeatureTypeOutputFormat c : DescribeFeatureTypeOutputFormat.values()) { if (c.value.equals(value)) return c; } return null; }
public void addExceptionMessage(WFSExceptionMessage exceptionMessage) { if (exceptionMessage != null) exceptionMessages.add(exceptionMessage); }
public void addExceptionMessages(Collection<WFSExceptionMessage> exceptionMessages) { for (WFSExceptionMessage exceptionMessage : exceptionMessages) { if (exceptionMessage != null) this.exceptionMessages.add(exceptionMessage); } }
public void addFirstExceptionMessage(WFSExceptionMessage exceptionMessage) { if (exceptionMessage != null) exceptionMessages.addFirst(exceptionMessage); }
public synchronized void sendErrorResponse( WFSException wfsException, String operationName, HttpServletRequest request, HttpServletResponse response) throws IOException { ExceptionReport exceptionReport = getExceptionReport(wfsException, operationName, request, true); response.setContentType("text/xml"); response.setCharacterEncoding(StandardCharsets.UTF_8.name()); response.setStatus( wfsException.getFirstExceptionMessage().getExceptionCode().getHttpStatusCode()); SAXWriter saxWriter = new SAXWriter(); saxWriter.setWriteEncoding(true); saxWriter.setIndentString(" "); saxWriter.setPrefix(Constants.OWS_NAMESPACE_PREFIX, Constants.OWS_NAMESPACE_URI); saxWriter.setSchemaLocation(Constants.OWS_NAMESPACE_URI, Constants.OWS_SCHEMA_LOCATION); try { saxWriter.setOutput(response.getWriter()); Marshaller marshaller = cityGMLBuilder.getJAXBContext().createMarshaller(); marshaller.marshal(exceptionReport, saxWriter); } catch (JAXBException | IOException e) { if (!response.isCommitted()) response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.getMessage()); } }
private void preprocessWFSException(WFSException wfsException, String operationName) { if (operationName != null) { WFSExceptionMessage message = wfsException.getFirstExceptionMessage(); WFSExceptionCode code = message.getExceptionCode(); if (message.getLocator() == null && (code == WFSExceptionCode.OPERATION_PROCESSING_FAILED || code == WFSExceptionCode.OPERATION_PARSING_FAILED || code == WFSExceptionCode.OPERATION_NOT_SUPPORTED)) { message.setLocator(operationName); } } }
@Override public Response toResponse(Throwable t) { int httpStatus; ExceptionInfo info = new ExceptionInfo(); if (t instanceof WFSException) { WFSExceptionMessage message = ((WFSException) t).getFirstExceptionMessage(); httpStatus = message.getExceptionCode().getHttpStatusCode(); info.setCode(message.getExceptionCode().getValue()); message.getExceptionTexts().forEach(info::addDescription); } else { if (t instanceof WebApplicationException) { WebApplicationException e = (WebApplicationException) t; httpStatus = e.getResponse().getStatusInfo().getStatusCode(); info.setCode(e.getResponse().getStatusInfo().getReasonPhrase()); } else { httpStatus = WFSExceptionCode.INTERNAL_SERVER_ERROR.getHttpStatusCode(); info.setCode(WFSExceptionCode.INTERNAL_SERVER_ERROR.getValue()); } do { String cause = t.getMessage(); if (cause != null) info.addDescription(cause); } while ((t = t.getCause()) != null); } info.getDescription().forEach(m -> log.error(LoggerUtil.getLogMessage(request, m))); return Response.status(httpStatus).entity(info).type(MediaType.APPLICATION_JSON).build(); }
public void addExceptionText(String exceptionText) { if (exceptionText != null) exceptionTexts.add(exceptionText); }
public void addExceptionTexts(Collection<String> exceptionTexts) { if (exceptionTexts != null) exceptionTexts.forEach(this::addExceptionText); }
public boolean isSetNumberMatched() { return numberMatched != -1; }
public boolean isSetStartId() { return startId != -1; }
public boolean supportsPagingByStartId() { if (!isSetSorting()) return true; if (getSorting().getSortProperties().size() != 1) return false; SortProperty sortProperty = getSorting().getSortProperties().get(0); if (sortProperty .getValueReference() .getSchemaPath() .getLastNode() .getPathElement() .getElementType() == PathElementType.SIMPLE_ATTRIBUTE) { SimpleAttribute attribute = (SimpleAttribute) sortProperty.getValueReference().getSchemaPath().getLastNode().getPathElement(); return MappingConstants.ID.equalsIgnoreCase(attribute.getColumn()) && attribute.hasParentType() && MappingConstants.CITYOBJECT.equalsIgnoreCase(attribute.getParentType().getTable()); } return false; }
@Override public void copyFrom(Query query) { super.copyFrom(query); if (query instanceof AbstractQueryExpression) { AbstractQueryExpression other = (AbstractQueryExpression) query; handle = other.handle; numberMatched = other.numberMatched; startId = other.startId; } }
public void validate(BaseRequestType wfsRequest) throws WFSException { if (!wfsRequest.isSetService()) throw new WFSException( WFSExceptionCode.MISSING_PARAMETER_VALUE, "The request lacks the mandatory " + KVPConstants.SERVICE + " parameter.", KVPConstants.SERVICE); else if (!Constants.WFS_SERVICE_STRING.equals(wfsRequest.getService())) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "The attribute 'service' must match the fixed value '" + Constants.WFS_SERVICE_STRING + "'.", KVPConstants.SERVICE); if (!wfsRequest.isSetVersion()) throw new WFSException( WFSExceptionCode.MISSING_PARAMETER_VALUE, "The request lacks the mandatory " + KVPConstants.VERSION + " parameter.", KVPConstants.VERSION); else if (!wfsConfig .getCapabilities() .getSupportedWFSVersions() .contains(wfsRequest.getVersion())) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "The attribute 'version' must match one of the supported version numbers '" + Util.collection2string(wfsConfig.getCapabilities().getSupportedWFSVersions(), ", ") + "'.", KVPConstants.VERSION); }
public PropertyValueWriter buildPropertyValueWriter(Writer writer) throws FeatureWriteException { try { saxWriter.setOutput(writer); return new PropertyValueWriter( valueReference, saxWriter, version, transformerChainFactory, namespaceFilter, geometryStripper, useSequentialWriting, eventChannel, config); } catch (DatatypeConfigurationException e) { throw new FeatureWriteException("Failed to create CityGML response writer.", e); } }
@Override public void copyFrom(Query query) { super.copyFrom(query); if (query instanceof QueryExpression) { QueryExpression other = (QueryExpression) query; valueReference = other.valueReference; schemaPath = other.schemaPath; propertyOffset = other.propertyOffset; } }
public void doExport( GetPropertyValueRequest pageRequest, HttpServletRequest request, HttpServletResponse response) throws WFSException { doExport( pageRequest.getWfsRequest(), pageRequest.getQueryExpression(), pageRequest.getNamespaceFilter(), pageRequest, request, response); }
public void doExport( GetPropertyValueType wfsRequest, QueryExpression queryExpression, NamespaceFilter namespaceFilter, HttpServletRequest request, HttpServletResponse response) throws WFSException { doExport(wfsRequest, queryExpression, namespaceFilter, null, request, response); }
@Override public void writeHeader() throws FeatureWriteException { }
@Override public void useIndentation(boolean useIndentation) { saxWriter.setIndentString(useIndentation ? " " : ""); }
public void startValueCollection(long matchNo, long returnNo, String previous, String next) throws FeatureWriteException { writeValueCollection(matchNo, returnNo, previous, next, WriteMode.HEAD); }
public void endValueCollection() throws FeatureWriteException { writeValueCollection(0, 0, null, null, WriteMode.TAIL); }
@Override public void updateSequenceId(long sequenceId) throws FeatureWriteException { if (useSequentialWriting) { try { sequentialWriter.updateSequenceId(sequenceId); } catch (InterruptedException e) { throw new FeatureWriteException("Failed to update sequence id.", e); } } }
public void writeTruncatedResponse(TruncatedResponse truncatedResponse) throws FeatureWriteException { try { SAXEventBuffer buffer = new SAXEventBuffer(); Marshaller marshaller = cityGMLBuilder.getJAXBContext().createMarshaller(); marshaller.marshal(truncatedResponse, buffer); writerPool.addWork(buffer); } catch (JAXBException e) { throw new FeatureWriteException("Failed to marshal truncated response element.", e); } }
public void close() throws FeatureWriteException { try { writerPool.shutdownAndWait(); } catch (InterruptedException e) { throw new FeatureWriteException("Failed to close CityGML response writer.", e); } finally { if (!writerPool.isTerminated()) writerPool.shutdownNow(); eventDispatcher.removeEventHandler(this); } }
@Override public void handleEvent(Event event) throws Exception { if (event.getChannel() == eventChannel && useSequentialWriting) sequentialWriter.interrupt(); }
public Select buildNumberMatchedQuery(QueryExpression queryExpression) throws WFSException { QueryExpression hitsQuery = new QueryExpression(queryExpression); hitsQuery.unsetCounterFilter(); hitsQuery.unsetSorting(); return buildHitsQuery(hitsQuery); }
public Select buildNumberReturnedQuery( QueryExpression queryExpression, long count, long startIndex, long pageNumber) throws WFSException { QueryExpression hitsQuery = new QueryExpression(queryExpression); hitsQuery.unsetCounterFilter(); hitsQuery.unsetSorting(); CounterFilter counterFilter = new CounterFilter(); if (pageNumber > 0 && hitsQuery.isSetStartId()) counterFilter.setStartId( hitsQuery.getStartId(), ComparisonOperatorName.GREATER_THAN_OR_EQUAL_TO); else if (startIndex > 0) counterFilter.setStartIndex(startIndex); if (count != Constants.COUNT_DEFAULT) counterFilter.setCount(count + queryExpression.getPropertyOffset()); if (counterFilter.isSetCount() || counterFilter.isSetStartId() || counterFilter.isSetStartIndex()) hitsQuery.setCounterFilter(counterFilter); return buildHitsQuery(hitsQuery); }
private Select buildHitsQuery(QueryExpression queryExpression) throws WFSException { try { builder.getBuildProperties().optimizeJoins(true); SQLQueryContext context = builder.buildSchemaPath(queryExpression.getSchemaPath(), false); builder.getBuildProperties().optimizeJoins(isSimpleProperty(queryExpression.getSchemaPath())); Select select = builder .buildQuery(queryExpression, context) .unsetOrderBy() .removeProjectionIf( t -> !(t instanceof Column) || !((Column) t).getName().equals(MappingConstants.ID)); return new Select() .addProjection(new Function("count", new WildCardColumn(new Table(select), false))); } catch (QueryBuildException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to build the database query.", queryExpression.getHandle(), e); } }
private boolean isSimpleProperty(SchemaPath schemaPath) { PathElementType type = schemaPath.getLastNode().getPathElement().getElementType(); return (type == PathElementType.SIMPLE_ATTRIBUTE || type == PathElementType.GEOMETRY_PROPERTY); }
private TruncatedResponse getTruncatedResponse( WFSException wfsException, HttpServletRequest request) { WFSExceptionReportHandler reportHandler = new WFSExceptionReportHandler(cityGMLBuilder); ExceptionReport exceptionReport = reportHandler.getExceptionReport( wfsException, KVPConstants.GET_PROPERTY_VALUE, request, true); TruncatedResponse truncatedResponse = new TruncatedResponse(); truncatedResponse.setExceptionReport(exceptionReport); return truncatedResponse; }
private long getNumberMatched( QueryExpression queryExpression, ResultTypeType resultType, Connection connection) throws WFSException, SQLException { if (!queryExpression.isSetNumberMatched()) { if (computeNumberMatched || resultType == ResultTypeType.HITS) { Select query = queryBuilder.buildNumberMatchedQuery(queryExpression); try (PreparedStatement stmt = connectionPool .getActiveDatabaseAdapter() .getSQLAdapter() .prepareStatement(query, connection); ResultSet rs = stmt.executeQuery()) { queryExpression.setNumberMatched(rs.next() ? rs.getLong(1) : 0); } } else queryExpression.setNumberMatched(Constants.UNKNOWN_NUMBER_MATCHED); } return queryExpression.getNumberMatched(); }
private long getNumberReturned( QueryExpression queryExpression, long count, long startIndex, long pageNumber, Connection connection) throws WFSException, SQLException { Select query = queryBuilder.buildNumberReturnedQuery(queryExpression, count, startIndex, pageNumber); try (PreparedStatement stmt = connectionPool .getActiveDatabaseAdapter() .getSQLAdapter() .prepareStatement(query, connection); ResultSet rs = stmt.executeQuery()) { return rs.next() ? Math.max(rs.getLong(1) - queryExpression.getPropertyOffset(), 0) : 0; } }
private Connection initConnection() throws SQLException { Connection connection = connectionPool.getConnection(); connection.setAutoCommit(false); return connection; }
@Override public void initializeContext( Set<FeatureType> featureTypes, CityGMLVersion version, ServletContext servletContext) throws SchemaReaderException { this.featureTypes = featureTypes; this.servletContext = servletContext; List<String> unsupported = Arrays.asList("TransportationComplex", "Track"); for (FeatureType featureType : featureTypes) { if (unsupported.contains(featureType.getPath())) throw new SchemaReaderException( "The feature type '" + featureType.getPath() + "' is not supported by CityJSON."); } }
@Override public void initializeContext( Set<FeatureType> featureTypes, CityGMLVersion version, ServletContext servletContext) throws SchemaReaderException { this.featureTypes = featureTypes; this.version = version; this.servletContext = servletContext; }
@Override public InputStream openSchema() throws SchemaReaderException, IOException { String localSchemaPath = version == CityGMLVersion.v2_0_0 ? Constants.CITYGML_2_0_SCHEMAS_PATH : Constants.CITYGML_1_0_SCHEMAS_PATH; Set<Module> modules = null; if (!featureTypes.isEmpty()) { modules = new HashSet<>(); for (FeatureType featureType : featureTypes) { Namespace namespace = featureType.getSchema().getNamespace(version); Module module = Modules.getModule(namespace.getURI()); if (module == null) throw new SchemaReaderException( "The feature type '" + new QName(namespace.getURI(), featureType.getPath()) + "' is not part of CityGML."); modules.add(module); } } if (modules != null && modules.size() == 1) { Module module = modules.iterator().next(); if (module instanceof CityGMLModule) { String fileName = module.getSchemaLocation(); fileName = fileName.substring(fileName.lastIndexOf("/")); return servletContext.getResourceAsStream(localSchemaPath + fileName); } else if (module instanceof ADEModule) return ((ADEModule) module).getSchemaResource().openStream(); } return new ByteArrayInputStream( createDynamicXMLSchema(version).getBytes(StandardCharsets.UTF_8)); }
private ValueReference parseValueReference( String valueReference_, FeatureType featureType, NamespaceFilter namespaceFilter, String handle) throws WFSException { try { SchemaPath schemaPath = xpathParser.parse(valueReference_, featureType, namespaceFilter); return new ValueReference(schemaPath); } catch (XPathException e) { throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "Invalid XPath expression used in ValueReference.", KVPConstants.VALUE_REFERENCE, e); } catch (InvalidSchemaPathException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to map XPath expression used in ValueReference to the CityGML schema.", handle, e); } }
private AbstractLiteral<?> parseLiteral( ValueReference valueReference, String literal_, String handle) throws WFSException { SimpleAttribute attribute = (SimpleAttribute) valueReference.getSchemaPath().getLastNode().getPathElement(); AbstractLiteral<?> literal = literalHandler.convertToSchemaLiteral(literal_, attribute.getType(), handle); if (literal == null) { WFSExceptionMessage message = new WFSExceptionMessage(WFSExceptionCode.OPERATION_PROCESSING_FAILED); message.addExceptionText("Failed to parse the literal value '" + literal_ + "'."); message.addExceptionText( "Expected a literal value of type '" + attribute.getType().value() + "'."); message.setLocator(handle); throw new WFSException(message); } return literal; }
private JAXBElement<?>[] parseOperands(List<Object> operands) { JAXBElement<?>[] result = new JAXBElement<?>[2]; for (Object operand : operands) { if (!(operand instanceof JAXBElement<?>)) continue; JAXBElement<?> jaxbElement = (JAXBElement<?>) operand; if (jaxbElement.getValue() instanceof String && jaxbElement.getName().equals(new QName(Constants.FES_NAMESPACE_URI, "ValueReference"))) result[0] = jaxbElement; else if (jaxbElement.getValue() instanceof AbstractGeometryType) result[1] = jaxbElement; else if (jaxbElement.getValue() instanceof EnvelopeType) result[1] = jaxbElement; } return result; }
private ValueReference parseValueReference( String valueReference_, FeatureType featureType, NamespaceFilter namespaceFilter, String handle) throws WFSException { try { SchemaPath schemaPath = xpathParser.parse(valueReference_, featureType, namespaceFilter); if (schemaPath.getLastNode().getPathElement().getElementType() != PathElementType.GEOMETRY_PROPERTY) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "'" + valueReference_ + "' is not a geometry property.", KVPConstants.VALUE_REFERENCE); return new ValueReference(schemaPath); } catch (XPathException e) { throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "Invalid XPath expression used in ValueReference.", KVPConstants.VALUE_REFERENCE, e); } catch (InvalidSchemaPathException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to map XPath expression used in ValueReference to the CityGML schema.", handle, e); } }
public FeatureType getFeatureType( QName featureTypeName, boolean onlyAdvertised, String parameterName, String handle) throws WFSException { if (featureTypeName == null) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "Failed to interpret feature type name as XML qualified name.", parameterName); FeatureType featureType = schemaMapping.getFeatureType(featureTypeName); if (featureType == null) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "'" + featureTypeName + "' is not a valid CityGML feature type.", parameterName); if (onlyAdvertised && !wfsConfig.getFeatureTypes().contains(featureTypeName)) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "The requested feature type '" + featureTypeName + "' is not advertised.", parameterName); version = featureType.getSchema().getCityGMLVersion(featureTypeName.getNamespaceURI()); if (version == null) throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to retrieve CityGML version for feature type '" + featureTypeName + "'.", handle); return featureType; }
public FeatureType getFeatureType(QName featureTypeName, String parameterName, String handle) throws WFSException { return getFeatureType(featureTypeName, true, parameterName, handle); }
public Set<FeatureType> getFeatureTypes( Collection<QName> featureTypeNames, boolean onlyAdvertised, boolean canBeEmpty, String parameterName, String handle) throws WFSException { Set<FeatureType> result = new HashSet<>(); CityGMLVersion featureVersion = null; for (QName featureTypeName : featureTypeNames) { FeatureType featureType = getFeatureType(featureTypeName, onlyAdvertised, parameterName, handle); if (featureVersion == null) featureVersion = version; else if (version != featureVersion) throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Mixing feature types from different CityGML versions is not supported.", handle); result.add(featureType); } if (!canBeEmpty && result.isEmpty()) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "The operation requires at least one feature type name to be provided.", parameterName); return result; }
public Set<FeatureType> getFeatureTypes( Collection<QName> featureTypeNames, boolean canBeEmpty, String parameterName, String handle) throws WFSException { return getFeatureTypes(featureTypeNames, true, canBeEmpty, parameterName, handle); }
public Set<FeatureType> getFeatureTypes( Collection<String> featureTypeNames, NamespaceContext namespaceContext, boolean canBeEmpty, String parameterName, String handle) throws WFSException { return getFeatureTypes( featureTypeNames, namespaceContext, true, canBeEmpty, parameterName, handle); }
public Predicate buildIdOperator( List<JAXBElement<? extends AbstractIdType>> idOpsElement, String handle) throws WFSException { ResourceIdOperator predicate = new ResourceIdOperator(); for (JAXBElement<?> abstractIdElement : idOpsElement) { if (!abstractIdElement.getName().getNamespaceURI().equals(Constants.FES_NAMESPACE_URI)) throw new WFSException( WFSExceptionCode.OPTION_NOT_SUPPORTED, "Only comparison operators associated with the namespace " + Constants.FES_NAMESPACE_URI + " are supported.", handle); predicate.addResourceId(getResourceId(abstractIdElement, handle)); } return predicate; }
public Predicate buildIdOperator(JAXBElement<?> idOpsElement, String handle) throws WFSException { if (!idOpsElement.getName().getNamespaceURI().equals(Constants.FES_NAMESPACE_URI)) throw new WFSException( WFSExceptionCode.OPTION_NOT_SUPPORTED, "Only comparison operators associated with the namespace " + Constants.FES_NAMESPACE_URI + " are supported.", handle); try { return new ResourceIdOperator(getResourceId(idOpsElement, handle)); } catch (FilterException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to build filter expression.", handle, e); } }
private String getResourceId(JAXBElement<?> abstractIdElement, String handle) throws WFSException { if (!(abstractIdElement.getValue() instanceof ResourceIdType)) throw new WFSException( WFSExceptionCode.OPTION_NOT_SUPPORTED, "Only " + new QName(Constants.FES_NAMESPACE_URI, "ResourceId").toString() + " is supported as ID filter.", handle); ResourceIdType resourceId = (ResourceIdType) abstractIdElement.getValue(); if (!resourceId.isSetRid()) throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "The mandatory rid attribute is not provided on the " + new QName(Constants.FES_NAMESPACE_URI, "ResourceId").toString() + " element.", handle); if (resourceId.isSetVersion() || resourceId.isSetStartDate() || resourceId.isSetEndDate() || resourceId.isSetPreviousRid()) ; return resourceId.getRid().replaceAll("^#+", ""); }
public void setDefaultSorting(Query query, FeatureType featureType, String handle) throws WFSException { try { SchemaPath schemaPath = new SchemaPath(featureType); schemaPath.appendChild( featureType.getProperty( MappingConstants.ID, CityDBADE200Module.v3_0.getNamespaceURI(), true)); query.setSorting(new Sorting(new SortProperty(new ValueReference(schemaPath)))); } catch (InvalidSchemaPathException | FilterException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to add default sorting by primary key to query.", handle); } }
public SelectionFilter getSelection( FilterType filter, FeatureType featureType, NamespaceFilter namespaceFilter, String handle) throws WFSException { if (filter == null) throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "No valid filter expression provided.", handle); Predicate predicate = null; if (filter.getComparisonOps() != null) predicate = buildPredicate(filter.getComparisonOps(), featureType, namespaceFilter, handle); else if (filter.getSpatialOps() != null) predicate = buildPredicate(filter.getSpatialOps(), featureType, namespaceFilter, handle); else if (filter.getLogicOps() != null) predicate = buildPredicate(filter.getLogicOps(), featureType, namespaceFilter, handle); else if (filter.get_Id() != null) predicate = buildPredicate(filter.get_Id(), handle); return predicate != null ? new SelectionFilter(predicate) : null; }
private Predicate buildPredicate( List<JAXBElement<? extends AbstractIdType>> idOperators, String handle) throws WFSException { return resourceIdFilterBuilder.buildIdOperator(idOperators, handle); }
public void addNotTerminatedFilter(Query query, String handle) throws WFSException { try { FeatureType superType = schemaMapping.getCommonSuperType(query.getFeatureTypeFilter().getFeatureTypes()); SchemaPath schemaPath = new SchemaPath(superType) .appendChild( superType.getProperty( "terminationDate", CoreModule.v2_0_0.getNamespaceURI(), true)); NullOperator isNull = ComparisonFactory.isNull(new ValueReference(schemaPath)); if (query.isSetSelection()) { SelectionFilter selection = query.getSelection(); selection.setPredicate(LogicalOperationFactory.AND(selection.getPredicate(), isNull)); } else query.setSelection(new SelectionFilter(isNull)); } catch (InvalidSchemaPathException | FilterException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to add is null test for termination date.", handle, e); } }
default void writeHeader() throws FeatureWriteException { }
public boolean isGetFeatureById() { return featureIdentifier != null; }
@Override public void copyFrom(Query query) { super.copyFrom(query); if (query instanceof QueryExpression) { QueryExpression other = (QueryExpression) query; featureIdentifier = other.featureIdentifier; numberReturned = other.numberReturned; startIndex = other.startIndex; } }
public void doExport( GetFeatureRequest pageRequest, HttpServletRequest request, HttpServletResponse response) throws WFSException { doExport( pageRequest.getWFSRequest(), pageRequest.getQueryExpressions(), pageRequest, request, response); }
public void doExport( GetFeatureType wfsRequest, List<QueryExpression> queryExpressions, HttpServletRequest request, HttpServletResponse response) throws WFSException { doExport(wfsRequest, queryExpressions, null, request, response); }
public Select buildQuery(QueryExpression queryExpression, long count, long pageNumber) throws WFSException { CounterFilter counterFilter = new CounterFilter(); if (pageNumber > 0 && queryExpression.isSetStartId()) counterFilter.setStartId(queryExpression.getStartId()); else if (queryExpression.getStartIndex() > 0) counterFilter.setStartIndex(queryExpression.getStartIndex()); if (count != Constants.COUNT_DEFAULT) counterFilter.setCount(queryExpression.getNumberReturned()); if (counterFilter.isSetCount() || counterFilter.isSetStartId() || counterFilter.isSetStartIndex()) queryExpression.setCounterFilter(counterFilter); try { return builder.buildQuery(queryExpression); } catch (QueryBuildException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to build the database query.", queryExpression.getHandle(), e); } }
public Select buildNumberReturnedQuery( QueryExpression queryExpression, long count, long startIndex, long pageNumber) throws WFSException { QueryExpression hitsQuery = new QueryExpression(queryExpression); hitsQuery.unsetCounterFilter(); hitsQuery.unsetSorting(); CounterFilter counterFilter = new CounterFilter(); if (pageNumber > 0 && queryExpression.isSetStartId()) counterFilter.setStartId(queryExpression.getStartId()); else if (startIndex > 0) counterFilter.setStartIndex(startIndex); if (count != Constants.COUNT_DEFAULT) counterFilter.setCount(count); if (counterFilter.isSetCount() || counterFilter.isSetStartId() || counterFilter.isSetStartIndex()) hitsQuery.setCounterFilter(counterFilter); return buildHitsQuery(hitsQuery); }
private Select buildHitsQuery(QueryExpression queryExpression) throws WFSException { try { Select select = builder .buildQuery(queryExpression) .unsetOrderBy() .removeProjectionIf( t -> !(t instanceof Column) || !((Column) t).getName().equals(MappingConstants.ID)); return new Select() .addProjection(new Function("count", new WildCardColumn(new Table(select), false))); } catch (QueryBuildException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to build the database query.", queryExpression.getHandle(), e); } }
private void processGlobalAppearances() throws FeatureWriteException, SQLException, InterruptedException { CacheTable globalAppTempTable = cacheTableManager.getCacheTable(CacheTableModel.GLOBAL_APPEARANCE); globalAppTempTable.createIndexes(); Select select = queryBuilder.buildGlobalAppearanceQuery(globalAppTempTable); try (PreparedStatement stmt = connectionPool .getActiveDatabaseAdapter() .getSQLAdapter() .prepareStatement(select, globalAppTempTable.getConnection()); ResultSet rs = stmt.executeQuery()) { if (rs.next()) { FeatureType appearanceType = schemaMapping.getFeatureType("Appearance", AppearanceModule.v2_0_0.getNamespaceURI()); writer.startAdditionalObjects(); do { long appearanceId = rs.getLong(1); DBSplittingResult splitter = new DBSplittingResult(appearanceId, appearanceType); databaseWorkerPool.addWork(splitter); } while (rs.next() && shouldRun); } } databaseWorkerPool.join(); }
private long getNumberMatched( List<QueryExpression> queryExpressions, ResultTypeType resultType, Connection connection) throws WFSException, SQLException { long matchAll = 0; boolean isUnknown = false; for (QueryExpression queryExpression : queryExpressions) { if (!queryExpression.isSetNumberMatched()) { if (computeNumberMatched || resultType == ResultTypeType.HITS) { Select query = queryBuilder.buildNumberMatchedQuery(queryExpression); try (PreparedStatement stmt = connectionPool .getActiveDatabaseAdapter() .getSQLAdapter() .prepareStatement(query, connection); ResultSet rs = stmt.executeQuery()) { queryExpression.setNumberMatched(rs.next() ? rs.getLong(1) : 0); } } else queryExpression.setNumberMatched(Constants.UNKNOWN_NUMBER_MATCHED); } if (queryExpression.getNumberMatched() == Constants.UNKNOWN_NUMBER_MATCHED) isUnknown = true; else if (!isUnknown) matchAll += queryExpression.getNumberMatched(); } return !isUnknown ? matchAll : Constants.UNKNOWN_NUMBER_MATCHED; }
private void setExporterContext( QueryExpression queryExpression, Query dummy, boolean isMultipleQueryRequest) { internalConfig.setRegisterGmlIdInCache(isMultipleQueryRequest); internalConfig.setTransformCoordinates( queryExpression.getTargetSrs().getSrid() != connectionPool .getActiveDatabaseAdapter() .getConnectionMetaData() .getReferenceSystem() .getSrid()); dummy.copyFrom(queryExpression); }
private TruncatedResponse getTruncatedResponse( WFSException wfsException, HttpServletRequest request) { WFSExceptionReportHandler reportHandler = new WFSExceptionReportHandler(cityGMLBuilder); ExceptionReport exceptionReport = reportHandler.getExceptionReport(wfsException, KVPConstants.GET_FEATURE, request, true); TruncatedResponse truncatedResponse = new TruncatedResponse(); truncatedResponse.setExceptionReport(exceptionReport); return truncatedResponse; }
void addSequenceIdWhenSorting(boolean addSequenceId) { this.addSequenceId = addSequenceId; }
@Override public void useIndentation(boolean useIndentation) { writer.setIndent(useIndentation ? " " : ""); }
@Override public void startFeatureCollection(long matchNo, long returnNo, String previous, String next) throws FeatureWriteException { }
@Override public void startFeatureCollection(long matchNo, long returnNo) throws FeatureWriteException { }
@Override public void endFeatureCollection() throws FeatureWriteException { checkForDuplicates = internalConfig.isRegisterGmlIdInCache(); }
@Override public void startAdditionalObjects() throws FeatureWriteException { }
@Override public void endAdditionalObjects() throws FeatureWriteException { }
@Override public void writeAdditionalObjects() throws FeatureWriteException { }
@Override public void writeTruncatedResponse(TruncatedResponse truncatedResponse) throws FeatureWriteException { }
@Override public void close() throws FeatureWriteException { try { writerPool.shutdownAndWait(); if (!isWriteSingleFeature || hasContent) { writer.writeEndDocument(); } } catch (InterruptedException | CityJSONWriteException e) { throw new FeatureWriteException("Failed to close CityJSON response writer.", e); } finally { if (!writerPool.isTerminated()) { writerPool.shutdownNow(); } eventDispatcher.removeEventHandler(this); } }
private boolean isFeatureAlreadyExported(AbstractFeature feature) { if (!feature.isSetId()) { return false; } IdCache cache = idCacheManager.getCache(IdCacheType.OBJECT); return cache.get(feature.getId()) != null; }
@Override public boolean supportsHitsResponse() { return false; }
protected void startAdditionalObjects() throws SAXException { if (!isInitialized) { Attributes dummyAttributes = new AttributesImpl(); saxWriter.startElement( Constants.WFS_NAMESPACE_URI, "additionalObjects", null, dummyAttributes); saxWriter.startElement( Constants.WFS_NAMESPACE_URI, "SimpleFeatureCollection", null, dummyAttributes); isInitialized = true; } }
protected void endAdditionalObjects() throws SAXException { if (isInitialized) { saxWriter.endElement(Constants.WFS_NAMESPACE_URI, "SimpleFeatureCollection", null); saxWriter.endElement(Constants.WFS_NAMESPACE_URI, "additionalObjects", null); } }
protected boolean hasAdditionalObjects() { return !tempWriters.isEmpty(); }
protected void cacheObject(AbstractFeature feature) throws FeatureWriteException { try { if (shouldRun) getOrCreateCacheWriter().writeFeatureMember(feature); } catch (CityGMLWriteException | IOException e) { shouldRun = false; throw new FeatureWriteException( "Failed to cache feature with gml:id '" + feature.getId() + "' as additional object.", e); } }
public void cleanCache() { for (Map.Entry<String, Path> entry : tempFiles.entrySet()) { CityModelWriter tempWriter = tempWriters.get(entry.getKey()); if (tempWriter != null) { try { tempWriter.close(); } catch (CityGMLWriteException e) { } } cacheCleanerPool.addWork(() -> Files.delete(entry.getValue())); } }
private CityModelWriter getOrCreateCacheWriter() throws CityGMLWriteException, IOException { String key = Thread.currentThread().getName(); CityModelWriter tempWriter = tempWriters.get(key); if (tempWriter == null) { Path tempFile = tempDir.resolve("objects-" + UUID.randomUUID().toString() + ".tmp"); CityGMLOutputFactory out = cityGMLBuilder.createCityGMLOutputFactory(version); tempWriter = out.createCityModelWriter(tempFile.toFile(), "UTF-8"); tempWriter.setPrefixes(version); tempWriter.setPrefixes(CityGMLContext.getInstance().getADEContexts()); tempWriter.setIndentString(""); tempFiles.put(key, tempFile); tempWriters.put(key, tempWriter); } return tempWriter; }
@Override public boolean supportsHitsResponse() { return true; }
@Override public FeatureWriter buildFeatureWriter(Writer writer) throws FeatureWriteException { try { saxWriter.setOutput(writer); return new CityGMLWriter( saxWriter, version, transformerChainFactory, geometryStripper, idCacheManager, eventChannel, internalConfig, config); } catch (DatatypeConfigurationException e) { throw new FeatureWriteException("Failed to create CityGML response writer.", e); } }
@Override public boolean supportsFlatHierarchies() { return !isWriteSingleFeature; }
@Override public void startFeatureCollection(long matchNo, long returnNo, String previous, String next) throws FeatureWriteException { level++; writeFeatureCollection(matchNo, returnNo, previous, next, WriteMode.HEAD); }
@Override public void startFeatureCollection(long matchNo, long returnNo) throws FeatureWriteException { startFeatureCollection(matchNo, returnNo, null, null); }
@Override public void endFeatureCollection() throws FeatureWriteException { writeFeatureCollection(0, 0, null, null, WriteMode.TAIL); level--; checkForDuplicates = internalConfig.isRegisterGmlIdInCache(); }
@Override public void startAdditionalObjects() throws FeatureWriteException { try { writerPool.join(); additionalObjectsHandler.startAdditionalObjects(); } catch (SAXException | InterruptedException e) { throw new FeatureWriteException( "Failed to marshal additional objects collection element.", e); } }
@Override public void endAdditionalObjects() throws FeatureWriteException { try { additionalObjectsHandler.endAdditionalObjects(); } catch (SAXException e) { throw new FeatureWriteException( "Failed to marshal additional objects collection element.", e); } }
@Override public void writeAdditionalObjects() throws FeatureWriteException { try { writerPool.join(); if (additionalObjectsHandler.hasAdditionalObjects()) additionalObjectsHandler.writeObjects(); } catch (InterruptedException e) { throw new FeatureWriteException("Failed to marshal additional objects.", e); } }
@Override public void writeTruncatedResponse(TruncatedResponse truncatedResponse) throws FeatureWriteException { try { SAXEventBuffer buffer = new SAXEventBuffer(); Marshaller marshaller = cityGMLBuilder.getJAXBContext().createMarshaller(); marshaller.marshal(truncatedResponse, buffer); writerPool.addWork(buffer); } catch (JAXBException e) { throw new FeatureWriteException("Failed to marshal truncated response element.", e); } }
@Override public void close() throws FeatureWriteException { try { writerPool.shutdownAndWait(); } catch (InterruptedException e) { throw new FeatureWriteException("Failed to close CityGML response writer.", e); } finally { if (!writerPool.isTerminated()) writerPool.shutdownNow(); if (additionalObjectsHandler.hasAdditionalObjects()) additionalObjectsHandler.cleanCache(); eventDispatcher.removeEventHandler(this); } }
private boolean isFeatureAlreadyExported(AbstractFeature feature) { if (!feature.isSetId()) return false; IdCache cache = idCacheManager.getCache(IdCacheType.OBJECT); return cache.get(feature.getId()) != null; }
@Override public void handleEvent(Event event) throws Exception { if (event.getChannel() == eventChannel && sequentialWriter != null) sequentialWriter.interrupt(); }
public List<StoredQueryAdapter> listStoredQueries(String handle) throws WFSException { List<StoredQueryAdapter> storedQueries = new ArrayList<>(); storedQueries.add(new StoredQueryAdapter(DEFAULT_QUERY.getId())); try { try (DirectoryStream<Path> stream = Files.newDirectoryStream(storedQueriesPath)) { for (Path file : stream) { if (Files.isRegularFile(file)) storedQueries.add(new StoredQueryAdapter(file)); } } } catch (IOException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to list stored queries.", handle, e); } return storedQueries; }
public StoredQuery getStoredQuery(StoredQueryAdapter adapter, String handle) throws WFSException { if (GET_FEATURE_BY_ID_NAME.equals(adapter.getId()) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(adapter.getId())) return DEFAULT_QUERY; Path file = adapter.isSetId() ? storedQueriesPath.resolve(getFileName(adapter.getId())) : adapter.getFile(); if (!Files.exists(file)) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "A stored query with identifier '" + adapter.getId() + "' is not offered by this server.", KVPConstants.STOREDQUERY_ID); return unmarshalStoredQuery(file, handle); }
public Element parseStoredQuery(StoredQueryAdapter adapter, String handle) throws WFSException { if (GET_FEATURE_BY_ID_NAME.equals(adapter.getId()) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(adapter.getId())) return DEFAULT_QUERY.toDOMElement(handle); Path file = adapter.isSetId() ? storedQueriesPath.resolve(getFileName(adapter.getId())) : adapter.getFile(); if (!Files.exists(file)) throw new WFSException( WFSExceptionCode.INVALID_PARAMETER_VALUE, "A stored query with identifier '" + adapter.getId() + "' is not offered by this server.", KVPConstants.STOREDQUERY_ID); return parseStoredQuery(file, handle); }
public void dropStoredQuery(String id, String handle) throws WFSException { if (GET_FEATURE_BY_ID_NAME.equals(id) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(id)) throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "The mandatory stored query '" + id + "' must not be dropped.", handle); Path file = storedQueriesPath.resolve(getFileName(id)); if (!Files.exists(file)) throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "A stored query with identifier '" + id + "' is not offered by this server.", handle); try { Files.delete(file); } catch (IOException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to drop the stored query with identifier '" + id + "'.", handle); } }
public boolean containsStoredQuery(String id, String handle) { return GET_FEATURE_BY_ID_NAME.equals(id) || DEPRECATED_GET_FEATURE_BY_ID_NAME.equals(id) || Files.exists(storedQueriesPath.resolve(getFileName(id))); }
private Element parseStoredQuery(Path file, String handle) throws WFSException { if (!Files.isReadable(file)) throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to read the stored query file.", handle); try { Document document = documentBuilderFactory.newDocumentBuilder().parse(file.toFile()); return processStoredQueryElement(document.getDocumentElement(), handle); } catch (SAXException | IOException | ParserConfigurationException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Fatal error whilst processing the stored query.", handle, e); } }
protected Element toDOMElement(String handle) throws WFSException { try { Document document = manager.getDocumentBuilderFactory().newDocumentBuilder().newDocument(); DescribeStoredQueriesResponseType response = new DescribeStoredQueriesResponseType(); response.getStoredQueryDescription().add(description); JAXBElement<DescribeStoredQueriesResponseType> jaxbElement = manager.getObjectFactory().createDescribeStoredQueriesResponse(response); Marshaller marshaller = manager.getCityGMLBuilder().getJAXBContext().createMarshaller(); marshaller.marshal(jaxbElement, document); return manager.processStoredQueryElement(document.getDocumentElement(), handle); } catch (ParserConfigurationException | JAXBException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to compile the stored query '" + getId() + "'.", handle, e); } }
private String toString(Object object) throws JAXBException, TransformerFactoryConfigurationError, TransformerException { if (object instanceof Element) return marshal((Element) object); else if (object instanceof JAXBElement<?>) return marshal((JAXBElement<?>) object); else return object.toString().trim(); }
private String marshal(Element element) throws TransformerFactoryConfigurationError, TransformerException { Transformer transformer = manager.getTransformerFactory().newTransformer(); transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes"); StreamResult result = new StreamResult(new StringWriter()); DOMSource source = new DOMSource(element); transformer.transform(source, result); return result.getWriter().toString(); }
private String marshal(JAXBElement<?> element) throws JAXBException { StringWriter writer = new StringWriter(); Marshaller marshaller = manager.getCityGMLBuilder().getJAXBContext().createMarshaller(); marshaller.setProperty(Marshaller.JAXB_FRAGMENT, true); marshaller.marshal(element, writer); return writer.toString(); }
private Object unmarshal(String object) throws JAXBException { StringReader reader = new StringReader(object); Unmarshaller unmarshaller = manager.getCityGMLBuilder().getJAXBContext().createUnmarshaller(); return unmarshaller.unmarshal(reader); }
protected boolean isSetFile() { return file != null; }
protected void configure() { bind(textureProvider).to(TextureProvider.class); }
@PreDestroy public void destroy() { textureProvider.destroy(); }
public void addTextureToCache(TextureWrapper texture, String name, String bucket) { texture.setPath(Paths.get(cachePath.toString(), bucket, name)); textureCachePool.addWork(texture); }
public boolean isUseTextureCache() { return wfsConfig.getConstraints().isExportAppearance() && wfsConfig.getServer().getTextureCache().isEnabled(); }
public void destroy() { if (isUseTextureCache() && textureCachePool != null) textureCachePool.shutdown(); }
private Connection initConnection() throws WFSException, SQLException { if (!connectionPool.isConnected()) DatabaseConnector.connect(config); Connection connection = connectionPool.getConnection(); connection.setAutoCommit(false); return connection; }
public boolean isSetBytes() { return bytes != null; }
@DELETE public void deleteCache() { java.nio.file.Path cachePath = textureProvider.getLocalCachePath(); if (cachePath != null) { boolean useCache = textureProvider.isUseTextureCache(); try { textureProvider.setUseTextureCache(false); try (Stream<java.nio.file.Path> stream = Files.walk(cachePath)) { stream .filter(p -> !p.equals(cachePath)) .sorted(Comparator.reverseOrder()) .map(java.nio.file.Path::toFile) .forEach(File::delete); } } catch (IOException e) { throw new WebApplicationException( "Failed to delete texture cache at '" + cachePath + "'.", e); } finally { textureProvider.setUseTextureCache(useCache); } } }
@GET @Produces("image/*") public Response getTexture( @PathParam("bucket") String bucket, @PathParam("name") String name, @Context HttpServletRequest request) throws WFSException, SQLException { try { TextureWrapper texture = null; if (textureProvider.isUseTextureCache()) texture = textureProvider.getFromCache(name, bucket); if (texture == null) { texture = textureProvider.getFromDatabase(name, request); if (textureProvider.isUseTextureCache()) textureProvider.addTextureToCache(texture, name, bucket); } return Response.ok() .entity(texture.isSetPath() ? texture.getPath().toFile() : texture.getBytes()) .type(texture.getMimeType()) .build(); } catch (WFSException | SQLException e) { log.error( LoggerUtil.getLogMessage( request, "Failed to load texture '" + bucket + "/" + name + "'. Check next messages for reasons.")); throw e; } }
public static String getServiceURL(HttpServletRequest request) throws WFSException { try { URL requestURL = new URL(request.getRequestURL().toString()); StringBuilder serverURL = new StringBuilder(requestURL.getProtocol()).append("://").append(requestURL.getHost()); if (requestURL.getPort() != -1 && requestURL.getPort() != requestURL.getDefaultPort()) serverURL.append(":").append(requestURL.getPort()); return serverURL.append(request.getContextPath()).toString(); } catch (MalformedURLException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "Failed to create server URL.", e); } }
public static boolean containsParameter(HttpServletRequest request, String name) { return getParameter(request, name) != null; }
public void requireServiceSlot(HttpServletRequest request, String locator) throws WFSException { if (requestQueue != null) { try { if (!requestQueue.offer(request.toString(), timeout, TimeUnit.SECONDS)) throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "The service is currently unavailable because it is overloaded. " + "Generally, this is a temporary state. Please retry later.", locator); } catch (InterruptedException e) { throw new WFSException( WFSExceptionCode.OPERATION_PROCESSING_FAILED, "The service has internally interrupted the request.", locator, e); } } }
public void requireServiceSlot(HttpServletRequest request) throws WFSException { requireServiceSlot(request, null); }
public void releaseServiceSlot(HttpServletRequest request) { if (requestQueue != null) { requestQueue.remove(request.toString()); } }
@Override public void doWork(CacheCleanerWork work) { try { work.run(); } catch (Exception e) { log.error("Failed to clean cache: " + e.getMessage()); } }
@Override public void shutdown() { }
@Override public void doWork(T work) { }
@Override public void shutdown() { }
@Override public void doWork(TextureWrapper work) { if (work.isSetBytes() && work.isSetPath()) { try { Path target = work.getPath(); Files.createDirectories(target.getParent()); Files.write(target, work.getBytes()); } catch (IOException e) { log.error("Failed to write texture to cache: " + e.getMessage()); log.error("Texture caching is disabled."); textureProvider.setUseTextureCache(false); } } }
@Override public <T extends AbstractGeometry> void visit(GeometryArrayProperty<T> arrayProperty) { arrayProperty.unsetGeometry(); }
@Override public <T extends AbstractGeometry> void visit(GeometryProperty<T> geometryProperty) { if (geometryProperty.isSetGeometry()) { String gmlId = geometryProperty.getGeometry().getId(); if (gmlId != null) geometryProperty.setHref("#" + gmlId); geometryProperty.unsetGeometry(); } }
@Override public long getSize( T object, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { return 0; }
@Override public boolean isWriteable( Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { return true; }
@Override public boolean isReadable(Class<?> arg0, Type arg1, Annotation[] arg2, MediaType arg3) { return true; }
@Override public void writeTo( T object, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException { try (OutputStreamWriter writer = new OutputStreamWriter(entityStream, StandardCharsets.UTF_8)) { httpHeaders.get("Content-Type").add(MediaType.APPLICATION_JSON + "; charset=utf-8"); getOrCreateGson().toJson(object, writer); } }
@Override public T readFrom( Class<T> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException { try (InputStreamReader reader = new InputStreamReader(entityStream, StandardCharsets.UTF_8)) { Type jsonType = type.equals(genericType) ? type : genericType; return getOrCreateGson().fromJson(reader, jsonType); } }
public void addDescription(String description) { this.description.add(description); }
@Override public void startPrefixMapping(String prefix, String uri) throws SAXException { if (Constants.GML_3_2_1_NAMESPACE_URI.equals(uri) || Constants.GML_3_3_NAMESPACE_URI.equals(uri)) uri = GMLCoreModule.v3_1_1.getNamespaceURI(); super.startPrefixMapping(prefix, uri); bindNamespace(prefix, uri); }
private void bindNamespace(String prefix, String uri) { prefixToUri.put(prefix, uri); uriToPrefix.computeIfAbsent(uri, k -> new HashSet<>()).add(prefix); }
@Override public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException { if (Constants.GML_3_2_1_NAMESPACE_URI.equals(uri) || Constants.GML_3_3_NAMESPACE_URI.equals(uri)) uri = GMLCoreModule.v3_1_1.getNamespaceURI(); super.startElement(uri, localName, qName, atts); }
private void onStartElement() throws XMLStreamException { namespaces.pushContext(); stateStack.push(SEEN_ELEMENT); state = SEEN_NOTHING; if (depth > 0) { writer.writeCharacters("\n"); } doIndent(); depth++; }
private void onEndElement() throws XMLStreamException { depth--; if (state == SEEN_ELEMENT) { writer.writeCharacters("\n"); doIndent(); } state = stateStack.pop(); namespaces.popContext(); }
private void onEmptyElement() throws XMLStreamException { state = SEEN_ELEMENT; if (depth > 0) { writer.writeCharacters("\n"); } doIndent(); }
private void doIndent() throws XMLStreamException { if (depth > 0) { for (int i = 0; i < depth; i++) writer.writeCharacters(indentStep); } }
@Override public void writeStartDocument() throws XMLStreamException { if (!writeFragment) forceStartDocument(); }
@Override public void writeStartDocument(String version) throws XMLStreamException { if (!writeFragment) forceStartDocument(version); }
@Override public void writeStartDocument(String encoding, String version) throws XMLStreamException { if (!writeFragment) forceStartDocument(encoding, version); }
public void forceStartDocument() throws XMLStreamException { writer.writeStartDocument(); writer.writeCharacters("\n"); }
public void forceStartDocument(String version) throws XMLStreamException { writer.writeStartDocument(version); writer.writeCharacters("\n"); }
public void forceStartDocument(String encoding, String version) throws XMLStreamException { writer.writeStartDocument(encoding, version); writer.writeCharacters("\n"); }
@Override public void writeStartElement(String localName) throws XMLStreamException { onStartElement(); writer.writeStartElement(localName); }
@Override public void writeStartElement(String namespaceURI, String localName) throws XMLStreamException { onStartElement(); writer.writeStartElement(namespaceURI, localName); }
@Override public void writeStartElement(String prefix, String localName, String namespaceURI) throws XMLStreamException { onStartElement(); writer.writeStartElement(prefix, localName, namespaceURI); }
@Override public void writeEmptyElement(String namespaceURI, String localName) throws XMLStreamException { onEmptyElement(); writer.writeEmptyElement(namespaceURI, localName); }
@Override public void writeEmptyElement(String prefix, String localName, String namespaceURI) throws XMLStreamException { onEmptyElement(); writer.writeEmptyElement(prefix, localName, namespaceURI); }
@Override public void writeEmptyElement(String localName) throws XMLStreamException { onEmptyElement(); writer.writeEmptyElement(localName); }
@Override public void writeEndElement() throws XMLStreamException { onEndElement(); writer.writeEndElement(); }
@Override public void writeCharacters(String text) throws XMLStreamException { state = SEEN_DATA; writer.writeCharacters(text); }
@Override public void writeCharacters(char[] text, int start, int len) throws XMLStreamException { state = SEEN_DATA; writer.writeCharacters(text, start, len); }
@Override public void writeCData(String data) throws XMLStreamException { state = SEEN_DATA; writer.writeCData(data); }
@Override public void writeEndDocument() throws XMLStreamException { if (!writeFragment) forceEndDocument(); }
public void forceEndDocument() throws XMLStreamException { writer.writeEndDocument(); }
@Override public void close() throws XMLStreamException { if (!writeFragment) { writer.close(); } }
@Override public void flush() throws XMLStreamException { writer.flush(); }
@Override public void writeAttribute(String localName, String value) throws XMLStreamException { writer.writeAttribute(localName, value); }
@Override public void writeAttribute(String prefix, String namespaceURI, String localName, String value) throws XMLStreamException { writer.writeAttribute(prefix, namespaceURI, localName, value); }
@Override public void writeAttribute(String namespaceURI, String localName, String value) throws XMLStreamException { writer.writeAttribute(namespaceURI, localName, value); }
@Override public void writeNamespace(String prefix, String namespaceURI) throws XMLStreamException { if (shouldWriteNamespace(prefix, namespaceURI)) { writer.writeNamespace(prefix, namespaceURI); } }
@Override public void writeDefaultNamespace(String namespaceURI) throws XMLStreamException { if (shouldWriteNamespace(XMLConstants.DEFAULT_NS_PREFIX, namespaceURI)) { writer.writeDefaultNamespace(namespaceURI); } }
@Override public void writeComment(String data) throws XMLStreamException { writer.writeComment(data); }
@Override public void writeProcessingInstruction(String target) throws XMLStreamException { writer.writeProcessingInstruction(target); }
@Override public void writeProcessingInstruction(String target, String data) throws XMLStreamException { writer.writeProcessingInstruction(target, data); }
@Override public void writeDTD(String dtd) throws XMLStreamException { writer.writeDTD(dtd); }
@Override public void writeEntityRef(String name) throws XMLStreamException { writer.writeEntityRef(name); }
@Override public String getPrefix(String uri) throws XMLStreamException { return writer.getPrefix(uri); }
@Override public void setPrefix(String prefix, String uri) throws XMLStreamException { writer.setPrefix(prefix, uri); }
@Override public void setDefaultNamespace(String uri) throws XMLStreamException { writer.setDefaultNamespace(uri); }
@Override public void setNamespaceContext(NamespaceContext context) throws XMLStreamException { writer.setNamespaceContext(context); }
@Override public Object getProperty(String name) throws IllegalArgumentException { return writer.getProperty(name); }
